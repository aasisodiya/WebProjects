(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.AFRAME = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
var THREE = global.THREE = _dereq_('three-dev');

// Allow cross-origin images to be loaded.
if (THREE.TextureLoader) {
  THREE.TextureLoader.prototype.crossOrigin = '';
}

// TODO: Eventually include these only if they are needed by a component.

_dereq_('../node_modules/three-dev/examples/js/loaders/OBJLoader');  // THREE.OBJLoader
_dereq_('../node_modules/three-dev/examples/js/loaders/MTLLoader');  // THREE.MTLLoader
_dereq_('../node_modules/three-dev/examples/js/loaders/ColladaLoader');  // THREE.ColladaLoader
_dereq_('../lib/vendor/Raycaster');  // THREE.Raycaster
_dereq_('../node_modules/three-dev/examples/js/controls/VRControls');  // THREE.VRControls
_dereq_('../node_modules/three-dev/examples/js/effects/VREffect');  // THREE.VREffect

module.exports = THREE;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../lib/vendor/Raycaster":3,"../node_modules/three-dev/examples/js/controls/VRControls":20,"../node_modules/three-dev/examples/js/effects/VREffect":21,"../node_modules/three-dev/examples/js/loaders/ColladaLoader":22,"../node_modules/three-dev/examples/js/loaders/MTLLoader":23,"../node_modules/three-dev/examples/js/loaders/OBJLoader":24,"three-dev":19}],2:[function(_dereq_,module,exports){
/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.14-c469b00
if (typeof WeakMap === "undefined") {
  (function() {
    var defineProperty = Object.defineProperty;
    var counter = Date.now() % 1e9;
    var WeakMap = function() {
      this.name = "__st" + (Math.random() * 1e9 >>> 0) + (counter++ + "__");
    };
    WeakMap.prototype = {
      set: function(key, value) {
        var entry = key[this.name];
        if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {
          value: [ key, value ],
          writable: true
        });
        return this;
      },
      get: function(key) {
        var entry;
        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;
      },
      "delete": function(key) {
        var entry = key[this.name];
        if (!entry || entry[0] !== key) return false;
        entry[0] = entry[1] = undefined;
        return true;
      },
      has: function(key) {
        var entry = key[this.name];
        if (!entry) return false;
        return entry[0] === key;
      }
    };
    window.WeakMap = WeakMap;
  })();
}

(function(global) {
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function(e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function(func) {
          func();
        });
      }
    });
    setImmediate = function(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function() {
      this.nodes_.forEach(function(node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function() {
      this.addListeners_(this.target);
    },
    addListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function(node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
       case "DOMAttrModified":
        var name = e.attrName;
        var namespace = e.relatedNode.namespaceURI;
        var target = e.target;
        var record = new getRecord("attributes", target);
        record.attributeName = name;
        record.attributeNamespace = namespace;
        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.attributes) return;
          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
            return;
          }
          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMCharacterDataModified":
        var target = e.target;
        var record = getRecord("characterData", target);
        var oldValue = e.prevValue;
        forEachAncestorAndObserverEnqueueRecord(target, function(options) {
          if (!options.characterData) return;
          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
          return record;
        });
        break;

       case "DOMNodeRemoved":
        this.addTransientObserver(e.target);

       case "DOMNodeInserted":
        var changedNode = e.target;
        var addedNodes, removedNodes;
        if (e.type === "DOMNodeInserted") {
          addedNodes = [ changedNode ];
          removedNodes = [];
        } else {
          addedNodes = [];
          removedNodes = [ changedNode ];
        }
        var previousSibling = changedNode.previousSibling;
        var nextSibling = changedNode.nextSibling;
        var record = getRecord("childList", e.target.parentNode);
        record.addedNodes = addedNodes;
        record.removedNodes = removedNodes;
        record.previousSibling = previousSibling;
        record.nextSibling = nextSibling;
        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {
          if (!options.childList) return;
          return record;
        });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;
})(self);

window.HTMLImports = window.HTMLImports || {
  flags: {}
};

(function(scope) {
  var IMPORT_LINK_TYPE = "import";
  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement("link"));
  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);
  var wrap = function(node) {
    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;
  };
  var rootDocument = wrap(document);
  var currentScriptDescriptor = {
    get: function() {
      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== "complete" ? document.scripts[document.scripts.length - 1] : null);
      return wrap(script);
    },
    configurable: true
  };
  Object.defineProperty(document, "_currentScript", currentScriptDescriptor);
  Object.defineProperty(rootDocument, "_currentScript", currentScriptDescriptor);
  var isIE = /Trident/.test(navigator.userAgent);
  function whenReady(callback, doc) {
    doc = doc || rootDocument;
    whenDocumentReady(function() {
      watchImportsLoad(callback, doc);
    }, doc);
  }
  var requiredReadyState = isIE ? "complete" : "interactive";
  var READY_EVENT = "readystatechange";
  function isDocumentReady(doc) {
    return doc.readyState === "complete" || doc.readyState === requiredReadyState;
  }
  function whenDocumentReady(callback, doc) {
    if (!isDocumentReady(doc)) {
      var checkReady = function() {
        if (doc.readyState === "complete" || doc.readyState === requiredReadyState) {
          doc.removeEventListener(READY_EVENT, checkReady);
          whenDocumentReady(callback, doc);
        }
      };
      doc.addEventListener(READY_EVENT, checkReady);
    } else if (callback) {
      callback();
    }
  }
  function markTargetLoaded(event) {
    event.target.__loaded = true;
  }
  function watchImportsLoad(callback, doc) {
    var imports = doc.querySelectorAll("link[rel=import]");
    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];
    function checkDone() {
      if (parsedCount == importCount && callback) {
        callback({
          allImports: imports,
          loadedImports: newImports,
          errorImports: errorImports
        });
      }
    }
    function loadedImport(e) {
      markTargetLoaded(e);
      newImports.push(this);
      parsedCount++;
      checkDone();
    }
    function errorLoadingImport(e) {
      errorImports.push(this);
      parsedCount++;
      checkDone();
    }
    if (importCount) {
      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {
        if (isImportLoaded(imp)) {
          parsedCount++;
          checkDone();
        } else {
          imp.addEventListener("load", loadedImport);
          imp.addEventListener("error", errorLoadingImport);
        }
      }
    } else {
      checkDone();
    }
  }
  function isImportLoaded(link) {
    return useNative ? link.__loaded || link.import && link.import.readyState !== "loading" : link.__importParsed;
  }
  if (useNative) {
    new MutationObserver(function(mxns) {
      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {
        if (m.addedNodes) {
          handleImports(m.addedNodes);
        }
      }
    }).observe(document.head, {
      childList: true
    });
    function handleImports(nodes) {
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (isImport(n)) {
          handleImport(n);
        }
      }
    }
    function isImport(element) {
      return element.localName === "link" && element.rel === "import";
    }
    function handleImport(element) {
      var loaded = element.import;
      if (loaded) {
        markTargetLoaded({
          target: element
        });
      } else {
        element.addEventListener("load", markTargetLoaded);
        element.addEventListener("error", markTargetLoaded);
      }
    }
    (function() {
      if (document.readyState === "loading") {
        var imports = document.querySelectorAll("link[rel=import]");
        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {
          handleImport(imp);
        }
      }
    })();
  }
  whenReady(function(detail) {
    window.HTMLImports.ready = true;
    window.HTMLImports.readyTime = new Date().getTime();
    var evt = rootDocument.createEvent("CustomEvent");
    evt.initCustomEvent("HTMLImportsLoaded", true, true, detail);
    rootDocument.dispatchEvent(evt);
  });
  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;
  scope.useNative = useNative;
  scope.rootDocument = rootDocument;
  scope.whenReady = whenReady;
  scope.isIE = isIE;
})(window.HTMLImports);

(function(scope) {
  var modules = [];
  var addModule = function(module) {
    modules.push(module);
  };
  var initializeModules = function() {
    modules.forEach(function(module) {
      module(scope);
    });
  };
  scope.addModule = addModule;
  scope.initializeModules = initializeModules;
})(window.HTMLImports);

window.HTMLImports.addModule(function(scope) {
  var CSS_URL_REGEXP = /(url\()([^)]*)(\))/g;
  var CSS_IMPORT_REGEXP = /(@import[\s]+(?!url\())([^;]*)(;)/g;
  var path = {
    resolveUrlsInStyle: function(style, linkUrl) {
      var doc = style.ownerDocument;
      var resolver = doc.createElement("a");
      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);
      return style;
    },
    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {
      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);
      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);
      return r;
    },
    replaceUrls: function(text, urlObj, linkUrl, regexp) {
      return text.replace(regexp, function(m, pre, url, post) {
        var urlPath = url.replace(/["']/g, "");
        if (linkUrl) {
          urlPath = new URL(urlPath, linkUrl).href;
        }
        urlObj.href = urlPath;
        urlPath = urlObj.href;
        return pre + "'" + urlPath + "'" + post;
      });
    }
  };
  scope.path = path;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = {
    async: true,
    ok: function(request) {
      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;
    },
    load: function(url, next, nextContext) {
      var request = new XMLHttpRequest();
      if (scope.flags.debug || scope.flags.bust) {
        url += "?" + Math.random();
      }
      request.open("GET", url, xhr.async);
      request.addEventListener("readystatechange", function(e) {
        if (request.readyState === 4) {
          var locationHeader = request.getResponseHeader("Location");
          var redirectedUrl = null;
          if (locationHeader) {
            var redirectedUrl = locationHeader.substr(0, 1) === "/" ? location.origin + locationHeader : locationHeader;
          }
          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);
        }
      });
      request.send();
      return request;
    },
    loadDocument: function(url, next, nextContext) {
      this.load(url, next, nextContext).responseType = "document";
    }
  };
  scope.xhr = xhr;
});

window.HTMLImports.addModule(function(scope) {
  var xhr = scope.xhr;
  var flags = scope.flags;
  var Loader = function(onLoad, onComplete) {
    this.cache = {};
    this.onload = onLoad;
    this.oncomplete = onComplete;
    this.inflight = 0;
    this.pending = {};
  };
  Loader.prototype = {
    addNodes: function(nodes) {
      this.inflight += nodes.length;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        this.require(n);
      }
      this.checkDone();
    },
    addNode: function(node) {
      this.inflight++;
      this.require(node);
      this.checkDone();
    },
    require: function(elt) {
      var url = elt.src || elt.href;
      elt.__nodeUrl = url;
      if (!this.dedupe(url, elt)) {
        this.fetch(url, elt);
      }
    },
    dedupe: function(url, elt) {
      if (this.pending[url]) {
        this.pending[url].push(elt);
        return true;
      }
      var resource;
      if (this.cache[url]) {
        this.onload(url, elt, this.cache[url]);
        this.tail();
        return true;
      }
      this.pending[url] = [ elt ];
      return false;
    },
    fetch: function(url, elt) {
      flags.load && console.log("fetch", url, elt);
      if (!url) {
        setTimeout(function() {
          this.receive(url, elt, {
            error: "href must be specified"
          }, null);
        }.bind(this), 0);
      } else if (url.match(/^data:/)) {
        var pieces = url.split(",");
        var header = pieces[0];
        var body = pieces[1];
        if (header.indexOf(";base64") > -1) {
          body = atob(body);
        } else {
          body = decodeURIComponent(body);
        }
        setTimeout(function() {
          this.receive(url, elt, null, body);
        }.bind(this), 0);
      } else {
        var receiveXhr = function(err, resource, redirectedUrl) {
          this.receive(url, elt, err, resource, redirectedUrl);
        }.bind(this);
        xhr.load(url, receiveXhr);
      }
    },
    receive: function(url, elt, err, resource, redirectedUrl) {
      this.cache[url] = resource;
      var $p = this.pending[url];
      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {
        this.onload(url, p, resource, err, redirectedUrl);
        this.tail();
      }
      this.pending[url] = null;
    },
    tail: function() {
      --this.inflight;
      this.checkDone();
    },
    checkDone: function() {
      if (!this.inflight) {
        this.oncomplete();
      }
    }
  };
  scope.Loader = Loader;
});

window.HTMLImports.addModule(function(scope) {
  var Observer = function(addCallback) {
    this.addCallback = addCallback;
    this.mo = new MutationObserver(this.handler.bind(this));
  };
  Observer.prototype = {
    handler: function(mutations) {
      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {
        if (m.type === "childList" && m.addedNodes.length) {
          this.addedNodes(m.addedNodes);
        }
      }
    },
    addedNodes: function(nodes) {
      if (this.addCallback) {
        this.addCallback(nodes);
      }
      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {
        if (n.children && n.children.length) {
          this.addedNodes(n.children);
        }
      }
    },
    observe: function(root) {
      this.mo.observe(root, {
        childList: true,
        subtree: true
      });
    }
  };
  scope.Observer = Observer;
});

window.HTMLImports.addModule(function(scope) {
  var path = scope.path;
  var rootDocument = scope.rootDocument;
  var flags = scope.flags;
  var isIE = scope.isIE;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = "link[rel=" + IMPORT_LINK_TYPE + "]";
  var importParser = {
    documentSelectors: IMPORT_SELECTOR,
    importsSelectors: [ IMPORT_SELECTOR, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]' ].join(","),
    map: {
      link: "parseLink",
      script: "parseScript",
      style: "parseStyle"
    },
    dynamicElements: [],
    parseNext: function() {
      var next = this.nextToParse();
      if (next) {
        this.parse(next);
      }
    },
    parse: function(elt) {
      if (this.isParsed(elt)) {
        flags.parse && console.log("[%s] is already parsed", elt.localName);
        return;
      }
      var fn = this[this.map[elt.localName]];
      if (fn) {
        this.markParsing(elt);
        fn.call(this, elt);
      }
    },
    parseDynamic: function(elt, quiet) {
      this.dynamicElements.push(elt);
      if (!quiet) {
        this.parseNext();
      }
    },
    markParsing: function(elt) {
      flags.parse && console.log("parsing", elt);
      this.parsingElement = elt;
    },
    markParsingComplete: function(elt) {
      elt.__importParsed = true;
      this.markDynamicParsingComplete(elt);
      if (elt.__importElement) {
        elt.__importElement.__importParsed = true;
        this.markDynamicParsingComplete(elt.__importElement);
      }
      this.parsingElement = null;
      flags.parse && console.log("completed", elt);
    },
    markDynamicParsingComplete: function(elt) {
      var i = this.dynamicElements.indexOf(elt);
      if (i >= 0) {
        this.dynamicElements.splice(i, 1);
      }
    },
    parseImport: function(elt) {
      elt.import = elt.__doc;
      if (window.HTMLImports.__importsParsingHook) {
        window.HTMLImports.__importsParsingHook(elt);
      }
      if (elt.import) {
        elt.import.__importParsed = true;
      }
      this.markParsingComplete(elt);
      if (elt.__resource && !elt.__error) {
        elt.dispatchEvent(new CustomEvent("load", {
          bubbles: false
        }));
      } else {
        elt.dispatchEvent(new CustomEvent("error", {
          bubbles: false
        }));
      }
      if (elt.__pending) {
        var fn;
        while (elt.__pending.length) {
          fn = elt.__pending.shift();
          if (fn) {
            fn({
              target: elt
            });
          }
        }
      }
      this.parseNext();
    },
    parseLink: function(linkElt) {
      if (nodeIsImport(linkElt)) {
        this.parseImport(linkElt);
      } else {
        linkElt.href = linkElt.href;
        this.parseGeneric(linkElt);
      }
    },
    parseStyle: function(elt) {
      var src = elt;
      elt = cloneStyle(elt);
      src.__appliedElement = elt;
      elt.__importElement = src;
      this.parseGeneric(elt);
    },
    parseGeneric: function(elt) {
      this.trackElement(elt);
      this.addElementToDocument(elt);
    },
    rootImportForElement: function(elt) {
      var n = elt;
      while (n.ownerDocument.__importLink) {
        n = n.ownerDocument.__importLink;
      }
      return n;
    },
    addElementToDocument: function(elt) {
      var port = this.rootImportForElement(elt.__importElement || elt);
      port.parentNode.insertBefore(elt, port);
    },
    trackElement: function(elt, callback) {
      var self = this;
      var done = function(e) {
        elt.removeEventListener("load", done);
        elt.removeEventListener("error", done);
        if (callback) {
          callback(e);
        }
        self.markParsingComplete(elt);
        self.parseNext();
      };
      elt.addEventListener("load", done);
      elt.addEventListener("error", done);
      if (isIE && elt.localName === "style") {
        var fakeLoad = false;
        if (elt.textContent.indexOf("@import") == -1) {
          fakeLoad = true;
        } else if (elt.sheet) {
          fakeLoad = true;
          var csr = elt.sheet.cssRules;
          var len = csr ? csr.length : 0;
          for (var i = 0, r; i < len && (r = csr[i]); i++) {
            if (r.type === CSSRule.IMPORT_RULE) {
              fakeLoad = fakeLoad && Boolean(r.styleSheet);
            }
          }
        }
        if (fakeLoad) {
          setTimeout(function() {
            elt.dispatchEvent(new CustomEvent("load", {
              bubbles: false
            }));
          });
        }
      }
    },
    parseScript: function(scriptElt) {
      var script = document.createElement("script");
      script.__importElement = scriptElt;
      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);
      scope.currentScript = scriptElt;
      this.trackElement(script, function(e) {
        if (script.parentNode) {
          script.parentNode.removeChild(script);
        }
        scope.currentScript = null;
      });
      this.addElementToDocument(script);
    },
    nextToParse: function() {
      this._mayParse = [];
      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());
    },
    nextToParseInDoc: function(doc, link) {
      if (doc && this._mayParse.indexOf(doc) < 0) {
        this._mayParse.push(doc);
        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));
        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {
          if (!this.isParsed(n)) {
            if (this.hasResource(n)) {
              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;
            } else {
              return;
            }
          }
        }
      }
      return link;
    },
    nextToParseDynamic: function() {
      return this.dynamicElements[0];
    },
    parseSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;
    },
    isParsed: function(node) {
      return node.__importParsed;
    },
    needsDynamicParsing: function(elt) {
      return this.dynamicElements.indexOf(elt) >= 0;
    },
    hasResource: function(node) {
      if (nodeIsImport(node) && node.__doc === undefined) {
        return false;
      }
      return true;
    }
  };
  function nodeIsImport(elt) {
    return elt.localName === "link" && elt.rel === IMPORT_LINK_TYPE;
  }
  function generateScriptDataUrl(script) {
    var scriptContent = generateScriptContent(script);
    return "data:text/javascript;charset=utf-8," + encodeURIComponent(scriptContent);
  }
  function generateScriptContent(script) {
    return script.textContent + generateSourceMapHint(script);
  }
  function generateSourceMapHint(script) {
    var owner = script.ownerDocument;
    owner.__importedScripts = owner.__importedScripts || 0;
    var moniker = script.ownerDocument.baseURI;
    var num = owner.__importedScripts ? "-" + owner.__importedScripts : "";
    owner.__importedScripts++;
    return "\n//# sourceURL=" + moniker + num + ".js\n";
  }
  function cloneStyle(style) {
    var clone = style.ownerDocument.createElement("style");
    clone.textContent = style.textContent;
    path.resolveUrlsInStyle(clone);
    return clone;
  }
  scope.parser = importParser;
  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;
});

window.HTMLImports.addModule(function(scope) {
  var flags = scope.flags;
  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;
  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;
  var rootDocument = scope.rootDocument;
  var Loader = scope.Loader;
  var Observer = scope.Observer;
  var parser = scope.parser;
  var importer = {
    documents: {},
    documentPreloadSelectors: IMPORT_SELECTOR,
    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(","),
    loadNode: function(node) {
      importLoader.addNode(node);
    },
    loadSubtree: function(parent) {
      var nodes = this.marshalNodes(parent);
      importLoader.addNodes(nodes);
    },
    marshalNodes: function(parent) {
      return parent.querySelectorAll(this.loadSelectorsForNode(parent));
    },
    loadSelectorsForNode: function(node) {
      var doc = node.ownerDocument || node;
      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;
    },
    loaded: function(url, elt, resource, err, redirectedUrl) {
      flags.load && console.log("loaded", url, elt);
      elt.__resource = resource;
      elt.__error = err;
      if (isImportLink(elt)) {
        var doc = this.documents[url];
        if (doc === undefined) {
          doc = err ? null : makeDocument(resource, redirectedUrl || url);
          if (doc) {
            doc.__importLink = elt;
            this.bootDocument(doc);
          }
          this.documents[url] = doc;
        }
        elt.__doc = doc;
      }
      parser.parseNext();
    },
    bootDocument: function(doc) {
      this.loadSubtree(doc);
      this.observer.observe(doc);
      parser.parseNext();
    },
    loadedAll: function() {
      parser.parseNext();
    }
  };
  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));
  importer.observer = new Observer();
  function isImportLink(elt) {
    return isLinkRel(elt, IMPORT_LINK_TYPE);
  }
  function isLinkRel(elt, rel) {
    return elt.localName === "link" && elt.getAttribute("rel") === rel;
  }
  function hasBaseURIAccessor(doc) {
    return !!Object.getOwnPropertyDescriptor(doc, "baseURI");
  }
  function makeDocument(resource, url) {
    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);
    doc._URL = url;
    var base = doc.createElement("base");
    base.setAttribute("href", url);
    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {
      Object.defineProperty(doc, "baseURI", {
        value: url
      });
    }
    var meta = doc.createElement("meta");
    meta.setAttribute("charset", "utf-8");
    doc.head.appendChild(meta);
    doc.head.appendChild(base);
    doc.body.innerHTML = resource;
    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {
      HTMLTemplateElement.bootstrap(doc);
    }
    return doc;
  }
  if (!document.baseURI) {
    var baseURIDescriptor = {
      get: function() {
        var base = document.querySelector("base");
        return base ? base.href : window.location.href;
      },
      configurable: true
    };
    Object.defineProperty(document, "baseURI", baseURIDescriptor);
    Object.defineProperty(rootDocument, "baseURI", baseURIDescriptor);
  }
  scope.importer = importer;
  scope.importLoader = importLoader;
});

window.HTMLImports.addModule(function(scope) {
  var parser = scope.parser;
  var importer = scope.importer;
  var dynamic = {
    added: function(nodes) {
      var owner, parsed, loading;
      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {
        if (!owner) {
          owner = n.ownerDocument;
          parsed = parser.isParsed(owner);
        }
        loading = this.shouldLoadNode(n);
        if (loading) {
          importer.loadNode(n);
        }
        if (this.shouldParseNode(n) && parsed) {
          parser.parseDynamic(n, loading);
        }
      }
    },
    shouldLoadNode: function(node) {
      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));
    },
    shouldParseNode: function(node) {
      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));
    }
  };
  importer.observer.addCallback = dynamic.added.bind(dynamic);
  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;
});

(function(scope) {
  var initializeModules = scope.initializeModules;
  var isIE = scope.isIE;
  if (scope.useNative) {
    return;
  }
  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== "function") {
    window.CustomEvent = function(inType, params) {
      params = params || {};
      var e = document.createEvent("CustomEvent");
      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);
      e.preventDefault = function() {
        Object.defineProperty(this, "defaultPrevented", {
          get: function() {
            return true;
          }
        });
      };
      return e;
    };
    window.CustomEvent.prototype = window.Event.prototype;
  }
  initializeModules();
  var rootDocument = scope.rootDocument;
  function bootstrap() {
    window.HTMLImports.importer.bootDocument(rootDocument);
  }
  if (document.readyState === "complete" || document.readyState === "interactive" && !window.attachEvent) {
    bootstrap();
  } else {
    document.addEventListener("DOMContentLoaded", bootstrap);
  }
})(window.HTMLImports);
},{}],3:[function(_dereq_,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };

    Object.defineProperties( this.params, {
      PointCloud: {
        get: function () {
          console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
          return this.Points;
        }
      }
    } );

  };

  function ascSort( a, b ) {

    return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

    if ( object.visible === false ) return;

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  }

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( camera instanceof THREE.PerspectiveCamera ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( ascSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( ascSort );

      return intersects;

    }

  };

}( THREE ) );

},{}],4:[function(_dereq_,module,exports){
// performance.now() polyfill from https://gist.github.com/paulirish/5438650

(function(){

  // prepare base perf object
  if (typeof window.performance === 'undefined') {
      window.performance = {};
  }

  if (!window.performance.now){

    var nowOffset = Date.now();

    if (performance.timing && performance.timing.navigationStart){
      nowOffset = performance.timing.navigationStart
    }


    window.performance.now = function now(){
      return Date.now() - nowOffset;
    }

  }

})();

var rStats = function rStats( settings ) {

    'use strict';

    function importCSS( url ){

        var element = document.createElement('link');
        element.href = url;
        element.rel = 'stylesheet';
        element.type = 'text/css';
        document.getElementsByTagName('head')[0].appendChild(element)

    }

    var _settings = settings || {},
        _colours = [ '#850700', '#c74900', '#fcb300', '#284280', '#4c7c0c' ];

    importCSS( 'http://fonts.googleapis.com/css?family=Roboto+Condensed:400,700,300' );
    importCSS( ( _settings.CSSPath?_settings.CSSPath:'' ) + 'rStats.css' );

    if( !_settings.values ) _settings.values = {};

    function Graph( _dom, _id, _def ) {

        var _def = _def || {};
        var _canvas = document.createElement( 'canvas' ),
            _ctx = _canvas.getContext( '2d' ),
            _max = 0,
            _current = 0;

        var c = _def.color?_def.color:'#666666';
        var wc = _def.warningColor?_def.warningColor:'#b70000';

        var _dotCanvas = document.createElement( 'canvas' ),
            _dotCtx = _dotCanvas.getContext( '2d' );
        _dotCanvas.width = 1;
        _dotCanvas.height = 2 * _elHeight;
        _dotCtx.fillStyle = '#444444';
        _dotCtx.fillRect( 0, 0, 1, 2 * _elHeight );
        _dotCtx.fillStyle = c;
        _dotCtx.fillRect( 0, _elHeight, 1, _elHeight );
        _dotCtx.fillStyle = '#ffffff';
        _dotCtx.globalAlpha = .5;
        _dotCtx.fillRect( 0, _elHeight, 1, 1 );
        _dotCtx.globalAlpha = 1;

        var _alarmCanvas = document.createElement( 'canvas' ),
            _alarmCtx = _alarmCanvas.getContext( '2d' );
        _alarmCanvas.width = 1;
        _alarmCanvas.height = 2 * _elHeight;
        _alarmCtx.fillStyle = '#444444';
        _alarmCtx.fillRect( 0, 0, 1, 2 * _elHeight );
        _alarmCtx.fillStyle = '#b70000';
        _alarmCtx.fillRect( 0, _elHeight, 1, _elHeight );
        _alarmCtx.globalAlpha = .5;
        _alarmCtx.fillStyle = '#ffffff';
        _alarmCtx.fillRect( 0, _elHeight, 1, 1 );
        _alarmCtx.globalAlpha = 1;

        function _init() {

            _canvas.width = _elWidth;
            _canvas.height = _elHeight;
            _canvas.style.width = _canvas.width + 'px';
            _canvas.style.height = _canvas.height + 'px';
            _canvas.className = 'rs-canvas';
            _dom.appendChild( _canvas );

            _ctx.fillStyle = '#444444';
            _ctx.fillRect( 0, 0, _canvas.width, _canvas.height );

        }

        function _draw( v, alarm ) {
            _current += ( v - _current ) * .1;
            _max *= .99;
            if( _current > _max ) _max = _current;
            _ctx.drawImage( _canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height );
            if( alarm ) {
                _ctx.drawImage( _alarmCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight );
            } else {
                _ctx.drawImage( _dotCanvas, _canvas.width - 1, _canvas.height - _current * _canvas.height / _max - _elHeight );
            }
        }

        _init();

        return {
            draw: _draw
        }

    }

    function StackGraph( _dom, _num ) {

        var _canvas = document.createElement( 'canvas' ),
            _ctx = _canvas.getContext( '2d' ),
            _max = 0,
            _current = 0;

        function _init() {

            _canvas.width = _elWidth;
            _canvas.height = _elHeight * _num;
            _canvas.style.width = _canvas.width + 'px';
            _canvas.style.height = _canvas.height + 'px';
            _canvas.className = 'rs-canvas';
            _dom.appendChild( _canvas );

            _ctx.fillStyle = '#444444';
            _ctx.fillRect( 0, 0, _canvas.width, _canvas.height );

        }

        function _draw( v ) {
            _ctx.drawImage( _canvas, 1, 0, _canvas.width - 1, _canvas.height, 0, 0, _canvas.width - 1, _canvas.height );
            var th = 0;
            for( var j in v ) {
                var h = v[ j ] * _canvas.height;
                _ctx.fillStyle = _colours[ j ];
                _ctx.fillRect( _canvas.width - 1, th, 1, h );
                th += h;
            }
        }

        _init();

        return {
            draw: _draw
        }

    }

    function PerfCounter( id, group ) {

        var _id = id,
            _time,
            _value = 0,
            _total = 0,
            _averageValue = 0,
            _accumValue = 0,
            _accumStart = Date.now(),
            _accumSamples = 0,
            _dom = document.createElement( 'div' ),
            _spanId = document.createElement( 'span' ),
            _spanValue = document.createElement( 'div' ),
            _spanValueText = document.createTextNode( '' ),
            _def = _settings?_settings.values[ _id.toLowerCase() ]:null,
            _graph = new Graph( _dom, _id, _def );

        _dom.className = 'rs-counter-base';

        _spanId.className = 'rs-counter-id'
        _spanId.textContent = ( _def && _def.caption )?_def.caption:_id;

        _spanValue.className = 'rs-counter-value';
        _spanValue.appendChild( _spanValueText );

        _dom.appendChild( _spanId );
        _dom.appendChild( _spanValue );
        if( group ) group.div.appendChild( _dom );
        else _div.appendChild( _dom );

        _time = performance.now();

        function _average( v ) {
            if( _def && _def.average ) {
                _accumValue += v;
                _accumSamples++;
                var t = Date.now();
                if( t - _accumStart >= ( _def.avgMs || 1000 ) ) {
                    _averageValue = _accumValue / _accumSamples;
                    _accumValue = 0;
                    _accumStart = t;
                    _accumSamples = 0;
                }
            }
        }

        function _start(){
            _time = performance.now();
        }

        function _end() {
            _value = performance.now() - _time;
            _average( _value );
        }

        function _tick() {
            _end();
            _start();
        }

        function _draw() {
            var v = ( _def && _def.average )?_averageValue:_value
            _spanValueText.nodeValue = Math.round( v * 100 ) / 100;
            var a = ( _def && ( ( _def.below && _value < _def.below ) || ( _def.over && _value > _def.over ) ) );
            _graph.draw( _value, a );
            _dom.style.color = a?'#b70000':'#ffffff';
        }

        function _frame() {
            var t = performance.now();
            var e = t - _time;
            _total++;
            if( e > 1000 ) {
                _value = _total * 1000 / e;
                _total = 0;
                _time = t;
                _average( _value );
           }
        }

        function _set( v ) {
            _value = v;
            _average( _value );
        }

        return {
            set: _set,
            start: _start,
            tick: _tick,
            end: _end,
            frame: _frame,
            value: function(){ return _value; },
            draw: _draw
        }

    }

    function sample() {

        var _value = 0;

        function _set( v ) {
            _value = v;
        }

        return {
            set: _set,
            value: function(){ return _value; }
        }

    }

    var _base,
        _div,
        _height = null,
        _elHeight = 10,
        _elWidth = 200;

    var _perfCounters = {},
        _samples = {};

    function _perf( id ) {

        id = id.toLowerCase();
        if( id === undefined ) id = 'default';
        if( _perfCounters[ id ] ) return _perfCounters[ id ];

        var group = null;
        if( _settings && _settings.groups ) {
            for( var j in _settings.groups ) {
                var g = _settings.groups[ parseInt( j, 10 ) ];
                if( g.values.indexOf( id.toLowerCase() ) != -1 ) {
                    group = g;
                    continue;
                }
            }
        }

        var p = new PerfCounter( id, group );
        _perfCounters[ id ] = p;
        return p;

    }

    function _init() {

        if( _settings.plugins ) {
            if( !_settings.values ) _settings.values = {};
            if( !_settings.groups ) _settings.groups = [];
            if( !_settings.fractions ) _settings.fractions = [];
            for( var j = 0; j < _settings.plugins.length; j++ ) {
                _settings.plugins[ j ].attach( _perf );
                for( var k in _settings.plugins[ j ].values ) {
                    _settings.values[ k ] = _settings.plugins[ j ].values [ k ];
                }
                _settings.groups = _settings.groups.concat( _settings.plugins[ j ].groups );
                _settings.fractions = _settings.fractions.concat( _settings.plugins[ j ].fractions );
            }
        } else {
            _settings.plugins = {};
        }

        _base = document.createElement( 'div' );
        _base.className = 'rs-base';
        _div = document.createElement( 'div' );
        _div.className = 'rs-container';
        _div.style.height = 'auto';
        _base.appendChild( _div );
        document.body.appendChild( _base );

        var style = window.getComputedStyle( _base, null ).getPropertyValue( 'font-size' );
        //_elHeight = parseFloat( style );

        if( !_settings ) return;

        if( _settings.groups ) {
            for( var j in _settings.groups ) {
                var g = _settings.groups[ parseInt( j, 10 ) ];
                var div = document.createElement( 'div' );
                div.className = 'rs-group';
                g.div = div;
                var h1 = document.createElement( 'h1' );
                h1.textContent = g.caption;
                h1.addEventListener( 'click', function( e ) {
                    this.classList.toggle( 'hidden' );
                    e.preventDefault();
                }.bind( div ) );
                _div.appendChild( h1 );
                _div.appendChild( div );
            }
        }

        if( _settings.fractions ) {
            for( var j in _settings.fractions ) {
                var f = _settings.fractions[ parseInt( j, 10 ) ];
                var div = document.createElement( 'div' );
                div.className = 'rs-fraction';
                var legend = document.createElement( 'div' );
                legend.className = 'rs-legend';

                var h = 0;
                for( var k in _settings.fractions[ j ].steps ) {
                    var p = document.createElement( 'p' );
                    p.textContent = _settings.fractions[ j ].steps[ k ];
                    p.style.color = _colours[ h ];
                    legend.appendChild( p );
                    h++;
                }
                div.appendChild( legend );
                div.style.height = h * _elHeight + 'px';
                f.div = div;
                var graph = new StackGraph( div, h );
                f.graph = graph;
                _div.appendChild( div );
            }
        }

    }

    function _update() {

        for( var j in _settings.plugins ) {
            _settings.plugins[ j ].update();
        }

        for( var j in _perfCounters ) {
            _perfCounters[ j ].draw();
        }

        if( _settings && _settings.fractions ) {
            for( var j in _settings.fractions ) {
                var f = _settings.fractions[ parseInt( j, 10 ) ];
                var v = [];
                var base = _perfCounters[ f.base.toLowerCase() ];
                if( base ) {
                    base = base.value();
                    for( var k in _settings.fractions[ j ].steps ) {
                        var s = _settings.fractions[ j ].steps[ parseInt( k, 10 ) ].toLowerCase();
                        var val = _perfCounters[ s ];
                        if( val ) {
                            v.push( val.value() / base );
                        }
                    }
                }
                f.graph.draw( v );
            }
        }

        /*if( _height != _div.clientHeight ) {
            _height = _div.clientHeight;
            _base.style.height = _height + 2 * _elHeight + 'px';
        console.log( _base.clientHeight );
        }*/

    }

    _init();

    return function( id ) {
        if( id ) return _perf( id );
        return {
            update: _update
        }
    }

};

if (typeof module !== "undefined") { module.exports = rStats; }
},{}],5:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = {};

Util.base64 = function(mimeType, base64) {
  return 'data:' + mimeType + ';base64,' + base64;
};

Util.isMobile = function() {
  var check = false;
  (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
  return check;
};

Util.isIOS = function() {
  return /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
};

Util.isIFrame = function() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
};

Util.appendQueryParameter = function(url, key, value) {
  // Determine delimiter based on if the URL already GET parameters in it.
  var delimiter = (url.indexOf('?') < 0 ? '?' : '&');
  url += delimiter + key + '=' + value;
  return url;
};

// From http://goo.gl/4WX3tg
Util.getQueryParameter = function(name) {
  name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
      results = regex.exec(location.search);
  return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

Util.isLandscapeMode = function() {
  return (window.orientation == 90 || window.orientation == -90);
};


module.exports = Util;

},{}],6:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Util = _dereq_('./util.js');

/**
 * Android and iOS compatible wakelock implementation.
 *
 * Refactored thanks to dkovalev@.
 */
function AndroidWakeLock() {
  var video = document.createElement('video');

  video.addEventListener('ended', function() {
    video.play();
  });

  this.request = function() {
    if (video.paused) {
      // Base64 version of videos_src/no-sleep-60s.webm.
      video.src = Util.base64('video/webm', 'GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4ECQoWBAhhTgGcBAAAAAAAH4xFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsggfG7AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU2LjQwLjEwMVdBjUxhdmY1Ni40MC4xMDFzpJAGSJTMbsLpDt/ySkipgX1fRImIQO1MAAAAAAAWVK5rAQAAAAAAADuuAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDmDgQEj44OEO5rKAOABAAAAAAAABrCBsLqBkB9DtnUBAAAAAAAAo+eBAKOmgQAAgKJJg0IAAV4BHsAHBIODCoAACmH2MAAAZxgz4dPSTFi5JACjloED6ACmAECSnABMQAADYAAAWi0quoCjloEH0ACmAECSnABNwAADYAAAWi0quoCjloELuACmAECSnABNgAADYAAAWi0quoCjloEPoACmAECSnABNYAADYAAAWi0quoCjloETiACmAECSnABNIAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTnghdwo5aBAAAApgBAkpwATOAAA2AAAFotKrqAo5aBA+gApgBAkpwATMAAA2AAAFotKrqAo5aBB9AApgBAkpwATIAAA2AAAFotKrqAo5aBC7gApgBAkpwATEAAA2AAAFotKrqAo5aBD6AApgDAkpwAQ2AAA2AAAFotKrqAo5aBE4gApgBAkpwATCAAA2AAAFotKrqAH0O2dQEAAAAAAACU54Iu4KOWgQAAAKYAQJKcAEvAAANgAABaLSq6gKOWgQPoAKYAQJKcAEtgAANgAABaLSq6gKOWgQfQAKYAQJKcAEsAAANgAABaLSq6gKOWgQu4AKYAQJKcAEqAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEogAANgAABaLSq6gKOWgROIAKYAQJKcAEnAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCRlCjloEAAACmAECSnABJgAADYAAAWi0quoCjloED6ACmAECSnABJIAADYAAAWi0quoCjloEH0ACmAMCSnABDYAADYAAAWi0quoCjloELuACmAECSnABI4AADYAAAWi0quoCjloEPoACmAECSnABIoAADYAAAWi0quoCjloETiACmAECSnABIYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngl3Ao5aBAAAApgBAkpwASCAAA2AAAFotKrqAo5aBA+gApgBAkpwASAAAA2AAAFotKrqAo5aBB9AApgBAkpwAR8AAA2AAAFotKrqAo5aBC7gApgBAkpwAR4AAA2AAAFotKrqAo5aBD6AApgBAkpwAR2AAA2AAAFotKrqAo5aBE4gApgBAkpwARyAAA2AAAFotKrqAH0O2dQEAAAAAAACU54J1MKOWgQAAAKYAwJKcAENgAANgAABaLSq6gKOWgQPoAKYAQJKcAEbgAANgAABaLSq6gKOWgQfQAKYAQJKcAEagAANgAABaLSq6gKOWgQu4AKYAQJKcAEaAAANgAABaLSq6gKOWgQ+gAKYAQJKcAEZAAANgAABaLSq6gKOWgROIAKYAQJKcAEYAAANgAABaLSq6gB9DtnUBAAAAAAAAlOeCjKCjloEAAACmAECSnABF4AADYAAAWi0quoCjloED6ACmAECSnABFwAADYAAAWi0quoCjloEH0ACmAECSnABFoAADYAAAWi0quoCjloELuACmAECSnABFgAADYAAAWi0quoCjloEPoACmAMCSnABDYAADYAAAWi0quoCjloETiACmAECSnABFYAADYAAAWi0quoAfQ7Z1AQAAAAAAAJTngqQQo5aBAAAApgBAkpwARUAAA2AAAFotKrqAo5aBA+gApgBAkpwARSAAA2AAAFotKrqAo5aBB9AApgBAkpwARQAAA2AAAFotKrqAo5aBC7gApgBAkpwARQAAA2AAAFotKrqAo5aBD6AApgBAkpwAROAAA2AAAFotKrqAo5aBE4gApgBAkpwARMAAA2AAAFotKrqAH0O2dQEAAAAAAACU54K7gKOWgQAAAKYAQJKcAESgAANgAABaLSq6gKOWgQPoAKYAQJKcAESAAANgAABaLSq6gKOWgQfQAKYAwJKcAENgAANgAABaLSq6gKOWgQu4AKYAQJKcAERgAANgAABaLSq6gKOWgQ+gAKYAQJKcAERAAANgAABaLSq6gKOWgROIAKYAQJKcAEQgAANgAABaLSq6gB9DtnUBAAAAAAAAlOeC0vCjloEAAACmAECSnABEIAADYAAAWi0quoCjloED6ACmAECSnABEAAADYAAAWi0quoCjloEH0ACmAECSnABD4AADYAAAWi0quoCjloELuACmAECSnABDwAADYAAAWi0quoCjloEPoACmAECSnABDoAADYAAAWi0quoCjloETiACmAECSnABDgAADYAAAWi0quoAcU7trAQAAAAAAABG7j7OBALeK94EB8YIBd/CBAw==');
      video.play();
    }
  };

  this.release = function() {
    video.pause();
    video.src = '';
  };
}

function iOSWakeLock() {
  var timer = null;

  this.request = function() {
    if (!timer) {
      timer = setInterval(function() {
        window.location = window.location;
        setTimeout(window.stop, 0);
      }, 30000);
    }
  }

  this.release = function() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
}


function getWakeLock() {
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  if (userAgent.match(/iPhone/i) || userAgent.match(/iPod/i)) {
    return iOSWakeLock;
  } else {
    return AndroidWakeLock;
  }
}

module.exports = getWakeLock();

},{"./util.js":5}],7:[function(_dereq_,module,exports){
'use strict';
// For more information about browser field, check out the browser field at https://github.com/substack/browserify-handbook#browser-field.

module.exports = {
    // Create a <link> tag with optional data attributes
    createLink: function(href, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0];
        var link = document.createElement('link');

        link.href = href;
        link.rel = 'stylesheet';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            link.setAttribute('data-' + key, value);
        }

        head.appendChild(link);
    },
    // Create a <style> tag with optional data attributes
    createStyle: function(cssText, attributes) {
        var head = document.head || document.getElementsByTagName('head')[0],
            style = document.createElement('style');

        style.type = 'text/css';

        for (var key in attributes) {
            if ( ! attributes.hasOwnProperty(key)) {
                continue;
            }
            var value = attributes[key];
            style.setAttribute('data-' + key, value);
        }

        if (style.sheet) { // for jsdom and IE9+
            style.innerHTML = cssText;
            style.sheet.cssText = cssText;
            head.appendChild(style);
        } else if (style.styleSheet) { // for IE8 and below
            head.appendChild(style);
            style.styleSheet.cssText = cssText;
        } else { // for Chrome, Firefox, and Safari
            style.appendChild(document.createTextNode(cssText));
            head.appendChild(style);
        }
    }
};

},{}],8:[function(_dereq_,module,exports){
/**
 * Expose `requestAnimationFrame()`.
 */

exports = module.exports = window.requestAnimationFrame
  || window.webkitRequestAnimationFrame
  || window.mozRequestAnimationFrame
  || fallback;

/**
 * Fallback implementation.
 */

var prev = new Date().getTime();
function fallback(fn) {
  var curr = new Date().getTime();
  var ms = Math.max(0, 16 - (curr - prev));
  var req = setTimeout(fn, ms);
  prev = curr;
  return req;
}

/**
 * Cancel.
 */

var cancel = window.cancelAnimationFrame
  || window.webkitCancelAnimationFrame
  || window.mozCancelAnimationFrame
  || window.clearTimeout;

exports.cancel = function(id){
  cancel.call(window, id);
};

},{}],9:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":10}],10:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":13}],11:[function(_dereq_,module,exports){
/*! (C) WebReflection Mit Style License */
(function(e,t,n,r){"use strict";function rt(e,t){for(var n=0,r=e.length;n<r;n++)vt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(vt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute("is"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is="'+t+'"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!=="style"&e.prevValue!==e.newValue&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(n--,F.splice(t--,1),vt(e,o))}function dt(e){throw new Error("A "+e+" type is already registered")}function vt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+"Callback"])&&n.call(e))}if(r in t)return;var i="__"+r+(Math.random()*1e5>>0),s="attached",o="detached",u="extends",a="ADDITION",f="MODIFICATION",l="REMOVAL",c="DOMAttrModified",h="DOMContentLoaded",p="DOMSubtreeModified",d="<",v="=",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=["ANNOTATION-XML","COLOR-PROFILE","FONT-FACE","FONT-FACE-SRC","FONT-FACE-URI","FONT-FACE-FORMAT","FONT-FACE-NAME","MISSING-GLYPH"],y=[],b=[],w="",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function mt(e){return e?(mt.prototype=e,new mt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,"addEventListener"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:"class",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,"propertychange",s)),t.call(this,e,o,u)},C(H,"addEventListener",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!=="setAttribute"&&(r[n]=t.value);return r})),t[r]=function(n,r){c=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type==="childList"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!=="style"&&(o=s.getAttribute(i.attributeName),o!==i.oldValue&&s.attributeChangedCallback(i.attributeName,i.oldValue,o)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener("DOMNodeInserted",ft(s)),t.addEventListener("DOMNodeRemoved",ft(o))),t.addEventListener(h,lt),t.addEventListener("readystatechange",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=""+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute("is",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t}),-2<S.call(y,v+c)+S.call(y,d+c)&&dt(n);if(!m.test(c)||-1<S.call(g,c))throw new Error("The type "+n+" is invalid");var i=function(){return f?t.createElement(l,c):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():c,c,p;return f&&-1<S.call(y,d+l)&&dt(l),p=y.push((f?v:d)+c)-1,w=w.concat(w.length?",":"",f?l+'[is="'+n.toLowerCase()+'"]':l),i.prototype=b[p]=T.call(a,"prototype")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,"registerElement");
},{}],12:[function(_dereq_,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   3.0.2
 */

(function() {
    "use strict";
    function lib$es6$promise$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function lib$es6$promise$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function lib$es6$promise$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var lib$es6$promise$utils$$_isArray;
    if (!Array.isArray) {
      lib$es6$promise$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      lib$es6$promise$utils$$_isArray = Array.isArray;
    }

    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
    var lib$es6$promise$asap$$len = 0;
    var lib$es6$promise$asap$$toString = {}.toString;
    var lib$es6$promise$asap$$vertxNext;
    var lib$es6$promise$asap$$customSchedulerFn;

    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
      lib$es6$promise$asap$$len += 2;
      if (lib$es6$promise$asap$$len === 2) {
        // If len is 2, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        if (lib$es6$promise$asap$$customSchedulerFn) {
          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
        } else {
          lib$es6$promise$asap$$scheduleFlush();
        }
      }
    }

    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
    }

    function lib$es6$promise$asap$$setAsap(asapFn) {
      lib$es6$promise$asap$$asap = asapFn;
    }

    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

    // test for web worker but not in IE10
    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function lib$es6$promise$asap$$useNextTick() {
      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
      // see https://github.com/cujojs/when/issues/410 for details
      return function() {
        process.nextTick(lib$es6$promise$asap$$flush);
      };
    }

    // vertx
    function lib$es6$promise$asap$$useVertxTimer() {
      return function() {
        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
      };
    }

    function lib$es6$promise$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function lib$es6$promise$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = lib$es6$promise$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function lib$es6$promise$asap$$useSetTimeout() {
      return function() {
        setTimeout(lib$es6$promise$asap$$flush, 1);
      };
    }

    var lib$es6$promise$asap$$queue = new Array(1000);
    function lib$es6$promise$asap$$flush() {
      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
        var callback = lib$es6$promise$asap$$queue[i];
        var arg = lib$es6$promise$asap$$queue[i+1];

        callback(arg);

        lib$es6$promise$asap$$queue[i] = undefined;
        lib$es6$promise$asap$$queue[i+1] = undefined;
      }

      lib$es6$promise$asap$$len = 0;
    }

    function lib$es6$promise$asap$$attemptVertx() {
      try {
        var r = _dereq_;
        var vertx = r('vertx');
        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
        return lib$es6$promise$asap$$useVertxTimer();
      } catch(e) {
        return lib$es6$promise$asap$$useSetTimeout();
      }
    }

    var lib$es6$promise$asap$$scheduleFlush;
    // Decide what async method to use to triggering processing of queued callbacks:
    if (lib$es6$promise$asap$$isNode) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
    } else if (lib$es6$promise$asap$$isWorker) {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof _dereq_ === 'function') {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }

    function lib$es6$promise$$internal$$noop() {}

    var lib$es6$promise$$internal$$PENDING   = void 0;
    var lib$es6$promise$$internal$$FULFILLED = 1;
    var lib$es6$promise$$internal$$REJECTED  = 2;

    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$selfFulfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function lib$es6$promise$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.');
    }

    function lib$es6$promise$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
        return lib$es6$promise$$internal$$GET_THEN_ERROR;
      }
    }

    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
       lib$es6$promise$asap$$asap(function(promise) {
        var sealed = false;
        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            lib$es6$promise$$internal$$resolve(promise, value);
          } else {
            lib$es6$promise$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          lib$es6$promise$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          lib$es6$promise$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, thenable._result);
      } else {
        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      }
    }

    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        } else if (lib$es6$promise$utils$$isFunction(then)) {
          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function lib$es6$promise$$internal$$resolve(promise, value) {
      if (promise === value) {
        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
      } else {
        lib$es6$promise$$internal$$fulfill(promise, value);
      }
    }

    function lib$es6$promise$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      lib$es6$promise$$internal$$publish(promise);
    }

    function lib$es6$promise$$internal$$fulfill(promise, value) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = lib$es6$promise$$internal$$FULFILLED;

      if (promise._subscribers.length !== 0) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
      }
    }

    function lib$es6$promise$$internal$$reject(promise, reason) {
      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
      promise._state = lib$es6$promise$$internal$$REJECTED;
      promise._result = reason;

      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
    }

    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
      }
    }

    function lib$es6$promise$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function lib$es6$promise$$internal$$ErrorObject() {
      this.error = null;
    }

    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
      }
    }

    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        lib$es6$promise$$internal$$resolve(promise, value);
      } else if (failed) {
        lib$es6$promise$$internal$$reject(promise, error);
      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
        lib$es6$promise$$internal$$fulfill(promise, value);
      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
        lib$es6$promise$$internal$$reject(promise, value);
      }
    }

    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          lib$es6$promise$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          lib$es6$promise$$internal$$reject(promise, reason);
        });
      } catch(e) {
        lib$es6$promise$$internal$$reject(promise, e);
      }
    }

    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
      var enumerator = this;

      enumerator._instanceConstructor = Constructor;
      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (enumerator._validateInput(input)) {
        enumerator._input     = input;
        enumerator.length     = input.length;
        enumerator._remaining = input.length;

        enumerator._init();

        if (enumerator.length === 0) {
          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
        } else {
          enumerator.length = enumerator.length || 0;
          enumerator._enumerate();
          if (enumerator._remaining === 0) {
            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
          }
        }
      } else {
        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
      }
    }

    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return lib$es6$promise$utils$$isArray(input);
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
      var enumerator = this;

      var length  = enumerator.length;
      var promise = enumerator.promise;
      var input   = enumerator._input;

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        enumerator._eachEntry(input[i], i);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var enumerator = this;
      var c = enumerator._instanceConstructor;

      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
          entry._onerror = null;
          enumerator._settledAt(entry._state, i, entry._result);
        } else {
          enumerator._willSettleAt(c.resolve(entry), i);
        }
      } else {
        enumerator._remaining--;
        enumerator._result[i] = entry;
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var enumerator = this;
      var promise = enumerator.promise;

      if (promise._state === lib$es6$promise$$internal$$PENDING) {
        enumerator._remaining--;

        if (state === lib$es6$promise$$internal$$REJECTED) {
          lib$es6$promise$$internal$$reject(promise, value);
        } else {
          enumerator._result[i] = value;
        }
      }

      if (enumerator._remaining === 0) {
        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
      }
    };

    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
      });
    };
    function lib$es6$promise$promise$all$$all(entries) {
      return new lib$es6$promise$enumerator$$default(this, entries).promise;
    }
    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
    function lib$es6$promise$promise$race$$race(entries) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor(lib$es6$promise$$internal$$noop);

      if (!lib$es6$promise$utils$$isArray(entries)) {
        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        lib$es6$promise$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        lib$es6$promise$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    }
    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
    function lib$es6$promise$promise$resolve$$resolve(object) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$resolve(promise, object);
      return promise;
    }
    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
    function lib$es6$promise$promise$reject$$reject(reason) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor(lib$es6$promise$$internal$$noop);
      lib$es6$promise$$internal$$reject(promise, reason);
      return promise;
    }
    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

    var lib$es6$promise$promise$$counter = 0;

    function lib$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function lib$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise's eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function lib$es6$promise$promise$$Promise(resolver) {
      this._id = lib$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if (lib$es6$promise$$internal$$noop !== resolver) {
        if (!lib$es6$promise$utils$$isFunction(resolver)) {
          lib$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
          lib$es6$promise$promise$$needsNew();
        }

        lib$es6$promise$$internal$$initializePromise(this, resolver);
      }
    }

    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

    lib$es6$promise$promise$$Promise.prototype = {
      constructor: lib$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor(lib$es6$promise$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          lib$es6$promise$asap$$asap(function(){
            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    function lib$es6$promise$polyfill$$polyfill() {
      var local;

      if (typeof global !== 'undefined') {
          local = global;
      } else if (typeof self !== 'undefined') {
          local = self;
      } else {
          try {
              local = Function('return this')();
          } catch (e) {
              throw new Error('polyfill failed because global object is unavailable in this environment');
          }
      }

      var P = local.Promise;

      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
        return;
      }

      local.Promise = lib$es6$promise$promise$$default;
    }
    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

    var lib$es6$promise$umd$$ES6Promise = {
      'Promise': lib$es6$promise$promise$$default,
      'polyfill': lib$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return lib$es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = lib$es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
    }

    lib$es6$promise$polyfill$$default();
}).call(this);


}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":16}],13:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],14:[function(_dereq_,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

module.exports = Object.assign || function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (Object.getOwnPropertySymbols) {
      symbols = Object.getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

},{}],15:[function(_dereq_,module,exports){
(function (global){
var performance = global.performance || {};

var present = (function () {
  var names = ['now', 'webkitNow', 'msNow', 'mozNow', 'oNow'];
  while (names.length) {
    var name = names.shift();
    if (name in performance) {
      return performance[name].bind(performance);
    }
  }

  var dateNow = Date.now || function () { return new Date().getTime(); };
  var navigationStart = (performance.timing || {}).navigationStart || dateNow();
  return function () {
    return dateNow() - navigationStart;
  };
}());

present.performanceNow = performance.now;
present.noConflict = function () {
  performance.now = present.performanceNow;
};
present.conflict = function () {
  performance.now = present;
};
present.conflict();

module.exports = present;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],17:[function(_dereq_,module,exports){
'use strict';

var raf = _dereq_('raf');
var now = _dereq_('time-now');

exports = module.exports = interval;
function interval(delay, fn, ctx) {
  var start = now();
  var data = Object.create(null);
  data.id = raf(loop);

  return data;

  function loop() {
    data.id = raf(loop);

    if ((now() - start) >= delay) {
      fn.call(ctx);
      start = now();
    }
  }
}


exports.clear = clearInterval;
function clearInterval(data) {
  raf.cancel(data.id);
}

},{"raf":8,"time-now":25}],18:[function(_dereq_,module,exports){
/*

style-attr
====

Very simple parsing and stringifying of style attributes.

`parse`
----

Convert a style attribute string to an object.

- input: string (eg. anything you might see in a style attribute)
- return: object

*/
function parse (raw) {
  var trim = function (s) { return s.trim(); };
  var obj = {};
  raw
    .split(';')
    .map(trim)
    .filter(Boolean)
    .forEach(function (item) {
      // split with `.indexOf` rather than `.split` because the value may also contain colons.
      var pos = item.indexOf(':');
      var key = item.substr(0, pos).trim();
      var val = item.substr(pos + 1).trim();

      obj[key] = val;
    });

  return obj;
}

/*

`stringify`
----

Convert an object into an attribute string

- input: object
- return: string

*/
function stringify (obj) {
  return Object.keys(obj)
    .map(function (key) {
      return key + ':' + obj[key];
    })
    .join(';');
}

/*

`normalize`
----

Normalize an attribute string (eg. collapse duplicates)

- input: string
- return: string

*/
function normalize (str) {
  return stringify(parse(str));
}

module.exports.parse = parse;
module.exports.stringify = stringify;
module.exports.normalize = normalize;

},{}],19:[function(_dereq_,module,exports){
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '74dev' };

//

if ( typeof define === 'function' && define.amd ) {

  define( 'three', THREE );

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

  module.exports = THREE;

}


// polyfills

if ( self.requestAnimationFrame === undefined || self.cancelAnimationFrame === undefined ) {

  // Missing in Android stock browser.

  ( function () {

    var lastTime = 0;
    var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

    for ( var x = 0; x < vendors.length && ! self.requestAnimationFrame; ++ x ) {

      self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
      self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

    }

    if ( self.requestAnimationFrame === undefined && self.setTimeout !== undefined ) {

      self.requestAnimationFrame = function ( callback ) {

        var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
        var id = self.setTimeout( function () {

          callback( currTime + timeToCall );

        }, timeToCall );
        lastTime = currTime + timeToCall;
        return id;

      };

    }

    if ( self.cancelAnimationFrame === undefined && self.clearTimeout !== undefined ) {

      self.cancelAnimationFrame = function ( id ) {

        self.clearTimeout( id );

      };

    }

  } )();

}

//

if ( self.performance === undefined ) {

  self.performance = {};

}

if ( self.performance.now === undefined ) {

  ( function () {

    var start = Date.now();

    self.performance.now = function () {

      return Date.now() - start;

    }

  } )();

}

//

if ( Number.EPSILON === undefined ) {

  Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  Math.sign = function ( x ) {

    return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

  };

}

if ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {

  // Missing in IE9-11.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

  Object.defineProperty( Function.prototype, 'name', {

    get: function () {

      return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    }

  } );

}

if ( Object.assign === undefined ) {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

  Object.defineProperty( Object, 'assign', {

    writable: true,
    configurable: true,

    value: function ( target ) {

      'use strict';

      if ( target === undefined || target === null ) {

        throw new TypeError( "Cannot convert first argument to object" );

      }

      var to = Object( target );

      for ( var i = 1, n = arguments.length; i !== n; ++ i ) {

        var nextSource = arguments[ i ];

        if ( nextSource === undefined || nextSource === null ) continue;

        nextSource = Object( nextSource );

        var keysArray = Object.keys( nextSource );

        for ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {

          var nextKey = keysArray[ nextIndex ];
          var desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );

          if ( desc !== undefined && desc.enumerable ) {

            to[ nextKey ] = nextSource[ nextKey ];

          }

        }

      }

      return to;

    }

  } );

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
// mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// Loop styles for AnimationAction

THREE.LoopOnce = 2200;
THREE.LoopRepeat = 2201;
THREE.LoopPingPong = 2202;

// Interpolation

THREE.InterpolateDiscrete = 2300;
THREE.InterpolateLinear = 2301;
THREE.InterpolateSmooth = 2302;

// Interpolant ending modes

THREE.ZeroCurvatureEnding = 2400;
THREE.ZeroSlopeEnding = 2401;
THREE.WrapAroundEnding = 2402;

// Triangle Draw modes

THREE.TrianglesDrawMode = 0;
THREE.TriangleStripDrawMode = 1;
THREE.TriangleFanDrawMode = 2;

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

  if ( arguments.length === 3 ) {

    return this.fromArray( arguments );

  }

  return this.set( color );

};

THREE.Color.prototype = {

  constructor: THREE.Color,

  r: 1, g: 1, b: 1,

  set: function ( value ) {

    if ( value instanceof THREE.Color ) {

      this.copy( value );

    } else if ( typeof value === 'number' ) {

      this.setHex( value );

    } else if ( typeof value === 'string' ) {

      this.setStyle( value );

    }

    return this;

  },

  setScalar: function ( scalar ) {

    this.r = scalar;
    this.g = scalar;
    this.b = scalar;

  },

  setHex: function ( hex ) {

    hex = Math.floor( hex );

    this.r = ( hex >> 16 & 255 ) / 255;
    this.g = ( hex >> 8 & 255 ) / 255;
    this.b = ( hex & 255 ) / 255;

    return this;

  },

  setRGB: function ( r, g, b ) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;

  },

  setHSL: function () {

    function hue2rgb( p, q, t ) {

      if ( t < 0 ) t += 1;
      if ( t > 1 ) t -= 1;
      if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
      if ( t < 1 / 2 ) return q;
      if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
      return p;

    }

    return function ( h, s, l ) {

      // h,s,l ranges are in 0.0 - 1.0
      h = THREE.Math.euclideanModulo( h, 1 );
      s = THREE.Math.clamp( s, 0, 1 );
      l = THREE.Math.clamp( l, 0, 1 );

      if ( s === 0 ) {

        this.r = this.g = this.b = l;

      } else {

        var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
        var q = ( 2 * l ) - p;

        this.r = hue2rgb( q, p, h + 1 / 3 );
        this.g = hue2rgb( q, p, h );
        this.b = hue2rgb( q, p, h - 1 / 3 );

      }

      return this;

    };

  }(),

  setStyle: function ( style ) {

    function handleAlpha( string ) {

      if ( string === undefined ) return;

      if ( parseFloat( string ) < 1 ) {

        console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

      }

    }


    var m;

    if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

      // rgb / hsl

      var color;
      var name = m[ 1 ];
      var components = m[ 2 ];

      switch ( name ) {

        case 'rgb':
        case 'rgba':

          if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

            // rgb(255,0,0) rgba(255,0,0,0.5)
            this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
            this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
            this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

            handleAlpha( color[ 5 ] );

            return this;

          }

          if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
            this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
            this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
            this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

            handleAlpha( color[ 5 ] );

            return this;

          }

          break;

        case 'hsl':
        case 'hsla':

          if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
            var h = parseFloat( color[ 1 ] ) / 360;
            var s = parseInt( color[ 2 ], 10 ) / 100;
            var l = parseInt( color[ 3 ], 10 ) / 100;

            handleAlpha( color[ 5 ] );

            return this.setHSL( h, s, l );

          }

          break;

      }

    } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

      // hex color

      var hex = m[ 1 ];
      var size = hex.length;

      if ( size === 3 ) {

        // #ff0
        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
        this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
        this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

        return this;

      } else if ( size === 6 ) {

        // #ff0000
        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
        this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
        this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

        return this;

      }

    }

    if ( style && style.length > 0 ) {

      // color keywords
      var hex = THREE.ColorKeywords[ style ];

      if ( hex !== undefined ) {

        // red
        this.setHex( hex );

      } else {

        // unknown color
        console.warn( 'THREE.Color: Unknown color ' + style );

      }

    }

    return this;

  },

  clone: function () {

    return new this.constructor( this.r, this.g, this.b );

  },

  copy: function ( color ) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;

  },

  copyGammaToLinear: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    this.r = Math.pow( color.r, gammaFactor );
    this.g = Math.pow( color.g, gammaFactor );
    this.b = Math.pow( color.b, gammaFactor );

    return this;

  },

  copyLinearToGamma: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    this.r = Math.pow( color.r, safeInverse );
    this.g = Math.pow( color.g, safeInverse );
    this.b = Math.pow( color.b, safeInverse );

    return this;

  },

  convertGammaToLinear: function () {

    var r = this.r, g = this.g, b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;

  },

  convertLinearToGamma: function () {

    this.r = Math.sqrt( this.r );
    this.g = Math.sqrt( this.g );
    this.b = Math.sqrt( this.b );

    return this;

  },

  getHex: function () {

    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  },

  getHexString: function () {

    return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  },

  getHSL: function ( optionalTarget ) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r, g = this.g, b = this.b;

    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );

    var hue, saturation;
    var lightness = ( min + max ) / 2.0;

    if ( min === max ) {

      hue = 0;
      saturation = 0;

    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

      switch ( max ) {

        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
        case g: hue = ( b - r ) / delta + 2; break;
        case b: hue = ( r - g ) / delta + 4; break;

      }

      hue /= 6;

    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;

  },

  getStyle: function () {

    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  },

  offsetHSL: function ( h, s, l ) {

    var hsl = this.getHSL();

    hsl.h += h; hsl.s += s; hsl.l += l;

    this.setHSL( hsl.h, hsl.s, hsl.l );

    return this;

  },

  add: function ( color ) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;

  },

  addColors: function ( color1, color2 ) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;

  },

  addScalar: function ( s ) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;

  },

  multiply: function ( color ) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;

  },

  lerp: function ( color, alpha ) {

    this.r += ( color.r - this.r ) * alpha;
    this.g += ( color.g - this.g ) * alpha;
    this.b += ( color.b - this.b ) * alpha;

    return this;

  },

  equals: function ( c ) {

    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.r = array[ offset ];
    this.g = array[ offset + 1 ];
    this.b = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.r;
    array[ offset + 1 ] = this.g;
    array[ offset + 2 ] = this.b;

    return array;

  }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  clone: function () {

    return new this.constructor( this._x, this._y, this._z, this._w );

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    var order = euler.order;

    if ( order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    };

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {}

};

Object.assign( THREE.Quaternion, {

  slerp: function( qa, qb, qm, t ) {

    return qm.copy( qa ).slerp( qb, t );

  },

  slerpFlat: function(
      dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    // fuzz-free, array-based Quaternion SLERP operation

    var x0 = src0[ srcOffset0 + 0 ],
      y0 = src0[ srcOffset0 + 1 ],
      z0 = src0[ srcOffset0 + 2 ],
      w0 = src0[ srcOffset0 + 3 ],

      x1 = src1[ srcOffset1 + 0 ],
      y1 = src1[ srcOffset1 + 1 ],
      z1 = src1[ srcOffset1 + 2 ],
      w1 = src1[ srcOffset1 + 3 ];

    if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

      var s = 1 - t,

        cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

        dir = ( cos >= 0 ? 1 : - 1 ),
        sqrSin = 1 - cos * cos;

      // Skip the Slerp for tiny steps to avoid numeric problems:
      if ( sqrSin > Number.EPSILON ) {

        var sin = Math.sqrt( sqrSin ),
          len = Math.atan2( sin, cos * dir );

        s = Math.sin( s * len ) / sin;
        t = Math.sin( t * len ) / sin;

      }

      var tDir = t * dir;

      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;

      // Normalize in case we just did a lerp:
      if ( s === 1 - t ) {

        var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;

      }

    }

    dst[ dstOffset ] = x0;
    dst[ dstOffset + 1 ] = y0;
    dst[ dstOffset + 2 ] = z0;
    dst[ dstOffset + 3 ] = w0;

  }

} );

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  get width() {

    return this.x;

  },

  set width( value ) {

    this.x = value;

  },

  get height() {

    return this.y;

  },

  set height( value ) {

    this.y = value;

  },

  //

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setScalar: function ( scalar ) {

    this.x = scalar;
    this.y = scalar;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    if ( isFinite( scalar ) ) {

      this.x *= scalar;
      this.y *= scalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    return this.multiplyScalar( 1 / scalar );

  },

  min: function ( v ) {

    this.x = Math.min( this.x, v.x );
    this.y = Math.min( this.y, v.y );

    return this;

  },

  max: function ( v ) {

    this.x = Math.max( this.x, v.x );
    this.y = Math.max( this.y, v.y );

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  clampLength: function ( min, max ) {

    var length = this.length();

    this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    return this;

  },

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  lengthManhattan: function() {

    return Math.abs( this.x ) + Math.abs( this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( length ) {

    return this.multiplyScalar( length / this.length() );

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];

    return this;

  },

  rotateAround: function ( center, angle ) {

    var c = Math.cos( angle ), s = Math.sin( angle );

    var x = this.x - center.x;
    var y = this.y - center.y;

    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;

    return this;

  }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setScalar: function ( scalar ) {

    this.x = scalar;
    this.y = scalar;
    this.z = scalar;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y, this.z );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    if ( isFinite( scalar ) ) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function applyEuler( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function applyAxisAngle( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function project( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function unproject( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    return this.multiplyScalar( 1 / scalar );

  },

  min: function ( v ) {

    this.x = Math.min( this.x, v.x );
    this.y = Math.min( this.y, v.y );
    this.z = Math.min( this.z, v.z );

    return this;

  },

  max: function ( v ) {

    this.x = Math.max( this.x, v.x );
    this.y = Math.max( this.y, v.y );
    this.z = Math.max( this.z, v.z );

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  clampLength: function ( min, max ) {

    var length = this.length();

    this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    return this;

  },

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( length ) {

    return this.multiplyScalar( length / this.length() );

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function projectOnVector( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function projectOnPlane( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function reflect( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[ 2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[ 6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;

  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];

    return this;

  }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

  constructor: THREE.Vector4,

  set: function ( x, y, z, w ) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;

  },

  setScalar: function ( scalar ) {

    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setW: function ( w ) {

    this.w = w;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      case 3: this.w = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      case 3: return this.w;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  clone: function () {

    return new this.constructor( this.x, this.y, this.z, this.w );

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = ( v.w !== undefined ) ? v.w : 1;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;

  },

  addScaledVector: function ( v, s ) {

    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    if ( isFinite( scalar ) ) {

      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;

    }

    return this;

  },

  applyMatrix4: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    return this;

  },

  divideScalar: function ( scalar ) {

    return this.multiplyScalar( 1 / scalar );

  },

  setAxisAngleFromQuaternion: function ( q ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos( q.w );

    var s = Math.sqrt( 1 - q.w * q.w );

    if ( s < 0.0001 ) {

       this.x = 1;
       this.y = 0;
       this.z = 0;

    } else {

       this.x = q.x / s;
       this.y = q.y / s;
       this.z = q.z / s;

    }

    return this;

  },

  setAxisAngleFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle, x, y, z,   // variables for result
      epsilon = 0.01,   // margin to allow for rounding errors
      epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

      te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    if ( ( Math.abs( m12 - m21 ) < epsilon )
       && ( Math.abs( m13 - m31 ) < epsilon )
       && ( Math.abs( m23 - m32 ) < epsilon ) ) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if ( ( Math.abs( m12 + m21 ) < epsilon2 )
         && ( Math.abs( m13 + m31 ) < epsilon2 )
         && ( Math.abs( m23 + m32 ) < epsilon2 )
         && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

        // this singularity is identity matrix so angle = 0

        this.set( 1, 0, 0, 0 );

        return this; // zero angle, arbitrary axis

      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = ( m11 + 1 ) / 2;
      var yy = ( m22 + 1 ) / 2;
      var zz = ( m33 + 1 ) / 2;
      var xy = ( m12 + m21 ) / 4;
      var xz = ( m13 + m31 ) / 4;
      var yz = ( m23 + m32 ) / 4;

      if ( ( xx > yy ) && ( xx > zz ) ) {

        // m11 is the largest diagonal term

        if ( xx < epsilon ) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;

        } else {

          x = Math.sqrt( xx );
          y = xy / x;
          z = xz / x;

        }

      } else if ( yy > zz ) {

        // m22 is the largest diagonal term

        if ( yy < epsilon ) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;

        } else {

          y = Math.sqrt( yy );
          x = xy / y;
          z = yz / y;

        }

      } else {

        // m33 is the largest diagonal term so base result on this

        if ( zz < epsilon ) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;

        } else {

          z = Math.sqrt( zz );
          x = xz / z;
          y = yz / z;

        }

      }

      this.set( x, y, z, angle );

      return this; // return 180 deg rotation

    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
              + ( m13 - m31 ) * ( m13 - m31 )
              + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    if ( Math.abs( s ) < 0.001 ) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = ( m32 - m23 ) / s;
    this.y = ( m13 - m31 ) / s;
    this.z = ( m21 - m12 ) / s;
    this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    return this;

  },

  min: function ( v ) {

    this.x = Math.min( this.x, v.x );
    this.y = Math.min( this.y, v.y );
    this.z = Math.min( this.z, v.z );
    this.w = Math.min( this.w, v.w );

    return this;

  },

  max: function ( v ) {

    this.x = Math.max( this.x, v.x );
    this.y = Math.max( this.y, v.y );
    this.z = Math.max( this.z, v.z );
    this.w = Math.max( this.w, v.w );

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    return this;

  },

  clampScalar: function () {

    var min, max;

    return function clampScalar( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector4();
        max = new THREE.Vector4();

      }

      min.set( minVal, minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  }(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );
    this.w = Math.floor( this.w );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );
    this.w = Math.ceil( this.w );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );
    this.w = Math.round( this.w );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;
    this.w = - this.w;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( length ) {

    return this.multiplyScalar( length / this.length() );

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;
    this.w += ( v.w - this.w ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];
    this.w = array[ offset + 3 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;
    array[ offset + 3 ] = this.w;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];
    this.w = attribute.array[ index + 3 ];

    return this;

  }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  clone: function () {

    return new this.constructor( this._x, this._y, this._z, this._order );

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order, update ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function () {

    var matrix;

    return function ( q, order, update ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion( q );
      this.setFromRotationMatrix( matrix, order, update );

      return this;

    };

  }(),

  setFromVector3: function ( v, order ) {

    return this.set( v.x, v.y, v.z, order || this._order );

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };

  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._order;

    return array;

  },

  toVector3: function ( optionalResult ) {

    if ( optionalResult ) {

      return optionalResult.set( this._x, this._y, this._z );

    } else {

      return new THREE.Vector3( this._x, this._y, this._z );

    }

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

  this.start = ( start !== undefined ) ? start : new THREE.Vector3();
  this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

  constructor: THREE.Line3,

  set: function ( start, end ) {

    this.start.copy( start );
    this.end.copy( end );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( line ) {

    this.start.copy( line.start );
    this.end.copy( line.end );

    return this;

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  },

  delta: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.end, this.start );

  },

  distanceSq: function () {

    return this.start.distanceToSquared( this.end );

  },

  distance: function () {

    return this.start.distanceTo( this.end );

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  closestPointToPointParameter: function () {

    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();

    return function ( point, clampToLine ) {

      startP.subVectors( point, this.start );
      startEnd.subVectors( this.end, this.start );

      var startEnd2 = startEnd.dot( startEnd );
      var startEnd_startP = startEnd.dot( startP );

      var t = startEnd_startP / startEnd2;

      if ( clampToLine ) {

        t = THREE.Math.clamp( t, 0, 1 );

      }

      return t;

    };

  }(),

  closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    var t = this.closestPointToPointParameter( point, clampToLine );

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  applyMatrix4: function ( matrix ) {

    this.start.applyMatrix4( matrix );
    this.end.applyMatrix4( matrix );

    return this;

  },

  equals: function ( line ) {

    return line.start.equals( this.start ) && line.end.equals( this.end );

  }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

  constructor: THREE.Box2,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] );

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector2();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = - Infinity;

    return this;

  },

  isEmpty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
         ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector2();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y )
    );

  },

  intersectsBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector2();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

  constructor: THREE.Box3,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] );

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector3();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and children's, world transforms

    var box;

    return function ( object ) {

      if ( box === undefined ) box = new THREE.Box3();

      var scope = this;

      this.makeEmpty();

      object.updateMatrixWorld( true );

      object.traverse( function ( node ) {

        var geometry = node.geometry;

        if ( geometry !== undefined ) {

          if ( geometry.boundingBox === null ) {

            geometry.computeBoundingBox();

          }

          box.copy( geometry.boundingBox );
          box.applyMatrix4( node.matrixWorld );
          scope.union( box );

        }

      } );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = - Infinity;

    return this;

  },

  isEmpty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ||
         point.z < this.min.z || point.z > this.max.z ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
       ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
       ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector3();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
      ( point.z - this.min.z ) / ( this.max.z - this.min.z )
    );

  },

  intersectsBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ||
         box.max.z < this.min.z || box.min.z > this.max.z ) {

      return false;

    }

    return true;

  },

  intersectsSphere: ( function () {

    var closestPoint;

    return function intersectsSphere( sphere ) {

      if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();

      // Find the point on the AABB closest to the sphere center.
      this.clampPoint( sphere.center, closestPoint );

      // If that point is inside the sphere, the AABB and sphere intersect.
      return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    };

  } )(),

  intersectsPlane: function ( plane ) {

    // We compute the minimum and maximum dot product values. If those values
    // are on the same side (back or front) of the plane, then there is no intersection.

    var min, max;

    if ( plane.normal.x > 0 ) {

      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;

    } else {

      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;

    }

    if ( plane.normal.y > 0 ) {

      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;

    } else {

      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;

    }

    if ( plane.normal.z > 0 ) {

      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;

    } else {

      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;

    }

    return ( min <= plane.constant && max >= plane.constant );

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  getBoundingSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Sphere();

      result.center = this.center();
      result.radius = this.size( v1 ).length() * 0.5;

      return result;

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  applyMatrix4: function () {

    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    return function ( matrix ) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
      points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
      points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
      points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
      points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
      points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
      points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
      points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

      this.makeEmpty();
      this.setFromPoints( points );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Matrix3 = function () {

  this.elements = new Float32Array( [

    1, 0, 0,
    0, 1, 0,
    0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix3.prototype = {

  constructor: THREE.Matrix3,

  set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
    te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
    te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    );

    return this;

  },

  clone: function () {

    return new this.constructor().fromArray( this.elements );

  },

  copy: function ( m ) {

    var me = m.elements;

    this.set(

      me[ 0 ], me[ 3 ], me[ 6 ],
      me[ 1 ], me[ 4 ], me[ 7 ],
      me[ 2 ], me[ 5 ], me[ 8 ]

    );

    return this;

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix3( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix3( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
      d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
      g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  },

  getInverse: function ( matrix, throwOnDegenerate ) {

    // input: THREE.Matrix4
    // ( based on http://code.google.com/p/webgl-mjs/ )

    var me = matrix.elements;
    var te = this.elements;

    te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
    te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
    te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
    te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
    te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
    te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
    te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
    te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
    te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

    var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

    // no inverse

    if ( det === 0 ) {

      var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnDegenerate || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1.0 / det );

    return this;

  },

  transpose: function () {

    var tmp, m = this.elements;

    tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];

    array[ offset + 3 ] = te[ 3 ];
    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];

    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];
    array[ offset + 8 ]  = te[ 8 ];

    return array;

  },

  getNormalMatrix: function ( m ) {

    // input: THREE.Matrix4

    this.getInverse( m ).transpose();

    return this;

  },

  transposeIntoArray: function ( r ) {

    var m = this.elements;

    r[ 0 ] = m[ 0 ];
    r[ 1 ] = m[ 3 ];
    r[ 2 ] = m[ 6 ];
    r[ 3 ] = m[ 1 ];
    r[ 4 ] = m[ 4 ];
    r[ 5 ] = m[ 7 ];
    r[ 6 ] = m[ 2 ];
    r[ 7 ] = m[ 5 ];
    r[ 8 ] = m[ 8 ];

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ],
      te[ 3 ], te[ 4 ], te[ 5 ],
      te[ 6 ], te[ 7 ], te[ 8 ]
    ];

  }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

  this.elements = new Float32Array( [

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix4.prototype = {

  constructor: THREE.Matrix4,

  set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  clone: function () {

    return new THREE.Matrix4().fromArray( this.elements );

  },

  copy: function ( m ) {

    this.elements.set( m.elements );

    return this;

  },

  copyPosition: function ( m ) {

    var te = this.elements;
    var me = m.elements;

    te[ 12 ] = me[ 12 ];
    te[ 13 ] = me[ 13 ];
    te[ 14 ] = me[ 14 ];

    return this;

  },

  extractBasis: function ( xAxis, yAxis, zAxis ) {

    var te = this.elements;

    xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
    yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
    zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

    return this;

  },

  makeBasis: function ( xAxis, yAxis, zAxis ) {

    this.set(
      xAxis.x, yAxis.x, zAxis.x, 0,
      xAxis.y, yAxis.y, zAxis.y, 0,
      xAxis.z, yAxis.z, zAxis.z, 0,
      0,       0,       0,       1
    );

    return this;

  },

  extractRotation: function () {

    var v1;

    return function ( m ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
      var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
      var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

      te[ 0 ] = me[ 0 ] * scaleX;
      te[ 1 ] = me[ 1 ] * scaleX;
      te[ 2 ] = me[ 2 ] * scaleX;

      te[ 4 ] = me[ 4 ] * scaleY;
      te[ 5 ] = me[ 5 ] * scaleY;
      te[ 6 ] = me[ 6 ] * scaleY;

      te[ 8 ] = me[ 8 ] * scaleZ;
      te[ 9 ] = me[ 9 ] * scaleZ;
      te[ 10 ] = me[ 10 ] * scaleZ;

      return this;

    };

  }(),

  makeRotationFromEuler: function ( euler ) {

    if ( euler instanceof THREE.Euler === false ) {

      console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    var te = this.elements;

    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos( x ), b = Math.sin( x );
    var c = Math.cos( y ), d = Math.sin( y );
    var e = Math.cos( z ), f = Math.sin( z );

    if ( euler.order === 'XYZ' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = - c * f;
      te[ 8 ] = d;

      te[ 1 ] = af + be * d;
      te[ 5 ] = ae - bf * d;
      te[ 9 ] = - b * c;

      te[ 2 ] = bf - ae * d;
      te[ 6 ] = be + af * d;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YXZ' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce + df * b;
      te[ 4 ] = de * b - cf;
      te[ 8 ] = a * d;

      te[ 1 ] = a * f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b;

      te[ 2 ] = cf * b - de;
      te[ 6 ] = df + ce * b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZXY' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce - df * b;
      te[ 4 ] = - a * f;
      te[ 8 ] = de + cf * b;

      te[ 1 ] = cf + de * b;
      te[ 5 ] = a * e;
      te[ 9 ] = df - ce * b;

      te[ 2 ] = - a * d;
      te[ 6 ] = b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZYX' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = be * d - af;
      te[ 8 ] = ae * d + bf;

      te[ 1 ] = c * f;
      te[ 5 ] = bf * d + ae;
      te[ 9 ] = af * d - be;

      te[ 2 ] = - d;
      te[ 6 ] = b * c;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YZX' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = bd - ac * f;
      te[ 8 ] = bc * f + ad;

      te[ 1 ] = f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b * e;

      te[ 2 ] = - d * e;
      te[ 6 ] = ad * f + bc;
      te[ 10 ] = ac - bd * f;

    } else if ( euler.order === 'XZY' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = - f;
      te[ 8 ] = d * e;

      te[ 1 ] = ac * f + bd;
      te[ 5 ] = a * e;
      te[ 9 ] = ad * f - bc;

      te[ 2 ] = bc * f - ad;
      te[ 6 ] = b * e;
      te[ 10 ] = bd * f + ac;

    }

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  makeRotationFromQuaternion: function ( q ) {

    var te = this.elements;

    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;

    te[ 0 ] = 1 - ( yy + zz );
    te[ 4 ] = xy - wz;
    te[ 8 ] = xz + wy;

    te[ 1 ] = xy + wz;
    te[ 5 ] = 1 - ( xx + zz );
    te[ 9 ] = yz - wx;

    te[ 2 ] = xz - wy;
    te[ 6 ] = yz + wx;
    te[ 10 ] = 1 - ( xx + yy );

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  lookAt: function () {

    var x, y, z;

    return function ( eye, target, up ) {

      if ( x === undefined ) x = new THREE.Vector3();
      if ( y === undefined ) y = new THREE.Vector3();
      if ( z === undefined ) z = new THREE.Vector3();

      var te = this.elements;

      z.subVectors( eye, target ).normalize();

      if ( z.lengthSq() === 0 ) {

        z.z = 1;

      }

      x.crossVectors( up, z ).normalize();

      if ( x.lengthSq() === 0 ) {

        z.x += 0.0001;
        x.crossVectors( up, z ).normalize();

      }

      y.crossVectors( z, x );


      te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
      te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
      te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

      return this;

    };

  }(),

  multiply: function ( m, n ) {

    if ( n !== undefined ) {

      console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
      return this.multiplyMatrices( m, n );

    }

    return this.multiplyMatrices( this, m );

  },

  multiplyMatrices: function ( a, b ) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function ( a, b, r ) {

    var te = this.elements;

    this.multiplyMatrices( a, b );

    r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    return this;

  },

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    return this;

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix4( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix4( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  determinant: function () {

    var te = this.elements;

    var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
        + n14 * n23 * n32
         - n13 * n24 * n32
         - n14 * n22 * n33
         + n12 * n24 * n33
         + n13 * n22 * n34
         - n12 * n23 * n34
      ) +
      n42 * (
        + n11 * n23 * n34
         - n11 * n24 * n33
         + n14 * n21 * n33
         - n13 * n21 * n34
         + n13 * n24 * n31
         - n14 * n23 * n31
      ) +
      n43 * (
        + n11 * n24 * n32
         - n11 * n22 * n34
         - n14 * n21 * n32
         + n12 * n21 * n34
         + n14 * n22 * n31
         - n12 * n24 * n31
      ) +
      n44 * (
        - n13 * n22 * n31
         - n11 * n23 * n32
         + n11 * n22 * n33
         + n13 * n21 * n32
         - n12 * n21 * n33
         + n12 * n23 * n31
      )

    );

  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];
    array[ offset + 3 ] = te[ 3 ];

    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];
    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];

    array[ offset + 8 ]  = te[ 8 ];
    array[ offset + 9 ]  = te[ 9 ];
    array[ offset + 10 ] = te[ 10 ];
    array[ offset + 11 ] = te[ 11 ];

    array[ offset + 12 ] = te[ 12 ];
    array[ offset + 13 ] = te[ 13 ];
    array[ offset + 14 ] = te[ 14 ];
    array[ offset + 15 ] = te[ 15 ];

    return array;

  },

  getPosition: function () {

    var v1;

    return function () {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

      var te = this.elements;
      return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

    };

  }(),

  setPosition: function ( v ) {

    var te = this.elements;

    te[ 12 ] = v.x;
    te[ 13 ] = v.y;
    te[ 14 ] = v.z;

    return this;

  },

  getInverse: function ( m, throwOnInvertible ) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements;
    var me = m.elements;

    var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
    var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
    var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
    var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

    te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

    var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

    if ( det === 0 ) {

      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1 / det );

    return this;

  },

  scale: function ( v ) {

    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;

    te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

  },

  makeTranslation: function ( x, y, z ) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      1, 0,  0, 0,
      0, c, - s, 0,
      0, s,  c, 0,
      0, 0,  0, 1

    );

    return this;

  },

  makeRotationY: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

       c, 0, s, 0,
       0, 1, 0, 0,
      - s, 0, c, 0,
       0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      c, - s, 0, 0,
      s,  c, 0, 0,
      0,  0, 1, 0,
      0,  0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function ( axis, angle ) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

     return this;

  },

  makeScale: function ( x, y, z ) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function ( position, quaternion, scale ) {

    this.makeRotationFromQuaternion( quaternion );
    this.scale( scale );
    this.setPosition( position );

    return this;

  },

  decompose: function () {

    var vector, matrix;

    return function ( position, quaternion, scale ) {

      if ( vector === undefined ) vector = new THREE.Vector3();
      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      var te = this.elements;

      var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
      var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
      var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if ( det < 0 ) {

        sx = - sx;

      }

      position.x = te[ 12 ];
      position.y = te[ 13 ];
      position.z = te[ 14 ];

      // scale the rotation part

      matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[ 0 ] *= invSX;
      matrix.elements[ 1 ] *= invSX;
      matrix.elements[ 2 ] *= invSX;

      matrix.elements[ 4 ] *= invSY;
      matrix.elements[ 5 ] *= invSY;
      matrix.elements[ 6 ] *= invSY;

      matrix.elements[ 8 ] *= invSZ;
      matrix.elements[ 9 ] *= invSZ;
      matrix.elements[ 10 ] *= invSZ;

      quaternion.setFromRotationMatrix( matrix );

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  makeFrustum: function ( left, right, bottom, top, near, far ) {

    var te = this.elements;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
    te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

    return this;

  },

  makePerspective: function ( fov, aspect, near, far ) {

    var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

  },

  makeOrthographic: function ( left, right, top, bottom, near, far ) {

    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    te[ 0 ] = 2 / w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
    te[ 1 ] = 0;  te[ 5 ] = 2 / h;  te[ 9 ] = 0;  te[ 13 ] = - y;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 / p; te[ 14 ] = - z;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

    return this;

  },

  equals: function ( matrix ) {

    var te = this.elements;
    var me = matrix.elements;

    for ( var i = 0; i < 16; i ++ ) {

      if ( te[ i ] !== me[ i ] ) return false;

    }

    return true;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
      te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
      te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
      te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
    ];

  }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

  this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
  this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

  constructor: THREE.Ray,

  set: function ( origin, direction ) {

    this.origin.copy( origin );
    this.direction.copy( direction );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( ray ) {

    this.origin.copy( ray.origin );
    this.direction.copy( ray.direction );

    return this;

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  },

  recast: function () {

    var v1 = new THREE.Vector3();

    return function ( t ) {

      this.origin.copy( this.at( t, v1 ) );

      return this;

    };

  }(),

  closestPointToPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    result.subVectors( point, this.origin );
    var directionDistance = result.dot( this.direction );

    if ( directionDistance < 0 ) {

      return result.copy( this.origin );

    }

    return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  },

  distanceToPoint: function ( point ) {

    return Math.sqrt( this.distanceSqToPoint( point ) );

  },

  distanceSqToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

      // point behind the ray

      if ( directionDistance < 0 ) {

        return this.origin.distanceToSquared( point );

      }

      v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

      return v1.distanceToSquared( point );

    };

  }(),

  distanceSqToSegment: function () {

    var segCenter = new THREE.Vector3();
    var segDir = new THREE.Vector3();
    var diff = new THREE.Vector3();

    return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
      segDir.copy( v1 ).sub( v0 ).normalize();
      diff.copy( this.origin ).sub( segCenter );

      var segExtent = v0.distanceTo( v1 ) * 0.5;
      var a01 = - this.direction.dot( segDir );
      var b0 = diff.dot( this.direction );
      var b1 = - diff.dot( segDir );
      var c = diff.lengthSq();
      var det = Math.abs( 1 - a01 * a01 );
      var s0, s1, sqrDist, extDet;

      if ( det > 0 ) {

        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if ( s0 >= 0 ) {

          if ( s1 >= - extDet ) {

            if ( s1 <= extDet ) {

              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

            } else {

              // region 1

              s1 = segExtent;
              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          } else {

            // region 5

            s1 = - segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        } else {

          if ( s1 <= - extDet ) {

            // region 4

            s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          } else if ( s1 <= extDet ) {

            // region 3

            s0 = 0;
            s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = s1 * ( s1 + 2 * b1 ) + c;

          } else {

            // region 2

            s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        }

      } else {

        // Ray and segment are parallel.

        s1 = ( a01 > 0 ) ? - segExtent : segExtent;
        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

      }

      if ( optionalPointOnRay ) {

        optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

      }

      if ( optionalPointOnSegment ) {

        optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

      }

      return sqrDist;

    };

  }(),

  intersectSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( sphere, optionalTarget ) {

      v1.subVectors( sphere.center, this.origin );

      var tca = v1.dot( this.direction );

      var d2 = v1.dot( v1 ) - tca * tca;

      var radius2 = sphere.radius * sphere.radius;

      if ( d2 > radius2 ) return null;

      var thc = Math.sqrt( radius2 - d2 );

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if ( t0 < 0 && t1 < 0 ) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if ( t0 < 0 ) return this.at( t1, optionalTarget );

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at( t0, optionalTarget );

    }

  }(),

  intersectsSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) <= sphere.radius;

  },

  distanceToPlane: function ( plane ) {

    var denominator = plane.normal.dot( this.direction );

    if ( denominator === 0 ) {

      // line is coplanar, return origin
      if ( plane.distanceToPoint( this.origin ) === 0 ) {

        return 0;

      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;

    }

    var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t :  null;

  },

  intersectPlane: function ( plane, optionalTarget ) {

    var t = this.distanceToPlane( plane );

    if ( t === null ) {

      return null;

    }

    return this.at( t, optionalTarget );

  },



  intersectsPlane: function ( plane ) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint( this.origin );

    if ( distToPoint === 0 ) {

      return true;

    }

    var denominator = plane.normal.dot( this.direction );

    if ( denominator * distToPoint < 0 ) {

      return true;

    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;

  },

  intersectBox: function ( box, optionalTarget ) {

    var tmin, tmax, tymin, tymax, tzmin, tzmax;

    var invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

      tmin = ( box.min.x - origin.x ) * invdirx;
      tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

      tmin = ( box.max.x - origin.x ) * invdirx;
      tmax = ( box.min.x - origin.x ) * invdirx;

    }

    if ( invdiry >= 0 ) {

      tymin = ( box.min.y - origin.y ) * invdiry;
      tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

      tymin = ( box.max.y - origin.y ) * invdiry;
      tymax = ( box.min.y - origin.y ) * invdiry;

    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

      tzmin = ( box.min.z - origin.z ) * invdirz;
      tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

      tzmin = ( box.max.z - origin.z ) * invdirz;
      tzmax = ( box.min.z - origin.z ) * invdirz;

    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    //return point closest to the ray (positive side)

    if ( tmax < 0 ) return null;

    return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  },

  intersectsBox: ( function () {

    var v = new THREE.Vector3();

    return function ( box ) {

      return this.intersectBox( box, v ) !== null;

    };

  } )(),

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();

    return function ( a, b, c, backfaceCulling, optionalTarget ) {

      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

      edge1.subVectors( b, a );
      edge2.subVectors( c, a );
      normal.crossVectors( edge1, edge2 );

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot( normal );
      var sign;

      if ( DdN > 0 ) {

        if ( backfaceCulling ) return null;
        sign = 1;

      } else if ( DdN < 0 ) {

        sign = - 1;
        DdN = - DdN;

      } else {

        return null;

      }

      diff.subVectors( this.origin, a );
      var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

      // b1 < 0, no intersection
      if ( DdQxE2 < 0 ) {

        return null;

      }

      var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

      // b2 < 0, no intersection
      if ( DdE1xQ < 0 ) {

        return null;

      }

      // b1+b2 > 1, no intersection
      if ( DdQxE2 + DdE1xQ > DdN ) {

        return null;

      }

      // Line intersects triangle, check if ray does.
      var QdN = - sign * diff.dot( normal );

      // t < 0, no intersection
      if ( QdN < 0 ) {

        return null;

      }

      // Ray intersects triangle.
      return this.at( QdN / DdN, optionalTarget );

    };

  }(),

  applyMatrix4: function ( matrix4 ) {

    this.direction.add( this.origin ).applyMatrix4( matrix4 );
    this.origin.applyMatrix4( matrix4 );
    this.direction.sub( this.origin );
    this.direction.normalize();

    return this;

  },

  equals: function ( ray ) {

    return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

  this.center = ( center !== undefined ) ? center : new THREE.Vector3();
  this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

  constructor: THREE.Sphere,

  set: function ( center, radius ) {

    this.center.copy( center );
    this.radius = radius;

    return this;

  },

  setFromPoints: function () {

    var box = new THREE.Box3();

    return function ( points, optionalCenter ) {

      var center = this.center;

      if ( optionalCenter !== undefined ) {

        center.copy( optionalCenter );

      } else {

        box.setFromPoints( points ).center( center );

      }

      var maxRadiusSq = 0;

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

      }

      this.radius = Math.sqrt( maxRadiusSq );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( sphere ) {

    this.center.copy( sphere.center );
    this.radius = sphere.radius;

    return this;

  },

  empty: function () {

    return ( this.radius <= 0 );

  },

  containsPoint: function ( point ) {

    return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  },

  distanceToPoint: function ( point ) {

    return ( point.distanceTo( this.center ) - this.radius );

  },

  intersectsSphere: function ( sphere ) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  },

  intersectsBox: function ( box ) {

    return box.intersectsSphere( this );

  },

  intersectsPlane: function ( plane ) {

    // We use the following equation to compute the signed distance from
    // the center of the sphere to the plane.
    //
    // distance = q * n - d
    //
    // If this distance is greater than the radius of the sphere,
    // then there is no intersection.

    return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

  },

  clampPoint: function ( point, optionalTarget ) {

    var deltaLengthSq = this.center.distanceToSquared( point );

    var result = optionalTarget || new THREE.Vector3();

    result.copy( point );

    if ( deltaLengthSq > ( this.radius * this.radius ) ) {

      result.sub( this.center ).normalize();
      result.multiplyScalar( this.radius ).add( this.center );

    }

    return result;

  },

  getBoundingBox: function ( optionalTarget ) {

    var box = optionalTarget || new THREE.Box3();

    box.set( this.center, this.center );
    box.expandByScalar( this.radius );

    return box;

  },

  applyMatrix4: function ( matrix ) {

    this.center.applyMatrix4( matrix );
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;

  },

  translate: function ( offset ) {

    this.center.add( offset );

    return this;

  },

  equals: function ( sphere ) {

    return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

  this.planes = [

    ( p0 !== undefined ) ? p0 : new THREE.Plane(),
    ( p1 !== undefined ) ? p1 : new THREE.Plane(),
    ( p2 !== undefined ) ? p2 : new THREE.Plane(),
    ( p3 !== undefined ) ? p3 : new THREE.Plane(),
    ( p4 !== undefined ) ? p4 : new THREE.Plane(),
    ( p5 !== undefined ) ? p5 : new THREE.Plane()

  ];

};

THREE.Frustum.prototype = {

  constructor: THREE.Frustum,

  set: function ( p0, p1, p2, p3, p4, p5 ) {

    var planes = this.planes;

    planes[ 0 ].copy( p0 );
    planes[ 1 ].copy( p1 );
    planes[ 2 ].copy( p2 );
    planes[ 3 ].copy( p3 );
    planes[ 4 ].copy( p4 );
    planes[ 5 ].copy( p5 );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( frustum ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      planes[ i ].copy( frustum.planes[ i ] );

    }

    return this;

  },

  setFromMatrix: function ( m ) {

    var planes = this.planes;
    var me = m.elements;
    var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    return this;

  },

  intersectsObject: function () {

    var sphere = new THREE.Sphere();

    return function ( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

      sphere.copy( geometry.boundingSphere );
      sphere.applyMatrix4( object.matrixWorld );

      return this.intersectsSphere( sphere );

    };

  }(),

  intersectsSphere: function ( sphere ) {

    var planes = this.planes;
    var center = sphere.center;
    var negRadius = - sphere.radius;

    for ( var i = 0; i < 6; i ++ ) {

      var distance = planes[ i ].distanceToPoint( center );

      if ( distance < negRadius ) {

        return false;

      }

    }

    return true;

  },

  intersectsBox: function () {

    var p1 = new THREE.Vector3(),
      p2 = new THREE.Vector3();

    return function ( box ) {

      var planes = this.planes;

      for ( var i = 0; i < 6 ; i ++ ) {

        var plane = planes[ i ];

        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        var d1 = plane.distanceToPoint( p1 );
        var d2 = plane.distanceToPoint( p2 );

        // if both outside plane, no intersection

        if ( d1 < 0 && d2 < 0 ) {

          return false;

        }

      }

      return true;

    };

  }(),


  containsPoint: function ( point ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      if ( planes[ i ].distanceToPoint( point ) < 0 ) {

        return false;

      }

    }

    return true;

  }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

  this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
  this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

  constructor: THREE.Plane,

  set: function ( normal, constant ) {

    this.normal.copy( normal );
    this.constant = constant;

    return this;

  },

  setComponents: function ( x, y, z, w ) {

    this.normal.set( x, y, z );
    this.constant = w;

    return this;

  },

  setFromNormalAndCoplanarPoint: function ( normal, point ) {

    this.normal.copy( normal );
    this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

    return this;

  },

  setFromCoplanarPoints: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( a, b, c ) {

      var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint( normal, a );

      return this;

    };

  }(),

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( plane ) {

    this.normal.copy( plane.normal );
    this.constant = plane.constant;

    return this;

  },

  normalize: function () {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar( inverseNormalLength );
    this.constant *= inverseNormalLength;

    return this;

  },

  negate: function () {

    this.constant *= - 1;
    this.normal.negate();

    return this;

  },

  distanceToPoint: function ( point ) {

    return this.normal.dot( point ) + this.constant;

  },

  distanceToSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) - sphere.radius;

  },

  projectPoint: function ( point, optionalTarget ) {

    return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  },

  orthoPoint: function ( point, optionalTarget ) {

    var perpendicularMagnitude = this.distanceToPoint( point );

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  },

  intersectLine: function () {

    var v1 = new THREE.Vector3();

    return function ( line, optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      var direction = line.delta( v1 );

      var denominator = this.normal.dot( direction );

      if ( denominator === 0 ) {

        // line is coplanar, return origin
        if ( this.distanceToPoint( line.start ) === 0 ) {

          return result.copy( line.start );

        }

        // Unsure if this is the correct method to handle this case.
        return undefined;

      }

      var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

      if ( t < 0 || t > 1 ) {

        return undefined;

      }

      return result.copy( direction ).multiplyScalar( t ).add( line.start );

    };

  }(),

  intersectsLine: function ( line ) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint( line.start );
    var endSign = this.distanceToPoint( line.end );

    return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  },

  intersectsBox: function ( box ) {

    return box.intersectsPlane( this );

  },

  intersectsSphere: function ( sphere ) {

    return sphere.intersectsPlane( this );

  },

  coplanarPoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( - this.constant );

  },

  applyMatrix4: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();

    return function ( matrix, optionalNormalMatrix ) {

      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
      var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

      var newCoplanarPoint = this.coplanarPoint( v2 );
      newCoplanarPoint.applyMatrix4( matrix );

      this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.constant = this.constant - offset.dot( this.normal );

    return this;

  },

  equals: function ( plane ) {

    return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

          uuid[ i ] = '-';

        } else if ( i === 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }

      }

      return uuid.join( '' );

    };

  }(),

  clamp: function ( value, min, max ) {

    return Math.max( min, Math.min( max, value ) );

  },

  // compute euclidian modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation

  euclideanModulo: function ( n, m ) {

    return ( ( n % m ) + m ) % m;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  random16: function () {

    console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
    return Math.random();

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return low + Math.floor( Math.random() * ( high - low + 1 ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  },

  nearestPowerOfTwo: function ( value ) {

    return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

  },

  nextPowerOfTwo: function ( value ) {

    value --;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value ++;

    return value;

  }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

  this.points = points;

  var c = [], v3 = { x: 0, y: 0, z: 0 },
  point, intPoint, weight, w2, w3,
  pa, pb, pc, pd;

  this.initFromArray = function ( a ) {

    this.points = [];

    for ( var i = 0; i < a.length; i ++ ) {

      this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    }

  };

  this.getPoint = function ( k ) {

    point = ( this.points.length - 1 ) * k;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    pa = this.points[ c[ 0 ] ];
    pb = this.points[ c[ 1 ] ];
    pc = this.points[ c[ 2 ] ];
    pd = this.points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    return v3;

  };

  this.getControlPointsArray = function () {

    var i, p, l = this.points.length,
      coords = [];

    for ( i = 0; i < l; i ++ ) {

      p = this.points[ i ];
      coords[ i ] = [ p.x, p.y, p.z ];

    }

    return coords;

  };

  // approximate length by summing linear segments

  this.getLength = function ( nSubDivisions ) {

    var i, index, nSamples, position,
      point = 0, intPoint = 0, oldIntPoint = 0,
      oldPosition = new THREE.Vector3(),
      tmpVec = new THREE.Vector3(),
      chunkLengths = [],
      totalLength = 0;

    // first point has 0 length

    chunkLengths[ 0 ] = 0;

    if ( ! nSubDivisions ) nSubDivisions = 100;

    nSamples = this.points.length * nSubDivisions;

    oldPosition.copy( this.points[ 0 ] );

    for ( i = 1; i < nSamples; i ++ ) {

      index = i / nSamples;

      position = this.getPoint( index );
      tmpVec.copy( position );

      totalLength += tmpVec.distanceTo( oldPosition );

      oldPosition.copy( position );

      point = ( this.points.length - 1 ) * index;
      intPoint = Math.floor( point );

      if ( intPoint !== oldIntPoint ) {

        chunkLengths[ intPoint ] = totalLength;
        oldIntPoint = intPoint;

      }

    }

    // last point ends with total length

    chunkLengths[ chunkLengths.length ] = totalLength;

    return { chunks: chunkLengths, total: totalLength };

  };

  this.reparametrizeByArcLength = function ( samplingCoef ) {

    var i, j,
      index, indexCurrent, indexNext,
      realDistance,
      sampling, position,
      newpoints = [],
      tmpVec = new THREE.Vector3(),
      sl = this.getLength();

    newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    for ( i = 1; i < this.points.length; i ++ ) {

      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );

      realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

      sampling = Math.ceil( samplingCoef * realDistance / sl.total );

      indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
      indexNext = i / ( this.points.length - 1 );

      for ( j = 1; j < sampling - 1; j ++ ) {

        index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

        position = this.getPoint( index );
        newpoints.push( tmpVec.copy( position ).clone() );

      }

      newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    }

    this.points = newpoints;

  };

  // Catmull-Rom

  function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

  this.a = ( a !== undefined ) ? a : new THREE.Vector3();
  this.b = ( b !== undefined ) ? b : new THREE.Vector3();
  this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

  var v0 = new THREE.Vector3();

  return function ( a, b, c, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    result.subVectors( c, b );
    v0.subVectors( a, b );
    result.cross( v0 );

    var resultLengthSq = result.lengthSq();
    if ( resultLengthSq > 0 ) {

      return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    }

    return result.set( 0, 0, 0 );

  };

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( point, a, b, c, optionalTarget ) {

    v0.subVectors( c, a );
    v1.subVectors( b, a );
    v2.subVectors( point, a );

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var denom = ( dot00 * dot11 - dot01 * dot01 );

    var result = optionalTarget || new THREE.Vector3();

    // collinear or singular triangle
    if ( denom === 0 ) {

      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set( - 2, - 1, - 1 );

    }

    var invDenom = 1 / denom;
    var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    // barycentric coordinates must always sum to 1
    return result.set( 1 - u - v, v, u );

  };

}();

THREE.Triangle.containsPoint = function () {

  var v1 = new THREE.Vector3();

  return function ( point, a, b, c ) {

    var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

    return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  };

}();

THREE.Triangle.prototype = {

  constructor: THREE.Triangle,

  set: function ( a, b, c ) {

    this.a.copy( a );
    this.b.copy( b );
    this.c.copy( c );

    return this;

  },

  setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    this.a.copy( points[ i0 ] );
    this.b.copy( points[ i1 ] );
    this.c.copy( points[ i2 ] );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( triangle ) {

    this.a.copy( triangle.a );
    this.b.copy( triangle.b );
    this.c.copy( triangle.c );

    return this;

  },

  area: function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();

    return function () {

      v0.subVectors( this.c, this.b );
      v1.subVectors( this.a, this.b );

      return v0.cross( v1 ).length() * 0.5;

    };

  }(),

  midpoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  },

  normal: function ( optionalTarget ) {

    return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

  },

  plane: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Plane();

    return result.setFromCoplanarPoints( this.a, this.b, this.c );

  },

  barycoordFromPoint: function ( point, optionalTarget ) {

    return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  },

  containsPoint: function ( point ) {

    return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

  },

  equals: function ( triangle ) {

    return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  }

};

// File:src/math/Interpolant.js

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 *    http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

THREE.Interpolant = function(
    parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  this.parameterPositions = parameterPositions;
  this._cachedIndex = 0;

  this.resultBuffer = resultBuffer !== undefined ?
      resultBuffer : new sampleValues.constructor( sampleSize );
  this.sampleValues = sampleValues;
  this.valueSize = sampleSize;

};

THREE.Interpolant.prototype = {

  constructor: THREE.Intepolant,

  evaluate: function( t ) {

    var pp = this.parameterPositions,
      i1 = this._cachedIndex,

      t1 = pp[   i1   ],
      t0 = pp[ i1 - 1 ];

    validate_interval: {

      seek: {

        var right;

        linear_scan: {
//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//-         if ( t >= t1 || t1 === undefined ) {
          forward_scan: if ( ! ( t < t1 ) ) {

            for ( var giveUpAt = i1 + 2; ;) {

              if ( t1 === undefined ) {

                if ( t < t0 ) break forward_scan;

                // after end

                i1 = pp.length;
                this._cachedIndex = i1;
                return this.afterEnd_( i1 - 1, t, t0 );

              }

              if ( i1 === giveUpAt ) break; // this loop

              t0 = t1;
              t1 = pp[ ++ i1 ];

              if ( t < t1 ) {

                // we have arrived at the sought interval
                break seek;

              }

            }

            // prepare binary search on the right side of the index
            right = pp.length;
            break linear_scan;

          }

//- slower code:
//-         if ( t < t0 || t0 === undefined ) {
          if ( ! ( t >= t0 ) ) {

            // looping?

            var t1global = pp[ 1 ];

            if ( t < t1global ) {

              i1 = 2; // + 1, using the scan for the details
              t0 = t1global;

            }

            // linear reverse scan

            for ( var giveUpAt = i1 - 2; ;) {

              if ( t0 === undefined ) {

                // before start

                this._cachedIndex = 0;
                return this.beforeStart_( 0, t, t1 );

              }

              if ( i1 === giveUpAt ) break; // this loop

              t1 = t0;
              t0 = pp[ -- i1 - 1 ];

              if ( t >= t0 ) {

                // we have arrived at the sought interval
                break seek;

              }

            }

            // prepare binary search on the left side of the index
            right = i1;
            i1 = 0;
            break linear_scan;

          }

          // the interval is valid

          break validate_interval;

        } // linear scan

        // binary search

        while ( i1 < right ) {

          var mid = ( i1 + right ) >>> 1;

          if ( t < pp[ mid ] ) {

            right = mid;

          } else {

            i1 = mid + 1;

          }

        }

        t1 = pp[   i1   ];
        t0 = pp[ i1 - 1 ];

        // check boundary cases, again

        if ( t0 === undefined ) {

          this._cachedIndex = 0;
          return this.beforeStart_( 0, t, t1 );

        }

        if ( t1 === undefined ) {

          i1 = pp.length;
          this._cachedIndex = i1;
          return this.afterEnd_( i1 - 1, t0, t );

        }

      } // seek

      this._cachedIndex = i1;

      this.intervalChanged_( i1, t0, t1 );

    } // validate_interval

    return this.interpolate_( i1, t0, t, t1 );

  },

  settings: null, // optional, subclass-specific settings structure
  // Note: The indirection allows central control of many interpolants.

  // --- Protected interface

  DefaultSettings_: {},

  getSettings_: function() {

    return this.settings || this.DefaultSettings_;

  },

  copySampleValue_: function( index ) {

    // copies a sample value to the result buffer

    var result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset = index * stride;

    for ( var i = 0; i !== stride; ++ i ) {

      result[ i ] = values[ offset + i ];

    }

    return result;

  },

  // Template methods for derived classes:

  interpolate_: function( i1, t0, t, t1 ) {

    throw new Error( "call to abstract method" );
    // implementations shall return this.resultBuffer

  },

  intervalChanged_: function( i1, t0, t1 ) {

    // empty

  }

};

Object.assign( THREE.Interpolant.prototype, {

  beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
    THREE.Interpolant.prototype.copySampleValue_,

  afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
    THREE.Interpolant.prototype.copySampleValue_

} );

// File:src/math/interpolants/CubicInterpolant.js

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

THREE.CubicInterpolant = function(
    parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  THREE.Interpolant.call(
      this, parameterPositions, sampleValues, sampleSize, resultBuffer );

  this._weightPrev = -0;
  this._offsetPrev = -0;
  this._weightNext = -0;
  this._offsetNext = -0;

};

THREE.CubicInterpolant.prototype =
    Object.assign( Object.create( THREE.Interpolant.prototype ), {

  constructor: THREE.CubicInterpolant,

  DefaultSettings_: {

    endingStart:  THREE.ZeroCurvatureEnding,
    endingEnd:    THREE.ZeroCurvatureEnding

  },

  intervalChanged_: function( i1, t0, t1 ) {

    var pp = this.parameterPositions,
      iPrev = i1 - 2,
      iNext = i1 + 1,

      tPrev = pp[ iPrev ],
      tNext = pp[ iNext ];

    if ( tPrev === undefined ) {

      switch ( this.getSettings_().endingStart ) {

        case THREE.ZeroSlopeEnding:

          // f'(t0) = 0
          iPrev = i1;
          tPrev = 2 * t0 - t1;

          break;

        case THREE.WrapAroundEnding:

          // use the other end of the curve
          iPrev = pp.length - 2;
          tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

          break;

        default: // ZeroCurvatureEnding

          // f''(t0) = 0 a.k.a. Natural Spline
          iPrev = i1;
          tPrev = t1;

      }

    }

    if ( tNext === undefined ) {

      switch ( this.getSettings_().endingEnd ) {

        case THREE.ZeroSlopeEnding:

          // f'(tN) = 0
          iNext = i1;
          tNext = 2 * t1 - t0;

          break;

        case THREE.WrapAroundEnding:

          // use the other end of the curve
          iNext = 1;
          tNext = t1 + pp[ 1 ] - pp[ 0 ];

          break;

        default: // ZeroCurvatureEnding

          // f''(tN) = 0, a.k.a. Natural Spline
          iNext = i1 - 1;
          tNext = t0;

      }

    }

    var halfDt = ( t1 - t0 ) * 0.5,
      stride = this.valueSize;

    this._weightPrev = halfDt / ( t0 - tPrev );
    this._weightNext = halfDt / ( tNext - t1 );
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;

  },

  interpolate_: function( i1, t0, t, t1 ) {

    var result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,

      o1 = i1 * stride,   o0 = o1 - stride,
      oP = this._offsetPrev,  oN = this._offsetNext,
      wP = this._weightPrev,  wN = this._weightNext,

      p = ( t - t0 ) / ( t1 - t0 ),
      pp = p * p,
      ppp = pp * p;

    // evaluate polynomials

    var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
    var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
    var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
    var sN =       wN   * ppp   -           wN      * pp;

    // combine data linearly

    for ( var i = 0; i !== stride; ++ i ) {

      result[ i ] =
          sP * values[ oP + i ] +
          s0 * values[ o0 + i ] +
          s1 * values[ o1 + i ] +
          sN * values[ oN + i ];

    }

    return result;

  }

} );

// File:src/math/interpolants/DiscreteInterpolant.js

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

THREE.DiscreteInterpolant = function(
    parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  THREE.Interpolant.call(
      this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.DiscreteInterpolant.prototype =
    Object.assign( Object.create( THREE.Interpolant.prototype ), {

  constructor: THREE.DiscreteInterpolant,

  interpolate_: function( i1, t0, t, t1 ) {

    return this.copySampleValue_( i1 - 1 );

  }

} );

// File:src/math/interpolants/LinearInterpolant.js

/**
 * @author tschw
 */

THREE.LinearInterpolant = function(
    parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  THREE.Interpolant.call(
      this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.LinearInterpolant.prototype =
    Object.assign( Object.create( THREE.Interpolant.prototype ), {

  constructor: THREE.LinearInterpolant,

  interpolate_: function( i1, t0, t, t1 ) {

    var result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,

      offset1 = i1 * stride,
      offset0 = offset1 - stride,

      weight1 = ( t - t0 ) / ( t1 - t0 ),
      weight0 = 1 - weight1;

    for ( var i = 0; i !== stride; ++ i ) {

      result[ i ] =
          values[ offset0 + i ] * weight0 +
          values[ offset1 + i ] * weight1;

    }

    return result;

  }

} );

// File:src/math/interpolants/QuaternionLinearInterpolant.js

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

THREE.QuaternionLinearInterpolant = function(
    parameterPositions, sampleValues, sampleSize, resultBuffer ) {

  THREE.Interpolant.call(
      this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.QuaternionLinearInterpolant.prototype =
    Object.assign( Object.create( THREE.Interpolant.prototype ), {

  constructor: THREE.QuaternionLinearInterpolant,

  interpolate_: function( i1, t0, t, t1 ) {

    var result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,

      offset = i1 * stride,

      alpha = ( t - t0 ) / ( t1 - t0 );

    for ( var end = offset + stride; offset !== end; offset += 4 ) {

      THREE.Quaternion.slerpFlat( result, 0,
          values, offset - stride, values, offset, alpha );

    }

    return result;

  }

} );

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

  this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;

  this.running = false;

};

THREE.Clock.prototype = {

  constructor: THREE.Clock,

  start: function () {

    this.startTime = self.performance.now();

    this.oldTime = this.startTime;
    this.running = true;

  },

  stop: function () {

    this.getElapsedTime();
    this.running = false;

  },

  getElapsedTime: function () {

    this.getDelta();
    return this.elapsedTime;

  },

  getDelta: function () {

    var diff = 0;

    if ( this.autoStart && ! this.running ) {

      this.start();

    }

    if ( this.running ) {

      var newTime = self.performance.now();

      diff = 0.001 * ( newTime - this.oldTime );
      this.oldTime = newTime;

      this.elapsedTime += diff;

    }

    return diff;

  }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

  constructor: THREE.EventDispatcher,

  apply: function ( object ) {

    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

  },

  addEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) this._listeners = {};

    var listeners = this._listeners;

    if ( listeners[ type ] === undefined ) {

      listeners[ type ] = [];

    }

    if ( listeners[ type ].indexOf( listener ) === - 1 ) {

      listeners[ type ].push( listener );

    }

  },

  hasEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return false;

    var listeners = this._listeners;

    if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

      return true;

    }

    return false;

  },

  removeEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ type ];

    if ( listenerArray !== undefined ) {

      var index = listenerArray.indexOf( listener );

      if ( index !== - 1 ) {

        listenerArray.splice( index, 1 );

      }

    }

  },

  dispatchEvent: function ( event ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ event.type ];

    if ( listenerArray !== undefined ) {

      event.target = this;

      var array = [];
      var length = listenerArray.length;

      for ( var i = 0; i < length; i ++ ) {

        array[ i ] = listenerArray[ i ];

      }

      for ( var i = 0; i < length; i ++ ) {

        array[ i ].call( this, event );

      }

    }

  }

};

// File:src/core/Layers.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Layers = function () {

  this.mask = 1;

};

THREE.Layers.prototype = {

  constructor: THREE.Layers,

  set: function ( channel ) {

    this.mask = 1 << channel;

  },

  enable: function ( channel ) {

    this.mask |= 1 << channel;

  },

  toggle: function ( channel ) {

    this.mask ^= 1 << channel;

  },

  disable: function ( channel ) {

    this.mask &= ~ ( 1 << channel );

  },

  test: function ( layers ) {

    return ( this.mask & layers.mask ) !== 0;

  }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };

    Object.defineProperties( this.params, {
      PointCloud: {
        get: function () {
          console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
          return this.Points;
        }
      }
    } );

  };

  function ascSort( a, b ) {

    return a.distance - b.distance;

  }

  function intersectObject( object, raycaster, intersects, recursive ) {

    if ( object.visible === false ) return;

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  }

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( camera instanceof THREE.PerspectiveCamera ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( ascSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( ascSort );

      return intersects;

    }

  };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

  Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Object3D';

  this.parent = null;
  this.children = [];

  this.up = THREE.Object3D.DefaultUp.clone();

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3( 1, 1, 1 );

  function onRotationChange() {

    quaternion.setFromEuler( rotation, false );

  }

  function onQuaternionChange() {

    rotation.setFromQuaternion( quaternion, undefined, false );

  }

  rotation.onChange( onRotationChange );
  quaternion.onChange( onQuaternionChange );

  Object.defineProperties( this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    },
    modelViewMatrix: {
      value: new THREE.Matrix4()
    },
    normalMatrix: {
      value: new THREE.Matrix3()
    }
  } );

  this.rotationAutoUpdate = true;

  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();

  this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
  this.matrixWorldNeedsUpdate = false;

  this.layers = new THREE.Layers();
  this.visible = true;

  this.castShadow = false;
  this.receiveShadow = false;

  this.frustumCulled = true;
  this.renderOrder = 0;

  this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

THREE.Object3D.prototype = {

  constructor: THREE.Object3D,

  applyMatrix: function ( matrix ) {

    this.matrix.multiplyMatrices( matrix, this.matrix );

    this.matrix.decompose( this.position, this.quaternion, this.scale );

  },

  setRotationFromAxisAngle: function ( axis, angle ) {

    // assumes axis is normalized

    this.quaternion.setFromAxisAngle( axis, angle );

  },

  setRotationFromEuler: function ( euler ) {

    this.quaternion.setFromEuler( euler, true );

  },

  setRotationFromMatrix: function ( m ) {

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix( m );

  },

  setRotationFromQuaternion: function ( q ) {

    // assumes q is normalized

    this.quaternion.copy( q );

  },

  rotateOnAxis: function () {

    // rotate object on axis in object space
    // axis is assumed to be normalized

    var q1 = new THREE.Quaternion();

    return function ( axis, angle ) {

      q1.setFromAxisAngle( axis, angle );

      this.quaternion.multiply( q1 );

      return this;

    };

  }(),

  rotateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  translateOnAxis: function () {

    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    var v1 = new THREE.Vector3();

    return function ( axis, distance ) {

      v1.copy( axis ).applyQuaternion( this.quaternion );

      this.position.add( v1.multiplyScalar( distance ) );

      return this;

    };

  }(),

  translateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  localToWorld: function ( vector ) {

    return vector.applyMatrix4( this.matrixWorld );

  },

  worldToLocal: function () {

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    };

  }(),

  lookAt: function () {

    // This routine does not support objects with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      m1.lookAt( vector, this.position, this.up );

      this.quaternion.setFromRotationMatrix( m1 );

    };

  }(),

  add: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.add( arguments[ i ] );

      }

      return this;

    }

    if ( object === this ) {

      console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
      return this;

    }

    if ( object instanceof THREE.Object3D ) {

      if ( object.parent !== null ) {

        object.parent.remove( object );

      }

      object.parent = this;
      object.dispatchEvent( { type: 'added' } );

      this.children.push( object );

    } else {

      console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    }

    return this;

  },

  remove: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.remove( arguments[ i ] );

      }

    }

    var index = this.children.indexOf( object );

    if ( index !== - 1 ) {

      object.parent = null;

      object.dispatchEvent( { type: 'removed' } );

      this.children.splice( index, 1 );

    }

  },

  getObjectById: function ( id ) {

    return this.getObjectByProperty( 'id', id );

  },

  getObjectByName: function ( name ) {

    return this.getObjectByProperty( 'name', name );

  },

  getObjectByProperty: function ( name, value ) {

    if ( this[ name ] === value ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectByProperty( name, value );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getWorldPosition: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.updateMatrixWorld( true );

    return result.setFromMatrixPosition( this.matrixWorld );

  },

  getWorldQuaternion: function () {

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Quaternion();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, result, scale );

      return result;

    };

  }(),

  getWorldRotation: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Euler();

      this.getWorldQuaternion( quaternion );

      return result.setFromQuaternion( quaternion, this.rotation.order, false );

    };

  }(),

  getWorldScale: function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, quaternion, result );

      return result;

    };

  }(),

  getWorldDirection: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.getWorldQuaternion( quaternion );

      return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    };

  }(),

  raycast: function () {},

  traverse: function ( callback ) {

    callback( this );

    var children = this.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      children[ i ].traverse( callback );

    }

  },

  traverseVisible: function ( callback ) {

    if ( this.visible === false ) return;

    callback( this );

    var children = this.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      children[ i ].traverseVisible( callback );

    }

  },

  traverseAncestors: function ( callback ) {

    var parent = this.parent;

    if ( parent !== null ) {

      callback( parent );

      parent.traverseAncestors( callback );

    }

  },

  updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

  },

  updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate === true || force === true ) {

      if ( this.parent === null ) {

        this.matrixWorld.copy( this.matrix );

      } else {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

      }

      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  },

  toJSON: function ( meta ) {

    var isRootObject = ( meta === undefined );

    var output = {};

    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if ( isRootObject ) {

      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };

      output.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };

    }

    // standard Object3D serialization

    var object = {};

    object.uuid = this.uuid;
    object.type = this.type;

    if ( this.name !== '' ) object.name = this.name;
    if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    if ( this.castShadow === true ) object.castShadow = true;
    if ( this.receiveShadow === true ) object.receiveShadow = true;
    if ( this.visible === false ) object.visible = false;

    object.matrix = this.matrix.toArray();

    //

    if ( this.geometry !== undefined ) {

      if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

        meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

      }

      object.geometry = this.geometry.uuid;

    }

    if ( this.material !== undefined ) {

      if ( meta.materials[ this.material.uuid ] === undefined ) {

        meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

      }

      object.material = this.material.uuid;

    }

    //

    if ( this.children.length > 0 ) {

      object.children = [];

      for ( var i = 0; i < this.children.length; i ++ ) {

        object.children.push( this.children[ i ].toJSON( meta ).object );

      }

    }

    if ( isRootObject ) {

      var geometries = extractFromCache( meta.geometries );
      var materials = extractFromCache( meta.materials );
      var textures = extractFromCache( meta.textures );
      var images = extractFromCache( meta.images );

      if ( geometries.length > 0 ) output.geometries = geometries;
      if ( materials.length > 0 ) output.materials = materials;
      if ( textures.length > 0 ) output.textures = textures;
      if ( images.length > 0 ) output.images = images;

    }

    output.object = object;

    return output;

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache ( cache ) {

      var values = [];
      for ( var key in cache ) {

        var data = cache[ key ];
        delete data.metadata;
        values.push( data );

      }
      return values;

    }

  },

  clone: function ( recursive ) {

    return new this.constructor().copy( this, recursive );

  },

  copy: function ( source, recursive ) {

    if ( recursive === undefined ) recursive = true;

    this.name = source.name;

    this.up.copy( source.up );

    this.position.copy( source.position );
    this.quaternion.copy( source.quaternion );
    this.scale.copy( source.scale );

    this.rotationAutoUpdate = source.rotationAutoUpdate;

    this.matrix.copy( source.matrix );
    this.matrixWorld.copy( source.matrixWorld );

    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    this.visible = source.visible;

    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;

    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;

    this.userData = JSON.parse( JSON.stringify( source.userData ) );

    if ( recursive === true ) {

      for ( var i = 0; i < source.children.length; i ++ ) {

        var child = source.children[ i ];
        this.add( child.clone() );

      }

    }

    return this;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

  this.a = a;
  this.b = b;
  this.c = c;

  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = Array.isArray( normal ) ? normal : [];

  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = Array.isArray( color ) ? color : [];

  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

  constructor: THREE.Face3,

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.a = source.a;
    this.b = source.b;
    this.c = source.c;

    this.normal.copy( source.normal );
    this.color.copy( source.color );

    this.materialIndex = source.materialIndex;

    for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

      this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    }

    for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

      this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    }

    return this;

  }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

  console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
  return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

  this.uuid = THREE.Math.generateUUID();

  this.array = array;
  this.itemSize = itemSize;

  this.dynamic = false;
  this.updateRange = { offset: 0, count: - 1 };

  this.version = 0;

};

THREE.BufferAttribute.prototype = {

  constructor: THREE.BufferAttribute,

  get count() {

    return this.array.length / this.itemSize;

  },

  set needsUpdate( value ) {

    if ( value === true ) this.version ++;

  },

  setDynamic: function ( value ) {

    this.dynamic = value;

    return this;

  },

  copy: function ( source ) {

    this.array = new source.array.constructor( source.array );
    this.itemSize = source.itemSize;

    this.dynamic = source.dynamic;

    return this;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  copyArray: function ( array ) {

    this.array.set( array );

    return this;

  },

  copyColorsArray: function ( colors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = colors.length; i < l; i ++ ) {

      var color = colors[ i ];

      if ( color === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
        color = new THREE.Color();

      }

      array[ offset ++ ] = color.r;
      array[ offset ++ ] = color.g;
      array[ offset ++ ] = color.b;

    }

    return this;

  },

  copyIndicesArray: function ( indices ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = indices.length; i < l; i ++ ) {

      var index = indices[ i ];

      array[ offset ++ ] = index.a;
      array[ offset ++ ] = index.b;
      array[ offset ++ ] = index.c;

    }

    return this;

  },

  copyVector2sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
        vector = new THREE.Vector2();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;

    }

    return this;

  },

  copyVector3sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
        vector = new THREE.Vector3();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;

    }

    return this;

  },

  copyVector4sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
        vector = new THREE.Vector4();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;
      array[ offset ++ ] = vector.w;

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  getX: function ( index ) {

    return this.array[ index * this.itemSize ];

  },

  setX: function ( index, x ) {

    this.array[ index * this.itemSize ] = x;

    return this;

  },

  getY: function ( index ) {

    return this.array[ index * this.itemSize + 1 ];

  },

  setY: function ( index, y ) {

    this.array[ index * this.itemSize + 1 ] = y;

    return this;

  },

  getZ: function ( index ) {

    return this.array[ index * this.itemSize + 2 ];

  },

  setZ: function ( index, z ) {

    this.array[ index * this.itemSize + 2 ] = z;

    return this;

  },

  getW: function ( index ) {

    return this.array[ index * this.itemSize + 3 ];

  },

  setW: function ( index, w ) {

    this.array[ index * this.itemSize + 3 ] = w;

    return this;

  },

  setXY: function ( index, x, y ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;
    this.array[ index + 3 ] = w;

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

  console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
  return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

  THREE.BufferAttribute.call( this, array, itemSize );

  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

  THREE.BufferAttribute.prototype.copy.call( this, source );

  this.meshPerAttribute = source.meshPerAttribute;

  return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

  this.uuid = THREE.Math.generateUUID();

  this.array = array;
  this.stride = stride;

  this.dynamic = false;
  this.updateRange = { offset: 0, count: - 1 };

  this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

  constructor: THREE.InterleavedBuffer,

  get length () {

    return this.array.length;

  },

  get count () {

    return this.array.length / this.stride;

  },

  set needsUpdate( value ) {

    if ( value === true ) this.version ++;

  },

  setDynamic: function ( value ) {

    this.dynamic = value;

    return this;

  },

  copy: function ( source ) {

    this.array = new source.array.constructor( source.array );
    this.stride = source.stride;
    this.dynamic = source.dynamic;

    return this;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.stride;
    index2 *= attribute.stride;

    for ( var i = 0, l = this.stride; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

  THREE.InterleavedBuffer.call( this, array, stride );

  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

  THREE.InterleavedBuffer.prototype.copy.call( this, source );

  this.meshPerAttribute = source.meshPerAttribute;

  return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

  this.uuid = THREE.Math.generateUUID();

  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

  constructor: THREE.InterleavedBufferAttribute,

  get length() {

    console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    return this.array.length;

  },

  get count() {

    return this.data.count;

  },

  setX: function ( index, x ) {

    this.data.array[ index * this.data.stride + this.offset ] = x;

    return this;

  },

  setY: function ( index, y ) {

    this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    return this;

  },

  setZ: function ( index, z ) {

    this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    return this;

  },

  setW: function ( index, w ) {

    this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    return this;

  },

  getX: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset ];

  },

  getY: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 1 ];

  },

  getZ: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 2 ];

  },

  getW: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 3 ];

  },

  setXY: function ( index, x, y ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;
    this.data.array[ index + 3 ] = w;

    return this;

  }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Geometry';

  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [ [] ];

  this.morphTargets = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  // update flags

  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;
  this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

  constructor: THREE.Geometry,

  applyMatrix: function ( matrix ) {

    var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

      var vertex = this.vertices[ i ];
      vertex.applyMatrix4( matrix );

    }

    for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

      var face = this.faces[ i ];
      face.normal.applyMatrix3( normalMatrix ).normalize();

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

      }

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;

  },

  rotateX: function () {

    // rotate geometry around world x-axis

    var m1;

    return function rotateX( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationX( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateY: function () {

    // rotate geometry around world y-axis

    var m1;

    return function rotateY( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationY( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateZ: function () {

    // rotate geometry around world z-axis

    var m1;

    return function rotateZ( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationZ( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  translate: function () {

    // translate geometry

    var m1;

    return function translate( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeTranslation( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  scale: function () {

    // scale geometry

    var m1;

    return function scale( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeScale( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  lookAt: function () {

    var obj;

    return function lookAt( vector ) {

      if ( obj === undefined ) obj = new THREE.Object3D();

      obj.lookAt( vector );

      obj.updateMatrix();

      this.applyMatrix( obj.matrix );

    };

  }(),

  fromBufferGeometry: function ( geometry ) {

    var scope = this;

    var indices = geometry.index !== null ? geometry.index.array : undefined;
    var attributes = geometry.attributes;

    var positions = attributes.position.array;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

    if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

    var tempNormals = [];
    var tempUVs = [];
    var tempUVs2 = [];

    for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

      scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

      if ( normals !== undefined ) {

        tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

      }

      if ( colors !== undefined ) {

        scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

      }

      if ( uvs !== undefined ) {

        tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

      }

      if ( uvs2 !== undefined ) {

        tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

      }

    }

    function addFace( a, b, c ) {

      var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
      var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

      var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors );

      scope.faces.push( face );

      if ( uvs !== undefined ) {

        scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

      }

      if ( uvs2 !== undefined ) {

        scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

      }

    }

    if ( indices !== undefined ) {

      var groups = geometry.groups;

      if ( groups.length > 0 ) {

        for ( var i = 0; i < groups.length; i ++ ) {

          var group = groups[ i ];

          var start = group.start;
          var count = group.count;

          for ( var j = start, jl = start + count; j < jl; j += 3 ) {

            addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ] );

          }

        }

      } else {

        for ( var i = 0; i < indices.length; i += 3 ) {

          addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

        }

      }

    } else {

      for ( var i = 0; i < positions.length / 3; i += 3 ) {

        addFace( i, i + 1, i + 2 );

      }

    }

    this.computeFaceNormals();

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.translate( offset.x, offset.y, offset.z );

    return offset;

  },

  normalize: function () {

    this.computeBoundingSphere();

    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;

    var s = radius === 0 ? 1 : 1.0 / radius;

    var matrix = new THREE.Matrix4();
    matrix.set(
      s, 0, 0, - s * center.x,
      0, s, 0, - s * center.y,
      0, 0, s, - s * center.z,
      0, 0, 0, 1
    );

    this.applyMatrix( matrix );

    return this;

  },

  computeFaceNormals: function () {

    var cb = new THREE.Vector3(), ab = new THREE.Vector3();

    for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

      var face = this.faces[ f ];

      var vA = this.vertices[ face.a ];
      var vB = this.vertices[ face.b ];
      var vC = this.vertices[ face.c ];

      cb.subVectors( vC, vB );
      ab.subVectors( vA, vB );
      cb.cross( ab );

      cb.normalize();

      face.normal.copy( cb );

    }

  },

  computeVertexNormals: function ( areaWeighted ) {

    var v, vl, f, fl, face, vertices;

    vertices = new Array( this.vertices.length );

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ] = new THREE.Vector3();

    }

    if ( areaWeighted ) {

      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm

      var vA, vB, vC;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vA = this.vertices[ face.a ];
        vB = this.vertices[ face.b ];
        vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        vertices[ face.a ].add( cb );
        vertices[ face.b ].add( cb );
        vertices[ face.c ].add( cb );

      }

    } else {

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vertices[ face.a ].add( face.normal );
        vertices[ face.b ].add( face.normal );
        vertices[ face.c ].add( face.normal );

      }

    }

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ].normalize();

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        vertexNormals[ 0 ].copy( vertices[ face.a ] );
        vertexNormals[ 1 ].copy( vertices[ face.b ] );
        vertexNormals[ 2 ].copy( vertices[ face.c ] );

      } else {

        vertexNormals[ 0 ] = vertices[ face.a ].clone();
        vertexNormals[ 1 ] = vertices[ face.b ].clone();
        vertexNormals[ 2 ] = vertices[ face.c ].clone();

      }

    }

  },

  computeMorphNormals: function () {

    var i, il, f, fl, face;

    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      if ( ! face.__originalFaceNormal ) {

        face.__originalFaceNormal = face.normal.clone();

      } else {

        face.__originalFaceNormal.copy( face.normal );

      }

      if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

      for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

        if ( ! face.__originalVertexNormals[ i ] ) {

          face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

        } else {

          face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

        }

      }

    }

    // use temp geometry to compute face and vertex normals for each morph

    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;

    for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

      // create on first access

      if ( ! this.morphNormals[ i ] ) {

        this.morphNormals[ i ] = {};
        this.morphNormals[ i ].faceNormals = [];
        this.morphNormals[ i ].vertexNormals = [];

        var dstNormalsFace = this.morphNormals[ i ].faceNormals;
        var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          faceNormal = new THREE.Vector3();
          vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

          dstNormalsFace.push( faceNormal );
          dstNormalsVertex.push( vertexNormals );

        }

      }

      var morphNormals = this.morphNormals[ i ];

      // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[ i ].vertices;

      // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();

      // store morph normals

      var faceNormal, vertexNormals;

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        faceNormal = morphNormals.faceNormals[ f ];
        vertexNormals = morphNormals.vertexNormals[ f ];

        faceNormal.copy( face.normal );

        vertexNormals.a.copy( face.vertexNormals[ 0 ] );
        vertexNormals.b.copy( face.vertexNormals[ 1 ] );
        vertexNormals.c.copy( face.vertexNormals[ 2 ] );

      }

    }

    // restore original normals

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;

    }

  },

  computeTangents: function () {

    console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

  },

  computeLineDistances: function () {

    var d = 0;
    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      if ( i > 0 ) {

        d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

      }

      this.lineDistances[ i ] = d;

    }

  },

  computeBoundingBox: function () {

    if ( this.boundingBox === null ) {

      this.boundingBox = new THREE.Box3();

    }

    this.boundingBox.setFromPoints( this.vertices );

  },

  computeBoundingSphere: function () {

    if ( this.boundingSphere === null ) {

      this.boundingSphere = new THREE.Sphere();

    }

    this.boundingSphere.setFromPoints( this.vertices );

  },

  merge: function ( geometry, matrix, materialIndexOffset ) {

    if ( geometry instanceof THREE.Geometry === false ) {

      console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
      return;

    }

    var normalMatrix,
    vertexOffset = this.vertices.length,
    vertices1 = this.vertices,
    vertices2 = geometry.vertices,
    faces1 = this.faces,
    faces2 = geometry.faces,
    uvs1 = this.faceVertexUvs[ 0 ],
    uvs2 = geometry.faceVertexUvs[ 0 ];

    if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    if ( matrix !== undefined ) {

      normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    }

    // vertices

    for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

      var vertex = vertices2[ i ];

      var vertexCopy = vertex.clone();

      if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

      vertices1.push( vertexCopy );

    }

    // faces

    for ( i = 0, il = faces2.length; i < il; i ++ ) {

      var face = faces2[ i ], faceCopy, normal, color,
      faceVertexNormals = face.vertexNormals,
      faceVertexColors = face.vertexColors;

      faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
      faceCopy.normal.copy( face.normal );

      if ( normalMatrix !== undefined ) {

        faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

      }

      for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

        normal = faceVertexNormals[ j ].clone();

        if ( normalMatrix !== undefined ) {

          normal.applyMatrix3( normalMatrix ).normalize();

        }

        faceCopy.vertexNormals.push( normal );

      }

      faceCopy.color.copy( face.color );

      for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

        color = faceVertexColors[ j ];
        faceCopy.vertexColors.push( color.clone() );

      }

      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

      faces1.push( faceCopy );

    }

    // uvs

    for ( i = 0, il = uvs2.length; i < il; i ++ ) {

      var uv = uvs2[ i ], uvCopy = [];

      if ( uv === undefined ) {

        continue;

      }

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( uv[ j ].clone() );

      }

      uvs1.push( uvCopy );

    }

  },

  mergeMesh: function ( mesh ) {

    if ( mesh instanceof THREE.Mesh === false ) {

      console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
      return;

    }

    mesh.matrixAutoUpdate && mesh.updateMatrix();

    this.merge( mesh.geometry, mesh.matrix );

  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */

  mergeVertices: function () {

    var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    var unique = [], changes = [];

    var v, key;
    var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    var precision = Math.pow( 10, precisionPoints );
    var i, il, face;
    var indices, j, jl;

    for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

      v = this.vertices[ i ];
      key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

      if ( verticesMap[ key ] === undefined ) {

        verticesMap[ key ] = i;
        unique.push( this.vertices[ i ] );
        changes[ i ] = unique.length - 1;

      } else {

        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[ i ] = changes[ verticesMap[ key ] ];

      }

    }


    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];

    for ( i = 0, il = this.faces.length; i < il; i ++ ) {

      face = this.faces[ i ];

      face.a = changes[ face.a ];
      face.b = changes[ face.b ];
      face.c = changes[ face.c ];

      indices = [ face.a, face.b, face.c ];

      var dupIndex = - 1;

      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for ( var n = 0; n < 3; n ++ ) {

        if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

          dupIndex = n;
          faceIndicesToRemove.push( i );
          break;

        }

      }

    }

    for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

      var idx = faceIndicesToRemove[ i ];

      this.faces.splice( idx, 1 );

      for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

        this.faceVertexUvs[ j ].splice( idx, 1 );

      }

    }

    // Use unique set of vertices

    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;

  },

  sortFacesByMaterialIndex: function () {

    var faces = this.faces;
    var length = faces.length;

    // tag faces

    for ( var i = 0; i < length; i ++ ) {

      faces[ i ]._id = i;

    }

    // sort faces

    function materialIndexSort( a, b ) {

      return a.materialIndex - b.materialIndex;

    }

    faces.sort( materialIndexSort );

    // sort uvs

    var uvs1 = this.faceVertexUvs[ 0 ];
    var uvs2 = this.faceVertexUvs[ 1 ];

    var newUvs1, newUvs2;

    if ( uvs1 && uvs1.length === length ) newUvs1 = [];
    if ( uvs2 && uvs2.length === length ) newUvs2 = [];

    for ( var i = 0; i < length; i ++ ) {

      var id = faces[ i ]._id;

      if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
      if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

    }

    if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
    if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    };

    // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    var vertices = [];

    for ( var i = 0; i < this.vertices.length; i ++ ) {

      var vertex = this.vertices[ i ];
      vertices.push( vertex.x, vertex.y, vertex.z );

    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for ( var i = 0; i < this.faces.length; i ++ ) {

      var face = this.faces[ i ];

      var hasMaterial = true;
      var hasFaceUv = false; // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;

      var faceType = 0;

      faceType = setBit( faceType, 0, 0 ); // isQuad
      faceType = setBit( faceType, 1, hasMaterial );
      faceType = setBit( faceType, 2, hasFaceUv );
      faceType = setBit( faceType, 3, hasFaceVertexUv );
      faceType = setBit( faceType, 4, hasFaceNormal );
      faceType = setBit( faceType, 5, hasFaceVertexNormal );
      faceType = setBit( faceType, 6, hasFaceColor );
      faceType = setBit( faceType, 7, hasFaceVertexColor );

      faces.push( faceType );
      faces.push( face.a, face.b, face.c );
      faces.push( face.materialIndex );

      if ( hasFaceVertexUv ) {

        var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

        faces.push(
          getUvIndex( faceVertexUvs[ 0 ] ),
          getUvIndex( faceVertexUvs[ 1 ] ),
          getUvIndex( faceVertexUvs[ 2 ] )
        );

      }

      if ( hasFaceNormal ) {

        faces.push( getNormalIndex( face.normal ) );

      }

      if ( hasFaceVertexNormal ) {

        var vertexNormals = face.vertexNormals;

        faces.push(
          getNormalIndex( vertexNormals[ 0 ] ),
          getNormalIndex( vertexNormals[ 1 ] ),
          getNormalIndex( vertexNormals[ 2 ] )
        );

      }

      if ( hasFaceColor ) {

        faces.push( getColorIndex( face.color ) );

      }

      if ( hasFaceVertexColor ) {

        var vertexColors = face.vertexColors;

        faces.push(
          getColorIndex( vertexColors[ 0 ] ),
          getColorIndex( vertexColors[ 1 ] ),
          getColorIndex( vertexColors[ 2 ] )
        );

      }

    }

    function setBit( value, position, enabled ) {

      return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    }

    function getNormalIndex( normal ) {

      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if ( normalsHash[ hash ] !== undefined ) {

        return normalsHash[ hash ];

      }

      normalsHash[ hash ] = normals.length / 3;
      normals.push( normal.x, normal.y, normal.z );

      return normalsHash[ hash ];

    }

    function getColorIndex( color ) {

      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if ( colorsHash[ hash ] !== undefined ) {

        return colorsHash[ hash ];

      }

      colorsHash[ hash ] = colors.length;
      colors.push( color.getHex() );

      return colorsHash[ hash ];

    }

    function getUvIndex( uv ) {

      var hash = uv.x.toString() + uv.y.toString();

      if ( uvsHash[ hash ] !== undefined ) {

        return uvsHash[ hash ];

      }

      uvsHash[ hash ] = uvs.length / 2;
      uvs.push( uv.x, uv.y );

      return uvsHash[ hash ];

    }

    data.data = {};

    data.data.vertices = vertices;
    data.data.normals = normals;
    if ( colors.length > 0 ) data.data.colors = colors;
    if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    data.data.faces = faces;

    return data;

  },

  clone: function () {

    /*
    // Handle primitives

    var parameters = this.parameters;

    if ( parameters !== undefined ) {

      var values = [];

      for ( var key in parameters ) {

        values.push( parameters[ key ] );

      }

      var geometry = Object.create( this.constructor.prototype );
      this.constructor.apply( geometry, values );
      return geometry;

    }

    return new this.constructor().copy( this );
    */

    return new THREE.Geometry().copy( this );

  },

  copy: function ( source ) {

    this.vertices = [];
    this.faces = [];
    this.faceVertexUvs = [ [] ];

    var vertices = source.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      this.vertices.push( vertices[ i ].clone() );

    }

    var faces = source.faces;

    for ( var i = 0, il = faces.length; i < il; i ++ ) {

      this.faces.push( faces[ i ].clone() );

    }

    for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

      var faceVertexUvs = source.faceVertexUvs[ i ];

      if ( this.faceVertexUvs[ i ] === undefined ) {

        this.faceVertexUvs[ i ] = [];

      }

      for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

        var uvs = faceVertexUvs[ j ], uvsCopy = [];

        for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

          var uv = uvs[ k ];

          uvsCopy.push( uv.clone() );

        }

        this.faceVertexUvs[ i ].push( uvsCopy );

      }

    }

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'DirectGeometry';

  this.indices = [];
  this.vertices = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];

  this.groups = [];

  this.morphTargets = {};

  this.skinWeights = [];
  this.skinIndices = [];

  // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.groupsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

  constructor: THREE.DirectGeometry,

  computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
  computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

  computeFaceNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

  },

  computeVertexNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

  },

  computeGroups: function ( geometry ) {

    var group;
    var groups = [];
    var materialIndex;

    var faces = geometry.faces;

    for ( var i = 0; i < faces.length; i ++ ) {

      var face = faces[ i ];

      // materials

      if ( face.materialIndex !== materialIndex ) {

        materialIndex = face.materialIndex;

        if ( group !== undefined ) {

          group.count = ( i * 3 ) - group.start;
          groups.push( group );

        }

        group = {
          start: i * 3,
          materialIndex: materialIndex
        };

      }

    }

    if ( group !== undefined ) {

      group.count = ( i * 3 ) - group.start;
      groups.push( group );

    }

    this.groups = groups;

  },

  fromGeometry: function ( geometry ) {

    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;

    var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;

    var morphTargetsPosition;

    if ( morphTargetsLength > 0 ) {

      morphTargetsPosition = [];

      for ( var i = 0; i < morphTargetsLength; i ++ ) {

        morphTargetsPosition[ i ] = [];

      }

      this.morphTargets.position = morphTargetsPosition;

    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;

    var morphTargetsNormal;

    if ( morphNormalsLength > 0 ) {

      morphTargetsNormal = [];

      for ( var i = 0; i < morphNormalsLength; i ++ ) {

        morphTargetsNormal[ i ] = [];

      }

      this.morphTargets.normal = morphTargetsNormal;

    }

    // skins

    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;

    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;

    //

    for ( var i = 0; i < faces.length; i ++ ) {

      var face = faces[ i ];

      this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

      } else {

        var normal = face.normal;

        this.normals.push( normal, normal, normal );

      }

      var vertexColors = face.vertexColors;

      if ( vertexColors.length === 3 ) {

        this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

      } else {

        var color = face.color;

        this.colors.push( color, color, color );

      }

      if ( hasFaceVertexUv === true ) {

        var vertexUvs = faceVertexUvs[ 0 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

          this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      if ( hasFaceVertexUv2 === true ) {

        var vertexUvs = faceVertexUvs[ 1 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

          this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      // morphs

      for ( var j = 0; j < morphTargetsLength; j ++ ) {

        var morphTarget = morphTargets[ j ].vertices;

        morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

      }

      for ( var j = 0; j < morphNormalsLength; j ++ ) {

        var morphNormal = morphNormals[ j ].vertexNormals[ i ];

        morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

      }

      // skins

      if ( hasSkinIndices ) {

        this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

      }

      if ( hasSkinWeights ) {

        this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

      }

    }

    this.computeGroups( geometry );

    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'BufferGeometry';

  this.index = null;
  this.attributes = {};

  this.morphAttributes = {};

  this.groups = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.drawRange = { start: 0, count: Infinity };

};

THREE.BufferGeometry.prototype = {

  constructor: THREE.BufferGeometry,

  getIndex: function () {

    return this.index;

  },

  setIndex: function ( index ) {

    this.index = index;

  },

  addAttribute: function ( name, attribute ) {

    if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

      this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

      return;

    }

    if ( name === 'index' ) {

      console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
      this.setIndex( attribute );

      return;

    }

    this.attributes[ name ] = attribute;

  },

  getAttribute: function ( name ) {

    return this.attributes[ name ];

  },

  removeAttribute: function ( name ) {

    delete this.attributes[ name ];

  },

  addGroup: function ( start, count, materialIndex ) {

    this.groups.push( {

      start: start,
      count: count,
      materialIndex: materialIndex !== undefined ? materialIndex : 0

    } );

  },

  clearGroups: function () {

    this.groups = [];

  },

  setDrawRange: function ( start, count ) {

    this.drawRange.start = start;
    this.drawRange.count = count;

  },

  applyMatrix: function ( matrix ) {

    var position = this.attributes.position;

    if ( position !== undefined ) {

      matrix.applyToVector3Array( position.array );
      position.needsUpdate = true;

    }

    var normal = this.attributes.normal;

    if ( normal !== undefined ) {

      var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

      normalMatrix.applyToVector3Array( normal.array );
      normal.needsUpdate = true;

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

  },

  rotateX: function () {

    // rotate geometry around world x-axis

    var m1;

    return function rotateX( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationX( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateY: function () {

    // rotate geometry around world y-axis

    var m1;

    return function rotateY( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationY( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  rotateZ: function () {

    // rotate geometry around world z-axis

    var m1;

    return function rotateZ( angle ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeRotationZ( angle );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  translate: function () {

    // translate geometry

    var m1;

    return function translate( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeTranslation( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  scale: function () {

    // scale geometry

    var m1;

    return function scale( x, y, z ) {

      if ( m1 === undefined ) m1 = new THREE.Matrix4();

      m1.makeScale( x, y, z );

      this.applyMatrix( m1 );

      return this;

    };

  }(),

  lookAt: function () {

    var obj;

    return function lookAt( vector ) {

      if ( obj === undefined ) obj = new THREE.Object3D();

      obj.lookAt( vector );

      obj.updateMatrix();

      this.applyMatrix( obj.matrix );

    };

  }(),

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.translate( offset.x, offset.y, offset.z );

    return offset;

  },

  setFromObject: function ( object ) {

    // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    var geometry = object.geometry;

    if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

      var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
      var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

      this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
      this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

      if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

        var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

        this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

      }

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

    } else if ( object instanceof THREE.Mesh ) {

      if ( geometry instanceof THREE.Geometry ) {

        this.fromGeometry( geometry );

      }

    }

    return this;

  },

  updateFromObject: function ( object ) {

    var geometry = object.geometry;

    if ( object instanceof THREE.Mesh ) {

      var direct = geometry.__directGeometry;

      if ( direct === undefined ) {

        return this.fromGeometry( geometry );

      }

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;
      geometry.groupsNeedUpdate = false;

      geometry = direct;

    }

    if ( geometry.verticesNeedUpdate === true ) {

      var attribute = this.attributes.position;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.vertices );
        attribute.needsUpdate = true;

      }

      geometry.verticesNeedUpdate = false;

    }

    if ( geometry.normalsNeedUpdate === true ) {

      var attribute = this.attributes.normal;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.normals );
        attribute.needsUpdate = true;

      }

      geometry.normalsNeedUpdate = false;

    }

    if ( geometry.colorsNeedUpdate === true ) {

      var attribute = this.attributes.color;

      if ( attribute !== undefined ) {

        attribute.copyColorsArray( geometry.colors );
        attribute.needsUpdate = true;

      }

      geometry.colorsNeedUpdate = false;

    }

    if ( geometry.uvsNeedUpdate ) {

      var attribute = this.attributes.uv;

      if ( attribute !== undefined ) {

        attribute.copyVector2sArray( geometry.uvs );
        attribute.needsUpdate = true;

      }

      geometry.uvsNeedUpdate = false;

    }

    if ( geometry.lineDistancesNeedUpdate ) {

      var attribute = this.attributes.lineDistance;

      if ( attribute !== undefined ) {

        attribute.copyArray( geometry.lineDistances );
        attribute.needsUpdate = true;

      }

      geometry.lineDistancesNeedUpdate = false;

    }

    if ( geometry.groupsNeedUpdate ) {

      geometry.computeGroups( object.geometry );
      this.groups = geometry.groups;

      geometry.groupsNeedUpdate = false;

    }

    return this;

  },

  fromGeometry: function ( geometry ) {

    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

    return this.fromDirectGeometry( geometry.__directGeometry );

  },

  fromDirectGeometry: function ( geometry ) {

    var positions = new Float32Array( geometry.vertices.length * 3 );
    this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    if ( geometry.normals.length > 0 ) {

      var normals = new Float32Array( geometry.normals.length * 3 );
      this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    }

    if ( geometry.colors.length > 0 ) {

      var colors = new Float32Array( geometry.colors.length * 3 );
      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    }

    if ( geometry.uvs.length > 0 ) {

      var uvs = new Float32Array( geometry.uvs.length * 2 );
      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    }

    if ( geometry.uvs2.length > 0 ) {

      var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
      this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    }

    if ( geometry.indices.length > 0 ) {

      var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
      var indices = new TypeArray( geometry.indices.length * 3 );
      this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    }

    // groups

    this.groups = geometry.groups;

    // morphs

    for ( var name in geometry.morphTargets ) {

      var array = [];
      var morphTargets = geometry.morphTargets[ name ];

      for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

        var morphTarget = morphTargets[ i ];

        var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

        array.push( attribute.copyVector3sArray( morphTarget ) );

      }

      this.morphAttributes[ name ] = array;

    }

    // skinning

    if ( geometry.skinIndices.length > 0 ) {

      var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
      this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    }

    if ( geometry.skinWeights.length > 0 ) {

      var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
      this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    }

    //

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    return this;

  },

  computeBoundingBox: function () {

    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new THREE.Box3();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        var bb = this.boundingBox;
        bb.makeEmpty();

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          bb.expandByPoint( vector );

        }

      }

      if ( positions === undefined || positions.length === 0 ) {

        this.boundingBox.min.set( 0, 0, 0 );
        this.boundingBox.max.set( 0, 0, 0 );

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

      }

    };

  }(),

  computeBoundingSphere: function () {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new THREE.Sphere();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        box.makeEmpty();

        var center = this.boundingSphere.center;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          box.expandByPoint( vector );

        }

        box.center( center );

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

        }

        this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

        if ( isNaN( this.boundingSphere.radius ) ) {

          console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

        }

      }

    };

  }(),

  computeFaceNormals: function () {

    // backwards compatibility

  },

  computeVertexNormals: function () {

    var index = this.index;
    var attributes = this.attributes;
    var groups = this.groups;

    if ( attributes.position ) {

      var positions = attributes.position.array;

      if ( attributes.normal === undefined ) {

        this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

      } else {

        // reset existing normals to zero

        var array = attributes.normal.array;

        for ( var i = 0, il = array.length; i < il; i ++ ) {

          array[ i ] = 0;

        }

      }

      var normals = attributes.normal.array;

      var vA, vB, vC,

      pA = new THREE.Vector3(),
      pB = new THREE.Vector3(),
      pC = new THREE.Vector3(),

      cb = new THREE.Vector3(),
      ab = new THREE.Vector3();

      // indexed elements

      if ( index ) {

        var indices = index.array;

        if ( groups.length === 0 ) {

          this.addGroup( 0, indices.length );

        }

        for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

          var group = groups[ j ];

          var start = group.start;
          var count = group.count;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            vA = indices[ i + 0 ] * 3;
            vB = indices[ i + 1 ] * 3;
            vC = indices[ i + 2 ] * 3;

            pA.fromArray( positions, vA );
            pB.fromArray( positions, vB );
            pC.fromArray( positions, vC );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ vA ] += cb.x;
            normals[ vA + 1 ] += cb.y;
            normals[ vA + 2 ] += cb.z;

            normals[ vB ] += cb.x;
            normals[ vB + 1 ] += cb.y;
            normals[ vB + 2 ] += cb.z;

            normals[ vC ] += cb.x;
            normals[ vC + 1 ] += cb.y;
            normals[ vC + 2 ] += cb.z;

          }

        }

      } else {

        // non-indexed elements (unconnected triangle soup)

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          pA.fromArray( positions, i );
          pB.fromArray( positions, i + 3 );
          pC.fromArray( positions, i + 6 );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          normals[ i ] = cb.x;
          normals[ i + 1 ] = cb.y;
          normals[ i + 2 ] = cb.z;

          normals[ i + 3 ] = cb.x;
          normals[ i + 4 ] = cb.y;
          normals[ i + 5 ] = cb.z;

          normals[ i + 6 ] = cb.x;
          normals[ i + 7 ] = cb.y;
          normals[ i + 8 ] = cb.z;

        }

      }

      this.normalizeNormals();

      attributes.normal.needsUpdate = true;

    }

  },

  merge: function ( geometry, offset ) {

    if ( geometry instanceof THREE.BufferGeometry === false ) {

      console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
      return;

    }

    if ( offset === undefined ) offset = 0;

    var attributes = this.attributes;

    for ( var key in attributes ) {

      if ( geometry.attributes[ key ] === undefined ) continue;

      var attribute1 = attributes[ key ];
      var attributeArray1 = attribute1.array;

      var attribute2 = geometry.attributes[ key ];
      var attributeArray2 = attribute2.array;

      var attributeSize = attribute2.itemSize;

      for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

        attributeArray1[ j ] = attributeArray2[ i ];

      }

    }

    return this;

  },

  normalizeNormals: function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = normals.length; i < il; i += 3 ) {

      x = normals[ i ];
      y = normals[ i + 1 ];
      z = normals[ i + 2 ];

      n = 1.0 / Math.sqrt( x * x + y * y + z * z );

      normals[ i ] *= n;
      normals[ i + 1 ] *= n;
      normals[ i + 2 ] *= n;

    }

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };

    // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    data.data = { attributes: {} };

    var index = this.index;

    if ( index !== null ) {

      var array = Array.prototype.slice.call( index.array );

      data.data.index = {
        type: index.array.constructor.name,
        array: array
      };

    }

    var attributes = this.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];

      var array = Array.prototype.slice.call( attribute.array );

      data.data.attributes[ key ] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      };

    }

    var groups = this.groups;

    if ( groups.length > 0 ) {

      data.data.groups = JSON.parse( JSON.stringify( groups ) );

    }

    var boundingSphere = this.boundingSphere;

    if ( boundingSphere !== null ) {

      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };

    }

    return data;

  },

  clone: function () {

    /*
    // Handle primitives

    var parameters = this.parameters;

    if ( parameters !== undefined ) {

      var values = [];

      for ( var key in parameters ) {

        values.push( parameters[ key ] );

      }

      var geometry = Object.create( this.constructor.prototype );
      this.constructor.apply( geometry, values );
      return geometry;

    }

    return new this.constructor().copy( this );
    */

    return new THREE.BufferGeometry().copy( this );

  },

  copy: function ( source ) {

    var index = source.index;

    if ( index !== null ) {

      this.setIndex( index.clone() );

    }

    var attributes = source.attributes;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];
      this.addAttribute( name, attribute.clone() );

    }

    var groups = source.groups;

    for ( var i = 0, l = groups.length; i < l; i ++ ) {

      var group = groups[ i ];
      this.addGroup( group.start, group.count );

    }

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

  THREE.BufferGeometry.call( this );

  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

  this.groups.push( {

    start: start,
    count: count,
    instances: instances

  } );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

  var index = source.index;

  if ( index !== null ) {

    this.setIndex( index.clone() );

  }

  var attributes = source.attributes;

  for ( var name in attributes ) {

    var attribute = attributes[ name ];
    this.addAttribute( name, attribute.clone() );

  }

  var groups = source.groups;

  for ( var i = 0, l = groups.length; i < l; i ++ ) {

    var group = groups[ i ];
    this.addGroup( group.start, group.count, group.instances );

  }

  return this;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/core/Uniform.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Uniform = function ( type, value ) {

  this.type = type;
  this.value = value;

  this.dynamic = false;

};

THREE.Uniform.prototype = {

  constructor: THREE.Uniform,

  onUpdate: function ( callback ) {

    this.dynamic = true;
    this.onUpdateCallback = callback;

    return this;

  }

};

// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

  this.name = name || THREE.Math.generateUUID();
  this.tracks = tracks;
  this.duration = ( duration !== undefined ) ? duration : -1;

  // this means it should figure out its duration by scanning the tracks
  if ( this.duration < 0 ) {

    this.resetDuration();

  }

  // maybe only do these on demand, as doing them here could potentially slow down loading
  // but leaving these here during development as this ensures a lot of testing of these functions
  this.trim();
  this.optimize();

};

THREE.AnimationClip.prototype = {

  constructor: THREE.AnimationClip,

  resetDuration: function() {

    var tracks = this.tracks,
      duration = 0;

    for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

      var track = this.tracks[ i ];

      duration = Math.max(
          duration, track.times[ track.times.length - 1 ] );

    }

    this.duration = duration;

  },

  trim: function() {

    for ( var i = 0; i < this.tracks.length; i ++ ) {

      this.tracks[ i ].trim( 0, this.duration );

    }

    return this;

  },

  optimize: function() {

    for ( var i = 0; i < this.tracks.length; i ++ ) {

      this.tracks[ i ].optimize();

    }

    return this;

  }

};

// Static methods:

Object.assign( THREE.AnimationClip, {

  parse: function( json ) {

    var tracks = [],
      jsonTracks = json.tracks,
      frameTime = 1.0 / ( json.fps || 1.0 );

    for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

      tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

    }

    return new THREE.AnimationClip( json.name, json.duration, tracks );

  },


  toJSON: function( clip ) {

    var tracks = [],
      clipTracks = clip.tracks;

    var json = {

      'name': clip.name,
      'duration': clip.duration,
      'tracks': tracks

    };

    for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

      tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );

    }

    return json;

  },


  CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {

    var numMorphTargets = morphTargetSequence.length;
    var tracks = [];

    for ( var i = 0; i < numMorphTargets; i ++ ) {

      var times = [];
      var values = [];

      times.push(
          ( i + numMorphTargets - 1 ) % numMorphTargets,
          i,
          ( i + 1 ) % numMorphTargets );

      values.push( 0, 1, 0 );

      var order = THREE.AnimationUtils.getKeyframeOrder( times );
      times = THREE.AnimationUtils.sortedArray( times, 1, order );
      values = THREE.AnimationUtils.sortedArray( values, 1, order );

      // if there is a key at the first frame, duplicate it as the
      // last frame as well for perfect loop.
      if ( times[ 0 ] === 0 ) {

        times.push( numMorphTargets );
        values.push( values[ 0 ] );

      }

      tracks.push(
          new THREE.NumberKeyframeTrack(
            '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
            times, values
          ).scale( 1.0 / fps ) );
    }

    return new THREE.AnimationClip( name, -1, tracks );

  },

  findByName: function( clipArray, name ) {

    for ( var i = 0; i < clipArray.length; i ++ ) {

      if ( clipArray[ i ].name === name ) {

        return clipArray[ i ];

      }
    }

    return null;

  },

  CreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {

    var animationToMorphTargets = {};

    // tested with https://regex101.com/ on trick sequences
    // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    var pattern = /^([\w-]*?)([\d]+)$/;

    // sort morph target names into animation groups based
    // patterns like Walk_001, Walk_002, Run_001, Run_002
    for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

      var morphTarget = morphTargets[ i ];
      var parts = morphTarget.name.match( pattern );

      if ( parts && parts.length > 1 ) {

        var name = parts[ 1 ];

        var animationMorphTargets = animationToMorphTargets[ name ];
        if ( ! animationMorphTargets ) {

          animationToMorphTargets[ name ] = animationMorphTargets = [];

        }

        animationMorphTargets.push( morphTarget );

      }

    }

    var clips = [];

    for ( var name in animationToMorphTargets ) {

      clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );

    }

    return clips;

  },

  // parse the animation.hierarchy format
  parseAnimation: function( animation, bones, nodeName ) {

    if ( ! animation ) {

      console.error( "  no animation in JSONLoader data" );
      return null;

    }

    var addNonemptyTrack = function(
        trackType, trackName, animationKeys, propertyName, destTracks ) {

      // only return track if there are actually keys.
      if ( animationKeys.length !== 0 ) {

        var times = [];
        var values = [];

        THREE.AnimationUtils.flattenJSON(
            animationKeys, times, values, propertyName );

        // empty keys are filtered out, so check again
        if ( times.length !== 0 ) {

          destTracks.push( new trackType( trackName, times, values ) );

        }

      }

    };

    var tracks = [];

    var clipName = animation.name || 'default';
    // automatic length determination in AnimationClip.
    var duration = animation.length || -1;
    var fps = animation.fps || 30;

    var hierarchyTracks = animation.hierarchy || [];

    for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

      var animationKeys = hierarchyTracks[ h ].keys;

      // skip empty tracks
      if ( ! animationKeys || animationKeys.length == 0 ) continue;

      // process morph targets in a way exactly compatible
      // with AnimationHandler.init( animation )
      if ( animationKeys[0].morphTargets ) {

        // figure out all morph targets used in this track
        var morphTargetNames = {};
        for ( var k = 0; k < animationKeys.length; k ++ ) {

          if ( animationKeys[k].morphTargets ) {

            for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

              morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
            }

          }

        }

        // create a track for each morph target with all zero
        // morphTargetInfluences except for the keys in which
        // the morphTarget is named.
        for ( var morphTargetName in morphTargetNames ) {

          var times = [];
          var values = [];

          for ( var m = 0;
              m !== animationKeys[k].morphTargets.length; ++ m ) {

            var animationKey = animationKeys[k];

            times.push( animationKey.time );
            values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )

          }

          tracks.push( new THREE.NumberKeyframeTrack(
              '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

        }

        duration = morphTargetNames.length * ( fps || 1.0 );

      } else {
        // ...assume skeletal animation

        var boneName = '.bones[' + bones[ h ].name + ']';

        addNonemptyTrack(
            THREE.VectorKeyframeTrack, boneName + '.position',
            animationKeys, 'pos', tracks );

        addNonemptyTrack(
            THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
            animationKeys, 'rot', tracks );

        addNonemptyTrack(
            THREE.VectorKeyframeTrack, boneName + '.scale',
            animationKeys, 'scl', tracks );

      }

    }

    if ( tracks.length === 0 ) {

      return null;

    }

    var clip = new THREE.AnimationClip( clipName, duration, tracks );

    return clip;

  }

} );


// File:src/animation/AnimationMixer.js

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.AnimationMixer = function( root ) {

  this._root = root;
  this._initMemoryManager();
  this._accuIndex = 0;

  this.time = 0;

  this.timeScale = 1.0;

};

THREE.AnimationMixer.prototype = {

  constructor: THREE.AnimationMixer,

  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction: function( clip, optionalRoot ) {

    var root = optionalRoot || this._root,
      rootUuid = root.uuid,
      clipName = ( typeof clip === 'string' ) ? clip : clip.name,
      clipObject = ( clip !== clipName ) ? clip : null,

      actionsForClip = this._actionsByClip[ clipName ],
      prototypeAction;

    if ( actionsForClip !== undefined ) {

      var existingAction =
          actionsForClip.actionByRoot[ rootUuid ];

      if ( existingAction !== undefined ) {

        return existingAction;

      }

      // we know the clip, so we don't have to parse all
      // the bindings again but can just copy
      prototypeAction = actionsForClip.knownActions[ 0 ];

      // also, take the clip from the prototype action
      clipObject = prototypeAction._clip;

      if ( clip !== clipName && clip !== clipObject ) {

        throw new Error(
            "Different clips with the same name detected!" );

      }

    }

    // clip must be known when specified via string
    if ( clipObject === null ) return null;

    // allocate all resources required to run it
    var newAction = new THREE.
        AnimationMixer._Action( this, clipObject, optionalRoot );

    this._bindAction( newAction, prototypeAction );

    // and make the action known to the memory manager
    this._addInactiveAction( newAction, clipName, rootUuid );

    return newAction;

  },

  // get an existing action
  existingAction: function( clip, optionalRoot ) {

    var root = optionalRoot || this._root,
      rootUuid = root.uuid,
      clipName = ( typeof clip === 'string' ) ? clip : clip.name,
      actionsForClip = this._actionsByClip[ clipName ];

    if ( actionsForClip !== undefined ) {

      return actionsForClip.actionByRoot[ rootUuid ] || null;

    }

    return null;

  },

  // deactivates all previously scheduled actions
  stopAllAction: function() {

    var actions = this._actions,
      nActions = this._nActiveActions,
      bindings = this._bindings,
      nBindings = this._nActiveBindings;

    this._nActiveActions = 0;
    this._nActiveBindings = 0;

    for ( var i = 0; i !== nActions; ++ i ) {

      actions[ i ].reset();

    }

    for ( var i = 0; i !== nBindings; ++ i ) {

      bindings[ i ].useCount = 0;

    }

    return this;

  },

  // advance the time and update apply the animation
  update: function( deltaTime ) {

    deltaTime *= this.timeScale;

    var actions = this._actions,
      nActions = this._nActiveActions,

      time = this.time += deltaTime,
      timeDirection = Math.sign( deltaTime ),

      accuIndex = this._accuIndex ^= 1;

    // run active actions

    for ( var i = 0; i !== nActions; ++ i ) {

      var action = actions[ i ];

      if ( action.enabled ) {

        action._update( time, deltaTime, timeDirection, accuIndex );

      }

    }

    // update scene graph

    var bindings = this._bindings,
      nBindings = this._nActiveBindings;

    for ( var i = 0; i !== nBindings; ++ i ) {

      bindings[ i ].apply( accuIndex );

    }

    return this;

  },

  // return this mixer's root target object
  getRoot: function() {

    return this._root;

  },

  // free all resources specific to a particular clip
  uncacheClip: function( clip ) {

    var actions = this._actions,
      clipName = clip.name,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[ clipName ];

    if ( actionsForClip !== undefined ) {

      // note: just calling _removeInactiveAction would mess up the
      // iteration state and also require updating the state we can
      // just throw away

      var actionsToRemove = actionsForClip.knownActions;

      for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

        var action = actionsToRemove[ i ];

        this._deactivateAction( action );

        var cacheIndex = action._cacheIndex,
          lastInactiveAction = actions[ actions.length - 1 ];

        action._cacheIndex = null;
        action._byClipCacheIndex = null;

        lastInactiveAction._cacheIndex = cacheIndex;
        actions[ cacheIndex ] = lastInactiveAction;
        actions.pop();

        this._removeInactiveBindingsForAction( action );

      }

      delete actionsByClip[ clipName ];

    }

  },

  // free all resources specific to a particular root target object
  uncacheRoot: function( root ) {

    var rootUuid = root.uuid,
      actionsByClip = this._actionsByClip;

    for ( var clipName in actionsByClip ) {

      var actionByRoot = actionsByClip[ clipName ].actionByRoot,
        action = actionByRoot[ rootUuid ];

      if ( action !== undefined ) {

        this._deactivateAction( action );
        this._removeInactiveAction( action );

      }

    }

    var bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[ rootUuid ];

    if ( bindingByName !== undefined ) {

      for ( var trackName in bindingByName ) {

        var binding = bindingByName[ trackName ];
        binding.restoreOriginalState();
        this._removeInactiveBinding( binding );

      }

    }

  },

  // remove a targeted clip from the cache
  uncacheAction: function( clip, optionalRoot ) {

    var action = this.existingAction( clip, optionalRoot );

    if ( action !== null ) {

      this._deactivateAction( action );
      this._removeInactiveAction( action );

    }

  }

};

THREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );

THREE.AnimationMixer._Action =
    function( mixer, clip, localRoot ) {

  this._mixer = mixer;
  this._clip = clip;
  this._localRoot = localRoot || null;

  var tracks = clip.tracks,
    nTracks = tracks.length,
    interpolants = new Array( nTracks );

  var interpolantSettings = {
      endingStart:  THREE.ZeroCurvatureEnding,
      endingEnd:    THREE.ZeroCurvatureEnding
  };

  for ( var i = 0; i !== nTracks; ++ i ) {

    var interpolant = tracks[ i ].createInterpolant( null );
    interpolants[ i ] = interpolant;
    interpolant.settings = interpolantSettings

  }

  this._interpolantSettings = interpolantSettings;

  this._interpolants = interpolants;  // bound by the mixer

  // inside: PropertyMixer (managed by the mixer)
  this._propertyBindings = new Array( nTracks );

  this._cacheIndex = null;      // for the memory manager
  this._byClipCacheIndex = null;    // for the memory manager

  this._timeScaleInterpolant = null;
  this._weightInterpolant = null;

  this.loop = THREE.LoopRepeat;
  this._loopCount = -1;

  // global mixer time when the action is to be started
  // it's set back to 'null' upon start of the action
  this._startTime = null;

  // scaled local time of the action
  // gets clamped or wrapped to 0..clip.duration according to loop
  this.time = 0;

  this.timeScale = 1;
  this._effectiveTimeScale = 1;

  this.weight = 1;
  this._effectiveWeight = 1;

  this.repetitions = Infinity;    // no. of repetitions when looping

  this.paused = false;        // false -> zero effective time scale
  this.enabled = true;        // true -> zero effective weight

  this.clampWhenFinished  = false;  // keep feeding the last frame?

  this.zeroSlopeAtStart   = true;   // for smooth interpolation w/o separate
  this.zeroSlopeAtEnd   = true;   // clips for start, loop and end

};

THREE.AnimationMixer._Action.prototype = {

  constructor: THREE.AnimationMixer._Action,

  // State & Scheduling

  play: function() {

    this._mixer._activateAction( this );

    return this;

  },

  stop: function() {

    this._mixer._deactivateAction( this );

    return this.reset();

  },

  reset: function() {

    this.paused = false;
    this.enabled = true;

    this.time = 0;      // restart clip
    this._loopCount = -1; // forget previous loops
    this._startTime = null; // forget scheduling

    return this.stopFading().stopWarping();

  },

  isRunning: function() {

    var start = this._startTime;

    return this.enabled && ! this.paused && this.timeScale !== 0 &&
        this._startTime === null && this._mixer._isActiveAction( this )

  },

  // return true when play has been called
  isScheduled: function() {

    return this._mixer._isActiveAction( this );

  },

  startAt: function( time ) {

    this._startTime = time;

    return this;

  },

  setLoop: function( mode, repetitions ) {

    this.loop = mode;
    this.repetitions = repetitions;

    return this;

  },

  // Weight

  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight: function( weight ) {

    this.weight = weight;

    // note: same logic as when updated at runtime
    this._effectiveWeight = this.enabled ? weight : 0;

    return this.stopFading();

  },

  // return the weight considering fading and .enabled
  getEffectiveWeight: function() {

    return this._effectiveWeight;

  },

  fadeIn: function( duration ) {

    return this._scheduleFading( duration, 0, 1 );

  },

  fadeOut: function( duration ) {

    return this._scheduleFading( duration, 1, 0 );

  },

  crossFadeFrom: function( fadeOutAction, duration, warp ) {

    var mixer = this._mixer;

    fadeOutAction.fadeOut( duration );
    this.fadeIn( duration );

    if( warp ) {

      var fadeInDuration = this._clip.duration,
        fadeOutDuration = fadeOutAction._clip.duration,

        startEndRatio = fadeOutDuration / fadeInDuration,
        endStartRatio = fadeInDuration / fadeOutDuration;

      fadeOutAction.warp( 1.0, startEndRatio, duration );
      this.warp( endStartRatio, 1.0, duration );

    }

    return this;

  },

  crossFadeTo: function( fadeInAction, duration, warp ) {

    return fadeInAction.crossFadeFrom( this, duration, warp );

  },

  stopFading: function() {

    var weightInterpolant = this._weightInterpolant;

    if ( weightInterpolant !== null ) {

      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant( weightInterpolant );

    }

    return this;

  },

  // Time Scale Control

  // set the weight stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale: function( timeScale ) {

    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 :timeScale;

    return this.stopWarping();

  },

  // return the time scale considering warping and .paused
  getEffectiveTimeScale: function() {

    return this._effectiveTimeScale;

  },

  setDuration: function( duration ) {

    this.timeScale = this._clip.duration / duration;

    return this.stopWarping();

  },

  syncWith: function( action ) {

    this.time = action.time;
    this.timeScale = action.timeScale;

    return this.stopWarping();

  },

  halt: function( duration ) {

    return this.warp( this._currentTimeScale, 0, duration );

  },

  warp: function( startTimeScale, endTimeScale, duration ) {

    var mixer = this._mixer, now = mixer.time,
      interpolant = this._timeScaleInterpolant,

      timeScale = this.timeScale;

    if ( interpolant === null ) {

      interpolant = mixer._lendControlInterpolant(),
      this._timeScaleInterpolant = interpolant;

    }

    var times = interpolant.parameterPositions,
      values = interpolant.sampleValues;

    times[ 0 ] = now;
    times[ 1 ] = now + duration;

    values[ 0 ] = startTimeScale / timeScale;
    values[ 1 ] = endTimeScale / timeScale;

    return this;

  },

  stopWarping: function() {

    var timeScaleInterpolant = this._timeScaleInterpolant;

    if ( timeScaleInterpolant !== null ) {

      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

    }

    return this;

  },

  // Object Accessors

  getMixer: function() {

    return this._mixer;

  },

  getClip: function() {

    return this._clip;

  },

  getRoot: function() {

    return this._localRoot || this._mixer._root;

  },

  // Interna

  _update: function( time, deltaTime, timeDirection, accuIndex ) {
    // called by the mixer

    var startTime = this._startTime;

    if ( startTime !== null ) {

      // check for scheduled start of action

      var timeRunning = ( time - startTime ) * timeDirection;
      if ( timeRunning < 0 || timeDirection === 0 ) {

        return; // yet to come / don't decide when delta = 0

      }

      // start

      this._startTime = null; // unschedule
      deltaTime = timeDirection * timeRunning;

    }

    // apply time scale and advance time

    deltaTime *= this._updateTimeScale( time );
    var clipTime = this._updateTime( deltaTime );

    // note: _updateTime may disable the action resulting in
    // an effective weight of 0

    var weight = this._updateWeight( time );

    if ( weight > 0 ) {

      var interpolants = this._interpolants;
      var propertyMixers = this._propertyBindings;

      for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

        interpolants[ j ].evaluate( clipTime );
        propertyMixers[ j ].accumulate( accuIndex, weight );

      }

    }

  },

  _updateWeight: function( time ) {

    var weight = 0;

    if ( this.enabled ) {

      weight = this.weight;
      var interpolant = this._weightInterpolant;

      if ( interpolant !== null ) {

        var interpolantValue = interpolant.evaluate( time )[ 0 ];

        weight *= interpolantValue;

        if ( time > interpolant.parameterPositions[ 1 ] ) {

          this.stopFading();

          if ( interpolantValue === 0 ) {

            // faded out, disable
            this.enabled = false;

          }

        }

      }

    }

    this._effectiveWeight = weight;
    return weight;

  },

  _updateTimeScale: function( time ) {

    var timeScale = 0;

    if ( ! this.paused ) {

      timeScale = this.timeScale;

      var interpolant = this._timeScaleInterpolant;

      if ( interpolant !== null ) {

        var interpolantValue = interpolant.evaluate( time )[ 0 ];

        timeScale *= interpolantValue;

        if ( time > interpolant.parameterPositions[ 1 ] ) {

          this.stopWarping();

          if ( timeScale === 0 ) {

            // motion has halted, pause
            this.pause = true;

          } else {

            // warp done - apply final time scale
            this.timeScale = timeScale;

          }

        }

      }

    }

    this._effectiveTimeScale = timeScale;
    return timeScale;

  },

  _updateTime: function( deltaTime ) {

    var time = this.time + deltaTime;

    if ( deltaTime === 0 ) return time;

    var duration = this._clip.duration,

      loop = this.loop,
      loopCount = this._loopCount,

      pingPong = false;

    switch ( loop ) {

      case THREE.LoopOnce:
      case THREE.LoopOnceClamp:

        if ( loopCount === -1 ) {

          // just started

          this.loopCount = 0;
          this._setEndings( true, true, false );

        }

        if ( time >= duration ) {

          time = duration;

        } else if ( time < 0 ) {

          time = 0;

        } else break;

        // reached the end

        if ( this.clampWhenFinished ) this.pause = true;
        else this.enabled = false;

        this._mixer.dispatchEvent( {
          type: 'finished', action: this,
          direction: deltaTime < 0 ? -1 : 1
        } );

        break;

      case THREE.LoopPingPong:

        pingPong = true;

      case THREE.LoopRepeat:

        if ( loopCount === -1 ) {

          // just started

          if ( deltaTime > 0 ) {

            loopCount = 0;

            this._setEndings(
                true, this.repetitions === 0, pingPong );

          } else {

            // when looping in reverse direction, the initial
            // transition through zero counts as a repetition,
            // so leave loopCount at -1

            this._setEndings(
                this.repetitions === 0, true, pingPong );

          }

        }

        if ( time >= duration || time < 0 ) {

          // wrap around

          var loopDelta = Math.floor( time / duration ); // signed
          time -= duration * loopDelta;

          loopCount += Math.abs( loopDelta );

          var pending = this.repetitions - loopCount;

          if ( pending < 0 ) {

            // stop (switch state, clamp time, fire event)

            if ( this.clampWhenFinished ) this.paused = true;
            else this.enabled = false;

            time = deltaTime > 0 ? duration : 0;

            this._mixer.dispatchEvent( {
              type: 'finished', action: this,
              direction: deltaTime > 0 ? 1 : -1
            } );

            break;

          } else if ( pending === 0 ) {

            // transition to last round

            var atStart = deltaTime < 0;
            this._setEndings( atStart, ! atStart, pingPong );

          } else {

            this._setEndings( false, false, pingPong );

          }

          this._loopCount = loopCount;

          this._mixer.dispatchEvent( {
            type: 'loop', action: this, loopDelta: loopDelta
          } );

        }

        if ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {

          // invert time for the "pong round"

          this.time = time;

          return duration - time;

        }

        break;

    }

    this.time = time;

    return time;

  },

  _setEndings: function( atStart, atEnd, pingPong ) {

    var settings = this._interpolantSettings;

    if ( pingPong ) {

      settings.endingStart  = THREE.ZeroSlopeEnding;
      settings.endingEnd    = THREE.ZeroSlopeEnding;

    } else {

      // assuming for LoopOnce atStart == atEnd == true

      if ( atStart ) {

        settings.endingStart = this.zeroSlopeAtStart ?
            THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

      } else {

        settings.endingStart = THREE.WrapAroundEnding;

      }

      if ( atEnd ) {

        settings.endingEnd = this.zeroSlopeAtEnd ?
            THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

      } else {

        settings.endingEnd   = THREE.WrapAroundEnding;

      }

    }

  },

  _scheduleFading: function( duration, weightNow, weightThen ) {

    var mixer = this._mixer, now = mixer.time,
      interpolant = this._weightInterpolant;

    if ( interpolant === null ) {

      interpolant = mixer._lendControlInterpolant(),
      this._weightInterpolant = interpolant;

    }

    var times = interpolant.parameterPositions,
      values = interpolant.sampleValues;

    times[ 0 ] = now;         values[ 0 ] = weightNow;
    times[ 1 ] = now + duration;  values[ 1 ] = weightThen;

    return this;

  }

};

// Implementation details:

Object.assign( THREE.AnimationMixer.prototype, {

  _bindAction: function( action, prototypeAction ) {

    var root = action._localRoot || this._root,
      tracks = action._clip.tracks,
      nTracks = tracks.length,
      bindings = action._propertyBindings,
      interpolants = action._interpolants,
      rootUuid = root.uuid,
      bindingsByRoot = this._bindingsByRootAndName,
      bindingsByName = bindingsByRoot[ rootUuid ];

    if ( bindingsByName === undefined ) {

      bindingsByName = {};
      bindingsByRoot[ rootUuid ] = bindingsByName;

    }

    for ( var i = 0; i !== nTracks; ++ i ) {

      var track = tracks[ i ],
        trackName = track.name,
        binding = bindingsByName[ trackName ];

      if ( binding !== undefined ) {

        bindings[ i ] = binding;

      } else {

        binding = bindings[ i ];

        if ( binding !== undefined ) {

          // existing binding, make sure the cache knows

          if ( binding._cacheIndex === null ) {

            ++ binding.referenceCount;
            this._addInactiveBinding( binding, rootUuid, trackName );

          }

          continue;

        }

        var path = prototypeAction && prototypeAction.
            _propertyBindings[ i ].binding.parsedPath;

        binding = new THREE.PropertyMixer(
            THREE.PropertyBinding.create( root, trackName, path ),
            track.ValueTypeName, track.getValueSize() );

        ++ binding.referenceCount;
        this._addInactiveBinding( binding, rootUuid, trackName );

        bindings[ i ] = binding;

      }

      interpolants[ i ].resultBuffer = binding.buffer;

    }

  },

  _activateAction: function( action ) {

    if ( ! this._isActiveAction( action ) ) {

      if ( action._cacheIndex === null ) {

        // this action has been forgotten by the cache, but the user
        // appears to be still using it -> rebind

        var rootUuid = ( action._localRoot || this._root ).uuid,
          clipName = action._clip.name,
          actionsForClip = this._actionsByClip[ clipName ];

        this._bindAction( action,
            actionsForClip && actionsForClip.knownActions[ 0 ] );

        this._addInactiveAction( action, clipName, rootUuid );

      }

      var bindings = action._propertyBindings;

      // increment reference counts / sort out state
      for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

        var binding = bindings[ i ];

        if ( binding.useCount ++ === 0 ) {

          this._lendBinding( binding );
          binding.saveOriginalState();

        }

      }

      this._lendAction( action );

    }

  },

  _deactivateAction: function( action ) {

    if ( this._isActiveAction( action ) ) {

      var bindings = action._propertyBindings;

      // decrement reference counts / sort out state
      for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

        var binding = bindings[ i ];

        if ( -- binding.useCount === 0 ) {

          binding.restoreOriginalState();
          this._takeBackBinding( binding );

        }

      }

      this._takeBackAction( action );

    }

  },

  // Memory manager

  _initMemoryManager: function() {

    this._actions = []; // 'nActiveActions' followed by inactive ones
    this._nActiveActions = 0;

    this._actionsByClip = {};
    // inside:
    // {
    //    knownActions: Array< _Action >  - used as prototypes
    //    actionByRoot: _Action     - lookup
    // }


    this._bindings = []; // 'nActiveBindings' followed by inactive ones
    this._nActiveBindings = 0;

    this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


    this._controlInterpolants = []; // same game as above
    this._nActiveControlInterpolants = 0;

    var scope = this;

    this.stats = {

      actions: {
        get total() { return scope._actions.length; },
        get inUse() { return scope._nActiveActions; }
      },
      bindings: {
        get total() { return scope._bindings.length; },
        get inUse() { return scope._nActiveBindings; }
      },
      controlInterpolants: {
        get total() { return scope._controlInterpolants.length; },
        get inUse() { return scope._nActiveControlInterpolants; }
      }

    };

  },

  // Memory management for _Action objects

  _isActiveAction: function( action ) {

    var index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;

  },

  _addInactiveAction: function( action, clipName, rootUuid ) {

    var actions = this._actions,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[ clipName ];

    if ( actionsForClip === undefined ) {

      actionsForClip = {

        knownActions: [ action ],
        actionByRoot: {}

      };

      action._byClipCacheIndex = 0;

      actionsByClip[ clipName ] = actionsForClip;

    } else {

      var knownActions = actionsForClip.knownActions;

      action._byClipCacheIndex = knownActions.length;
      knownActions.push( action );

    }

    action._cacheIndex = actions.length;
    actions.push( action );

    actionsForClip.actionByRoot[ rootUuid ] = action;

  },

  _removeInactiveAction: function( action ) {

    var actions = this._actions,
      lastInactiveAction = actions[ actions.length - 1 ],
      cacheIndex = action._cacheIndex;

    lastInactiveAction._cacheIndex = cacheIndex;
    actions[ cacheIndex ] = lastInactiveAction;
    actions.pop();

    action._cacheIndex = null;


    var clipName = action._clip.name,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[ clipName ],
      knownActionsForClip = actionsForClip.knownActions,

      lastKnownAction =
        knownActionsForClip[ knownActionsForClip.length - 1 ],

      byClipCacheIndex = action._byClipCacheIndex;

    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
    knownActionsForClip.pop();

    action._byClipCacheIndex = null;


    var actionByRoot = actionsForClip.actionByRoot,
      rootUuid = ( actions._localRoot || this._root ).uuid;

    delete actionByRoot[ rootUuid ];

    if ( knownActionsForClip.length === 0 ) {

      delete actionsByClip[ clipName ];

    }

    this._removeInactiveBindingsForAction( action );

  },

  _removeInactiveBindingsForAction: function( action ) {

    var bindings = action._propertyBindings;
    for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

      var binding = bindings[ i ];

      if ( -- binding.referenceCount === 0 ) {

        this._removeInactiveBinding( binding );

      }

    }

  },

  _lendAction: function( action ) {

    // [ active actions |  inactive actions  ]
    // [  active actions >| inactive actions ]
    //                 s        a
    //                  <-swap->
    //                 a        s

    var actions = this._actions,
      prevIndex = action._cacheIndex,

      lastActiveIndex = this._nActiveActions ++,

      firstInactiveAction = actions[ lastActiveIndex ];

    action._cacheIndex = lastActiveIndex;
    actions[ lastActiveIndex ] = action;

    firstInactiveAction._cacheIndex = prevIndex;
    actions[ prevIndex ] = firstInactiveAction;

  },

  _takeBackAction: function( action ) {

    // [  active actions  | inactive actions ]
    // [ active actions |< inactive actions  ]
    //        a        s
    //         <-swap->
    //        s        a

    var actions = this._actions,
      prevIndex = action._cacheIndex,

      firstInactiveIndex = -- this._nActiveActions,

      lastActiveAction = actions[ firstInactiveIndex ];

    action._cacheIndex = firstInactiveIndex;
    actions[ firstInactiveIndex ] = action;

    lastActiveAction._cacheIndex = prevIndex;
    actions[ prevIndex ] = lastActiveAction;

  },

  // Memory management for PropertyMixer objects

  _addInactiveBinding: function( binding, rootUuid, trackName ) {

    var bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[ rootUuid ],

      bindings = this._bindings;

    if ( bindingByName === undefined ) {

      bindingByName = {};
      bindingsByRoot[ rootUuid ] = bindingByName;

    }

    bindingByName[ trackName ] = binding;

    binding._cacheIndex = bindings.length;
    bindings.push( binding );

  },

  _removeInactiveBinding: function( binding ) {

    var bindings = this._bindings,
      propBinding = binding.binding,
      rootUuid = propBinding.rootNode.uuid,
      trackName = propBinding.path,
      bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[ rootUuid ],

      lastInactiveBinding = bindings[ bindings.length - 1 ],
      cacheIndex = binding._cacheIndex;

    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[ cacheIndex ] = lastInactiveBinding;
    bindings.pop();

    delete bindingByName[ trackName ];

    remove_empty_map: {

      for ( var _ in bindingByName ) break remove_empty_map;

      delete bindingsByRoot[ rootUuid ];

    }

  },

  _lendBinding: function( binding ) {

    var bindings = this._bindings,
      prevIndex = binding._cacheIndex,

      lastActiveIndex = this._nActiveBindings ++,

      firstInactiveBinding = bindings[ lastActiveIndex ];

    binding._cacheIndex = lastActiveIndex;
    bindings[ lastActiveIndex ] = binding;

    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[ prevIndex ] = firstInactiveBinding;

  },

  _takeBackBinding: function( binding ) {

    var bindings = this._bindings,
      prevIndex = binding._cacheIndex,

      firstInactiveIndex = -- this._nActiveBindings,

      lastActiveBinding = bindings[ firstInactiveIndex ];

    binding._cacheIndex = firstInactiveIndex;
    bindings[ firstInactiveIndex ] = binding;

    lastActiveBinding._cacheIndex = prevIndex;
    bindings[ prevIndex ] = lastActiveBinding;

  },


  // Memory management of Interpolants for weight and time scale

  _lendControlInterpolant: function() {

    var interpolants = this._controlInterpolants,
      lastActiveIndex = this._nActiveControlInterpolants ++,
      interpolant = interpolants[ lastActiveIndex ];

    if ( interpolant === undefined ) {

      interpolant = new THREE.LinearInterpolant(
          new Float32Array( 2 ), new Float32Array( 2 ),
            1, this._controlInterpolantsResultBuffer );

      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[ lastActiveIndex ] = interpolant;

    }

    return interpolant;

  },

  _takeBackControlInterpolant: function( interpolant ) {

    var interpolants = this._controlInterpolants,
      prevIndex = interpolant.__cacheIndex,

      firstInactiveIndex = -- this._nActiveControlInterpolants,

      lastActiveInterpolant = interpolants[ firstInactiveIndex ];

    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[ firstInactiveIndex ] = interpolant;

    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[ prevIndex ] = lastActiveInterpolant;

  },

  _controlInterpolantsResultBuffer: new Float32Array( 1 )

} );


// File:src/animation/AnimationObjectGroup.js

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  -   The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */

THREE.AnimationObjectGroup = function( var_args ) {

  this.uuid = THREE.Math.generateUUID();

  // cached objects followed by the active ones
  this._objects = Array.prototype.slice.call( arguments );

  this.nCachedObjects_ = 0;     // threshold
  // note: read by PropertyBinding.Composite

  var indices = {};
  this._indicesByUUID = indices;    // for bookkeeping

  for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    indices[ arguments[ i ].uuid ] = i;

  }

  this._paths = [];         // inside: string
  this._parsedPaths = [];       // inside: { we don't care, here }
  this._bindings = [];        // inside: Array< PropertyBinding >
  this._bindingsIndicesByPath = {};   // inside: indices in these arrays

  var scope = this;

  this.stats = {

    objects: {
      get total() { return scope._objects.length; },
      get inUse() { return this.total - scope.nCachedObjects_;  }
    },

    get bindingsPerObject() { return scope._bindings.length; }

  };

};

THREE.AnimationObjectGroup.prototype = {

  constructor: THREE.AnimationObjectGroup,

  add: function( var_args ) {

    var objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      indicesByUUID = this._indicesByUUID,
      paths = this._paths,
      parsedPaths = this._parsedPaths,
      bindings = this._bindings,
      nBindings = bindings.length;

    for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

      var object = arguments[ i ],
        uuid = object.uuid,
        index = indicesByUUID[ uuid ];

      if ( index === undefined ) {

        // unknown object -> add it to the ACTIVE region

        index = nObjects ++;
        indicesByUUID[ uuid ] = index;
        objects.push( object );

        // accounting is done, now do the same for all bindings

        for ( var j = 0, m = nBindings; j !== m; ++ j ) {

          bindings[ j ].push(
              new THREE.PropertyBinding(
                object, paths[ j ], parsedPaths[ j ] ) );

        }

      } else if ( index < nCachedObjects ) {

        var knownObject = objects[ index ];

        // move existing object to the ACTIVE region

        var firstActiveIndex = -- nCachedObjects,
          lastCachedObject = objects[ firstActiveIndex ];

        indicesByUUID[ lastCachedObject.uuid ] = index;
        objects[ index ] = lastCachedObject;

        indicesByUUID[ uuid ] = firstActiveIndex;
        objects[ firstActiveIndex ] = object;

        // accounting is done, now do the same for all bindings

        for ( var j = 0, m = nBindings; j !== m; ++ j ) {

          var bindingsForPath = bindings[ j ],
            lastCached = bindingsForPath[ firstActiveIndex ],
            binding = bindingsForPath[ index ];

          bindingsForPath[ index ] = lastCached;

          if ( binding === undefined ) {

            // since we do not bother to create new bindings
            // for objects that are cached, the binding may
            // or may not exist

            binding = new THREE.PropertyBinding(
                object, paths[ j ], parsedPaths[ j ] );

          }

          bindingsForPath[ firstActiveIndex ] = binding;

        }

      } else if ( objects[ index ] !== knownObject) {

        console.error( "Different objects with the same UUID " +
            "detected. Clean the caches or recreate your " +
            "infrastructure when reloading scenes..." );

      } // else the object is already where we want it to be

    } // for arguments

    this.nCachedObjects_ = nCachedObjects;

  },

  remove: function( var_args ) {

    var objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;

    for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

      var object = arguments[ i ],
        uuid = object.uuid,
        index = indicesByUUID[ uuid ];

      if ( index !== undefined && index >= nCachedObjects ) {

        // move existing object into the CACHED region

        var lastCachedIndex = nCachedObjects ++,
          firstActiveObject = objects[ lastCachedIndex ];

        indicesByUUID[ firstActiveObject.uuid ] = index;
        objects[ index ] = firstActiveObject;

        indicesByUUID[ uuid ] = lastCachedIndex;
        objects[ lastCachedIndex ] = object;

        // accounting is done, now do the same for all bindings

        for ( var j = 0, m = nBindings; j !== m; ++ j ) {

          var bindingsForPath = bindings[ j ],
            firstActive = bindingsForPath[ lastCachedIndex ],
            binding = bindingsForPath[ index ];

          bindingsForPath[ index ] = firstActive;
          bindingsForPath[ lastCachedIndex ] = binding;

        }

      }

    } // for arguments

    this.nCachedObjects_ = nCachedObjects;

  },

  // remove & forget
  uncache: function( var_args ) {

    var objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;

    for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

      var object = arguments[ i ],
        uuid = object.uuid,
        index = indicesByUUID[ uuid ];

      if ( index !== undefined ) {

        delete indicesByUUID[ uuid ];

        if ( index < nCachedObjects ) {

          // object is cached, shrink the CACHED region

          var firstActiveIndex = -- nCachedObjects,
            lastCachedObject = objects[ firstActiveIndex ],
            lastIndex = -- nObjects,
            lastObject = objects[ lastIndex ];

          // last cached object takes this object's place
          indicesByUUID[ lastCachedObject.uuid ] = index;
          objects[ index ] = lastCachedObject;

          // last object goes to the activated slot and pop
          indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
          objects[ firstActiveIndex ] = lastObject;
          objects.pop();

          // accounting is done, now do the same for all bindings

          for ( var j = 0, m = nBindings; j !== m; ++ j ) {

            var bindingsForPath = bindings[ j ],
              lastCached = bindingsForPath[ firstActiveIndex ],
              last = bindingsForPath[ lastIndex ];

            bindingsForPath[ index ] = lastCached;
            bindingsForPath[ firstActiveIndex ] = last;
            bindingsForPath.pop();

          }

        } else {

          // object is active, just swap with the last and pop

          var lastIndex = -- nObjects,
            lastObject = objects[ lastIndex ];

          indicesByUUID[ lastObject.uuid ] = index;
          objects[ index ] = lastObject;
          objects.pop();

          // accounting is done, now do the same for all bindings

          for ( var j = 0, m = nBindings; j !== m; ++ j ) {

            var bindingsForPath = bindings[ j ];

            bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
            bindingsForPath.pop();

          }

        } // cached or active

      } // if object is known

    } // for arguments

    this.nCachedObjects_ = nCachedObjects;

  },

  // Internal interface used by befriended PropertyBinding.Composite:

  subscribe_: function( path, parsedPath ) {
    // returns an array of bindings for the given path that is changed
    // according to the contained objects in the group

    var indicesByPath = this._bindingsIndicesByPath,
      index = indicesByPath[ path ],
      bindings = this._bindings;

    if ( index !== undefined ) return bindings[ index ];

    var paths = this._paths,
      parsedPaths = this._parsedPaths,
      objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      bindingsForPath = new Array( nObjects );

    index = bindings.length;

    indicesByPath[ path ] = index;

    paths.push( path );
    parsedPaths.push( parsedPath );
    bindings.push( bindingsForPath );

    for ( var i = nCachedObjects,
        n = objects.length; i !== n; ++ i ) {

      var object = objects[ i ];

      bindingsForPath[ i ] =
          new THREE.PropertyBinding( object, path, parsedPath );

    }

    return bindingsForPath;

  },

  unsubscribe_: function( path ) {
    // tells the group to forget about a property path and no longer
    // update the array previously obtained with 'subscribe_'

    var indicesByPath = this._bindingsIndicesByPath,
      index = indicesByPath[ path ];

    if ( index !== undefined ) {

      var paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        lastBindingsIndex = bindings.length - 1,
        lastBindings = bindings[ lastBindingsIndex ],
        lastBindingsPath = path[ lastBindingsIndex ];

      indicesByPath[ lastBindingsPath ] = index;

      bindings[ index ] = lastBindings;
      bindings.pop();

      parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
      parsedPaths.pop();

      paths[ index ] = paths[ lastBindingsIndex ];
      paths.pop();

    }

  }

};


// File:src/animation/AnimationUtils.js

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

  // same as Array.prototype.slice, but also works on typed arrays
  arraySlice: function( array, from, to ) {

    if ( THREE.AnimationUtils.isTypedArray( array ) ) {

      return new array.constructor( array.subarray( from, to ) );

    }

    return array.slice( from, to );

  },

  // converts an array to a specific type
  convertArray: function( array, type, forceClone ) {

    if ( ! array || // let 'undefined' and 'null' pass
        ! forceClone && array.constructor === type ) return array;

    if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

      return new type( array ); // create typed array

    }

    return Array.prototype.slice.call( array ); // create Array

  },

  isTypedArray: function( object ) {

    return ArrayBuffer.isView( object ) &&
        ! ( object instanceof DataView );

  },

  // returns an array by which times and values can be sorted
  getKeyframeOrder: function( times ) {

    function compareTime( i, j ) {

      return times[ i ] - times[ j ];

    }

    var n = times.length;
    var result = new Array( n );
    for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

    result.sort( compareTime );

    return result;

  },

  // uses the array previously returned by 'getKeyframeOrder' to sort data
  sortedArray: function( values, stride, order ) {

    var nValues = values.length;
    var result = new values.constructor( nValues );

    for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

      var srcOffset = order[ i ] * stride;

      for ( var j = 0; j !== stride; ++ j ) {

        result[ dstOffset ++ ] = values[ srcOffset + j ];

      }

    }

    return result;

  },

  // function for parsing AOS keyframe formats
  flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

    var i = 1, key = jsonKeys[ 0 ];

    while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

      key = jsonKeys[ i ++ ];

    }

    if ( key === undefined ) return; // no data

    var value = key[ valuePropertyName ];
    if ( value === undefined ) return; // no data

    if ( Array.isArray( value ) ) {

      do {

        value = key[ valuePropertyName ];

        if ( value !== undefined ) {

          times.push( key.time );
          values.push.apply( values, value ); // push all elements

        }

        key = jsonKeys[ i ++ ];

      } while ( key !== undefined );

    } else if ( value.toArray !== undefined ) {
      // ...assume THREE.Math-ish

      do {

        value = key[ valuePropertyName ];

        if ( value !== undefined ) {

          times.push( key.time );
          value.toArray( values, values.length );

        }

        key = jsonKeys[ i ++ ];

      } while ( key !== undefined );

    } else {
      // otherwise push as-is

      do {

        value = key[ valuePropertyName ];

        if ( value !== undefined ) {

          times.push( key.time );
          values.push( value );

        }

        key = jsonKeys[ i ++ ];

      } while ( key !== undefined );

    }

  }

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.KeyframeTrack = function ( name, times, values, interpolation ) {

  if( name === undefined ) throw new Error( "track name is undefined" );

  if( times === undefined || times.length === 0 ) {

    throw new Error( "no keyframes in track named " + name );

  }

  this.name = name;

  this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );
  this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );

  this.setInterpolation( interpolation || this.DefaultInterpolation );

  this.validate();
  this.optimize();

};

THREE.KeyframeTrack.prototype = {

  constructor: THREE.KeyframeTrack,

  TimeBufferType: Float32Array,
  ValueBufferType: Float32Array,

  DefaultInterpolation: THREE.InterpolateLinear,

  InterpolantFactoryMethodDiscrete: function( result ) {

    return new THREE.DiscreteInterpolant(
        this.times, this.values, this.getValueSize(), result );

  },

  InterpolantFactoryMethodLinear: function( result ) {

    return new THREE.LinearInterpolant(
        this.times, this.values, this.getValueSize(), result );

  },

  InterpolantFactoryMethodSmooth: function( result ) {

    return new THREE.CubicInterpolant(
        this.times, this.values, this.getValueSize(), result );

  },

  setInterpolation: function( interpolation ) {

    var factoryMethod = undefined;

    switch ( interpolation ) {

      case THREE.InterpolateDiscrete:

        factoryMethod = this.InterpolantFactoryMethodDiscrete;

        break;

      case THREE.InterpolateLinear:

        factoryMethod = this.InterpolantFactoryMethodLinear;

        break;

      case THREE.InterpolateSmooth:

        factoryMethod = this.InterpolantFactoryMethodSmooth;

        break;

    }

    if ( factoryMethod === undefined ) {

      var message = "unsupported interpolation for " +
          this.ValueTypeName + " keyframe track named " + this.name;

      if ( this.createInterpolant === undefined ) {

        // fall back to default, unless the default itself is messed up
        if ( interpolation !== this.DefaultInterpolation ) {

          this.setInterpolation( this.DefaultInterpolation );

        } else {

          throw new Error( message ); // fatal, in this case

        }

      }

      console.warn( message );
      return;

    }

    this.createInterpolant = factoryMethod;

  },

  getInterpolation: function() {

    switch ( this.createInterpolant ) {

      case this.InterpolantFactoryMethodDiscrete:

        return THREE.InterpolateDiscrete;

      case this.InterpolantFactoryMethodLinear:

        return THREE.InterpolateLinear;

      case this.InterpolantFactoryMethodSmooth:

        return THREE.InterpolateSmooth;

    }

  },

  getValueSize: function() {

    return this.values.length / this.times.length;

  },

  // move all keyframes either forwards or backwards in time
  shift: function( timeOffset ) {

    if( timeOffset !== 0.0 ) {

      var times = this.times;

      for( var i = 0, n = times.length; i !== n; ++ i ) {

        times[ i ] += timeOffset;

      }

    }

    return this;

  },

  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale: function( timeScale ) {

    if( timeScale !== 1.0 ) {

      var times = this.times;

      for( var i = 0, n = times.length; i !== n; ++ i ) {

        times[ i ] *= timeScale;

      }

    }

    return this;

  },

  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim: function( startTime, endTime ) {

    var times = this.times;
    var nKeys = times.length;

    var firstKeysToRemove = 0;
    for ( var i = 1; i !== nKeys; ++ i ) {

      if ( times[i] <= startTime ) ++ firstKeysToRemove;

    }

    var lastKeysToRemove = 0;
    for ( var i = nKeys - 2; i !== 0; -- i ) {

      if ( times[i] >= endTime ) ++ lastKeysToRemove;
      else break;

    }

    // remove last keys first because it doesn't affect the position of the first keys (the otherway around doesn't work as easily)
    if( ( firstKeysToRemove + lastKeysToRemove ) !== 0 ) {

      var from = firstKeysToRemove;
      var to = nKeys - lastKeysToRemove - firstKeysToRemove;

      this.times = THREE.AnimationUtils.arraySlice( times, from, to );

      var values = this.values;
      var stride = this.getValueSize();
      this.values = THREE.AnimationUtils.arraySlice( values, from * stride, to * stride );

    }

    return this;

  },

  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate: function() {

    var valid = true;

    var valueSize = this.getValueSize();
    if ( valueSize - Math.floor( valueSize ) !== 0 ) {

      console.error( "invalid value size in track", this );
      valid = false;

    }

    var times = this.times,
      values = this.values,

      nKeys = times.length;

    if( nKeys === 0 ) {

      console.error( "track is empty", this );
      valid = false;

    }

    var prevTime = null;

    for( var i = 0; i !== nKeys; i ++ ) {

      var currTime = times[ i ];

      if ( typeof currTime === 'number' && isNaN( currTime ) ) {

        console.error( "time is not a valid number", this, i, currTime );
        valid = false;
        break;

      }

      if( prevTime !== null && prevTime > currTime ) {

        console.error( "out of order keys", this, i, currTime, prevTime );
        valid = false;
        break;

      }

      prevTime = currTime;

    }

    if ( values !== undefined ) {

      if ( THREE.AnimationUtils.isTypedArray( values ) ) {

        for ( var i = 0, n = values.length; i !== n; ++ i ) {

          var value = values[ i ];

          if ( isNaN( value ) ) {

            console.error( "value is not a valid number", this, i, value );
            valid = false;
            break;

          }

        }

      }

    }

    return valid;

  },

  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize: function() {

    var times = this.times,
      values = this.values,
      stride = this.getValueSize(),

      writeIndex = 1;

    for( var i = 1, n = times.length - 1; i <= n; ++ i ) {

      var keep = false;

      var time = times[ i ];
      var timeNext = times[ i + 1 ];

      // remove adjacent keyframes scheduled at the same time

      if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

        // remove unnecessary keyframes same as their neighbors
        var offset = i * stride,
          offsetP = offset - stride,
          offsetN = offset + stride;

        for ( var j = 0; j !== stride; ++ j ) {

          var value = values[ offset + j ];

          if ( value !== values[ offsetP + j ] ||
              value !== values[ offsetN + j ] ) {

            keep = true;
            break;

          }

        }

      }

      // in-place compaction

      if ( keep ) {

        if ( i !== writeIndex ) {

          times[ writeIndex ] = times[ i ];

          var readOffset = i * stride,
            writeOffset = writeIndex * stride;

          for ( var j = 0; j !== stride; ++ j ) {

            values[ writeOffset + j ] = values[ readOffset + j ];

          }


        }

        ++ writeIndex;

      }

    }

    if ( writeIndex !== times.length ) {

      this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );
      this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

    }

    return this;

  }

};

// Static methods:

Object.assign( THREE.KeyframeTrack, {

  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):

  parse: function( json ) {

    if( json.type === undefined ) {

      throw new Error( "track type undefined, can not parse" );

    }

    var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );

    if ( json.times === undefined ) {

      console.warn( "legacy JSON format detected, converting" );

      var times = [], values = [];

      THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

      json.times = times;
      json.values = values;

    }

    // derived classes can define a static parse method
    if ( trackType.parse !== undefined ) {

      return trackType.parse( json );

    } else {

      // by default, we asssume a constructor compatible with the base
      return new trackType(
          json.name, json.times, json.values, json.interpolation );

    }

  },

  toJSON: function( track ) {

    var trackType = track.constructor;

    var json;

    // derived classes can define a static toJSON method
    if ( trackType.toJSON !== undefined ) {

      json = trackType.toJSON( track );

    } else {

      // by default, we assume the data can be serialized as-is
      json = {

        'name': track.name,
        'times': THREE.AnimationUtils.convertArray( track.times, Array ),
        'values': THREE.AnimationUtils.convertArray( track.values, Array )

      };

      var interpolation = track.getInterpolation();

      if ( interpolation !== track.DefaultInterpolation ) {

        json.interpolation = interpolation;

      }

    }

    json.type = track.ValueTypeName; // mandatory

    return json;

  },

  _getTrackTypeForValueTypeName: function( typeName ) {

    switch( typeName.toLowerCase() ) {

      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":

        return THREE.NumberKeyframeTrack;

      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":

        return THREE.VectorKeyframeTrack;

      case "color":

        return THREE.ColorKeyframeTrack;

      case "quaternion":

        return THREE.QuaternionKeyframeTrack;

      case "bool":
      case "boolean":

        return THREE.BooleanKeyframeTrack;

      case "string":

        return THREE.StringKeyframeTrack;

    };

    throw new Error( "Unsupported typeName: " + typeName );

  }

} );

// File:src/animation/PropertyBinding.js

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.PropertyBinding = function ( rootNode, path, parsedPath ) {

  this.path = path;
  this.parsedPath = parsedPath ||
      THREE.PropertyBinding.parseTrackName( path );

  this.node = THREE.PropertyBinding.findNode(
      rootNode, this.parsedPath.nodeName ) || rootNode;

  this.rootNode = rootNode;

};

THREE.PropertyBinding.prototype = {

  constructor: THREE.PropertyBinding,

  getValue: function getValue_unbound( targetArray, offset ) {

    this.bind();
    this.getValue( targetArray, offset );

    // Note: This class uses a State pattern on a per-method basis:
    // 'bind' sets 'this.getValue' / 'setValue' and shadows the
    // prototype version of these methods with one that represents
    // the bound state. When the property is not found, the methods
    // become no-ops.

  },

  setValue: function getValue_unbound( sourceArray, offset ) {

    this.bind();
    this.setValue( sourceArray, offset );

  },

  // create getter / setter pair for a property in the scene graph
  bind: function() {

    var targetObject = this.node,
      parsedPath = this.parsedPath,

      objectName = parsedPath.objectName,
      propertyName = parsedPath.propertyName,
      propertyIndex = parsedPath.propertyIndex;

    if ( ! targetObject ) {

      targetObject = THREE.PropertyBinding.findNode(
          this.rootNode, parsedPath.nodeName ) || this.rootNode;

      this.node = targetObject;

    }

    // set fail state so we can just 'return' on error
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;

    // ensure there is a value node
    if ( ! targetObject ) {

      console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
      return;

    }

    if( objectName ) {

      var objectIndex = parsedPath.objectIndex;

      // special cases were we need to reach deeper into the hierarchy to get the face materials....
      switch ( objectName ) {

        case 'materials':

          if( ! targetObject.material ) {

            console.error( '  can not bind to material as node does not have a material', this );
            return;

          }

          if( ! targetObject.material.materials ) {

            console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
            return;

          }

          targetObject = targetObject.material.materials;

          break;

        case 'bones':

          if( ! targetObject.skeleton ) {

            console.error( '  can not bind to bones as node does not have a skeleton', this );
            return;

          }

          // potential future optimization: skip this if propertyIndex is already an integer
          // and convert the integer string to a true integer.

          targetObject = targetObject.skeleton.bones;

          // support resolving morphTarget names into indices.
          for ( var i = 0; i < targetObject.length; i ++ ) {

            if ( targetObject[i].name === objectIndex ) {

              objectIndex = i;
              break;

            }

          }

          break;

        default:

          if ( targetObject[ objectName ] === undefined ) {

            console.error( '  can not bind to objectName of node, undefined', this );
            return;

          }

          targetObject = targetObject[ objectName ];

      }


      if ( objectIndex !== undefined ) {

        if( targetObject[ objectIndex ] === undefined ) {

          console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
          return;

        }

        targetObject = targetObject[ objectIndex ];

      }

    }

    // resolve property
    var nodeProperty = targetObject[ propertyName ];

    if ( ! nodeProperty ) {

      var nodeName = parsedPath.nodeName;

      console.error( "  trying to update property for track: " + nodeName +
          '.' + propertyName + " but it wasn't found.", targetObject );
      return;

    }

    // determine versioning scheme
    var versioning = this.Versioning.None;

    if ( targetObject.needsUpdate !== undefined ) { // material

      versioning = this.Versioning.NeedsUpdate;
      this.targetObject = targetObject;

    } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

      versioning = this.Versioning.MatrixWorldNeedsUpdate;
      this.targetObject = targetObject;

    }

    // determine how the property gets bound
    var bindingType = this.BindingType.Direct;

    if ( propertyIndex !== undefined ) {
      // access a sub element of the property array (only primitives are supported right now)

      if ( propertyName === "morphTargetInfluences" ) {
        // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

        // support resolving morphTarget names into indices.
        if ( ! targetObject.geometry ) {

          console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
          return;

        }

        if ( ! targetObject.geometry.morphTargets ) {

          console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
          return;

        }

        for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

          if ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {

            propertyIndex = i;
            break;

          }

        }

      }

      bindingType = this.BindingType.ArrayElement;

      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;

    } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
      // must use copy for Object3D.Euler/Quaternion

      bindingType = this.BindingType.HasFromToArray;

      this.resolvedProperty = nodeProperty;

    } else if ( nodeProperty.length !== undefined ) {

      bindingType = this.BindingType.EntireArray;

      this.resolvedProperty = nodeProperty;

    } else {

      this.propertyName = propertyName;

    }

    // select getter / setter
    this.getValue = this.GetterByBindingType[ bindingType ];
    this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

  },

  unbind: function() {

    this.node = null;

    // back to the prototype version of getValue / setValue
    // note: avoiding to mutate the shape of 'this' via 'delete'
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;

  }

};

Object.assign( THREE.PropertyBinding.prototype, { // prototype, continued

  // these are used to "bind" a nonexistent property
  _getValue_unavailable: function() {},
  _setValue_unavailable: function() {},

  // initial state of these methods that calls 'bind'
  _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
  _setValue_unbound: THREE.PropertyBinding.prototype.setValue,

  BindingType: {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  },

  Versioning: {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  },

  GetterByBindingType: [

    function getValue_direct( buffer, offset ) {

      buffer[ offset ] = this.node[ this.propertyName ];

    },

    function getValue_array( buffer, offset ) {

      var source = this.resolvedProperty;

      for ( var i = 0, n = source.length; i !== n; ++ i ) {

        buffer[ offset ++ ] = source[ i ];

      }

    },

    function getValue_arrayElement( buffer, offset ) {

      buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

    },

    function getValue_toArray( buffer, offset ) {

      this.resolvedProperty.toArray( buffer, offset );

    }

  ],

  SetterByBindingTypeAndVersioning: [

    [
      // Direct

      function setValue_direct( buffer, offset ) {

        this.node[ this.propertyName ] = buffer[ offset ];

      },

      function setValue_direct_setNeedsUpdate( buffer, offset ) {

        this.node[ this.propertyName ] = buffer[ offset ];
        this.targetObject.needsUpdate = true;

      },

      function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

        this.node[ this.propertyName ] = buffer[ offset ];
        this.targetObject.matrixWorldNeedsUpdate = true;

      }

    ], [

      // EntireArray

      function setValue_array( buffer, offset ) {

        var dest = this.resolvedProperty;

        for ( var i = 0, n = dest.length; i !== n; ++ i ) {

          dest[ i ] = buffer[ offset ++ ];

        }

      },

      function setValue_array_setNeedsUpdate( buffer, offset ) {

        var dest = this.resolvedProperty;

        for ( var i = 0, n = dest.length; i !== n; ++ i ) {

          dest[ i ] = buffer[ offset ++ ];

        }

        this.targetObject.needsUpdate = true;

      },

      function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

        var dest = this.resolvedProperty;

        for ( var i = 0, n = dest.length; i !== n; ++ i ) {

          dest[ i ] = buffer[ offset ++ ];

        }

        this.targetObject.matrixWorldNeedsUpdate = true;

      }

    ], [

      // ArrayElement

      function setValue_arrayElement( buffer, offset ) {

        this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

      },

      function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

        this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
        this.targetObject.needsUpdate = true;

      },

      function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

        this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
        this.targetObject.matrixWorldNeedsUpdate = true;

      }

    ], [

      // HasToFromArray

      function setValue_fromArray( buffer, offset ) {

        this.resolvedProperty.fromArray( buffer, offset );

      },

      function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

        this.resolvedProperty.fromArray( buffer, offset );
        this.targetObject.needsUpdate = true;

      },

      function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

        this.resolvedProperty.fromArray( buffer, offset );
        this.targetObject.matrixWorldNeedsUpdate = true;

      }

    ]

  ]

} );

THREE.PropertyBinding.Composite =
    function( targetGroup, path, optionalParsedPath ) {

  var parsedPath = optionalParsedPath ||
      THREE.PropertyBinding.parseTrackName( path );

  this._targetGroup = targetGroup;
  this._bindings = targetGroup.subscribe_( path, parsedPath );

};

THREE.PropertyBinding.Composite.prototype = {

  constructor: THREE.PropertyBinding.Composite,

  getValue: function( array, offset ) {

    this.bind(); // bind all binding

    var firstValidIndex = this._targetGroup.nCachedObjects_,
      binding = this._bindings[ firstValidIndex ];

    // and only call .getValue on the first
    if ( binding !== undefined ) binding.getValue( array, offset );

  },

  setValue: function( array, offset ) {

    var bindings = this._bindings;

    for ( var i = this._targetGroup.nCachedObjects_,
        n = bindings.length; i !== n; ++ i ) {

      bindings[ i ].setValue( array, offset );

    }

  },

  bind: function() {

    var bindings = this._bindings;

    for ( var i = this._targetGroup.nCachedObjects_,
        n = bindings.length; i !== n; ++ i ) {

      bindings[ i ].bind();

    }

  },

  unbind: function() {

    var bindings = this._bindings;

    for ( var i = this._targetGroup.nCachedObjects_,
        n = bindings.length; i !== n; ++ i ) {

      bindings[ i ].unbind();

    }

  }

};

THREE.PropertyBinding.create = function( root, path, parsedPath ) {

  if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {

    return new THREE.PropertyBinding( root, path, parsedPath );

  } else {

    return new THREE.PropertyBinding.Composite( root, path, parsedPath );

  }

};

THREE.PropertyBinding.parseTrackName = function( trackName ) {

  // matches strings in the form of:
  //    nodeName.property
  //    nodeName.property[accessor]
  //    nodeName.material.property[accessor]
  //    uuid.property[accessor]
  //    uuid.objectName[objectIndex].propertyName[propertyIndex]
  //    parentName/nodeName.property
  //    parentName/parentName/nodeName.property[index]
  //    .bone[Armature.DEF_cog].position
  // created and tested via https://regex101.com/#javascript

  var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_. ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
  var matches = re.exec(trackName);

  if( ! matches ) {
    throw new Error( "cannot parse trackName at all: " + trackName );
  }

    if (matches.index === re.lastIndex) {
        re.lastIndex++;
    }

  var results = {
    // directoryName: matches[1], // (tschw) currently unused
    nodeName: matches[3],   // allowed to be null, specified root node.
    objectName: matches[5],
    objectIndex: matches[7],
    propertyName: matches[9],
    propertyIndex: matches[11]  // allowed to be null, specifies that the whole property is set.
  };

  if( results.propertyName === null || results.propertyName.length === 0 ) {
    throw new Error( "can not parse propertyName from trackName: " + trackName );
  }

  return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

  if( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

    return root;

  }

  // search into skeleton bones.
  if( root.skeleton ) {

    var searchSkeleton = function( skeleton ) {

      for( var i = 0; i < skeleton.bones.length; i ++ ) {

        var bone = skeleton.bones[i];

        if( bone.name === nodeName ) {

          return bone;

        }
      }

      return null;

    };

    var bone = searchSkeleton( root.skeleton );

    if( bone ) {

      return bone;

    }
  }

  // search into node subtree.
  if( root.children ) {

    var searchNodeSubtree = function( children ) {

      for( var i = 0; i < children.length; i ++ ) {

        var childNode = children[i];

        if( childNode.name === nodeName || childNode.uuid === nodeName ) {

          return childNode;

        }

        var result = searchNodeSubtree( childNode.children );

        if( result ) return result;

      }

      return null;

    };

    var subTreeNode = searchNodeSubtree( root.children );

    if( subTreeNode ) {

      return subTreeNode;

    }

  }

  return null;

}

// File:src/animation/PropertyMixer.js

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.PropertyMixer = function ( binding, typeName, valueSize ) {

  this.binding = binding;
  this.valueSize = valueSize;

  var bufferType = Float64Array,
    mixFunction;

  switch ( typeName ) {

    case 'quaternion':      mixFunction = this._slerp;    break;

    case 'string':
    case 'bool':

      bufferType = Array,   mixFunction = this._select;   break;

    default:          mixFunction = this._lerp;

  }

  this.buffer = new bufferType( valueSize * 4 );
  // layout: [ incoming | accu0 | accu1 | orig ]
  //
  // interpolators can use .buffer as their .result
  // the data then goes to 'incoming'
  //
  // 'accu0' and 'accu1' are used frame-interleaved for
  // the cumulative result and are compared to detect
  // changes
  //
  // 'orig' stores the original state of the property

  this._mixBufferRegion = mixFunction;

  this.cumulativeWeight = 0;

  this.useCount = 0;
  this.referenceCount = 0;

};

THREE.PropertyMixer.prototype = {

  constructor: THREE.PropertyMixer,

  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate: function( accuIndex, weight ) {

    // note: happily accumulating nothing when weight = 0, the caller knows
    // the weight and shouldn't have made the call in the first place

    var buffer = this.buffer,
      stride = this.valueSize,
      offset = accuIndex * stride + stride,

      currentWeight = this.cumulativeWeight;

    if ( currentWeight === 0 ) {

      // accuN := incoming * weight

      for ( var i = 0; i !== stride; ++ i ) {

        buffer[ offset + i ] = buffer[ i ];

      }

      currentWeight = weight;

    } else {

      // accuN := accuN + incoming * weight

      currentWeight += weight;
      var mix = weight / currentWeight;
      this._mixBufferRegion( buffer, offset, 0, mix, stride );

    }

    this.cumulativeWeight = currentWeight;

  },

  // apply the state of 'accu<i>' to the binding when accus differ
  apply: function( accuIndex ) {

    var stride = this.valueSize,
      buffer = this.buffer,
      offset = accuIndex * stride + stride,

      weight = this.cumulativeWeight,

      binding = this.binding;

    this.cumulativeWeight = 0;

    if ( weight < 1 ) {

      // accuN := accuN + original * ( 1 - cumulativeWeight )

      var originalValueOffset = stride * 3;

      this._mixBufferRegion(
          buffer, offset, originalValueOffset, 1 - weight, stride );

    }

    for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

      if ( buffer[ i ] !== buffer[ i + stride ] ) {

        // value has changed -> update scene graph

        binding.setValue( buffer, offset );
        break;

      }

    }

  },

  // remember the state of the bound property and copy it to both accus
  saveOriginalState: function() {

    var binding = this.binding;

    var buffer = this.buffer,
      stride = this.valueSize,

      originalValueOffset = stride * 3;

    binding.getValue( buffer, originalValueOffset );

    // accu[0..1] := orig -- initially detect changes against the original
    for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

      buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

    }

    this.cumulativeWeight = 0;

  },

  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState: function() {

    var originalValueOffset = this.valueSize * 3;
    this.binding.setValue( this.buffer, originalValueOffset );

  },


  // mix functions

  _select: function( buffer, dstOffset, srcOffset, t, stride ) {

    if ( t >= 0.5 ) {

      for ( var i = 0; i !== stride; ++ i ) {

        buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

      }

    }

  },

  _slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    THREE.Quaternion.slerpFlat( buffer, dstOffset,
        buffer, dstOffset, buffer, srcOffset, t );

  },

  _lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    var s = 1 - t;

    for ( var i = 0; i !== stride; ++ i ) {

      var j = dstOffset + i;

      buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

    }

  }

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.BooleanKeyframeTrack = function ( name, times, values ) {

  THREE.KeyframeTrack.call( this, name, times, values );

};

THREE.BooleanKeyframeTrack.prototype =
    Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

  constructor: THREE.BooleanKeyframeTrack,

  ValueTypeName: 'bool',
  ValueBufferType: Array,

  DefaultInterpolation: THREE.IntepolateDiscrete,

  InterpolantFactoryMethodLinear: undefined,
  InterpolantFactoryMethodSmooth: undefined

  // Note: Actually this track could have a optimized / compressed
  // representation of a single value and a custom interpolant that
  // computes "firstValue ^ isOdd( index )".

} );

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {

  THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.NumberKeyframeTrack.prototype =
    Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

  constructor: THREE.NumberKeyframeTrack,

  ValueTypeName: 'number',

  // ValueBufferType is inherited

  // DefaultInterpolation is inherited

} );

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {

  THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.QuaternionKeyframeTrack.prototype =
    Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

  constructor: THREE.QuaternionKeyframeTrack,

  ValueTypeName: 'quaternion',

  // ValueBufferType is inherited

  DefaultInterpolation: THREE.InterpolateLinear,

  InterpolantFactoryMethodLinear: function( result ) {

    return new THREE.QuaternionLinearInterpolant(
        this.times, this.values, this.getValueSize(), result );

  },

  InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {

  THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.StringKeyframeTrack.prototype =
    Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

  constructor: THREE.StringKeyframeTrack,

  ValueTypeName: 'string',
  ValueBufferType: Array,

  DefaultInterpolation: THREE.IntepolateDiscrete,

  InterpolantFactoryMethodLinear: undefined,

  InterpolantFactoryMethodSmooth: undefined

} );

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {

  THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.VectorKeyframeTrack.prototype =
    Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

  constructor: THREE.VectorKeyframeTrack,

  ValueTypeName: 'vector'

  // ValueBufferType is inherited

  // DefaultInterpolation is inherited

} );

// File:src/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

  THREE.Object3D.call( this );

  this.type = 'Audio';

  this.context = listener.context;
  this.source = this.context.createBufferSource();
  this.source.onended = this.onEnded.bind( this );

  this.gain = this.context.createGain();
  this.gain.connect( listener.getInput() );

  this.autoplay = false;

  this.startTime = 0;
  this.playbackRate = 1;
  this.isPlaying = false;
  this.hasPlaybackControl = true;
  this.sourceType = 'empty';

  this.filter = null;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.getOutput = function () {

  return this.gain;

};

THREE.Audio.prototype.load = function ( file ) {

  var buffer = new THREE.AudioBuffer( this.context );
  buffer.load( file );

  this.setBuffer( buffer );

  return this;

};

THREE.Audio.prototype.setNodeSource = function ( audioNode ) {

  this.hasPlaybackControl = false;
  this.sourceType = 'audioNode';
  this.source = audioNode;
  this.connect();

  return this;

};

THREE.Audio.prototype.setBuffer = function ( audioBuffer ) {

  var scope = this;

  audioBuffer.onReady( function( buffer ) {

    scope.source.buffer = buffer;
    scope.sourceType = 'buffer';
    if ( scope.autoplay ) scope.play();

  } );

  return this;

};

THREE.Audio.prototype.play = function () {

  if ( this.isPlaying === true ) {

    console.warn( 'THREE.Audio: Audio is already playing.' );
    return;

  }

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return;

  }

  var source = this.context.createBufferSource();

  source.buffer = this.source.buffer;
  source.loop = this.source.loop;
  source.onended = this.source.onended;
  source.start( 0, this.startTime );
  source.playbackRate.value = this.playbackRate;

  this.isPlaying = true;

  this.source = source;

  this.connect();

};

THREE.Audio.prototype.pause = function () {

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return;

  }

  this.source.stop();
  this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return;

  }

  this.source.stop();
  this.startTime = 0;

};

THREE.Audio.prototype.connect = function () {

  if ( this.filter !== null ) {

    this.source.connect( this.filter );
    this.filter.connect( this.getOutput() );

  } else {

    this.source.connect( this.getOutput() );

  }

};

THREE.Audio.prototype.disconnect = function () {

  if ( this.filter !== null ) {

    this.source.disconnect( this.filter );
    this.filter.disconnect( this.getOutput() );

  } else {

    this.source.disconnect( this.getOutput() );

  }

};

THREE.Audio.prototype.getFilter = function () {

  return this.filter;

};

THREE.Audio.prototype.setFilter = function ( value ) {

  if ( value === undefined ) value = null;

  if ( this.isPlaying === true ) {

    this.disconnect();
    this.filter = value;
    this.connect();

  } else {

    this.filter = value;

  }

};

THREE.Audio.prototype.setPlaybackRate = function ( value ) {

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return;

  }

  this.playbackRate = value;

  if ( this.isPlaying === true ) {

    this.source.playbackRate.value = this.playbackRate;

  }

};

THREE.Audio.prototype.getPlaybackRate = function () {

  return this.playbackRate;

};

THREE.Audio.prototype.onEnded = function() {

  this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return;

  }

  this.source.loop = value;

};

THREE.Audio.prototype.getLoop = function () {

  if ( this.hasPlaybackControl === false ) {

    console.warn( 'THREE.Audio: this Audio has no playback control.' );
    return false;

  }

  return this.source.loop;

};


THREE.Audio.prototype.setVolume = function ( value ) {

  this.gain.gain.value = value;

};

THREE.Audio.prototype.getVolume = function () {

  return this.gain.gain.value;

};

// File:src/audio/AudioAnalyser.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioAnalyser = function ( audio, fftSize ) {

  this.analyser = audio.context.createAnalyser();
  this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

  this.data = new Uint8Array( this.analyser.frequencyBinCount );

  audio.getOutput().connect( this.analyser );

};

THREE.AudioAnalyser.prototype = {

  constructor: THREE.AudioAnalyser,

  getData: function () {

    this.analyser.getByteFrequencyData( this.data );
    return this.data;

  }

};

// File:src/audio/AudioBuffer.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioBuffer = function ( context ) {

  this.context = context;
  this.ready = false;
  this.readyCallbacks = [];

};

THREE.AudioBuffer.prototype.load = function ( file ) {

  var scope = this;

  var request = new XMLHttpRequest();
  request.open( 'GET', file, true );
  request.responseType = 'arraybuffer';
  request.onload = function ( e ) {

    scope.context.decodeAudioData( this.response, function ( buffer ) {

      scope.buffer = buffer;
      scope.ready = true;

      for ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {

        scope.readyCallbacks[ i ]( scope.buffer );

      }

      scope.readyCallbacks = [];

    } );

  };
  request.send();

  return this;

};

THREE.AudioBuffer.prototype.onReady = function ( callback ) {

  if ( this.ready ) {

    callback( this.buffer );

  } else {

    this.readyCallbacks.push( callback );

  }

};

// File:src/audio/PositionalAudio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PositionalAudio = function ( listener ) {

  THREE.Audio.call( this, listener );

  this.panner = this.context.createPanner();
  this.panner.connect( this.gain );

};

THREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );
THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;

THREE.PositionalAudio.prototype.getOutput = function () {

  return this.panner;

};

THREE.PositionalAudio.prototype.setRefDistance = function ( value ) {

  this.panner.refDistance = value;

};

THREE.PositionalAudio.prototype.getRefDistance = function () {

  return this.panner.refDistance;

};

THREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {

  this.panner.rolloffFactor = value;

};

THREE.PositionalAudio.prototype.getRolloffFactor = function () {

  return this.panner.rolloffFactor;

};

THREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {

  this.panner.distanceModel = value;

};

THREE.PositionalAudio.prototype.getDistanceModel = function () {

  return this.panner.distanceModel;

};

THREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {

  this.panner.maxDistance = value;

};

THREE.PositionalAudio.prototype.getMaxDistance = function () {

  return this.panner.maxDistance;

};

THREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();

  return function updateMatrixWorld( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    position.setFromMatrixPosition( this.matrixWorld );

    this.panner.setPosition( position.x, position.y, position.z );

  };

} )();

// File:src/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

  THREE.Object3D.call( this );

  this.type = 'AudioListener';

  this.context = new ( window.AudioContext || window.webkitAudioContext )();

  this.gain = this.context.createGain();
  this.gain.connect( this.context.destination );

  this.filter = null;

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.getInput = function () {

  return this.gain;

};

THREE.AudioListener.prototype.removeFilter = function ( ) {

  if ( this.filter !== null ) {

    this.gain.disconnect( this.filter );
    this.filter.disconnect( this.context.destination );
    this.gain.connect( this.context.destination );
    this.filter = null;

  }

};

THREE.AudioListener.prototype.setFilter = function ( value ) {

  if ( this.filter !== null ) {

    this.gain.disconnect( this.filter );
    this.filter.disconnect( this.context.destination );

  } else {

    this.gain.disconnect( this.context.destination );

  }

  this.filter = value;
  this.gain.connect( this.filter );
  this.filter.connect( this.context.destination );

};

THREE.AudioListener.prototype.getFilter = function () {

  return this.filter;

};

THREE.AudioListener.prototype.setMasterVolume = function ( value ) {

  this.gain.gain.value = value;

};

THREE.AudioListener.prototype.getMasterVolume = function () {

  return this.gain.gain.value;

};


THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3();

  var orientation = new THREE.Vector3();

  return function updateMatrixWorld( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var listener = this.context.listener;
    var up = this.up;

    this.matrixWorld.decompose( position, quaternion, scale );

    orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    listener.setPosition( position.x, position.y, position.z );
    listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  };

} )();

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

  THREE.Object3D.call( this );

  this.type = 'Camera';

  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

  var quaternion = new THREE.Quaternion();

  return function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.getWorldQuaternion( quaternion );

    return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  };

}();

THREE.Camera.prototype.lookAt = function () {

  // This routine does not support cameras with rotated and/or translated parent(s)

  var m1 = new THREE.Matrix4();

  return function ( vector ) {

    m1.lookAt( this.position, vector, this.up );

    this.quaternion.setFromRotationMatrix( m1 );

  };

}();

THREE.Camera.prototype.clone = function () {

  return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.matrixWorldInverse.copy( source.matrixWorldInverse );
  this.projectionMatrix.copy( source.projectionMatrix );

  return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

  THREE.Object3D.call( this );

  this.type = 'CubeCamera';

  var fov = 90, aspect = 1;

  var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPX.up.set( 0, - 1, 0 );
  cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
  this.add( cameraPX );

  var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNX.up.set( 0, - 1, 0 );
  cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
  this.add( cameraNX );

  var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPY.up.set( 0, 0, 1 );
  cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
  this.add( cameraPY );

  var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNY.up.set( 0, 0, - 1 );
  cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
  this.add( cameraNY );

  var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPZ.up.set( 0, - 1, 0 );
  cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
  this.add( cameraPZ );

  var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNZ.up.set( 0, - 1, 0 );
  cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
  this.add( cameraNZ );

  var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };

  this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

  this.updateCubeMap = function ( renderer, scene ) {

    if ( this.parent === null ) this.updateMatrixWorld();

    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.texture.generateMipmaps;

    renderTarget.texture.generateMipmaps = false;

    renderTarget.activeCubeFace = 0;
    renderer.render( scene, cameraPX, renderTarget );

    renderTarget.activeCubeFace = 1;
    renderer.render( scene, cameraNX, renderTarget );

    renderTarget.activeCubeFace = 2;
    renderer.render( scene, cameraPY, renderTarget );

    renderTarget.activeCubeFace = 3;
    renderer.render( scene, cameraNY, renderTarget );

    renderTarget.activeCubeFace = 4;
    renderer.render( scene, cameraPZ, renderTarget );

    renderTarget.texture.generateMipmaps = generateMipmaps;

    renderTarget.activeCubeFace = 5;
    renderer.render( scene, cameraNZ, renderTarget );

    renderer.setRenderTarget( null );

  };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

  THREE.Camera.call( this );

  this.type = 'OrthographicCamera';

  this.zoom = 1;

  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;

  this.near = ( near !== undefined ) ? near : 0.1;
  this.far = ( far !== undefined ) ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

  var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  var cx = ( this.right + this.left ) / 2;
  var cy = ( this.top + this.bottom ) / 2;

  this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.copy = function ( source ) {

  THREE.Camera.prototype.copy.call( this, source );

  this.left = source.left;
  this.right = source.right;
  this.top = source.top;
  this.bottom = source.bottom;
  this.near = source.near;
  this.far = source.far;

  this.zoom = source.zoom;

  return this;

};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.zoom = this.zoom;
  data.object.left = this.left;
  data.object.right = this.right;
  data.object.top = this.top;
  data.object.bottom = this.bottom;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

  THREE.Camera.call( this );

  this.type = 'PerspectiveCamera';

  this.zoom = 1;

  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (full-frame) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

  if ( frameHeight === undefined ) frameHeight = 24;

  this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
  this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;

  this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

  var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

  if ( this.fullWidth ) {

    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
    var bottom = - top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs( right - left );
    var height = Math.abs( top - bottom );

    this.projectionMatrix.makeFrustum(
      left + this.x * width / this.fullWidth,
      left + ( this.x + this.width ) * width / this.fullWidth,
      top - ( this.y + this.height ) * height / this.fullHeight,
      top - this.y * height / this.fullHeight,
      this.near,
      this.far
    );

  } else {

    this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

  }

};

THREE.PerspectiveCamera.prototype.copy = function ( source ) {

  THREE.Camera.prototype.copy.call( this, source );

  this.fov = source.fov;
  this.aspect = source.aspect;
  this.near = source.near;
  this.far = source.far;

  this.zoom = source.zoom;

  return this;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.zoom = this.zoom;
  data.object.fov = this.fov;
  data.object.aspect = this.aspect;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/cameras/StereoCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.StereoCamera = function ( fov, aspect, near, far ) {

  THREE.PerspectiveCamera.call( this, fov, aspect, near, far );

  this.type = 'StereoCamera';

  this.focalLength = 125;

  this.cameraL = new THREE.PerspectiveCamera();
  this.cameraL.layers.enable( 1 );
  this.cameraL.matrixAutoUpdate = false;

  this.cameraR = new THREE.PerspectiveCamera();
  this.cameraR.layers.enable( 2 );
  this.cameraR.matrixAutoUpdate = false;

};

THREE.StereoCamera.prototype = Object.create( THREE.PerspectiveCamera.prototype );
THREE.StereoCamera.prototype.constructor = THREE.StereoCamera;

THREE.StereoCamera.prototype.updateMatrixWorld = ( function () {

  var focalLength, fov, aspect, near, far;

  var eyeRight = new THREE.Matrix4();
  var eyeLeft = new THREE.Matrix4();

  return function updateMatrixWorld ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var needsUpdate = focalLength !== this.focalLength || fov !== this.fov ||
                      aspect !== this.aspect || near !== this.near ||
                      far !== this.far;

    if ( needsUpdate ) {

      focalLength = this.focalLength;
      fov = this.fov;
      aspect = this.aspect;
      near = this.near;
      far = this.far;

      // Off-axis stereoscopic effect based on
      // http://paulbourke.net/stereographics/stereorender/

      var projectionMatrix = this.projectionMatrix.clone();
      var eyeSep = focalLength / 30 * 0.5;
      var eyeSepOnProjection = eyeSep * near / focalLength;
      var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
      var xmin, xmax;

      // translate xOffset

      eyeLeft.elements[ 12 ] = - eyeSep;
      eyeRight.elements[ 12 ] = eyeSep;

      // for left eye

      xmin = - ymax * aspect + eyeSepOnProjection;
      xmax = ymax * aspect + eyeSepOnProjection;

      projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
      projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

      this.cameraL.projectionMatrix.copy( projectionMatrix );

      // for right eye

      xmin = - ymax * aspect - eyeSepOnProjection;
      xmax = ymax * aspect - eyeSepOnProjection;

      projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
      projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

      this.cameraR.projectionMatrix.copy( projectionMatrix );

    }

    this.cameraL.matrixWorld.copy( this.matrixWorld ).multiply( eyeLeft );
    this.cameraR.matrixWorld.copy( this.matrixWorld ).multiply( eyeRight );

  };

} )();

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color, intensity ) {

  THREE.Object3D.call( this );

  this.type = 'Light';

  this.color = new THREE.Color( color );
  this.intensity = intensity !== undefined ? intensity : 1;

  this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.intensity = source.intensity;

  return this;

};

THREE.Light.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;

  if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

  if ( this.distance !== undefined ) data.object.distance = this.distance;
  if ( this.angle !== undefined ) data.object.angle = this.angle;
  if ( this.decay !== undefined ) data.object.decay = this.decay;
  if ( this.exponent !== undefined ) data.object.exponent = this.exponent;

  return data;

};

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

  this.camera = camera;

  this.bias = 0;
  this.darkness = 1;

  this.mapSize = new THREE.Vector2( 512, 512 );

  this.map = null;
  this.matrix = null;

};

THREE.LightShadow.prototype = {

  constructor: THREE.LightShadow,

  copy: function ( source ) {

    this.camera = source.camera.clone();

    this.bias = source.bias;
    this.darkness = source.darkness;

    this.mapSize.copy( source.mapSize );

    return this;

  },

  clone: function () {

    return new this.constructor().copy( this );

  }

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color, intensity ) {

  THREE.Light.call( this, color, intensity );

  this.type = 'AmbientLight';

  this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

  THREE.Light.call( this, color, intensity );

  this.type = 'DirectionalLight';

  this.position.set( 0, 1, 0 );
  this.updateMatrix();

  this.target = new THREE.Object3D();

  this.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.target = source.target.clone();

  this.shadow = source.shadow.clone();

  return this;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

  THREE.Light.call( this, skyColor, intensity );

  this.type = 'HemisphereLight';

  this.castShadow = undefined;

  this.position.set( 0, 1, 0 );
  this.updateMatrix();

  this.groundColor = new THREE.Color( groundColor );

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.groundColor.copy( source.groundColor );

  return this;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

  THREE.Light.call( this, color, intensity );

  this.type = 'PointLight';

  this.distance = ( distance !== undefined ) ? distance : 0;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.distance = source.distance;
  this.decay = source.decay;

  this.shadow = source.shadow.clone();

  return this;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

  THREE.Light.call( this, color, intensity );

  this.type = 'SpotLight';

  this.position.set( 0, 1, 0 );
  this.updateMatrix();

  this.target = new THREE.Object3D();

  this.distance = ( distance !== undefined ) ? distance : 0;
  this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  this.exponent = ( exponent !== undefined ) ? exponent : 10;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

  this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.copy = function ( source ) {

  THREE.Light.prototype.copy.call( this, source );

  this.distance = source.distance;
  this.angle = source.angle;
  this.exponent = source.exponent;
  this.decay = source.decay;

  this.target = source.target.clone();

  this.shadow = source.shadow.clone();

  return this;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

  enabled: false,

  files: {},

  add: function ( key, file ) {

    if ( this.enabled === false ) return;

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[ key ] = file;

  },

  get: function ( key ) {

    if ( this.enabled === false ) return;

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[ key ];

  },

  remove: function ( key ) {

    delete this.files[ key ];

  },

  clear: function () {

    this.files = {};

  }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

  this.onLoadStart = function () {};
  this.onLoadProgress = function () {};
  this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

  constructor: THREE.Loader,

  crossOrigin: undefined,

  extractUrlBase: function ( url ) {

    var parts = url.split( '/' );

    if ( parts.length === 1 ) return './';

    parts.pop();

    return parts.join( '/' ) + '/';

  },

  initMaterials: function ( materials, texturePath, crossOrigin ) {

    var array = [];

    for ( var i = 0; i < materials.length; ++ i ) {

      array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    }

    return array;

  },

  createMaterial: ( function () {

    var color, textureLoader, materialLoader;

    return function ( m, texturePath, crossOrigin ) {

      if ( color === undefined ) color = new THREE.Color();
      if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
      if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

      // convert from old material format

      var textures = {};

      function loadTexture( path, repeat, offset, wrap, anisotropy ) {

        var fullPath = texturePath + path;
        var loader = THREE.Loader.Handlers.get( fullPath );

        var texture;

        if ( loader !== null ) {

          texture = loader.load( fullPath );

        } else {

          textureLoader.setCrossOrigin( crossOrigin );
          texture = textureLoader.load( fullPath );

        }

        if ( repeat !== undefined ) {

          texture.repeat.fromArray( repeat );

          if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
          if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

        }

        if ( offset !== undefined ) {

          texture.offset.fromArray( offset );

        }

        if ( wrap !== undefined ) {

          if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
          if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

          if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
          if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

        }

        if ( anisotropy !== undefined ) {

          texture.anisotropy = anisotropy;

        }

        var uuid = THREE.Math.generateUUID();

        textures[ uuid ] = texture;

        return uuid;

      }

      //

      var json = {
        uuid: THREE.Math.generateUUID(),
        type: 'MeshLambertMaterial'
      };

      for ( var name in m ) {

        var value = m[ name ];

        switch ( name ) {
          case 'DbgColor':
          case 'DbgIndex':
          case 'opticalDensity':
          case 'illumination':
            break;
          case 'DbgName':
            json.name = value;
            break;
          case 'blending':
            json.blending = THREE[ value ];
            break;
          case 'colorAmbient':
            console.warn( 'THREE.Loader.createMaterial: colorAmbient is no longer supported' );
            break;
          case 'colorDiffuse':
            json.color = color.fromArray( value ).getHex();
            break;
          case 'colorSpecular':
            json.specular = color.fromArray( value ).getHex();
            break;
          case 'colorEmissive':
            json.emissive = color.fromArray( value ).getHex();
            break;
          case 'specularCoef':
            json.shininess = value;
            break;
          case 'shading':
            if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
            if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
            break;
          case 'mapDiffuse':
            json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
            break;
          case 'mapDiffuseRepeat':
          case 'mapDiffuseOffset':
          case 'mapDiffuseWrap':
          case 'mapDiffuseAnisotropy':
            break;
          case 'mapLight':
            json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
            break;
          case 'mapLightRepeat':
          case 'mapLightOffset':
          case 'mapLightWrap':
          case 'mapLightAnisotropy':
            break;
          case 'mapAO':
            json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
            break;
          case 'mapAORepeat':
          case 'mapAOOffset':
          case 'mapAOWrap':
          case 'mapAOAnisotropy':
            break;
          case 'mapBump':
            json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
            break;
          case 'mapBumpScale':
            json.bumpScale = value;
            break;
          case 'mapBumpRepeat':
          case 'mapBumpOffset':
          case 'mapBumpWrap':
          case 'mapBumpAnisotropy':
            break;
          case 'mapNormal':
            json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
            break;
          case 'mapNormalFactor':
            json.normalScale = [ value, value ];
            break;
          case 'mapNormalRepeat':
          case 'mapNormalOffset':
          case 'mapNormalWrap':
          case 'mapNormalAnisotropy':
            break;
          case 'mapSpecular':
            json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
            break;
          case 'mapSpecularRepeat':
          case 'mapSpecularOffset':
          case 'mapSpecularWrap':
          case 'mapSpecularAnisotropy':
            break;
          case 'mapAlpha':
            json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
            break;
          case 'mapAlphaRepeat':
          case 'mapAlphaOffset':
          case 'mapAlphaWrap':
          case 'mapAlphaAnisotropy':
            break;
          case 'flipSided':
            json.side = THREE.BackSide;
            break;
          case 'doubleSided':
            json.side = THREE.DoubleSide;
            break;
          case 'transparency':
            console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
            json.opacity = value;
            break;
          case 'depthTest':
          case 'depthWrite':
          case 'colorWrite':
          case 'opacity':
          case 'reflectivity':
          case 'transparent':
          case 'visible':
          case 'wireframe':
            json[ name ] = value;
            break;
          case 'vertexColors':
            if ( value === true ) json.vertexColors = THREE.VertexColors;
            if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
            break;
          default:
            console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
            break;
        }

      }

      if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
      if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

      if ( json.opacity < 1 ) json.transparent = true;

      materialLoader.setTextures( textures );

      return materialLoader.parse( json );

    };

  } )()

};

THREE.Loader.Handlers = {

  handlers: [],

  add: function ( regex, loader ) {

    this.handlers.push( regex, loader );

  },

  get: function ( file ) {

    var handlers = this.handlers;

    for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

      var regex = handlers[ i ];
      var loader  = handlers[ i + 1 ];

      if ( regex.test( file ) ) {

        return loader;

      }

    }

    return null;

  }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

  constructor: THREE.XHRLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.path !== undefined ) url = this.path + url;

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) {

        setTimeout( function () {

          onLoad( cached );

        }, 0 );

      }

      return cached;

    }

    var request = new XMLHttpRequest();
    request.overrideMimeType( 'text/plain' );
    request.open( 'GET', url, true );

    request.addEventListener( 'load', function ( event ) {

      var response = event.target.response;

      THREE.Cache.add( url, response );

      if ( this.status === 200 ) {

        if ( onLoad ) onLoad( response );

        scope.manager.itemEnd( url );

      } else if ( this.status === 0 ) {

        // Some browsers return HTTP Status 0 when using non-http protocol
        // e.g. 'file://' or 'data://'. Handle as success.

        console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

        if ( onLoad ) onLoad( response );

        scope.manager.itemEnd( url );

      } else {

        if ( onError ) onError( event );

        scope.manager.itemError( url );

      }

    }, false );

    if ( onProgress !== undefined ) {

      request.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    request.addEventListener( 'error', function ( event ) {

      if ( onError ) onError( event );

      scope.manager.itemError( url );

    }, false );

    if ( this.responseType !== undefined ) request.responseType = this.responseType;
    if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    request.send( null );

    scope.manager.itemStart( url );

    return request;

  },

  setPath: function ( value ) {

    this.path = value;

  },

  setResponseType: function ( value ) {

    this.responseType = value;

  },

  setWithCredentials: function ( value ) {

    this.withCredentials = value;

  }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

  constructor: THREE.ImageLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.path !== undefined ) url = this.path + url;

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      scope.manager.itemStart( url );

      if ( onLoad ) {

        setTimeout( function () {

          onLoad( cached );

          scope.manager.itemEnd( url );

        }, 0 );

      } else {

        scope.manager.itemEnd( url );

      }

      return cached;

    }

    var image = document.createElement( 'img' );

    image.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this );

      if ( onLoad ) onLoad( this );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      image.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    image.addEventListener( 'error', function ( event ) {

      if ( onError ) onError( event );

      scope.manager.itemError( url );

    }, false );

    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    scope.manager.itemStart( url );

    image.src = url;

    return image;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setPath: function ( value ) {

    this.path = value;

  }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

  if ( typeof manager === 'boolean' ) {

    console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
    manager = undefined;

  }

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  this.withCredentials = false;

};

THREE.JSONLoader.prototype = {

  constructor: THREE.JSONLoader,

  // Deprecated

  get statusDomElement () {

    if ( this._statusDomElement === undefined ) {

      this._statusDomElement = document.createElement( 'div' );

    }

    console.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );
    return this._statusDomElement;

  },

  load: function( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

    var loader = new THREE.XHRLoader( this.manager );
    loader.setWithCredentials( this.withCredentials );
    loader.load( url, function ( text ) {

      var json = JSON.parse( text );
      var metadata = json.metadata;

      if ( metadata !== undefined ) {

        var type = metadata.type;

        if ( type !== undefined ) {

          if ( type.toLowerCase() === 'object' ) {

            console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
            return;

          }

          if ( type.toLowerCase() === 'scene' ) {

            console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
            return;

          }

        }

      }

      var object = scope.parse( json, texturePath );
      onLoad( object.geometry, object.materials );

    }, onProgress, onError );

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  parse: function ( json, texturePath ) {

    var geometry = new THREE.Geometry(),
    scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    parseModel( scale );

    parseSkin();
    parseMorphing( scale );
    parseAnimations();

    geometry.computeFaceNormals();
    geometry.computeBoundingSphere();

    function parseModel( scale ) {

      function isBitSet( value, position ) {

        return value & ( 1 << position );

      }

      var i, j, fi,

      offset, zLength,

    colorIndex, normalIndex, uvIndex, materialIndex,

      type,
      isQuad,
      hasMaterial,
      hasFaceVertexUv,
      hasFaceNormal, hasFaceVertexNormal,
      hasFaceColor, hasFaceVertexColor,

    vertex, face, faceA, faceB, hex, normal,

      uvLayer, uv, u, v,

      faces = json.faces,
      vertices = json.vertices,
      normals = json.normals,
      colors = json.colors,

      nUvLayers = 0;

      if ( json.uvs !== undefined ) {

        // disregard empty arrays

        for ( i = 0; i < json.uvs.length; i ++ ) {

          if ( json.uvs[ i ].length ) nUvLayers ++;

        }

        for ( i = 0; i < nUvLayers; i ++ ) {

          geometry.faceVertexUvs[ i ] = [];

        }

      }

      offset = 0;
      zLength = vertices.length;

      while ( offset < zLength ) {

        vertex = new THREE.Vector3();

        vertex.x = vertices[ offset ++ ] * scale;
        vertex.y = vertices[ offset ++ ] * scale;
        vertex.z = vertices[ offset ++ ] * scale;

        geometry.vertices.push( vertex );

      }

      offset = 0;
      zLength = faces.length;

      while ( offset < zLength ) {

        type = faces[ offset ++ ];


        isQuad              = isBitSet( type, 0 );
        hasMaterial         = isBitSet( type, 1 );
        hasFaceVertexUv     = isBitSet( type, 3 );
        hasFaceNormal       = isBitSet( type, 4 );
        hasFaceVertexNormal = isBitSet( type, 5 );
        hasFaceColor       = isBitSet( type, 6 );
        hasFaceVertexColor  = isBitSet( type, 7 );

        // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

        if ( isQuad ) {

          faceA = new THREE.Face3();
          faceA.a = faces[ offset ];
          faceA.b = faces[ offset + 1 ];
          faceA.c = faces[ offset + 3 ];

          faceB = new THREE.Face3();
          faceB.a = faces[ offset + 1 ];
          faceB.b = faces[ offset + 2 ];
          faceB.c = faces[ offset + 3 ];

          offset += 4;

          if ( hasMaterial ) {

            materialIndex = faces[ offset ++ ];
            faceA.materialIndex = materialIndex;
            faceB.materialIndex = materialIndex;

          }

          // to get face <=> uv index correspondence

          fi = geometry.faces.length;

          if ( hasFaceVertexUv ) {

            for ( i = 0; i < nUvLayers; i ++ ) {

              uvLayer = json.uvs[ i ];

              geometry.faceVertexUvs[ i ][ fi ] = [];
              geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

              for ( j = 0; j < 4; j ++ ) {

                uvIndex = faces[ offset ++ ];

                u = uvLayer[ uvIndex * 2 ];
                v = uvLayer[ uvIndex * 2 + 1 ];

                uv = new THREE.Vector2( u, v );

                if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

              }

            }

          }

          if ( hasFaceNormal ) {

            normalIndex = faces[ offset ++ ] * 3;

            faceA.normal.set(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

            faceB.normal.copy( faceA.normal );

          }

          if ( hasFaceVertexNormal ) {

            for ( i = 0; i < 4; i ++ ) {

              normalIndex = faces[ offset ++ ] * 3;

              normal = new THREE.Vector3(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );


              if ( i !== 2 ) faceA.vertexNormals.push( normal );
              if ( i !== 0 ) faceB.vertexNormals.push( normal );

            }

          }


          if ( hasFaceColor ) {

            colorIndex = faces[ offset ++ ];
            hex = colors[ colorIndex ];

            faceA.color.setHex( hex );
            faceB.color.setHex( hex );

          }


          if ( hasFaceVertexColor ) {

            for ( i = 0; i < 4; i ++ ) {

              colorIndex = faces[ offset ++ ];
              hex = colors[ colorIndex ];

              if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
              if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

            }

          }

          geometry.faces.push( faceA );
          geometry.faces.push( faceB );

        } else {

          face = new THREE.Face3();
          face.a = faces[ offset ++ ];
          face.b = faces[ offset ++ ];
          face.c = faces[ offset ++ ];

          if ( hasMaterial ) {

            materialIndex = faces[ offset ++ ];
            face.materialIndex = materialIndex;

          }

          // to get face <=> uv index correspondence

          fi = geometry.faces.length;

          if ( hasFaceVertexUv ) {

            for ( i = 0; i < nUvLayers; i ++ ) {

              uvLayer = json.uvs[ i ];

              geometry.faceVertexUvs[ i ][ fi ] = [];

              for ( j = 0; j < 3; j ++ ) {

                uvIndex = faces[ offset ++ ];

                u = uvLayer[ uvIndex * 2 ];
                v = uvLayer[ uvIndex * 2 + 1 ];

                uv = new THREE.Vector2( u, v );

                geometry.faceVertexUvs[ i ][ fi ].push( uv );

              }

            }

          }

          if ( hasFaceNormal ) {

            normalIndex = faces[ offset ++ ] * 3;

            face.normal.set(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

          }

          if ( hasFaceVertexNormal ) {

            for ( i = 0; i < 3; i ++ ) {

              normalIndex = faces[ offset ++ ] * 3;

              normal = new THREE.Vector3(
                normals[ normalIndex ++ ],
                normals[ normalIndex ++ ],
                normals[ normalIndex ]
              );

              face.vertexNormals.push( normal );

            }

          }


          if ( hasFaceColor ) {

            colorIndex = faces[ offset ++ ];
            face.color.setHex( colors[ colorIndex ] );

          }


          if ( hasFaceVertexColor ) {

            for ( i = 0; i < 3; i ++ ) {

              colorIndex = faces[ offset ++ ];
              face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

            }

          }

          geometry.faces.push( face );

        }

      }

    };

    function parseSkin() {

      var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

      if ( json.skinWeights ) {

        for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

          var x =                               json.skinWeights[ i ];
          var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
          var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
          var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

          geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

        }

      }

      if ( json.skinIndices ) {

        for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

          var a =                               json.skinIndices[ i ];
          var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
          var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
          var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

          geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

        }

      }

      geometry.bones = json.bones;

      if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

        console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
          geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

      }

    };

    function parseMorphing( scale ) {

      if ( json.morphTargets !== undefined ) {

        for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

          geometry.morphTargets[ i ] = {};
          geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
          geometry.morphTargets[ i ].vertices = [];

          var dstVertices = geometry.morphTargets[ i ].vertices;
          var srcVertices = json.morphTargets[ i ].vertices;

          for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

            var vertex = new THREE.Vector3();
            vertex.x = srcVertices[ v ] * scale;
            vertex.y = srcVertices[ v + 1 ] * scale;
            vertex.z = srcVertices[ v + 2 ] * scale;

            dstVertices.push( vertex );

          }

        }

      }

      if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

        console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

        var faces = geometry.faces;
        var morphColors = json.morphColors[ 0 ].colors;

        for ( var i = 0, l = faces.length; i < l; i ++ ) {

          faces[ i ].color.fromArray( morphColors, i * 3 );

        }

      }

    }

    function parseAnimations() {

      var outputAnimations = [];

      // parse old style Bone/Hierarchy animations
      var animations = [];

      if ( json.animation !== undefined ) {

        animations.push( json.animation );

      }

      if ( json.animations !== undefined ) {

        if ( json.animations.length ) {

          animations = animations.concat( json.animations );

        } else {

          animations.push( json.animations );

        }

      }

      for ( var i = 0; i < animations.length; i ++ ) {

        var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
        if ( clip ) outputAnimations.push( clip );

      }

      // parse implicit morph animations
      if ( geometry.morphTargets ) {

        // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
        var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
        outputAnimations = outputAnimations.concat( morphAnimationClips );

      }

      if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

    };

    if ( json.materials === undefined || json.materials.length === 0 ) {

      return { geometry: geometry };

    } else {

      var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

      return { geometry: geometry, materials: materials };

    }

  }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

  var scope = this;

  var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

  this.onStart = undefined;
  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function ( url ) {

    itemsTotal ++;

    if ( isLoading === false ) {

      if ( scope.onStart !== undefined ) {

        scope.onStart( url, itemsLoaded, itemsTotal );

      }

    }

    isLoading = true;

  };

  this.itemEnd = function ( url ) {

    itemsLoaded ++;

    if ( scope.onProgress !== undefined ) {

      scope.onProgress( url, itemsLoaded, itemsTotal );

    }

    if ( itemsLoaded === itemsTotal ) {

      isLoading = false;

      if ( scope.onLoad !== undefined ) {

        scope.onLoad();

      }

    }

  };

  this.itemError = function ( url ) {

    if ( scope.onError !== undefined ) {

      scope.onError( url );

    }

  };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

  constructor: THREE.BufferGeometryLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  parse: function ( json ) {

    var geometry = new THREE.BufferGeometry();

    var index = json.data.index;

    if ( index !== undefined ) {

      var typedArray = new self[ index.type ]( index.array );
      geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

    }

    var attributes = json.data.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];
      var typedArray = new self[ attribute.type ]( attribute.array );

      geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

    }

    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    if ( groups !== undefined ) {

      for ( var i = 0, n = groups.length; i !== n; ++ i ) {

        var group = groups[ i ];

        geometry.addGroup( group.start, group.count, group.materialIndex );

      }

    }

    var boundingSphere = json.data.boundingSphere;

    if ( boundingSphere !== undefined ) {

      var center = new THREE.Vector3();

      if ( boundingSphere.center !== undefined ) {

        center.fromArray( boundingSphere.center );

      }

      geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

    }

    return geometry;

  }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.textures = {};

};

THREE.MaterialLoader.prototype = {

  constructor: THREE.MaterialLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setTextures: function ( value ) {

    this.textures = value;

  },

  getTexture: function ( name ) {

    var textures = this.textures;

    if ( textures[ name ] === undefined ) {

      console.warn( 'THREE.MaterialLoader: Undefined texture', name );

    }

    return textures[ name ];

  },

  parse: function ( json ) {

    var material = new THREE[ json.type ];

    if ( json.uuid !== undefined ) material.uuid = json.uuid;
    if ( json.name !== undefined ) material.name = json.name;
    if ( json.color !== undefined ) material.color.setHex( json.color );
    if ( json.roughness !== undefined ) material.roughness = json.roughness;
    if ( json.metalness !== undefined ) material.metalness = json.metalness;
    if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    if ( json.shininess !== undefined ) material.shininess = json.shininess;
    if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    if ( json.shading !== undefined ) material.shading = json.shading;
    if ( json.blending !== undefined ) material.blending = json.blending;
    if ( json.side !== undefined ) material.side = json.side;
    if ( json.opacity !== undefined ) material.opacity = json.opacity;
    if ( json.transparent !== undefined ) material.transparent = json.transparent;
    if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
    if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
    if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

    // for PointsMaterial
    if ( json.size !== undefined ) material.size = json.size;
    if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    // maps

    if ( json.map !== undefined ) material.map = this.getTexture( json.map );

    if ( json.alphaMap !== undefined ) {

      material.alphaMap = this.getTexture( json.alphaMap );
      material.transparent = true;

    }

    if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
    if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

    if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
    if ( json.normalScale !== undefined ) {

      var normalScale = json.normalScale;

      if ( Array.isArray( normalScale ) === false ) {

        // Blender exporter used to export a scalar. See #7459

        normalScale = [ normalScale, normalScale ];

      }

      material.normalScale = new THREE.Vector2().fromArray( normalScale );

    }

    if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
    if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
    if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

    if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
    if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );

    if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
    if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

    if ( json.envMap !== undefined ) {

      material.envMap = this.getTexture( json.envMap );
      material.combine = THREE.MultiplyOperation;

    }

    if ( json.reflectivity ) material.reflectivity = json.reflectivity;

    if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
    if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

    if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
    if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

    // MeshFaceMaterial

    if ( json.materials !== undefined ) {

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        material.materials.push( this.parse( json.materials[ i ] ) );

      }

    }

    return material;

  }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

  constructor: THREE.ObjectLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.texturePath === '' ) {

      this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    }

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.load( url, function ( text ) {

      scope.parse( JSON.parse( text ), onLoad );

    }, onProgress, onError );

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json, onLoad ) {

    var geometries = this.parseGeometries( json.geometries );

    var images = this.parseImages( json.images, function () {

      if ( onLoad !== undefined ) onLoad( object );

    } );

    var textures  = this.parseTextures( json.textures, images );
    var materials = this.parseMaterials( json.materials, textures );

    var object = this.parseObject( json.object, geometries, materials );

    if ( json.animations ) {

      object.animations = this.parseAnimations( json.animations );

    }

    if ( json.images === undefined || json.images.length === 0 ) {

      if ( onLoad !== undefined ) onLoad( object );

    }

    return object;

  },

  parseGeometries: function ( json ) {

    var geometries = {};

    if ( json !== undefined ) {

      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var geometry;
        var data = json[ i ];

        switch ( data.type ) {

          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':

            geometry = new THREE[ data.type ](
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );

            break;

          case 'BoxGeometry':
          case 'CubeGeometry': // backwards compatible

            geometry = new THREE.BoxGeometry(
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );

            break;

          case 'CircleBufferGeometry':

            geometry = new THREE.CircleBufferGeometry(
              data.radius,
              data.segments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'CircleGeometry':

            geometry = new THREE.CircleGeometry(
              data.radius,
              data.segments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'CylinderGeometry':

            geometry = new THREE.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'SphereGeometry':

            geometry = new THREE.SphereGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'SphereBufferGeometry':

            geometry = new THREE.SphereBufferGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'DodecahedronGeometry':

            geometry = new THREE.DodecahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'IcosahedronGeometry':

            geometry = new THREE.IcosahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'OctahedronGeometry':

            geometry = new THREE.OctahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'TetrahedronGeometry':

            geometry = new THREE.TetrahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'RingGeometry':

            geometry = new THREE.RingGeometry(
              data.innerRadius,
              data.outerRadius,
              data.thetaSegments,
              data.phiSegments,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'TorusGeometry':

            geometry = new THREE.TorusGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );

            break;

          case 'TorusKnotGeometry':

            geometry = new THREE.TorusKnotGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.p,
              data.q,
              data.heightScale
            );

            break;

          case 'BufferGeometry':

            geometry = bufferGeometryLoader.parse( data );

            break;

          case 'Geometry':

            geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

            break;

          default:

            console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

            continue;

        }

        geometry.uuid = data.uuid;

        if ( data.name !== undefined ) geometry.name = data.name;

        geometries[ data.uuid ] = geometry;

      }

    }

    return geometries;

  },

  parseMaterials: function ( json, textures ) {

    var materials = {};

    if ( json !== undefined ) {

      var loader = new THREE.MaterialLoader();
      loader.setTextures( textures );

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var material = loader.parse( json[ i ] );
        materials[ material.uuid ] = material;

      }

    }

    return materials;

  },

  parseAnimations: function ( json ) {

    var animations = [];

    for ( var i = 0; i < json.length; i ++ ) {

      var clip = THREE.AnimationClip.parse( json[ i ] );

      animations.push( clip );

    }

    return animations;

  },

  parseImages: function ( json, onLoad ) {

    var scope = this;
    var images = {};

    function loadImage( url ) {

      scope.manager.itemStart( url );

      return loader.load( url, function () {

        scope.manager.itemEnd( url );

      } );

    }

    if ( json !== undefined && json.length > 0 ) {

      var manager = new THREE.LoadingManager( onLoad );

      var loader = new THREE.ImageLoader( manager );
      loader.setCrossOrigin( this.crossOrigin );

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var image = json[ i ];
        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

        images[ image.uuid ] = loadImage( path );

      }

    }

    return images;

  },

  parseTextures: function ( json, images ) {

    function parseConstant( value ) {

      if ( typeof( value ) === 'number' ) return value;

      console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

      return THREE[ value ];

    }

    var textures = {};

    if ( json !== undefined ) {

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];

        if ( data.image === undefined ) {

          console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

        }

        if ( images[ data.image ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

        }

        var texture = new THREE.Texture( images[ data.image ] );
        texture.needsUpdate = true;

        texture.uuid = data.uuid;

        if ( data.name !== undefined ) texture.name = data.name;
        if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
        if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
        if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
        if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
        if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
        if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
        if ( Array.isArray( data.wrap ) ) {

          texture.wrapS = parseConstant( data.wrap[ 0 ] );
          texture.wrapT = parseConstant( data.wrap[ 1 ] );

        }

        textures[ data.uuid ] = texture;

      }

    }

    return textures;

  },

  parseObject: function () {

    var matrix = new THREE.Matrix4();

    return function ( data, geometries, materials ) {

      var object;

      function getGeometry( name ) {

        if ( geometries[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

        }

        return geometries[ name ];

      }

      function getMaterial( name ) {

        if ( name === undefined ) return undefined;

        if ( materials[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined material', name );

        }

        return materials[ name ];

      }

      switch ( data.type ) {

        case 'Scene':

          object = new THREE.Scene();

          break;

        case 'PerspectiveCamera':

          object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

          break;

        case 'OrthographicCamera':

          object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

          break;

        case 'AmbientLight':

          object = new THREE.AmbientLight( data.color, data.intensity );

          break;

        case 'DirectionalLight':

          object = new THREE.DirectionalLight( data.color, data.intensity );

          break;

        case 'PointLight':

          object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

          break;

        case 'SpotLight':

          object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

          break;

        case 'HemisphereLight':

          object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

          break;

        case 'Mesh':

          var geometry = getGeometry( data.geometry );
          var material = getMaterial( data.material );

          if ( geometry.bones && geometry.bones.length > 0 ) {

            object = new THREE.SkinnedMesh( geometry, material );

          } else {

            object = new THREE.Mesh( geometry, material );

          }

          break;

        case 'LOD':

          object = new THREE.LOD();

          break;

        case 'Line':

          object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

          break;

        case 'PointCloud':
        case 'Points':

          object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Sprite':

          object = new THREE.Sprite( getMaterial( data.material ) );

          break;

        case 'Group':

          object = new THREE.Group();

          break;

        default:

          object = new THREE.Object3D();

      }

      object.uuid = data.uuid;

      if ( data.name !== undefined ) object.name = data.name;
      if ( data.matrix !== undefined ) {

        matrix.fromArray( data.matrix );
        matrix.decompose( object.position, object.quaternion, object.scale );

      } else {

        if ( data.position !== undefined ) object.position.fromArray( data.position );
        if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
        if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

      }

      if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
      if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

      if ( data.visible !== undefined ) object.visible = data.visible;
      if ( data.userData !== undefined ) object.userData = data.userData;

      if ( data.children !== undefined ) {

        for ( var child in data.children ) {

          object.add( this.parseObject( data.children[ child ], geometries, materials ) );

        }

      }

      if ( data.type === 'LOD' ) {

        var levels = data.levels;

        for ( var l = 0; l < levels.length; l ++ ) {

          var level = levels[ l ];
          var child = object.getObjectByProperty( 'uuid', level.object );

          if ( child !== undefined ) {

            object.addLevel( child, level.distance );

          }

        }

      }

      return object;

    }

  }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

  constructor: THREE.TextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var texture = new THREE.Texture();

    var loader = new THREE.ImageLoader( this.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.setPath( this.path );
    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

    return texture;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setPath: function ( value ) {

    this.path = value;

  }

};

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.CubeTextureLoader.prototype = {

  constructor: THREE.CubeTextureLoader,

  load: function ( urls, onLoad, onProgress, onError ) {

    var texture = new THREE.CubeTexture( [] );

    var loader = new THREE.ImageLoader();
    loader.setCrossOrigin( this.crossOrigin );
    loader.setPath( this.path );

    var loaded = 0;

    function loadTexture( i ) {

      loader.load( urls[ i ], function ( image ) {

        texture.images[ i ] = image;

        loaded ++;

        if ( loaded === 6 ) {

          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      }, undefined, onError );

    }

    for ( var i = 0; i < urls.length; ++ i ) {

      loadTexture( i );

    }

    return texture;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setPath: function ( value ) {

    this.path = value;

  }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  // override in sub classes
  this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

  constructor: THREE.BinaryTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texture = new THREE.DataTexture();

    var loader = new THREE.XHRLoader( this.manager );
    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( buffer ) {

      var texData = scope._parser( buffer );

      if ( ! texData ) return;

      if ( undefined !== texData.image ) {

        texture.image = texData.image;

      } else if ( undefined !== texData.data ) {

        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;

      }

      texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
      texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

      texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
      texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

      texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

      if ( undefined !== texData.format ) {

        texture.format = texData.format;

      }
      if ( undefined !== texData.type ) {

        texture.type = texData.type;

      }

      if ( undefined !== texData.mipmaps ) {

        texture.mipmaps = texData.mipmaps;

      }

      if ( 1 === texData.mipmapCount ) {

        texture.minFilter = THREE.LinearFilter;

      }

      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture, texData );

    }, onProgress, onError );


    return texture;

  }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  // override in sub classes
  this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

  constructor: THREE.CompressedTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var images = [];

    var texture = new THREE.CompressedTexture();
    texture.image = images;

    var loader = new THREE.XHRLoader( this.manager );
    loader.setPath( this.path );
    loader.setResponseType( 'arraybuffer' );

    function loadTexture( i ) {

      loader.load( url[ i ], function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        images[ i ] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };

        loaded += 1;

        if ( loaded === 6 ) {

          if ( texDatas.mipmapCount === 1 )
            texture.minFilter = THREE.LinearFilter;

          texture.format = texDatas.format;
          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      }, onProgress, onError );

    }

    if ( Array.isArray( url ) ) {

      var loaded = 0;

      for ( var i = 0, il = url.length; i < il; ++ i ) {

        loadTexture( i );

      }

    } else {

      // compressed cubemap texture stored in a single DDS file

      loader.load( url, function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        if ( texDatas.isCubemap ) {

          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for ( var f = 0; f < faces; f ++ ) {

            images[ f ] = { mipmaps : [] };

            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

              images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
              images[ f ].format = texDatas.format;
              images[ f ].width = texDatas.width;
              images[ f ].height = texDatas.height;

            }

          }

        } else {

          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;

        }

        if ( texDatas.mipmapCount === 1 ) {

          texture.minFilter = THREE.LinearFilter;

        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture );

      }, onProgress, onError );

    }

    return texture;

  },

  setPath: function ( value ) {

    this.path = value;

  }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

  Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Material';

  this.side = THREE.FrontSide;

  this.opacity = 1;
  this.transparent = false;

  this.blending = THREE.NormalBlending;

  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;

  this.depthFunc = THREE.LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;

  this.colorWrite = true;

  this.precision = null; // override the renderer's default precision for this material

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;

  this.alphaTest = 0;

  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;

  this._needsUpdate = true;

};

THREE.Material.prototype = {

  constructor: THREE.Material,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  setValues: function ( values ) {

    if ( values === undefined ) return;

    for ( var key in values ) {

      var newValue = values[ key ];

      if ( newValue === undefined ) {

        console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
        continue;

      }

      var currentValue = this[ key ];

      if ( currentValue === undefined ) {

        console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
        continue;

      }

      if ( currentValue instanceof THREE.Color ) {

        currentValue.set( newValue );

      } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

        currentValue.copy( newValue );

      } else if ( key === 'overdraw' ) {

        // ensure overdraw is backwards-compatible with legacy boolean type
        this[ key ] = Number( newValue );

      } else {

        this[ key ] = newValue;

      }

    }

  },

  toJSON: function ( meta ) {

    var isRoot = meta === undefined;

    if ( isRoot ) {

      meta = {
        textures: {},
        images: {}
      };

    }

    var data = {
      metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };

    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();

    if ( this.roughness !== 0.5 ) data.roughness = this.roughness;
    if ( this.metalness > 0 ) data.metalness = this.metalness;

    if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
    if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
    if ( this.shininess !== undefined ) data.shininess = this.shininess;

    if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
    if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    if ( this.bumpMap instanceof THREE.Texture ) {

      data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
      data.bumpScale = this.bumpScale;

    }
    if ( this.normalMap instanceof THREE.Texture ) {

      data.normalMap = this.normalMap.toJSON( meta ).uuid;
      data.normalScale = this.normalScale.toArray();

    }
    if ( this.displacementMap instanceof THREE.Texture ) {

      data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;

    }
    if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

    if ( this.envMap instanceof THREE.Texture ) {

      data.envMap = this.envMap.toJSON( meta ).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap

    }

    if ( this.size !== undefined ) data.size = this.size;
    if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
    if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
    if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
    if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

    if ( this.opacity < 1 ) data.opacity = this.opacity;
    if ( this.transparent === true ) data.transparent = this.transparent;
    if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    if ( this.wireframe === true ) data.wireframe = this.wireframe;
    if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

    // TODO: Copied from Object3D.toJSON

    function extractFromCache ( cache ) {

      var values = [];

      for ( var key in cache ) {

        var data = cache[ key ];
        delete data.metadata;
        values.push( data );

      }

      return values;

    }

    if ( isRoot ) {

      var textures = extractFromCache( meta.textures );
      var images = extractFromCache( meta.images );

      if ( textures.length > 0 ) data.textures = textures;
      if ( images.length > 0 ) data.images = images;

    }

    return data;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.name = source.name;

    this.side = source.side;

    this.opacity = source.opacity;
    this.transparent = source.transparent;

    this.blending = source.blending;

    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;

    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;

    this.colorWrite = source.colorWrite;

    this.precision = source.precision;

    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;

    this.alphaTest = source.alphaTest;

    this.overdraw = source.overdraw;

    this.visible = source.visible;

    return this;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineBasicMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.linewidth = source.linewidth;
  this.linecap = source.linecap;
  this.linejoin = source.linejoin;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineDashedMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;

  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.linewidth = source.linewidth;

  this.scale = source.scale;
  this.dashSize = source.dashSize;
  this.gapSize = source.gapSize;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshBasicMaterial';

  this.color = new THREE.Color( 0xffffff ); // emissive

  this.map = null;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.map = source.map;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;

  return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshLambertMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.emissiveMap = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.emissive.copy( source.emissive );

  this.map = source.map;

  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.emissiveMap = source.emissiveMap;

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshPhongMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );
  this.specular = new THREE.Color( 0x111111 );
  this.shininess = 30;

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.emissiveMap = null;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.emissive.copy( source.emissive );
  this.specular.copy( source.specular );
  this.shininess = source.shininess;

  this.map = source.map;

  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.emissiveMap = source.emissiveMap;

  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;

  this.normalMap = source.normalMap;
  this.normalScale.copy( source.normalScale );

  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;

  this.specularMap = source.specularMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.combine = source.combine;
  this.reflectivity = source.reflectivity;
  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

// File:src/materials/MeshStandardMaterial.js

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,

 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshStandardMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshStandardMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.roughness = 0.5;
  this.metalness = 0.5;

  this.emissive = new THREE.Color( 0x000000 );

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.emissiveMap = null;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.displacementMap = null;
  this.displacementScale = 1;
  this.displacementBias = 0;

  this.roughnessMap = null;

  this.metalnessMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.envMapIntensity = 1.0;

  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;

THREE.MeshStandardMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.roughness = source.roughness;
  this.metalness = source.metalness;

  this.emissive.copy( source.emissive );

  this.map = source.map;

  this.lightMap = source.lightMap;
  this.lightMapIntensity = source.lightMapIntensity;

  this.aoMap = source.aoMap;
  this.aoMapIntensity = source.aoMapIntensity;

  this.emissiveMap = source.emissiveMap;

  this.bumpMap = source.bumpMap;
  this.bumpScale = source.bumpScale;

  this.normalMap = source.normalMap;
  this.normalScale.copy( source.normalScale );

  this.displacementMap = source.displacementMap;
  this.displacementScale = source.displacementScale;
  this.displacementBias = source.displacementBias;

  this.roughnessMap = source.roughnessMap;

  this.metalnessMap = source.metalnessMap;

  this.alphaMap = source.alphaMap;

  this.envMap = source.envMap;
  this.envMapIntensity = source.envMapIntensity;

  this.refractionRatio = source.refractionRatio;

  this.fog = source.fog;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;
  this.wireframeLinecap = source.wireframeLinecap;
  this.wireframeLinejoin = source.wireframeLinejoin;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;
  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshDepthMaterial';

  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

  THREE.Material.call( this, parameters );

  this.type = 'MeshNormalMaterial';

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

  this.uuid = THREE.Math.generateUUID();

  this.type = 'MultiMaterial';

  this.materials = materials instanceof Array ? materials : [];

  this.visible = true;

};

THREE.MultiMaterial.prototype = {

  constructor: THREE.MultiMaterial,

  toJSON: function ( meta ) {

    var output = {
      metadata: {
        version: 4.2,
        type: 'material',
        generator: 'MaterialExporter'
      },
      uuid: this.uuid,
      type: this.type,
      materials: []
    };

    var materials = this.materials;

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      var material = materials[ i ].toJSON( meta );
      delete material.metadata;

      output.materials.push( material );

    }

    output.visible = this.visible;

    return output;

  },

  clone: function () {

    var material = new this.constructor();

    for ( var i = 0; i < this.materials.length; i ++ ) {

      material.materials.push( this.materials[ i ].clone() );

    }

    material.visible = this.visible;

    return material;

  }

};

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'PointsMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.map = null;

  this.size = 1;
  this.sizeAttenuation = true;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );

  this.map = source.map;

  this.size = source.size;
  this.sizeAttenuation = source.sizeAttenuation;

  this.vertexColors = source.vertexColors;

  this.fog = source.fog;

  return this;

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'ShaderMaterial';

  this.defines = {};
  this.uniforms = {};

  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  this.shading = THREE.SmoothShading;

  this.linewidth = 1;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  this.extensions = {
    derivatives: false, // set to use derivatives
    fragDepth: false, // set to use fragment depth values
    drawBuffers: false, // set to use draw buffers
    shaderTextureLOD: false // set to use shader texture LOD
  };

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [ 1, 1, 1 ],
    'uv': [ 0, 0 ],
    'uv2': [ 0, 0 ]
  };

  this.index0AttributeName = undefined;

  if ( parameters !== undefined ) {

    if ( parameters.attributes !== undefined ) {

      console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

    }

    this.setValues( parameters );

  }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.fragmentShader = source.fragmentShader;
  this.vertexShader = source.vertexShader;

  this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

  this.defines = source.defines;

  this.shading = source.shading;

  this.wireframe = source.wireframe;
  this.wireframeLinewidth = source.wireframeLinewidth;

  this.fog = source.fog;

  this.lights = source.lights;

  this.vertexColors = source.vertexColors;

  this.skinning = source.skinning;

  this.morphTargets = source.morphTargets;
  this.morphNormals = source.morphNormals;

  this.extensions = source.extensions;

  return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

  var data = THREE.Material.prototype.toJSON.call( this, meta );

  data.uniforms = this.uniforms;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;

  return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

  THREE.ShaderMaterial.call( this, parameters );

  this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  uvOffset: new THREE.Vector2(),
 *  uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.map = null;

  this.rotation = 0;

  this.fog = false;

  // set parameters

  this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

  THREE.Material.prototype.copy.call( this, source );

  this.color.copy( source.color );
  this.map = source.map;

  this.rotation = source.rotation;

  this.fog = source.fog;

  return this;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.sourceFile = '';

  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];

  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  this.version = 0;
  this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

  constructor: THREE.Texture,

  set needsUpdate ( value ) {

    if ( value === true ) this.version ++;

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.image = source.image;
    this.mipmaps = source.mipmaps.slice( 0 );

    this.mapping = source.mapping;

    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;

    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;

    this.anisotropy = source.anisotropy;

    this.format = source.format;
    this.type = source.type;

    this.offset.copy( source.offset );
    this.repeat.copy( source.repeat );

    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;

    return this;

  },

  toJSON: function ( meta ) {

    if ( meta.textures[ this.uuid ] !== undefined ) {

      return meta.textures[ this.uuid ];

    }

    function getDataURL( image ) {

      var canvas;

      if ( image.toDataURL !== undefined ) {

        canvas = image;

      } else {

        canvas = document.createElement( 'canvas' );
        canvas.width = image.width;
        canvas.height = image.height;

        canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

      }

      if ( canvas.width > 2048 || canvas.height > 2048 ) {

        return canvas.toDataURL( 'image/jpeg', 0.6 );

      } else {

        return canvas.toDataURL( 'image/png' );

      }

    }

    var output = {
      metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },

      uuid: this.uuid,
      name: this.name,

      mapping: this.mapping,

      repeat: [ this.repeat.x, this.repeat.y ],
      offset: [ this.offset.x, this.offset.y ],
      wrap: [ this.wrapS, this.wrapT ],

      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy
    };

    if ( this.image !== undefined ) {

      // TODO: Move to THREE.Image

      var image = this.image;

      if ( image.uuid === undefined ) {

        image.uuid = THREE.Math.generateUUID(); // UGH

      }

      if ( meta.images[ image.uuid ] === undefined ) {

        meta.images[ image.uuid ] = {
          uuid: image.uuid,
          url: getDataURL( image )
        };

      }

      output.image = image.uuid;

    }

    meta.textures[ this.uuid ] = output;

    return output;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  },

  transformUv: function ( uv ) {

    if ( this.mapping !== THREE.UVMapping )  return;

    uv.multiply( this.repeat );
    uv.add( this.offset );

    if ( uv.x < 0 || uv.x > 1 ) {

      switch ( this.wrapS ) {

        case THREE.RepeatWrapping:

          uv.x = uv.x - Math.floor( uv.x );
          break;

        case THREE.ClampToEdgeWrapping:

          uv.x = uv.x < 0 ? 0 : 1;
          break;

        case THREE.MirroredRepeatWrapping:

          if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

            uv.x = Math.ceil( uv.x ) - uv.x;

          } else {

            uv.x = uv.x - Math.floor( uv.x );

          }
          break;

      }

    }

    if ( uv.y < 0 || uv.y > 1 ) {

      switch ( this.wrapT ) {

        case THREE.RepeatWrapping:

          uv.y = uv.y - Math.floor( uv.y );
          break;

        case THREE.ClampToEdgeWrapping:

          uv.y = uv.y < 0 ? 0 : 1;
          break;

        case THREE.MirroredRepeatWrapping:

          if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

            uv.y = Math.ceil( uv.y ) - uv.y;

          } else {

            uv.y = uv.y - Math.floor( uv.y );

          }
          break;

      }

    }

    if ( this.flipY ) {

      uv.y = 1 - uv.y;

    }

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

  THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.images = images;
  this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.prototype.copy = function ( source ) {

  THREE.Texture.prototype.copy.call( this, source );

  this.images = source.images;

  return this;

};
// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { width: width, height: height };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { data: data, width: width, height: height };

  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

  this.flipY = false;
  this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.generateMipmaps = false;

  var scope = this;

  function update() {

    requestAnimationFrame( update );

    if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

      scope.needsUpdate = true;

    }

  }

  update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

  THREE.Object3D.call( this );

  this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;
// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Points';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.create( THREE.Object3D.prototype );
THREE.Points.prototype.constructor = THREE.Points;

THREE.Points.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function raycast( raycaster, intersects ) {

    var object = this;
    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;
    var threshold = raycaster.params.Points.threshold;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( matrixWorld );

    if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    //

    inverseMatrix.getInverse( matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    var localThresholdSq = localThreshold * localThreshold;
    var position = new THREE.Vector3();

    function testPoint( point, index ) {

      var rayPointDistanceSq = ray.distanceSqToPoint( point );

      if ( rayPointDistanceSq < localThresholdSq ) {

        var intersectPoint = ray.closestPointToPoint( point );
        intersectPoint.applyMatrix4( matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) return;

        intersects.push( {

          distance: distance,
          distanceToRay: Math.sqrt( rayPointDistanceSq ),
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object

        } );

      }

    }

    if ( geometry instanceof THREE.BufferGeometry ) {

      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( index !== null ) {

        var indices = index.array;

        for ( var i = 0, il = indices.length; i < il; i ++ ) {

          var a = indices[ i ];

          position.fromArray( positions, a * 3 );

          testPoint( position, a );

        }

      } else {

        for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

          position.fromArray( positions, i * 3 );

          testPoint( position, i );

        }

      }

    } else {

      var vertices = geometry.vertices;

      for ( var i = 0, l = vertices.length; i < l; i ++ ) {

        testPoint( vertices[ i ], i );

      }

    }

  };

}() );

THREE.Points.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

  if ( mode === 1 ) {

    console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
    return new THREE.LineSegments( geometry, material );

  }

  THREE.Object3D.call( this );

  this.type = 'Line';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function raycast( raycaster, intersects ) {

    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;

    var geometry = this.geometry;
    var matrixWorld = this.matrixWorld;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( matrixWorld );

    if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    //

    inverseMatrix.getInverse( matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    var vStart = new THREE.Vector3();
    var vEnd = new THREE.Vector3();
    var interSegment = new THREE.Vector3();
    var interRay = new THREE.Vector3();
    var step = this instanceof THREE.LineSegments ? 2 : 1;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( index !== null ) {

        var indices = index.array;

        for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

          var a = indices[ i ];
          var b = indices[ i + 1 ];

          vStart.fromArray( positions, a * 3 );
          vEnd.fromArray( positions, b * 3 );

          var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

          if ( distSq > precisionSq ) continue;

          interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo( interRay );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
            index: i,
            face: null,
            faceIndex: null,
            object: this

          } );

        }

      } else {

        for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

          vStart.fromArray( positions, 3 * i );
          vEnd.fromArray( positions, 3 * i + 3 );

          var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

          if ( distSq > precisionSq ) continue;

          interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

          var distance = raycaster.ray.origin.distanceTo( interRay );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
            index: i,
            face: null,
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var vertices = geometry.vertices;
      var nbVertices = vertices.length;

      for ( var i = 0; i < nbVertices - 1; i += step ) {

        var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

        if ( distSq > precisionSq ) continue;

        interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

        var distance = raycaster.ray.origin.distanceTo( interRay );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4( this.matrixWorld ),
          index: i,
          face: null,
          faceIndex: null,
          object: this

        } );

      }

    }

  };

}() );

THREE.Line.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

  THREE.Line.call( this, geometry, material );

  this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Mesh';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  this.drawMode = THREE.TrianglesDrawMode;

  this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.setDrawMode = function ( value ) {

  this.drawMode = value;

};

THREE.Mesh.prototype.updateMorphTargets = function () {

  if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

    this.morphTargetBase = - 1;
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};

    for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

      this.morphTargetInfluences.push( 0 );
      this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

    }

  }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

  if ( this.morphTargetDictionary[ name ] !== undefined ) {

    return this.morphTargetDictionary[ name ];

  }

  console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

  return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();

  var tempA = new THREE.Vector3();
  var tempB = new THREE.Vector3();
  var tempC = new THREE.Vector3();

  var uvA = new THREE.Vector2();
  var uvB = new THREE.Vector2();
  var uvC = new THREE.Vector2();

  var barycoord = new THREE.Vector3();

  var intersectionPoint = new THREE.Vector3();
  var intersectionPointWorld = new THREE.Vector3();

  function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

    THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

    uv1.multiplyScalar( barycoord.x );
    uv2.multiplyScalar( barycoord.y );
    uv3.multiplyScalar( barycoord.z );

    uv1.add( uv2 ).add( uv3 );

    return uv1.clone();

  }

  function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

    var intersect;
    var material = object.material;

    if ( material.side === THREE.BackSide ) {

      intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    } else {

      intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

    }

    if ( intersect === null ) return null;

    intersectionPointWorld.copy( point );
    intersectionPointWorld.applyMatrix4( object.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

    if ( distance < raycaster.near || distance > raycaster.far ) return null;

    return {
      distance: distance,
      point: intersectionPointWorld.clone(),
      object: object
    };

  }

  function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

    vA.fromArray( positions, a * 3 );
    vB.fromArray( positions, b * 3 );
    vC.fromArray( positions, c * 3 );

    var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

    if ( intersection ) {

      if ( uvs ) {

        uvA.fromArray( uvs, a * 2 );
        uvB.fromArray( uvs, b * 2 );
        uvC.fromArray( uvs, c * 2 );

        intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

      }

      intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
      intersection.faceIndex = a;

    }

    return intersection;

  }

  return function raycast( raycaster, intersects ) {

    var geometry = this.geometry;
    var material = this.material;
    var matrixWorld = this.matrixWorld;

    if ( material === undefined ) return;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( matrixWorld );

    if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    //

    inverseMatrix.getInverse( matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    // Check boundingBox before continuing

    if ( geometry.boundingBox !== null ) {

      if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

    }

    var uvs, intersection;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var a, b, c;
      var index = geometry.index;
      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( attributes.uv !== undefined ) {

        uvs = attributes.uv.array;

      }

      if ( index !== null ) {

        var indices = index.array;

        for ( var i = 0, l = indices.length; i < l; i += 3 ) {

          a = indices[ i ];
          b = indices[ i + 1 ];
          c = indices[ i + 2 ];

          intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

          if ( intersection ) {

            intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
            intersects.push( intersection );

          }

        }

      } else {


        for ( var i = 0, l = positions.length; i < l; i += 9 ) {

          a = i / 3;
          b = a + 1;
          c = a + 2;

          intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

          if ( intersection ) {

            intersection.index = a; // triangle number in positions buffer semantics
            intersects.push( intersection );

          }

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var fvA, fvB, fvC;
      var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;
      var materials = isFaceMaterial === true ? material.materials : null;

      var vertices = geometry.vertices;
      var faces = geometry.faces;
      var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
      if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

      for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

        var face = faces[ f ];
        var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

        if ( faceMaterial === undefined ) continue;

        fvA = vertices[ face.a ];
        fvB = vertices[ face.b ];
        fvC = vertices[ face.c ];

        if ( faceMaterial.morphTargets === true ) {

          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;

          vA.set( 0, 0, 0 );
          vB.set( 0, 0, 0 );
          vC.set( 0, 0, 0 );

          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

            var influence = morphInfluences[ t ];

            if ( influence === 0 ) continue;

            var targets = morphTargets[ t ].vertices;

            vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
            vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
            vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

          }

          vA.add( fvA );
          vB.add( fvB );
          vC.add( fvC );

          fvA = vA;
          fvB = vB;
          fvC = vC;

        }

        intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

        if ( intersection ) {

          if ( uvs ) {

            var uvs_f = uvs[ f ];
            uvA.copy( uvs_f[ 0 ] );
            uvB.copy( uvs_f[ 1 ] );
            uvC.copy( uvs_f[ 2 ] );

            intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

          }

          intersection.face = face;
          intersection.faceIndex = f;
          intersects.push( intersection );

        }

      }

    }

  };

}() );

THREE.Mesh.prototype.clone = function () {

  return new this.constructor( this.geometry, this.material ).copy( this );

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

  THREE.Object3D.call( this );

  this.type = 'Bone';

  this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

THREE.Bone.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.skin = source.skin;

  return this;

};

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

  this.identityMatrix = new THREE.Matrix4();

  // copy the bone array

  bones = bones || [];

  this.bones = bones.slice( 0 );

  // create a bone texture or an array of floats

  if ( this.useVertexTexture ) {

    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
    size = Math.max( size, 4 );

    this.boneTextureWidth = size;
    this.boneTextureHeight = size;

    this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

  } else {

    this.boneMatrices = new Float32Array( 16 * this.bones.length );

  }

  // use the supplied bone inverses or calculate the inverses

  if ( boneInverses === undefined ) {

    this.calculateInverses();

  } else {

    if ( this.bones.length === boneInverses.length ) {

      this.boneInverses = boneInverses.slice( 0 );

    } else {

      console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

      this.boneInverses = [];

      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        this.boneInverses.push( new THREE.Matrix4() );

      }

    }

  }

};

THREE.Skeleton.prototype.calculateInverses = function () {

  this.boneInverses = [];

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    var inverse = new THREE.Matrix4();

    if ( this.bones[ b ] ) {

      inverse.getInverse( this.bones[ b ].matrixWorld );

    }

    this.boneInverses.push( inverse );

  }

};

THREE.Skeleton.prototype.pose = function () {

  var bone;

  // recover the bind-time world matrices

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    }

  }

  // compute the local matrices, positions, rotations and scales

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      if ( bone.parent ) {

        bone.matrix.getInverse( bone.parent.matrixWorld );
        bone.matrix.multiply( bone.matrixWorld );

      } else {

        bone.matrix.copy( bone.matrixWorld );

      }

      bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    }

  }

};

THREE.Skeleton.prototype.update = ( function () {

  var offsetMatrix = new THREE.Matrix4();

  return function update() {

    // flatten bone matrices to array

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

      // compute the offset between the current and the original transform

      var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

      offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
      offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

    }

    if ( this.useVertexTexture ) {

      this.boneTexture.needsUpdate = true;

    }

  };

} )();

THREE.Skeleton.prototype.clone = function () {

  return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

};

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'SkinnedMesh';

  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();

  // init bones

  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.

  var bones = [];

  if ( this.geometry && this.geometry.bones !== undefined ) {

    var bone, gbone;

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      bone = new THREE.Bone( this );
      bones.push( bone );

      bone.name = gbone.name;
      bone.position.fromArray( gbone.pos );
      bone.quaternion.fromArray( gbone.rotq );
      if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    }

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      if ( gbone.parent !== - 1 && gbone.parent !== null ) {

        bones[ gbone.parent ].add( bones[ b ] );

      } else {

        this.add( bones[ b ] );

      }

    }

  }

  this.normalizeSkinWeights();

  this.updateMatrixWorld( true );
  this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

  this.skeleton = skeleton;

  if ( bindMatrix === undefined ) {

    this.updateMatrixWorld( true );

    this.skeleton.calculateInverses();

    bindMatrix = this.matrixWorld;

  }

  this.bindMatrix.copy( bindMatrix );
  this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

  this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

  if ( this.geometry instanceof THREE.Geometry ) {

    for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

      var sw = this.geometry.skinWeights[ i ];

      var scale = 1.0 / sw.lengthManhattan();

      if ( scale !== Infinity ) {

        sw.multiplyScalar( scale );

      } else {

        sw.set( 1, 0, 0, 0 ); // do something reasonable

      }

    }

  } else if ( this.geometry instanceof THREE.BufferGeometry ) {

    var vec = new THREE.Vector4();

    var skinWeight = this.geometry.attributes.skinWeight;

    for ( var i = 0; i < skinWeight.count; i ++ ) {

      vec.x = skinWeight.getX( i );
      vec.y = skinWeight.getY( i );
      vec.z = skinWeight.getZ( i );
      vec.w = skinWeight.getW( i );

      var scale = 1.0 / vec.lengthManhattan();

      if ( scale !== Infinity ) {

        vec.multiplyScalar( scale );

      } else {

        vec.set( 1, 0, 0, 0 ); // do something reasonable

      }

      skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

    }

  }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

  THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

  if ( this.bindMode === "attached" ) {

    this.bindMatrixInverse.getInverse( this.matrixWorld );

  } else if ( this.bindMode === "detached" ) {

    this.bindMatrixInverse.getInverse( this.bindMatrix );

  } else {

    console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

  }

};

THREE.SkinnedMesh.prototype.clone = function() {

  return new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

  THREE.Object3D.call( this );

  this.type = 'LOD';

  Object.defineProperties( this, {
    levels: {
      enumerable: true,
      value: []
    },
    objects: {
      get: function () {

        console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
        return this.levels;

      }
    }
  } );

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

  if ( distance === undefined ) distance = 0;

  distance = Math.abs( distance );

  var levels = this.levels;

  for ( var l = 0; l < levels.length; l ++ ) {

    if ( distance < levels[ l ].distance ) {

      break;

    }

  }

  levels.splice( l, 0, { distance: distance, object: object } );

  this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

  var levels = this.levels;

  for ( var i = 1, l = levels.length; i < l; i ++ ) {

    if ( distance < levels[ i ].distance ) {

      break;

    }

  }

  return levels[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function raycast( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  };

}() );

THREE.LOD.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function update( camera ) {

    var levels = this.levels;

    if ( levels.length > 1 ) {

      v1.setFromMatrixPosition( camera.matrixWorld );
      v2.setFromMatrixPosition( this.matrixWorld );

      var distance = v1.distanceTo( v2 );

      levels[ 0 ].object.visible = true;

      for ( var i = 1, l = levels.length; i < l; i ++ ) {

        if ( distance >= levels[ i ].distance ) {

          levels[ i - 1 ].object.visible = false;
          levels[ i ].object.visible = true;

        } else {

          break;

        }

      }

      for ( ; i < l; i ++ ) {

        levels[ i ].object.visible = false;

      }

    }

  };

}();

THREE.LOD.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source, false );

  var levels = source.levels;

  for ( var i = 0, l = levels.length; i < l; i ++ ) {

    var level = levels[ i ];

    this.addLevel( level.object.clone(), level.distance );

  }

  return this;

};

THREE.LOD.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.levels = [];

  var levels = this.levels;

  for ( var i = 0, l = levels.length; i < l; i ++ ) {

    var level = levels[ i ];

    data.object.levels.push( {
      object: level.object.uuid,
      distance: level.distance
    } );

  }

  return data;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

  var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
  var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
  var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

  var geometry = new THREE.BufferGeometry();
  geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  return function Sprite( material ) {

    THREE.Object3D.call( this );

    this.type = 'Sprite';

    this.geometry = geometry;
    this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

  };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function raycast( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    var guessSizeSq = this.scale.x * this.scale.y;

    if ( distanceSq > guessSizeSq ) {

      return;

    }

    intersects.push( {

      distance: Math.sqrt( distanceSq ),
      point: this.position,
      face: null,
      object: this

    } );

  };

}() );

THREE.Sprite.prototype.clone = function () {

  return new this.constructor( this.material ).copy( this );

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

  THREE.Object3D.call( this );

  this.lensFlares = [];

  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;

  if ( texture !== undefined ) {

    this.add( texture, size, distance, blending, color );

  }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

  if ( size === undefined ) size = - 1;
  if ( distance === undefined ) distance = 0;
  if ( opacity === undefined ) opacity = 1;
  if ( color === undefined ) color = new THREE.Color( 0xffffff );
  if ( blending === undefined ) blending = THREE.NormalBlending;

  distance = Math.min( distance, Math.max( 0, distance ) );

  this.lensFlares.push( {
    texture: texture, // THREE.Texture
    size: size,     // size in pixels (-1 = use texture.width)
    distance: distance,   // distance (0-1) from light source (0=at light source)
    x: 0, y: 0, z: 0, // screen position (-1 => 1) z = 0 is in front z = 1 is back
    scale: 1,     // scale
    rotation: 0,    // rotation
    opacity: opacity, // opacity
    color: color,   // color
    blending: blending  // blending
  } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = - this.positionScreen.x * 2;
  var vecY = - this.positionScreen.y * 2;

  for ( f = 0; f < fl; f ++ ) {

    flare = this.lensFlares[ f ];

    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;

    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  }

};

THREE.LensFlare.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  this.positionScreen.copy( source.positionScreen );
  this.customUpdateCallback = source.customUpdateCallback;

  for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    this.lensFlares.push( source.lensFlares[ i ] );

  }

  return this;

};

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

  THREE.Object3D.call( this );

  this.type = 'Scene';

  this.fog = null;
  this.overrideMaterial = null;

  this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source ) {

  THREE.Object3D.prototype.copy.call( this, source );

  if ( source.fog !== null ) this.fog = source.fog.clone();
  if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

  this.autoUpdate = source.autoUpdate;
  this.matrixAutoUpdate = source.matrixAutoUpdate;

  return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

  this.name = '';

  this.color = new THREE.Color( color );

  this.near = ( near !== undefined ) ? near : 1;
  this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

  return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

  this.name = '';

  this.color = new THREE.Color( color );
  this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

  return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment' ] ="#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment' ] ="#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment' ] ="#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/ambient_pars.glsl

THREE.ShaderChunk[ 'ambient_pars' ] ="uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\treturn PI * ambientLightColor;\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment' ] ="#ifdef USE_AOMAP\n\n\treflectedLight.indirectDiffuse *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment' ] ="#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex' ] ="\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex' ] ="\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl

THREE.ShaderChunk[ 'bsdfs' ] ="float calcLightAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\tif ( decayExponent > 0.0 ) {\n\n\t  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n}\n\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick '94\n\t//;float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\n\tfloat a2 = alpha * alpha;\n\n\tfloat gl = dotNL + pow( a2 + ( 1.0 - a2 ) * dotNL * dotNL, 0.5 );\n\n\tfloat gv = dotNV + pow( a2 + ( 1.0 - a2 ) * dotNV * dotNV, 0.5 );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = alpha * alpha;\n\n\tfloat denom = dotNH * dotNH * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / ( denom * denom );\n\n}\n\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = roughness * roughness; // UE4's roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n\treturn specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / square( ggxRoughness + 0.0001 ) - 2.0 );\n}";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] ="#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment' ] ="#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex' ] ="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex' ] ="#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common' ] ="#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat square( const in float x ) { return x*x; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\n\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n\t#ifdef GAMMA_INPUT\n\n\t\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n\t#else\n\n\t\treturn a;\n\n\t#endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n\t#ifdef GAMMA_OUTPUT\n\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n\t#else\n\n\t\treturn a;\n\n\t#endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex' ] ="#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex' ] ="#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] ="#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment' ] ="#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = inputToLinear( emissiveColor.rgb );\n\n\ttotalEmissiveLight *= emissiveColor.rgb;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] ="#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment' ] ="#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\tenvColor.xyz = inputToLinear( envColor.xyz );\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment' ] ="#if defined( USE_ENVMAP ) || defined( STANDARD )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n\n#ifdef USE_ENVMAP\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex' ] ="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex' ] ="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment' ] ="#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment' ] ="#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl

THREE.ShaderChunk[ 'lights_pars' ] ="#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t  vec3 direction;\n\t  vec3 color;\n\t  int shadow;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tIncidentLight getDirectionalDirectLight( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n\n\t\tIncidentLight directLight;\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\n\t\treturn directLight;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t  vec3 position;\n\t  vec3 color;\n\t  float distance;\n\t  float decay;\n\t  int shadow;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\tIncidentLight getPointDirectLight( const in PointLight pointLight, const in GeometricContext geometry ) {\n\n\t\tIncidentLight directLight;\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= calcLightAttenuation( length( lVector ), pointLight.distance, pointLight.decay );\n\n\t\treturn directLight;\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t  vec3 position;\n\t  vec3 direction;\n\t  vec3 color;\n\t  float distance;\n\t  float decay;\n\t  float angleCos;\n\t  float exponent;\n\t  int shadow;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\tIncidentLight getSpotDirectLight( const in SpotLight spotLight, const in GeometricContext geometry ) {\n\n\t\tIncidentLight directLight;\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat spotEffect = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( spotEffect > spotLight.angleCos ) {\n\n\t\t\tfloat spotEffect = dot( spotLight.direction, directLight.direction );\n\t\t\tspotEffect = saturate( pow( saturate( spotEffect ), spotLight.exponent ) );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= ( spotEffect * calcLightAttenuation( length( lVector ), spotLight.distance, spotLight.decay ) );\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\n\t\t}\n\n\t\treturn directLight;\n\n\t}\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t  vec3 direction;\n\t  vec3 skyColor;\n\t  vec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\treturn PI * mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t}\n\n#endif\n\n\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#else\n\n\t\t\tfloat flipNormal = 1.0;\n\n\t\t#endif\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvec3 envMapColor = vec3( 0.0 );\n\n\t\t#endif\n\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( square( blinnShininessExponent ) + 1.0 );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#else\n\n\t\t\tfloat flipNormal = 1.0;\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tenvMapColor.rgb = inputToLinear( envMapColor.rgb );\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment' ] ="#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex' ] ="vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tIncidentLight directLight = getPointDirectLight( pointLights[ i ], geometry );\n\n\t\tfloat dotNL = dot( geometry.normal, directLight.direction );\n\t\tvec3 directLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tIncidentLight directLight = getSpotDirectLight( spotLights[ i ], geometry );\n\n\t\tfloat dotNL = dot( geometry.normal, directLight.direction );\n\t\tvec3 directLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\n#endif\n\n#if NUM_DIR_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tIncidentLight directLight = getDirectionalDirectLight( directionalLights[ i ], geometry );\n\n\t\tfloat dotNL = dot( geometry.normal, directLight.direction );\n\t\tvec3 directLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n\t{\n\n\n\t\t#if NUM_HEMI_LIGHTS > 0\n\n\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t\t\t#endif\n\n\t\t\t}\n\n\t\t#endif\n\n\t}\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment' ] ="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] ="#ifdef USE_ENVMAP\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * PI * directLight.color; // punctual light\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex' ] ="#ifdef USE_ENVMAP\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex' ] ="#ifdef USE_ENVMAP\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl

THREE.ShaderChunk[ 'lights_standard_fragment' ] ="StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n";

// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_standard_pars_fragment' ] ="struct StandardMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n};\n\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * PI * directLight.color; // punctual light\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n}\n\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Standard\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n";

// File:src/renderers/shaders/ShaderChunk/lights_template.glsl

THREE.ShaderChunk[ 'lights_template' ] ="//\n// This is a template that can be used to light a material, it uses pluggable RenderEquations (RE)\n//   for specific lighting scenarios.\n//\n// Instructions for use:\n//  - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n//  - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n//  - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n//\n// TODO:\n//  - Add area light support.\n//  - Add sphere light support.\n//  - Add diffuse light probe (irradiance cubemap) support.\n//\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tPointLight pointLight = pointLights[ i ];\n\n\t\tIncidentLight directLight = getPointDirectLight( pointLight, geometry );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tif ( pointLight.shadow > - 1 ) {\n\t\t\tfor ( int j = 0; j < NUM_SHADOWS; j ++ ) {\n\t\t\t\tif ( j == pointLight.shadow ) {\n\t\t\t\t\tdirectLight.color *= shadows[ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tSpotLight spotLight = spotLights[ i ];\n\n\t\tIncidentLight directLight = getSpotDirectLight( spotLight, geometry );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tif ( spotLight.shadow > - 1 ) {\n\t\t\tfor ( int j = 0; j < NUM_SHADOWS; j ++ ) {\n\t\t\t\tif ( j == spotLight.shadow ) {\n\t\t\t\t\tdirectLight.color *= shadows[ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tDirectionalLight directionalLight = directionalLights[ i ];\n\n\t\tIncidentLight directLight = getDirectionalDirectLight( directionalLight, geometry );\n\n\t\t#ifdef USE_SHADOWMAP\n\t\tif ( directionalLight.shadow > - 1 ) {\n\t\t\tfor ( int j = 0; j < NUM_SHADOWS; j ++ ) {\n\t\t\t\tif ( j == directionalLight.shadow ) {\n\t\t\t\t\tdirectLight.color *= shadows[ j ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\t{\n\n\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t\t#ifdef USE_LIGHTMAP\n\n\t\t\tirradiance += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t\t}\n\n\t\t#endif\n\n\t\t// #if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\t\t// TODO, replace 8 with the real maxMIPLevel\n\t\t\t// irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, 8 ); // comment out until seams are fixed\n\n\t\t// #endif\n\n\t\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\t{\n\n\t\t// TODO, replace 8 with the real maxMIPLevel\n\t\tvec3 radiance = getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), 8 );\n\n\t\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n\n\t}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment' ] ="\n\toutgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment' ] ="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex' ] ="#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n\t#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment' ] ="#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\n\n\tdiffuseColor *= texelColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment' ] ="#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment' ] ="#ifdef USE_MAP\n\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment' ] ="#ifdef USE_MAP\n\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl

THREE.ShaderChunk[ 'metalnessmap_fragment' ] ="float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl

THREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] ="#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex' ] ="#ifdef USE_MORPHNORMALS\n\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex' ] ="#ifdef USE_MORPHTARGETS\n\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl

THREE.ShaderChunk[ 'normal_fragment' ] ="#ifdef FLAT_SHADED\n\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n\t#endif\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment' ] ="#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl

THREE.ShaderChunk[ 'roughnessmap_fragment' ] ="float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl

THREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] ="#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment' ] ="vec3 shadowMask = vec3( 1.0 );\n\n#ifdef USE_SHADOWMAP\n\n\tfloat shadows[ NUM_SHADOWS ];\n\n\tfor ( int i = 0; i < NUM_SHADOWS; i ++ ) {\n\n\t\tfloat texelSizeY =  1.0 / shadowMapSize[ i ].y;\n\n\t\tfloat shadow = 0.0;\n\n#ifdef POINT_LIGHT_SHADOWS\n\n\t\t// to save on uniform space, we use the sign of @shadowDarkness[ i ] to determine\n\t\t// whether or not this light is a point light ( shadowDarkness[ i ] < 0 == point light)\n\t\tbool isPointLight = shadowDarkness[ i ] < 0.0;\n\n\t\tif ( isPointLight ) {\n\n\t\t\t// get the real shadow darkness\n\t\t\tfloat realShadowDarkness = abs( shadowDarkness[ i ] );\n\n\t\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t\t// the distance from the light to the world-space position of the fragment.\n\t\t\tvec3 lightToPosition = vShadowCoord[ i ].xyz;\n\n\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t// bd3D = base direction 3D\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\t// dp = distance from light to fragment position\n\t\t\tfloat dp = length( lightToPosition );\n\n\t\t\t// base measurement\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\t// Dr = disk radius\n\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tconst float Dr = 1.25;\n\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tconst float Dr = 2.25;\n\t#endif\n\n\t\t\t// os = offset scale\n\t\t\tfloat os = Dr *  2.0 * texelSizeY;\n\n\t\t\tconst vec3 Gsd = vec3( - 1, 0, 1 );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xxy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xzy * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.zyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.xyx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxz * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yxx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D + Gsd.yzx * os, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tshadow *= realShadowDarkness * ( 1.0 / 21.0 );\n\n\t#else // no percentage-closer filtering:\n\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tfloat dp = length( lightToPosition );\n\n\t\t\tadjustShadowValue1K( dp, texture2D( shadowMap[ i ], cubeToUV( bd3D, texelSizeY ) ), shadowBias[ i ], shadow );\n\n\t\t\tshadow *= realShadowDarkness;\n\n\t#endif\n\n\t\t} else {\n\n#endif // POINT_LIGHT_SHADOWS\n\n\t\t\tfloat texelSizeX =  1.0 / shadowMapSize[ i ].x;\n\n\t\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t\tbool frustumTest = all( frustumTestVec );\n\n\t\t\tif ( frustumTest ) {\n\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t// Percentage-close filtering\n\t\t\t\t// (9 pixel kernel)\n\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\t\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\t\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\t\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\t\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\t\tshadow += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\tshadow /= 9.0;\n\t\t\t\t*/\n\n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tconst float ShadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = texelSizeX;\n\t\t\t\tfloat yPixelOffset = texelSizeY;\n\n\t\t\t\tfloat dx0 = - 1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = - 1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfloat fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += ShadowDelta;\n\n\t\t\t\tshadow *= shadowDarkness[ i ];\n\n\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t// Percentage-close filtering\n\t\t\t\t// (9 pixel kernel)\n\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tfloat xPixelOffset = texelSizeX;\n\t\t\t\tfloat yPixelOffset = texelSizeY;\n\n\t\t\t\tfloat dx0 = - 1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = - 1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[ 0 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[ 0 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[ 0 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[ 1 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[ 1 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[ 1 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 0 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 1 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[ 2 ][ 2 ] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[ 0 ] = vec3( lessThan( depthKernel[ 0 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 0 ] *= vec3( 0.25 );\n\n\t\t\t\tshadowKernel[ 1 ] = vec3( lessThan( depthKernel[ 1 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 1 ] *= vec3( 0.25 );\n\n\t\t\t\tshadowKernel[ 2 ] = vec3( lessThan( depthKernel[ 2 ], shadowZ ) );\n\t\t\t\tshadowKernel[ 2 ] *= vec3( 0.25 );\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[ i ].xy );\n\n\t\t\t\tshadowKernel[ 0 ] = mix( shadowKernel[ 1 ], shadowKernel[ 0 ], fractionalCoord.x );\n\t\t\t\tshadowKernel[ 1 ] = mix( shadowKernel[ 2 ], shadowKernel[ 1 ], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[ 0 ][ 1 ], shadowKernel[ 0 ][ 0 ], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[ 0 ][ 2 ], shadowKernel[ 0 ][ 1 ], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[ 1 ][ 1 ], shadowKernel[ 1 ][ 0 ], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[ 1 ][ 2 ], shadowKernel[ 1 ][ 1 ], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) ) * shadowDarkness[ i ];\n\n\t#else // no percentage-closer filtering:\n\n\t\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\tshadow = shadowDarkness[ i ];\n\n\t#endif\n\n\t\t\t}\n\n#ifdef SHADOWMAP_DEBUG\n\n\t\t\tif ( inFrustum ) {\n\n\t\t\t\tif ( i == 0 ) {\n\n\t\t\t\t\toutgoingLight *= vec3( 1.0, 0.5, 0.0 );\n\n\t\t\t\t} else if ( i == 1 ) {\n\n\t\t\t\t\toutgoingLight *= vec3( 0.0, 1.0, 0.8 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\toutgoingLight *= vec3( 0.0, 0.5, 1.0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n#endif\n\n#ifdef POINT_LIGHT_SHADOWS\n\n\t\t}\n\n#endif\n\n\t\tshadowMask = shadowMask * vec3( 1.0 - shadow );\n\n\t\tshadows[ i ] = 1.0 - shadow;\n\n\t}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] ="#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ NUM_SHADOWS ];\n\tuniform vec2 shadowMapSize[ NUM_SHADOWS ];\n\n\tuniform float shadowDarkness[ NUM_SHADOWS ];\n\tuniform float shadowBias[ NUM_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ NUM_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n\t#ifdef POINT_LIGHT_SHADOWS\n\n\t\t// adjustShadowValue1K() upacks the depth value stored in @textureData, adds @bias to it, and then\n\t\t// comapres the result with @testDepth. If @testDepth is larger than or equal to that result, then\n\t\t// @shadowValue is incremented by 1.0.\n\n\t\tvoid adjustShadowValue1K( const float testDepth, const vec4 textureData, const float bias, inout float shadowValue ) {\n\n\t\t\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\t\tif ( testDepth >= dot( textureData, bitSh ) * 1000.0 + bias )\n\t\t\t\tshadowValue += 1.0;\n\n\t\t}\n\n\t\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t\t// 2D texture:\n\t\t//\n\t\t// xzXZ\n\t\t//  y Y\n\t\t//\n\t\t// Y - Positive y direction\n\t\t// y - Negative y direction\n\t\t// X - Positive x direction\n\t\t// x - Negative x direction\n\t\t// Z - Positive z direction\n\t\t// z - Negative z direction\n\t\t//\n\t\t// Source and test bed:\n\t\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\t\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t\t// Number of texels to avoid at the edge of each square\n\n\t\t\tvec3 absV = abs( v );\n\n\t\t\t// Intersect unit cube\n\n\t\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\t\tabsV *= scaleToCube;\n\n\t\t\t// Apply scale to avoid seams\n\n\t\t\t// two texels less per square (one texel will do for NEAREST)\n\t\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t\t// Unwrap\n\n\t\t\t// space: -1 ... 1 range for each square\n\t\t\t//\n\t\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\t\tvec2 planar = v.xy;\n\n\t\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\t\tif ( absV.z >= almostOne ) {\n\n\t\t\t\tif ( v.z > 0.0 )\n\t\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\t\tfloat signX = sign( v.x );\n\t\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\t\tfloat signY = sign( v.y );\n\t\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t\t}\n\n\t\t\t// Transform to UV space\n\n\t\t\t// scale := 0.5 / dim\n\t\t\t// translate := ( center + 0.5 ) / dim\n\t\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t\t}\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\tuniform mat4 shadowMatrix[ NUM_SHADOWS ];\n\tvarying vec4 vShadowCoord[ NUM_SHADOWS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex' ] ="#ifdef USE_SHADOWMAP\n\n\tfor ( int i = 0; i < NUM_SHADOWS; i ++ ) {\n\n\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex' ] ="#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex' ] ="#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex' ] ="#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment' ] ="float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment' ] ="#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment' ] ="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex' ] ="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex' ] ="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex' ] ="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex' ] ="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n\t#endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

  merge: function ( uniforms ) {

    var merged = {};

    for ( var u = 0; u < uniforms.length; u ++ ) {

      var tmp = this.clone( uniforms[ u ] );

      for ( var p in tmp ) {

        merged[ p ] = tmp[ p ];

      }

    }

    return merged;

  },

  clone: function ( uniforms_src ) {

    var uniforms_dst = {};

    for ( var u in uniforms_src ) {

      uniforms_dst[ u ] = {};

      for ( var p in uniforms_src[ u ] ) {

        var parameter_src = uniforms_src[ u ][ p ];

        if ( parameter_src instanceof THREE.Color ||
           parameter_src instanceof THREE.Vector2 ||
           parameter_src instanceof THREE.Vector3 ||
           parameter_src instanceof THREE.Vector4 ||
           parameter_src instanceof THREE.Matrix3 ||
           parameter_src instanceof THREE.Matrix4 ||
           parameter_src instanceof THREE.Texture ) {

          uniforms_dst[ u ][ p ] = parameter_src.clone();

        } else if ( Array.isArray( parameter_src ) ) {

          uniforms_dst[ u ][ p ] = parameter_src.slice();

        } else {

          uniforms_dst[ u ][ p ] = parameter_src;

        }

      }

    }

    return uniforms_dst;

  }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

  common: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },

    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "specularMap" : { type: "t", value: null },
    "alphaMap" : { type: "t", value: null },

    "envMap" : { type: "t", value: null },
    "flipEnvMap" : { type: "f", value: - 1 },
    "reflectivity" : { type: "f", value: 1.0 },
    "refractionRatio" : { type: "f", value: 0.98 }

  },

  aomap: {

    "aoMap" : { type: "t", value: null },
    "aoMapIntensity" : { type: "f", value: 1 },

  },

  lightmap: {

    "lightMap" : { type: "t", value: null },
    "lightMapIntensity" : { type: "f", value: 1 },

  },

  emissivemap: {

    "emissiveMap" : { type: "t", value: null },

  },

  bumpmap: {

    "bumpMap" : { type: "t", value: null },
    "bumpScale" : { type: "f", value: 1 }

  },

  normalmap: {

    "normalMap" : { type: "t", value: null },
    "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }

  },

  displacementmap: {

    "displacementMap" : { type: "t", value: null },
    "displacementScale" : { type: "f", value: 1 },
    "displacementBias" : { type: "f", value: 0 }

  },

  roughnessmap: {

    "roughnessMap" : { type: "t", value: null }

  },

  metalnessmap: {

    "metalnessMap" : { type: "t", value: null }

  },

  fog: {

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  ambient: {

    "ambientLightColor" : { type: "fv", value: [] }

  },

  lights: {

    "directionalLights" : { type: "sa", value: [], properties: {
      "direction": { type: "v3" },
      "color": { type: "c" },
      "shadow": { type: "i" }
    } },

    "hemisphereLights" : { type: "sa", value: [], properties: {
      "direction": { type: "v3" },
      "skyColor": { type: "c" },
      "groundColor": { type: "c" }
    } },

    "pointLights" : { type: "sa", value: [], properties: {
      "color": { type: "c" },
      "position": { type: "v3" },
      "decay": { type: "f" },
      "distance": { type: "f" },
      "shadow": { type: "i" }
    } },

    "spotLights" : { type: "sa", value: [], properties: {
      "color": { type: "c" },
      "position": { type: "v3" },
      "direction": { type: "v3" },
      "distance": { type: "f" },
      "angleCos": { type: "f" },
      "exponent": { type: "f" },
      "decay": { type: "f" },
      "shadow": { type: "i" }
    } }

  },

  points: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },
    "size" : { type: "f", value: 1.0 },
    "scale" : { type: "f", value: 1.0 },
    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) }

  },

  shadowmap: {

    "shadowMap": { type: "tv", value: [] },
    "shadowMapSize": { type: "v2v", value: [] },

    "shadowBias" : { type: "fv1", value: [] },
    "shadowDarkness": { type: "fv1", value: [] },

    "shadowMatrix" : { type: "m4v", value: [] }

  }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

  'basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],

      " #ifdef USE_ENVMAP",

        THREE.ShaderChunk[ "beginnormal_vertex" ],
        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " #endif",

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

      " ReflectedLight reflectedLight;",
      " reflectedLight.directDiffuse = vec3( 0.0 );",
      " reflectedLight.directSpecular = vec3( 0.0 );",
      " reflectedLight.indirectDiffuse = diffuseColor.rgb;",
      " reflectedLight.indirectSpecular = vec3( 0.0 );",

        THREE.ShaderChunk[ "aomap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        "reflectedLight.indirectDiffuse *= shadowMask;",

        "vec3 outgoingLight = reflectedLight.indirectDiffuse;",

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'lambert': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "emissivemap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "ambient" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
      }

    ] ),

    vertexShader: [

      "#define LAMBERT",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "bsdfs" ],
      THREE.ShaderChunk[ "lights_pars" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "beginnormal_vertex" ],
        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_lambert_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform float opacity;",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "ambient_pars" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = getAmbientLightIrradiance( ambientLightColor );",
      " vec3 totalEmissiveLight = emissive;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "emissivemap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        // former lightmap_fragment.glsl
      " #ifdef USE_LIGHTMAP",

      "   totalAmbientLight += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;", // factor of PI should not be present; included here to prevent breakage

      " #endif",

        // former aomap_fragment.glsl
      " #ifdef USE_AOMAP",

      "   totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;",

      " #endif",

      " #ifdef DOUBLE_SIDED",

      "   if ( gl_FrontFacing )",
      "     outgoingLight += RECIPROCAL_PI * diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + totalEmissiveLight;",
      "   else",
      "     outgoingLight += RECIPROCAL_PI * diffuseColor.rgb * ( vLightBack * shadowMask + totalAmbientLight ) + totalEmissiveLight;",

      " #else",

      "   outgoingLight += RECIPROCAL_PI * diffuseColor.rgb * ( vLightFront * shadowMask + totalAmbientLight ) + totalEmissiveLight;",

      " #endif",

        THREE.ShaderChunk[ "envmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'phong': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "emissivemap" ],
      THREE.UniformsLib[ "bumpmap" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "displacementmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "ambient" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
        "shininess": { type: "f", value: 30 }
      }

    ] ),

    vertexShader: [

      "#define PHONG",

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "beginnormal_vertex" ],
        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

      " vNormal = normalize( transformedNormal );",

      "#endif",

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "displacementmap_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = - mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_phong_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "#define PHONG",

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "bsdfs" ],
      THREE.ShaderChunk[ "ambient_pars" ],
      THREE.ShaderChunk[ "lights_pars" ],
      THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
      " vec3 totalEmissiveLight = emissive;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "normal_fragment" ],
        THREE.ShaderChunk[ "emissivemap_fragment" ],

        THREE.ShaderChunk[ "shadowmap_fragment" ],

        // accumulation
        THREE.ShaderChunk[ "lights_phong_fragment" ],
        THREE.ShaderChunk[ "lights_template" ],

        // modulation
        THREE.ShaderChunk[ "aomap_fragment" ],

        "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'standard': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "emissivemap" ],
      THREE.UniformsLib[ "bumpmap" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "displacementmap" ],
      THREE.UniformsLib[ "roughnessmap" ],
      THREE.UniformsLib[ "metalnessmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "ambient" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "roughness": { type: "f", value: 0.5 },
        "metalness": { type: "f", value: 0 },
        "envMapIntensity" : { type: "f", value: 1 } // temporary
      }

    ] ),

    vertexShader: [

      "#define STANDARD",

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "displacementmap_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {", // STANDARD

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "beginnormal_vertex" ],
        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

      " vNormal = normalize( transformedNormal );",

      "#endif",

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "displacementmap_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = - mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "#define STANDARD",

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform float roughness;",
      "uniform float metalness;",
      "uniform float opacity;",

      "uniform float envMapIntensity;", // temporary

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "emissivemap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "bsdfs" ],
      THREE.ShaderChunk[ "ambient_pars" ],
      THREE.ShaderChunk[ "lights_pars" ],
      THREE.ShaderChunk[ "lights_standard_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "roughnessmap_pars_fragment" ],
      THREE.ShaderChunk[ "metalnessmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );",
      " vec3 totalEmissiveLight = emissive;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "roughnessmap_fragment" ],
        THREE.ShaderChunk[ "metalnessmap_fragment" ],
        THREE.ShaderChunk[ "normal_fragment" ],
        THREE.ShaderChunk[ "emissivemap_fragment" ],

        THREE.ShaderChunk[ "shadowmap_fragment" ],

        // accumulation
        THREE.ShaderChunk[ "lights_standard_fragment" ],
        THREE.ShaderChunk[ "lights_template" ],

        // modulation
        THREE.ShaderChunk[ "aomap_fragment" ],

        "vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveLight;",

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'points': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "points" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      "uniform float size;",
      "uniform float scale;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],

      " #ifdef USE_SIZEATTENUATION",
      "   gl_PointSize = size * ( scale / - mvPosition.z );",
      " #else",
      "   gl_PointSize = size;",
      " #endif",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_particle_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_particle_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

      " outgoingLight = diffuseColor.rgb * shadowMask;",

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'dashed': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],

      {
        "scale"    : { type: "f", value: 1 },
        "dashSize" : { type: "f", value: 1 },
        "totalSize": { type: "f", value: 2 }
      }

    ] ),

    vertexShader: [

      "uniform float scale;",
      "attribute float lineDistance;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vLineDistance = scale * lineDistance;",

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform float dashSize;",
      "uniform float totalSize;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " if ( mod( vLineDistance, totalSize ) > dashSize ) {",

      "   discard;",

      " }",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );",

      "}"

    ].join( "\n" )

  },

  'depth': {

    uniforms: {

      "mNear": { type: "f", value: 1.0 },
      "mFar" : { type: "f", value: 2000.0 },
      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform float mNear;",
      "uniform float mFar;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   float depth = gl_FragDepthEXT / gl_FragCoord.w;",

      " #else",

      "   float depth = gl_FragCoord.z / gl_FragCoord.w;",

      " #endif",

      " float color = 1.0 - smoothstep( mNear, mFar, depth );",
      " gl_FragColor = vec4( vec3( color ), opacity );",

      "}"

    ].join( "\n" )

  },

  'normal': {

    uniforms: {

      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vNormal = normalize( normalMatrix * normal );",

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform float opacity;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'cube': {

    uniforms: {
      "tCube": { type: "t", value: null },
      "tFlip": { type: "f", value: - 1 }
    },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform samplerCube tCube;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'equirect': {

    uniforms: {
      "tEquirect": { type: "t", value: null },
      "tFlip": { type: "f", value: - 1 }
    },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform sampler2D tEquirect;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        // "  gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
        "vec3 direction = normalize( vWorldPosition );",
        "vec2 sampleUV;",
        "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
        "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
        "gl_FragColor = texture2D( tEquirect, sampleUV );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join( "\n" )

  },

  /* Depth encoding into RGBA texture
   *
   * based on SpiderGL shadow map example
   * http://spidergl.org/example.php?id=6
   *
   * originally from
   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
   *
   * see also
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   */

  'depthRGBA': {

    uniforms: {},

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],

        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join( "\n" ),

    fragmentShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "vec4 pack_depth( const in float depth ) {",

      " const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      " const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      " vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "  vec4 res = fract( depth * bit_shift );",
      " res -= res.xxyz * bit_mask;",
      " return res;",

      "}",

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

      " #else",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

      " #endif",

        //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
        //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
        //"gl_FragData[ 0 ] = pack_depth( z );",
        //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

      "}"

    ].join( "\n" )

  },


  'distanceRGBA': {

    uniforms: {

      "lightPos": { type: "v3", value: new THREE.Vector3( 0, 0, 0 ) }

    },

    vertexShader: [

      "varying vec4 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "begin_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "project_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],

        "vWorldPosition = worldPosition;",

      "}"

    ].join( "\n" ),

    fragmentShader: [

      "uniform vec3 lightPos;",
      "varying vec4 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],

      "vec4 pack1K ( float depth ) {",

      "   depth /= 1000.0;",
      "   const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
        " const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
        " vec4 res = fract( depth * bitSh );",
        " res -= res.xxyz * bitMsk;",
        " return res; ",

      "}",

      "float unpack1K ( vec4 color ) {",

      " const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
      " return dot( color, bitSh ) * 1000.0;",

      "}",

      "void main () {",

      " gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );",

      "}"

    ].join( "\n" )

  }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

  console.log( 'THREE.WebGLRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
  _context = parameters.context !== undefined ? parameters.context : null,

  _width = _canvas.width,
  _height = _canvas.height,

  pixelRatio = 1,

  _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  _depth = parameters.depth !== undefined ? parameters.depth : true,
  _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

  _clearColor = new THREE.Color( 0x000000 ),
  _clearAlpha = 0;

  var lights = [];

  var opaqueObjects = [];
  var opaqueObjectsLastIndex = - 1;
  var transparentObjects = [];
  var transparentObjectsLastIndex = - 1;

  var morphInfluences = new Float32Array( 8 );


  var sprites = [];
  var lensFlares = [];

  // public properties

  this.domElement = _canvas;
  this.context = null;

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility
  this.gammaInput = false;
  this.gammaOutput = false;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // flags

  this.autoScaleCubemaps = true;

  // internal properties

  var _this = this,

  // internal state cache

  _currentViewport = null,
  _currentProgram = null,
  _currentRenderTarget = null,
  _currentFramebuffer = null,
  _currentMaterialId = - 1,
  _currentGeometryProgram = '',
  _currentCamera = null,

  _usedTextureUnits = 0,

  _scissor = new THREE.Vector4( 0, 0, _canvas.width, _canvas.height ),
  _scissorTest = false,

  _viewport = new THREE.Vector4( 0, 0, _canvas.width, _canvas.height ),

  // frustum

  _frustum = new THREE.Frustum(),

   // camera matrices cache

  _projScreenMatrix = new THREE.Matrix4(),

  _vector3 = new THREE.Vector3(),

  // light arrays cache

  _lights = {

    hash: '',

    ambient: [ 0, 0, 0 ],
    directional: [],
    point: [],
    spot: [],
    hemi: [],

    shadows: [],
    shadowsPointLight: 0

  },

  // info

  _infoMemory = {

    geometries: 0,
    textures: 0

  },

  _infoRender = {

    calls: 0,
    vertices: 0,
    faces: 0,
    points: 0

  };

  this.info = {

    render: _infoRender,
    memory: _infoMemory,
    programs: null

  };


  // initialize

  var _gl;

  try {

    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };

    _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    if ( _gl === null ) {

      if ( _canvas.getContext( 'webgl' ) !== null ) {

        throw 'Error creating WebGL context with your selected attributes.';

      } else {

        throw 'Error creating WebGL context.';

      }

    }

    _canvas.addEventListener( 'webglcontextlost', onContextLost, false );

  } catch ( error ) {

    console.error( 'THREE.WebGLRenderer: ' + error );

  }

  var extensions = new THREE.WebGLExtensions( _gl );

  extensions.get( 'OES_texture_float' );
  extensions.get( 'OES_texture_float_linear' );
  extensions.get( 'OES_texture_half_float' );
  extensions.get( 'OES_texture_half_float_linear' );
  extensions.get( 'OES_standard_derivatives' );
  extensions.get( 'ANGLE_instanced_arrays' );

  if ( extensions.get( 'OES_element_index_uint' ) ) {

    THREE.BufferGeometry.MaxIndex = 4294967296;

  }

  var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

  var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
  var properties = new THREE.WebGLProperties();
  var objects = new THREE.WebGLObjects( _gl, properties, this.info );
  var programCache = new THREE.WebGLPrograms( this, capabilities );
  var lightCache = new THREE.WebGLLights();

  this.info.programs = programCache.programs;

  var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
  var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

  //

  function getTargetPixelRatio() {

    return _currentRenderTarget === null ? pixelRatio : 1;

  }

  function glClearColor( r, g, b, a ) {

    if ( _premultipliedAlpha === true ) {

      r *= a; g *= a; b *= a;

    }

    _gl.clearColor( r, g, b, a );

  }

  function setDefaultGLState() {

    state.init();

    state.scissor( _scissor );
    state.viewport( _viewport );

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  }

  function resetGLState() {

    _currentProgram = null;
    _currentCamera = null;

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;

    state.reset();

  }

  setDefaultGLState();

  this.context = _gl;
  this.capabilities = capabilities;
  this.extensions = extensions;
  this.properties = properties;
  this.state = state;

  // shadow map

  var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );

  this.shadowMap = shadowMap;


  // Plugins

  var spritePlugin = new THREE.SpritePlugin( this, sprites );
  var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

  // API

  this.getContext = function () {

    return _gl;

  };

  this.getContextAttributes = function () {

    return _gl.getContextAttributes();

  };

  this.forceContextLoss = function () {

    extensions.get( 'WEBGL_lose_context' ).loseContext();

  };

  this.getMaxAnisotropy = ( function () {

    var value;

    return function getMaxAnisotropy() {

      if ( value !== undefined ) return value;

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension !== null ) {

        value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

      } else {

        value = 0;

      }

      return value;

    };

  } )();

  this.getPrecision = function () {

    return capabilities.precision;

  };

  this.getPixelRatio = function () {

    return pixelRatio;

  };

  this.setPixelRatio = function ( value ) {

    if ( value !== undefined ) pixelRatio = value;

  };

  this.getSize = function () {

    return {
      width: _width,
      height: _height
    };

  };

  this.setSize = function ( width, height, updateStyle ) {

    _width = width;
    _height = height;

    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewport.set( x, y, width, height ).multiplyScalar( pixelRatio );

    state.viewport( _viewport );

  };

  this.setScissor = function ( x, y, width, height ) {

    _scissor.set( x, y, width, height ).multiplyScalar( pixelRatio );

    state.scissor( _scissor );

  };

  this.setScissorTest = function ( boolean ) {

    _scissorTest = boolean;

    state.setScissorTest( boolean );

  };

  // Clearing

  this.getClearColor = function () {

    return _clearColor;

  };

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );

    _clearAlpha = alpha !== undefined ? alpha : 1;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.setClearAlpha = function ( alpha ) {

    _clearAlpha = alpha;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.clear = function ( color, depth, stencil ) {

    var bits = 0;

    if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear( bits );

  };

  this.clearColor = function () {

    _gl.clear( _gl.COLOR_BUFFER_BIT );

  };

  this.clearDepth = function () {

    _gl.clear( _gl.DEPTH_BUFFER_BIT );

  };

  this.clearStencil = function () {

    _gl.clear( _gl.STENCIL_BUFFER_BIT );

  };

  this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    this.setRenderTarget( renderTarget );
    this.clear( color, depth, stencil );

  };

  // Reset

  this.resetGLState = resetGLState;

  this.dispose = function() {

    _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

  };

  // Events

  function onContextLost( event ) {

    event.preventDefault();

    resetGLState();
    setDefaultGLState();

    properties.clear();

  }

  function onTextureDispose( event ) {

    var texture = event.target;

    texture.removeEventListener( 'dispose', onTextureDispose );

    deallocateTexture( texture );

    _infoMemory.textures --;


  }

  function onRenderTargetDispose( event ) {

    var renderTarget = event.target;

    renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    deallocateRenderTarget( renderTarget );

    _infoMemory.textures --;

  }

  function onMaterialDispose( event ) {

    var material = event.target;

    material.removeEventListener( 'dispose', onMaterialDispose );

    deallocateMaterial( material );

  }

  // Buffer deallocation

  function deallocateTexture( texture ) {

    var textureProperties = properties.get( texture );

    if ( texture.image && textureProperties.__image__webglTextureCube ) {

      // cube texture

      _gl.deleteTexture( textureProperties.__image__webglTextureCube );

    } else {

      // 2D texture

      if ( textureProperties.__webglInit === undefined ) return;

      _gl.deleteTexture( textureProperties.__webglTexture );

    }

    // remove all webgl properties
    properties.delete( texture );

  }

  function deallocateRenderTarget( renderTarget ) {

    var renderTargetProperties = properties.get( renderTarget );
    var textureProperties = properties.get( renderTarget.texture );

    if ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;

    _gl.deleteTexture( textureProperties.__webglTexture );

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      for ( var i = 0; i < 6; i ++ ) {

        _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
        _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

      }

    } else {

      _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
      _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

    }

    properties.delete( renderTarget.texture );
    properties.delete( renderTarget );

  }

  function deallocateMaterial( material ) {

    releaseMaterialProgramReference( material );

    properties.delete( material );

  }


  function releaseMaterialProgramReference( material ) {

    var programInfo = properties.get( material ).program;

    material.program = undefined;

    if ( programInfo !== undefined ) {

      programCache.releaseProgram( programInfo );

    }

  }

  // Buffer rendering

  this.renderBufferImmediate = function ( object, program, material ) {

    state.initAttributes();

    var buffers = properties.get( object );

    if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    var attributes = program.getAttributes();

    if ( object.hasPositions ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasNormals ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

      if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {

        for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

          var array = object.normalArray;

          var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
          var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
          var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

          array[ i + 0 ] = nx;
          array[ i + 1 ] = ny;
          array[ i + 2 ] = nz;

          array[ i + 3 ] = nx;
          array[ i + 4 ] = ny;
          array[ i + 5 ] = nz;

          array[ i + 6 ] = nx;
          array[ i + 7 ] = ny;
          array[ i + 8 ] = nz;

        }

      }

      _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.normal );

      _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasUvs && material.map ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.uv );

      _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.color );

      _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    }

    state.disableUnusedAttributes();

    _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    object.count = 0;

  };

  this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

    setMaterial( material );

    var program = setProgram( camera, fog, material, object );

    var updateBuffers = false;
    var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    if ( geometryProgram !== _currentGeometryProgram ) {

      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;

    }

    // morph targets

    var morphTargetInfluences = object.morphTargetInfluences;

    if ( morphTargetInfluences !== undefined ) {

      var activeInfluences = [];

      for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

        var influence = morphTargetInfluences[ i ];
        activeInfluences.push( [ influence, i ] );

      }

      activeInfluences.sort( absNumericalSort );

      if ( activeInfluences.length > 8 ) {

        activeInfluences.length = 8;

      }

      var morphAttributes = geometry.morphAttributes;

      for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

        var influence = activeInfluences[ i ];
        morphInfluences[ i ] = influence[ 0 ];

        if ( influence[ 0 ] !== 0 ) {

          var index = influence[ 1 ];

          if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
          if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

        } else {

          if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
          if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

        }

      }

      var uniforms = program.getUniforms();

      if ( uniforms.morphTargetInfluences !== null ) {

        _gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );

      }

      updateBuffers = true;

    }

    //

    var index = geometry.index;
    var position = geometry.attributes.position;

    if ( material.wireframe === true ) {

      index = objects.getWireframeAttribute( geometry );

    }

    var renderer;

    if ( index !== null ) {

      renderer = indexedBufferRenderer;
      renderer.setIndex( index );

    } else {

      renderer = bufferRenderer;

    }

    if ( updateBuffers ) {

      setupVertexAttributes( material, program, geometry );

      if ( index !== null ) {

        _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

      }

    }

    //

    var dataStart = 0;
    var dataCount = Infinity;

    if ( index !== null ) {

      dataCount = index.count;

    } else if ( position !== undefined ) {

      dataCount = position.count;

    }

    var rangeStart = geometry.drawRange.start;
    var rangeCount = geometry.drawRange.count;

    var groupStart = group !== null ? group.start : 0;
    var groupCount = group !== null ? group.count : Infinity;

    var drawStart = Math.max( dataStart, rangeStart, groupStart );
    var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

    var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

    //

    if ( object instanceof THREE.Mesh ) {

      if ( material.wireframe === true ) {

        state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
        renderer.setMode( _gl.LINES );

      } else {

        switch ( object.drawMode ) {

          case THREE.TrianglesDrawMode:
            renderer.setMode( _gl.TRIANGLES );
            break;

          case THREE.TriangleStripDrawMode:
            renderer.setMode( _gl.TRIANGLE_STRIP );
            break;

          case THREE.TriangleFanDrawMode:
            renderer.setMode( _gl.TRIANGLE_FAN );
            break;

        }

      }


    } else if ( object instanceof THREE.Line ) {

      var lineWidth = material.linewidth;

      if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

      state.setLineWidth( lineWidth * getTargetPixelRatio() );

      if ( object instanceof THREE.LineSegments ) {

        renderer.setMode( _gl.LINES );

      } else {

        renderer.setMode( _gl.LINE_STRIP );

      }

    } else if ( object instanceof THREE.Points ) {

      renderer.setMode( _gl.POINTS );

    }

    if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

      renderer.renderInstances( geometry, drawStart, drawCount );

    } else {

      renderer.render( drawStart, drawCount );

    }

  };

  function setupVertexAttributes( material, program, geometry, startIndex ) {

    var extension;

    if ( geometry instanceof THREE.InstancedBufferGeometry ) {

      extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

    }

    if ( startIndex === undefined ) startIndex = 0;

    state.initAttributes();

    var geometryAttributes = geometry.attributes;

    var programAttributes = program.getAttributes();

    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for ( var name in programAttributes ) {

      var programAttribute = programAttributes[ name ];

      if ( programAttribute >= 0 ) {

        var geometryAttribute = geometryAttributes[ name ];

        if ( geometryAttribute !== undefined ) {

          var size = geometryAttribute.itemSize;
          var buffer = objects.getAttributeBuffer( geometryAttribute );

          if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            if ( data instanceof THREE.InstancedInterleavedBuffer ) {

              state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = data.meshPerAttribute * data.count;

              }

            } else {

              state.enableAttribute( programAttribute );

            }

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

          } else {

            if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

              state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

              }

            } else {

              state.enableAttribute( programAttribute );

            }

            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

          }

        } else if ( materialDefaultAttributeValues !== undefined ) {

          var value = materialDefaultAttributeValues[ name ];

          if ( value !== undefined ) {

            switch ( value.length ) {

              case 2:
                _gl.vertexAttrib2fv( programAttribute, value );
                break;

              case 3:
                _gl.vertexAttrib3fv( programAttribute, value );
                break;

              case 4:
                _gl.vertexAttrib4fv( programAttribute, value );
                break;

              default:
                _gl.vertexAttrib1fv( programAttribute, value );

            }

          }

        }

      }

    }

    state.disableUnusedAttributes();

  }

  // Sorting

  function absNumericalSort( a, b ) {

    return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

  }

  function painterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } else if ( a.material.id !== b.material.id ) {

      return a.material.id - b.material.id;

    } else if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  // Rendering

  this.render = function ( scene, camera, renderTarget, forceClear ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var fog = scene.fog;

    // reset caching for this frame

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;
    _currentCamera = null;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if ( camera.parent === null ) camera.updateMatrixWorld();

    camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    _frustum.setFromMatrix( _projScreenMatrix );

    lights.length = 0;

    opaqueObjectsLastIndex = - 1;
    transparentObjectsLastIndex = - 1;

    sprites.length = 0;
    lensFlares.length = 0;

    projectObject( scene, camera );

    opaqueObjects.length = opaqueObjectsLastIndex + 1;
    transparentObjects.length = transparentObjectsLastIndex + 1;

    if ( _this.sortObjects === true ) {

      opaqueObjects.sort( painterSortStable );
      transparentObjects.sort( reversePainterSortStable );

    }

    setupLights( lights, camera );

    //

    shadowMap.render( scene, camera );

    //

    _infoRender.calls = 0;
    _infoRender.vertices = 0;
    _infoRender.faces = 0;
    _infoRender.points = 0;

    if ( renderTarget === undefined ) {

      renderTarget = null;

    }

    this.setRenderTarget( renderTarget );

    if ( this.autoClear || forceClear ) {

      this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    }

    //

    if ( scene.overrideMaterial ) {

      var overrideMaterial = scene.overrideMaterial;

      renderObjects( opaqueObjects, camera, fog, overrideMaterial );
      renderObjects( transparentObjects, camera, fog, overrideMaterial );

    } else {

      // opaque pass (front-to-back order)

      state.setBlending( THREE.NoBlending );
      renderObjects( opaqueObjects, camera, fog );

      // transparent pass (back-to-front order)

      renderObjects( transparentObjects, camera, fog );

    }

    // custom render plugins (post pass)

    spritePlugin.render( scene, camera );
    lensFlarePlugin.render( scene, camera, _currentViewport );

    // Generate mipmap if we're using any kind of mipmap filtering

    if ( renderTarget ) {

      var texture = renderTarget.texture;

      if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
          texture.minFilter !== THREE.NearestFilter &&
          texture.minFilter !== THREE.LinearFilter ) {

        updateRenderTargetMipmap( renderTarget );

      }

    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.setDepthTest( true );
    state.setDepthWrite( true );
    state.setColorWrite( true );

    // _gl.finish();

  };

  function pushRenderItem( object, geometry, material, z, group ) {

    var array, index;

    // allocate the next position in the appropriate array

    if ( material.transparent ) {

      array = transparentObjects;
      index = ++ transparentObjectsLastIndex;

    } else {

      array = opaqueObjects;
      index = ++ opaqueObjectsLastIndex;

    }

    // recycle existing render item or grow the array

    var renderItem = array[ index ];

    if ( renderItem !== undefined ) {

      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.z = _vector3.z;
      renderItem.group = group;

    } else {

      renderItem = {
        id: object.id,
        object: object,
        geometry: geometry,
        material: material,
        z: _vector3.z,
        group: group
      };

      // assert( index === array.length );
      array.push( renderItem );

    }

  }

  function projectObject( object, camera ) {

    if ( object.visible === false ) return;

    if ( object.layers.test( camera.layers ) ) {

      if ( object instanceof THREE.Light ) {

        lights.push( object );

      } else if ( object instanceof THREE.Sprite ) {

        if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

          sprites.push( object );

        }

      } else if ( object instanceof THREE.LensFlare ) {

        lensFlares.push( object );

      } else if ( object instanceof THREE.ImmediateRenderObject ) {

        if ( _this.sortObjects === true ) {

          _vector3.setFromMatrixPosition( object.matrixWorld );
          _vector3.applyProjection( _projScreenMatrix );

        }

        pushRenderItem( object, null, object.material, _vector3.z, null );

      } else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

        if ( object instanceof THREE.SkinnedMesh ) {

          object.skeleton.update();

        }

        if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

          var material = object.material;

          if ( material.visible === true ) {

            if ( _this.sortObjects === true ) {

              _vector3.setFromMatrixPosition( object.matrixWorld );
              _vector3.applyProjection( _projScreenMatrix );

            }

            var geometry = objects.update( object );

            if ( material instanceof THREE.MultiMaterial ) {

              var groups = geometry.groups;
              var materials = material.materials;

              for ( var i = 0, l = groups.length; i < l; i ++ ) {

                var group = groups[ i ];
                var groupMaterial = materials[ group.materialIndex ];

                if ( groupMaterial.visible === true ) {

                  pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

                }

              }

            } else {

              pushRenderItem( object, geometry, material, _vector3.z, null );

            }

          }

        }

      }

    }

    var children = object.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      projectObject( children[ i ], camera );

    }

  }

  function renderObjects( renderList, camera, fog, overrideMaterial ) {

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var renderItem = renderList[ i ];

      var object = renderItem.object;
      var geometry = renderItem.geometry;
      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
      var group = renderItem.group;

      object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
      object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

      if ( object instanceof THREE.ImmediateRenderObject ) {

        setMaterial( material );

        var program = setProgram( camera, fog, material, object );

        _currentGeometryProgram = '';

        object.render( function ( object ) {

          _this.renderBufferImmediate( object, program, material );

        } );

      } else {

        _this.renderBufferDirect( camera, fog, geometry, material, object, group );

      }

    }

  }

  function initMaterial( material, fog, object ) {

    var materialProperties = properties.get( material );

    var parameters = programCache.getParameters( material, _lights, fog, object );
    var code = programCache.getProgramCode( material, parameters );

    var program = materialProperties.program;
    var programChange = true;

    if ( program === undefined ) {

      // new material
      material.addEventListener( 'dispose', onMaterialDispose );

    } else if ( program.code !== code ) {

      // changed glsl or parameters
      releaseMaterialProgramReference( material );

    } else if ( parameters.shaderID !== undefined ) {

      // same glsl and uniform list
      return;

    } else {

      // only rebuild uniform list
      programChange = false;

    }

    if ( programChange ) {

      if ( parameters.shaderID ) {

        var shader = THREE.ShaderLib[ parameters.shaderID ];

        materialProperties.__webglShader = {
          name: material.type,
          uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader
        };

      } else {

        materialProperties.__webglShader = {
          name: material.type,
          uniforms: material.uniforms,
          vertexShader: material.vertexShader,
          fragmentShader: material.fragmentShader
        };

      }

      material.__webglShader = materialProperties.__webglShader;

      program = programCache.acquireProgram( material, parameters, code );

      materialProperties.program = program;
      material.program = program;

    }

    var attributes = program.getAttributes();

    if ( material.morphTargets ) {

      material.numSupportedMorphTargets = 0;

      for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

        if ( attributes[ 'morphTarget' + i ] >= 0 ) {

          material.numSupportedMorphTargets ++;

        }

      }

    }

    if ( material.morphNormals ) {

      material.numSupportedMorphNormals = 0;

      for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

        if ( attributes[ 'morphNormal' + i ] >= 0 ) {

          material.numSupportedMorphNormals ++;

        }

      }

    }

    materialProperties.uniformsList = [];

    var uniforms = materialProperties.__webglShader.uniforms,
      uniformLocations = materialProperties.program.getUniforms();

    for ( var u in uniforms ) {

      var location = uniformLocations[ u ];

      if ( location ) {

        materialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );

      }

    }

    if ( material instanceof THREE.MeshPhongMaterial ||
        material instanceof THREE.MeshLambertMaterial ||
        material instanceof THREE.MeshStandardMaterial ||
        material.lights ) {

      // store the light setup it was created for

      materialProperties.lightsHash = _lights.hash;

      // wire up the material to this renderer's lighting state

      uniforms.ambientLightColor.value = _lights.ambient;
      uniforms.directionalLights.value = _lights.directional;
      uniforms.pointLights.value = _lights.point;
      uniforms.spotLights.value = _lights.spot;
      uniforms.hemisphereLights.value = _lights.hemi;

    }

    // detect dynamic uniforms

    materialProperties.hasDynamicUniforms = false;

    for ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {

      var uniform = materialProperties.uniformsList[ j ][ 0 ];

      if ( uniform.dynamic === true ) {

        materialProperties.hasDynamicUniforms = true;
        break;

      }

    }

  }

  function setMaterial( material ) {

    setMaterialFaces( material );

    if ( material.transparent === true ) {

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

    } else {

      state.setBlending( THREE.NoBlending );

    }

    state.setDepthFunc( material.depthFunc );
    state.setDepthTest( material.depthTest );
    state.setDepthWrite( material.depthWrite );
    state.setColorWrite( material.colorWrite );
    state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  }

  function setMaterialFaces( material ) {

    material.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );
    state.setFlipSided( material.side === THREE.BackSide );

  }

  function setProgram( camera, fog, material, object ) {

    _usedTextureUnits = 0;

    var materialProperties = properties.get( material );

    if ( materialProperties.program === undefined ) {

      material.needsUpdate = true;

    }

    if ( materialProperties.lightsHash !== undefined &&
      materialProperties.lightsHash !== _lights.hash ) {

      material.needsUpdate = true;

    }

    if ( material.needsUpdate ) {

      initMaterial( material, fog, object );
      material.needsUpdate = false;

    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;

    var program = materialProperties.program,
      p_uniforms = program.getUniforms(),
      m_uniforms = materialProperties.__webglShader.uniforms;

    if ( program.id !== _currentProgram ) {

      _gl.useProgram( program.program );
      _currentProgram = program.id;

      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;

    }

    if ( material.id !== _currentMaterialId ) {

      _currentMaterialId = material.id;

      refreshMaterial = true;

    }

    if ( refreshProgram || camera !== _currentCamera ) {

      _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      if ( capabilities.logarithmicDepthBuffer ) {

        _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

      }


      if ( camera !== _currentCamera ) {

        _currentCamera = camera;

        // lighting uniforms depend on the camera so enforce an update
        // now, in case this material supports lights - or later, when
        // the next material that does gets activated:

        refreshMaterial = true;   // set to true on material change
        refreshLights = true;   // remains set until update done

      }

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if ( material instanceof THREE.ShaderMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshStandardMaterial ||
         material.envMap ) {

        if ( p_uniforms.cameraPosition !== undefined ) {

          _vector3.setFromMatrixPosition( camera.matrixWorld );
          _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

        }

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshStandardMaterial ||
         material instanceof THREE.ShaderMaterial ||
         material.skinning ) {

        if ( p_uniforms.viewMatrix !== undefined ) {

          _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

        }

      }

    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen

    if ( material.skinning ) {

      if ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

      }

      if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

      }

      if ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {

        if ( p_uniforms.boneTexture !== undefined ) {

          var textureUnit = getTextureUnit();

          _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
          _this.setTexture( object.skeleton.boneTexture, textureUnit );

        }

        if ( p_uniforms.boneTextureWidth !== undefined ) {

          _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

        }

        if ( p_uniforms.boneTextureHeight !== undefined ) {

          _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

        }

      } else if ( object.skeleton && object.skeleton.boneMatrices ) {

        if ( p_uniforms.boneGlobalMatrices !== undefined ) {

          _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

        }

      }

    }

    if ( refreshMaterial ) {

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshStandardMaterial ||
         material.lights ) {

        // the current material requires lighting info

        // note: all lighting uniforms are always set correctly
        // they simply reference the renderer's state for their
        // values
        //
        // use the current material's .needsUpdate flags to set
        // the GL state when required

        markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

      }

      // refresh uniforms common to several materials

      if ( fog && material.fog ) {

        refreshUniformsFog( m_uniforms, fog );

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshStandardMaterial ) {

        refreshUniformsCommon( m_uniforms, material );

      }

      // refresh single material specific uniforms

      if ( material instanceof THREE.LineBasicMaterial ) {

        refreshUniformsLine( m_uniforms, material );

      } else if ( material instanceof THREE.LineDashedMaterial ) {

        refreshUniformsLine( m_uniforms, material );
        refreshUniformsDash( m_uniforms, material );

      } else if ( material instanceof THREE.PointsMaterial ) {

        refreshUniformsPoints( m_uniforms, material );

      } else if ( material instanceof THREE.MeshLambertMaterial ) {

        refreshUniformsLambert( m_uniforms, material );

      } else if ( material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsPhong( m_uniforms, material );

      } else if ( material instanceof THREE.MeshStandardMaterial ) {

        refreshUniformsStandard( m_uniforms, material );

      } else if ( material instanceof THREE.MeshDepthMaterial ) {

        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;

      } else if ( material instanceof THREE.MeshNormalMaterial ) {

        m_uniforms.opacity.value = material.opacity;

      }

      if ( shadowMap.enabled ) {

        if ( object.receiveShadow && ! material._shadowPass ) {

          refreshUniformsShadow( m_uniforms, camera );

        }

      }

      // load common uniforms

      loadUniformsGeneric( materialProperties.uniformsList );

    }

    loadUniformsMatrices( p_uniforms, object );

    if ( p_uniforms.modelMatrix !== undefined ) {

      _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

    }

    if ( materialProperties.hasDynamicUniforms === true ) {

      updateDynamicUniforms( materialProperties.uniformsList, object, camera );

    }

    return program;

  }

  function updateDynamicUniforms ( uniforms, object, camera ) {

    var dynamicUniforms = [];

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];
      var onUpdateCallback = uniform.onUpdateCallback;

      if ( onUpdateCallback !== undefined ) {

        onUpdateCallback.bind( uniform )( object, camera );
        dynamicUniforms.push( uniforms[ j ] );

      }

    }

    loadUniformsGeneric( dynamicUniforms );

  }

  // Uniforms (refresh uniforms objects)

  function refreshUniformsCommon ( uniforms, material ) {

    uniforms.opacity.value = material.opacity;

    uniforms.diffuse.value = material.color;

    if ( material.emissive ) {

      uniforms.emissive.value = material.emissive;

    }

    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;

    if ( material.aoMap ) {

      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;

    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map
    // 6. emissive map

    var uvScaleMap;

    if ( material.map ) {

      uvScaleMap = material.map;

    } else if ( material.specularMap ) {

      uvScaleMap = material.specularMap;

    } else if ( material.displacementMap ) {

      uvScaleMap = material.displacementMap;

    } else if ( material.normalMap ) {

      uvScaleMap = material.normalMap;

    } else if ( material.bumpMap ) {

      uvScaleMap = material.bumpMap;

    } else if ( material.roughnessMap ) {

      uvScaleMap = material.roughnessMap;

    } else if ( material.metalnessMap ) {

      uvScaleMap = material.metalnessMap;

    } else if ( material.alphaMap ) {

      uvScaleMap = material.alphaMap;

    } else if ( material.emissiveMap ) {

      uvScaleMap = material.emissiveMap;

    }

    if ( uvScaleMap !== undefined ) {

      if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {

        uvScaleMap = uvScaleMap.texture;

      }

      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;

  }

  function refreshUniformsLine ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;

  }

  function refreshUniformsDash ( uniforms, material ) {

    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;

  }

  function refreshUniformsPoints ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

    uniforms.map.value = material.map;

    if ( material.map !== null ) {

      var offset = material.map.offset;
      var repeat = material.map.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

  }

  function refreshUniformsFog ( uniforms, fog ) {

    uniforms.fogColor.value = fog.color;

    if ( fog instanceof THREE.Fog ) {

      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;

    } else if ( fog instanceof THREE.FogExp2 ) {

      uniforms.fogDensity.value = fog.density;

    }

  }

  function refreshUniformsLambert ( uniforms, material ) {

    if ( material.lightMap ) {

      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;

    }

    if ( material.emissiveMap ) {

      uniforms.emissiveMap.value = material.emissiveMap;

    }

  }

  function refreshUniformsPhong ( uniforms, material ) {

    uniforms.specular.value = material.specular;
    uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    if ( material.lightMap ) {

      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;

    }

    if ( material.emissiveMap ) {

      uniforms.emissiveMap.value = material.emissiveMap;

    }

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    if ( material.displacementMap ) {

      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;

    }

  }

  function refreshUniformsStandard ( uniforms, material ) {

    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;

    if ( material.roughnessMap ) {

      uniforms.roughnessMap.value = material.roughnessMap;

    }

    if ( material.metalnessMap ) {

      uniforms.metalnessMap.value = material.metalnessMap;

    }

    if ( material.lightMap ) {

      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;

    }

    if ( material.emissiveMap ) {

      uniforms.emissiveMap.value = material.emissiveMap;

    }

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    if ( material.displacementMap ) {

      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;

    }

    if ( material.envMap ) {

      //uniforms.envMap.value = material.envMap; // part of uniforms common
      uniforms.envMapIntensity.value = material.envMapIntensity;

    }

  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate ( uniforms, value ) {

    uniforms.ambientLightColor.needsUpdate = value;

    uniforms.directionalLights.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;

  }

  function refreshUniformsShadow ( uniforms, camera ) {

    if ( uniforms.shadowMatrix ) {

      var shadows = _lights.shadows;

      for ( var i = 0, l = shadows.length; i < l; i ++ ) {

        var light = shadows[ i ];
        var shadow = light.shadow;

        if ( light instanceof THREE.PointLight ) {

          // for point lights we set the shadow matrix to be a translation-only matrix
          // equal to inverse of the light's position
          _vector3.setFromMatrixPosition( light.matrixWorld ).negate();
          shadow.matrix.identity().setPosition( _vector3 );

          // for point lights we set the sign of the shadowDarkness uniform to be negative
          uniforms.shadowDarkness.value[ i ] = - shadow.darkness;

        } else {

          uniforms.shadowDarkness.value[ i ] = shadow.darkness;

        }

        uniforms.shadowBias.value[ i ] = shadow.bias;
        uniforms.shadowMap.value[ i ] = shadow.map;
        uniforms.shadowMapSize.value[ i ] = shadow.mapSize;
        uniforms.shadowMatrix.value[ i ] = shadow.matrix;

      }

    }

  }

  // Uniforms (load to GPU)

  function loadUniformsMatrices ( uniforms, object ) {

    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );

    if ( uniforms.normalMatrix ) {

      _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );

    }

  }

  function getTextureUnit() {

    var textureUnit = _usedTextureUnits;

    if ( textureUnit >= capabilities.maxTextures ) {

      console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

    }

    _usedTextureUnits += 1;

    return textureUnit;

  }

  function loadUniformsGeneric ( uniforms ) {

    var texture, textureUnit;

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];

      // needsUpdate property is not added to all uniforms.
      if ( uniform.needsUpdate === false ) continue;

      var type = uniform.type;
      var value = uniform.value;
      var location = uniforms[ j ][ 1 ];

      switch ( type ) {

        case '1i':
          _gl.uniform1i( location, value );
          break;

        case '1f':
          _gl.uniform1f( location, value );
          break;

        case '2f':
          _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
          break;

        case '3f':
          _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
          break;

        case '4f':
          _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
          break;

        case '1iv':
          _gl.uniform1iv( location, value );
          break;

        case '3iv':
          _gl.uniform3iv( location, value );
          break;

        case '1fv':
          _gl.uniform1fv( location, value );
          break;

        case '2fv':
          _gl.uniform2fv( location, value );
          break;

        case '3fv':
          _gl.uniform3fv( location, value );
          break;

        case '4fv':
          _gl.uniform4fv( location, value );
          break;

        case 'Matrix2fv':
          _gl.uniformMatrix2fv( location, false, value );
          break;

        case 'Matrix3fv':
          _gl.uniformMatrix3fv( location, false, value );
          break;

        case 'Matrix4fv':
          _gl.uniformMatrix4fv( location, false, value );
          break;

        //

        case 'i':

          // single integer
          _gl.uniform1i( location, value );

          break;

        case 'f':

          // single float
          _gl.uniform1f( location, value );

          break;

        case 'v2':

          // single THREE.Vector2
          _gl.uniform2f( location, value.x, value.y );

          break;

        case 'v3':

          // single THREE.Vector3
          _gl.uniform3f( location, value.x, value.y, value.z );

          break;

        case 'v4':

          // single THREE.Vector4
          _gl.uniform4f( location, value.x, value.y, value.z, value.w );

          break;

        case 'c':

          // single THREE.Color
          _gl.uniform3f( location, value.r, value.g, value.b );

          break;

        /*
        case 's':

          // TODO: Optimize this.
          for( var propertyName in uniform.properties ) {

            var property = uniform.properties[ propertyName ];
            var locationProperty =  location[ propertyName ];
            var valueProperty = value[ propertyName ];

            switch( property.type ) {
              case 'i':
                _gl.uniform1i( locationProperty, valueProperty );
                break;
              case 'f':
                _gl.uniform1f( locationProperty, valueProperty );
                break;
              case 'v2':
                _gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
                break;
              case 'v3':
                _gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
                break;
              case 'v4':
                _gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
                break;
              case 'c':
                _gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
                break;
            };

          }

          break;
        */

        case 'sa':

          // TODO: Optimize this.
          for ( var i = 0; i < value.length; i ++ ) {

            for ( var propertyName in uniform.properties ) {

              var property = uniform.properties[ propertyName ];
              var locationProperty =  location[ i ][ propertyName ];
              var valueProperty = value[ i ][ propertyName ];

              switch ( property.type ) {
                case 'i':
                  _gl.uniform1i( locationProperty, valueProperty );
                  break;
                case 'f':
                  _gl.uniform1f( locationProperty, valueProperty );
                  break;
                case 'v2':
                  _gl.uniform2f( locationProperty, valueProperty.x, valueProperty.y );
                  break;
                case 'v3':
                  _gl.uniform3f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z );
                  break;
                case 'v4':
                  _gl.uniform4f( locationProperty, valueProperty.x, valueProperty.y, valueProperty.z, valueProperty.w );
                  break;
                case 'c':
                  _gl.uniform3f( locationProperty, valueProperty.r, valueProperty.g, valueProperty.b );
                  break;
              }

            }

          }

          break;

        case 'iv1':

          // flat array of integers (JS or typed array)
          _gl.uniform1iv( location, value );

          break;

        case 'iv':

          // flat array of integers with 3 x N size (JS or typed array)
          _gl.uniform3iv( location, value );

          break;

        case 'fv1':

          // flat array of floats (JS or typed array)
          _gl.uniform1fv( location, value );

          break;

        case 'fv':

          // flat array of floats with 3 x N size (JS or typed array)
          _gl.uniform3fv( location, value );

          break;

        case 'v2v':

          // array of THREE.Vector2

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 2 * value.length );

          }

          for ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {

            uniform._array[ i2 + 0 ] = value[ i ].x;
            uniform._array[ i2 + 1 ] = value[ i ].y;

          }

          _gl.uniform2fv( location, uniform._array );

          break;

        case 'v3v':

          // array of THREE.Vector3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 3 * value.length );

          }

          for ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {

            uniform._array[ i3 + 0 ] = value[ i ].x;
            uniform._array[ i3 + 1 ] = value[ i ].y;
            uniform._array[ i3 + 2 ] = value[ i ].z;

          }

          _gl.uniform3fv( location, uniform._array );

          break;

        case 'v4v':

          // array of THREE.Vector4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 4 * value.length );

          }

          for ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {

            uniform._array[ i4 + 0 ] = value[ i ].x;
            uniform._array[ i4 + 1 ] = value[ i ].y;
            uniform._array[ i4 + 2 ] = value[ i ].z;
            uniform._array[ i4 + 3 ] = value[ i ].w;

          }

          _gl.uniform4fv( location, uniform._array );

          break;

        case 'm2':

          // single THREE.Matrix2
          _gl.uniformMatrix2fv( location, false, value.elements );

          break;

        case 'm3':

          // single THREE.Matrix3
          _gl.uniformMatrix3fv( location, false, value.elements );

          break;

        case 'm3v':

          // array of THREE.Matrix3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 9 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

          }

          _gl.uniformMatrix3fv( location, false, uniform._array );

          break;

        case 'm4':

          // single THREE.Matrix4
          _gl.uniformMatrix4fv( location, false, value.elements );

          break;

        case 'm4v':

          // array of THREE.Matrix4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 16 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

          }

          _gl.uniformMatrix4fv( location, false, uniform._array );

          break;

        case 't':

          // single THREE.Texture (2d or cube)

          texture = value;
          textureUnit = getTextureUnit();

          _gl.uniform1i( location, textureUnit );

          if ( ! texture ) continue;

          if ( texture instanceof THREE.CubeTexture ||
             ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

            // CompressedTexture can have Array in image :/

            setCubeTexture( texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

            setCubeTextureDynamic( texture.texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTarget ) {

            _this.setTexture( texture.texture, textureUnit );

          } else {

            _this.setTexture( texture, textureUnit );

          }

          break;

        case 'tv':

          // array of THREE.Texture (2d or cube)

          if ( uniform._array === undefined ) {

            uniform._array = [];

          }

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            uniform._array[ i ] = getTextureUnit();

          }

          _gl.uniform1iv( location, uniform._array );

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            texture = uniform.value[ i ];
            textureUnit = uniform._array[ i ];

            if ( ! texture ) continue;

            if ( texture instanceof THREE.CubeTexture ||
               ( texture.image instanceof Array && texture.image.length === 6 ) ) {

              // CompressedTexture can have Array in image :/

              setCubeTexture( texture, textureUnit );

            } else if ( texture instanceof THREE.WebGLRenderTarget ) {

              _this.setTexture( texture.texture, textureUnit );

            } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

              setCubeTextureDynamic( texture.texture, textureUnit );

            } else {

              _this.setTexture( texture, textureUnit );

            }

          }

          break;

        default:

          console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

      }

    }

  }

  function setupLights ( lights, camera ) {

    var l, ll, light,
    r = 0, g = 0, b = 0,
    color,
    intensity,
    distance,

    viewMatrix = camera.matrixWorldInverse,

    directionalLength = 0,
    pointLength = 0,
    spotLength = 0,
    hemiLength = 0,

    shadowsLength = 0;

    _lights.shadowsPointLight = 0;

    for ( l = 0, ll = lights.length; l < ll; l ++ ) {

      light = lights[ l ];

      color = light.color;
      intensity = light.intensity;
      distance = light.distance;

      if ( light instanceof THREE.AmbientLight ) {

        r += color.r * intensity;
        g += color.g * intensity;
        b += color.b * intensity;

      } else if ( light instanceof THREE.DirectionalLight ) {

        var uniforms = lightCache.get( light );

        uniforms.direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        uniforms.direction.sub( _vector3 );
        uniforms.direction.transformDirection( viewMatrix );
        uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

        if ( light.castShadow ) {

          uniforms.shadow = shadowsLength;

          _lights.shadows[ shadowsLength ++ ] = light;

        } else {

          uniforms.shadow = - 1;

        }

        _lights.directional[ directionalLength ++ ] = uniforms;

      } else if ( light instanceof THREE.PointLight ) {

        var uniforms = lightCache.get( light );

        uniforms.position.setFromMatrixPosition( light.matrixWorld );
        uniforms.position.applyMatrix4( viewMatrix );

        uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
        uniforms.distance = light.distance;
        uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

        if ( light.castShadow ) {

          uniforms.shadow = shadowsLength;

          _lights.shadows[ shadowsLength ++ ] = light;
          _lights.shadowsPointLight ++;

        } else {

          uniforms.shadow = - 1;

        }

        _lights.point[ pointLength ++ ] = uniforms;

      } else if ( light instanceof THREE.SpotLight ) {

        var uniforms = lightCache.get( light );

        uniforms.position.setFromMatrixPosition( light.matrixWorld );
        uniforms.position.applyMatrix4( viewMatrix );

        uniforms.color.copy( color ).multiplyScalar( intensity );
        uniforms.distance = distance;

        uniforms.direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        uniforms.direction.sub( _vector3 );
        uniforms.direction.transformDirection( viewMatrix );

        uniforms.angleCos = Math.cos( light.angle );
        uniforms.exponent = light.exponent;
        uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

        if ( light.castShadow ) {

          uniforms.shadow = shadowsLength;

          _lights.shadows[ shadowsLength ++ ] = light;

        } else {

          uniforms.shadow = - 1;

        }

        _lights.spot[ spotLength ++ ] = uniforms;

      } else if ( light instanceof THREE.HemisphereLight ) {

        var uniforms = lightCache.get( light );

        uniforms.direction.setFromMatrixPosition( light.matrixWorld );
        uniforms.direction.transformDirection( viewMatrix );
        uniforms.direction.normalize();

        uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
        uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

        _lights.hemi[ hemiLength ++ ] = uniforms;

      }

    }

    _lights.ambient[ 0 ] = r;
    _lights.ambient[ 1 ] = g;
    _lights.ambient[ 2 ] = b;

    _lights.directional.length = directionalLength;
    _lights.point.length = pointLength;
    _lights.spot.length = spotLength;
    _lights.hemi.length = hemiLength;

    _lights.shadows.length = shadowsLength;

    _lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;

  }

  // GL state setting

  this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    if ( cullFace === THREE.CullFaceNone ) {

      state.disable( _gl.CULL_FACE );

    } else {

      if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      if ( cullFace === THREE.CullFaceBack ) {

        _gl.cullFace( _gl.BACK );

      } else if ( cullFace === THREE.CullFaceFront ) {

        _gl.cullFace( _gl.FRONT );

      } else {

        _gl.cullFace( _gl.FRONT_AND_BACK );

      }

      state.enable( _gl.CULL_FACE );

    }

  };

  // Textures

  function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

    var extension;

    if ( isImagePowerOfTwo ) {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    } else {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

      if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

      }

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

      if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

      }

    }

    extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    if ( extension ) {

      if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
      if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

      if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

        _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
        properties.get( texture ).__currentAnisotropy = texture.anisotropy;

      }

    }

  }

  function uploadTexture( textureProperties, texture, slot ) {

    if ( textureProperties.__webglInit === undefined ) {

      textureProperties.__webglInit = true;

      texture.addEventListener( 'dispose', onTextureDispose );

      textureProperties.__webglTexture = _gl.createTexture();

      _infoMemory.textures ++;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    texture.image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

    if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false ) {

      texture.image = makePowerOfTwo( texture.image );

    }

    var image = texture.image,
    isImagePowerOfTwo = isPowerOfTwo( image ),
    glFormat = paramThreeToGL( texture.format ),
    glType = paramThreeToGL( texture.type );

    setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

    var mipmap, mipmaps = texture.mipmaps;

    if ( texture instanceof THREE.DataTexture ) {

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

      }

    } else if ( texture instanceof THREE.CompressedTexture ) {

      for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

        mipmap = mipmaps[ i ];

        if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

          if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

            state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

          } else {

            console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

          }

        } else {

          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

      }

    } else {

      // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

      }

    }

    if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

    textureProperties.__version = texture.version;

    if ( texture.onUpdate ) texture.onUpdate( texture );

  }

  this.setTexture = function ( texture, slot ) {

    var textureProperties = properties.get( texture );

    if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

      var image = texture.image;

      if ( image === undefined ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
        return;

      }

      if ( image.complete === false ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
        return;

      }

      uploadTexture( textureProperties, texture, slot );

      return;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

  };

  function clampToMaxSize ( image, maxSize ) {

    if ( image.width > maxSize || image.height > maxSize ) {

      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.

      var scale = maxSize / Math.max( image.width, image.height );

      var canvas = document.createElement( 'canvas' );
      canvas.width = Math.floor( image.width * scale );
      canvas.height = Math.floor( image.height * scale );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

      console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

      return canvas;

    }

    return image;

  }

  function isPowerOfTwo( image ) {

    return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

  }

  function textureNeedsPowerOfTwo( texture ) {

    if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
    if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

    return false;

  }

  function makePowerOfTwo( image ) {

    if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

      var canvas = document.createElement( 'canvas' );
      canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
      canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, canvas.width, canvas.height );

      console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

      return canvas;

    }

    return image;

  }

  function setCubeTexture ( texture, slot ) {

    var textureProperties = properties.get( texture );

    if ( texture.image.length === 6 ) {

      if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

        if ( ! textureProperties.__image__webglTextureCube ) {

          texture.addEventListener( 'dispose', onTextureDispose );

          textureProperties.__image__webglTextureCube = _gl.createTexture();

          _infoMemory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

        var cubeImage = [];

        for ( var i = 0; i < 6; i ++ ) {

          if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

            cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

          } else {

            cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

          }

        }

        var image = cubeImage[ 0 ],
        isImagePowerOfTwo = isPowerOfTwo( image ),
        glFormat = paramThreeToGL( texture.format ),
        glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          if ( ! isCompressed ) {

            if ( isDataTexture ) {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

            } else {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

            }

          } else {

            var mipmap, mipmaps = cubeImage[ i ].mipmaps;

            for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

              mipmap = mipmaps[ j ];

              if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

                  state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                  console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                }

              } else {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

              }

            }

          }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) {

          _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

        }

        textureProperties.__version = texture.version;

        if ( texture.onUpdate ) texture.onUpdate( texture );

      } else {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

      }

    }

  }

  function setCubeTextureDynamic ( texture, slot ) {

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

  }

  // Render targets

  // Setup storage for target texture and bind it to correct framebuffer
  function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {

    var glFormat = paramThreeToGL( renderTarget.texture.format );
    var glType = paramThreeToGL( renderTarget.texture.type );
    state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
    _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    _gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
    _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  }

  // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
  function setupRenderBufferStorage ( renderbuffer, renderTarget ) {

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else {

      // FIXME: We don't support !depth !stencil
      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    }

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

  }

  // Setup GL resources for a non-texture depth buffer
  function setupDepthRenderbuffer( renderTarget ) {

    var renderTargetProperties = properties.get( renderTarget );

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

    if ( isCube ) {

      renderTargetProperties.__webglDepthbuffer = [];

      for ( var i = 0; i < 6; i ++ ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
        renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
        setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

      }

    } else {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
      renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
      setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

    }

    _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

  }

  // Set up GL resources for the render target
  function setupRenderTarget( renderTarget ) {

    var renderTargetProperties = properties.get( renderTarget );
    var textureProperties = properties.get( renderTarget.texture );

    renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    textureProperties.__webglTexture = _gl.createTexture();

    _infoMemory.textures ++;

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
    var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );

    // Setup framebuffer

    if ( isCube ) {

      renderTargetProperties.__webglFramebuffer = [];

      for ( var i = 0; i < 6; i ++ ) {

        renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

      }

    } else {

      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    }

    // Setup color buffer

    if ( isCube ) {

      state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
      setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

      for ( var i = 0; i < 6; i ++ ) {

        setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

      }

      if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
      state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    } else {

      state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
      setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
      setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

      if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
      state.bindTexture( _gl.TEXTURE_2D, null );

    }

    // Setup depth and stencil buffers

    if ( renderTarget.depthBuffer ) {

      setupDepthRenderbuffer( renderTarget );

    }

  }

  this.setRenderTarget = function ( renderTarget ) {

    _currentRenderTarget = renderTarget;

    if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

      setupRenderTarget( renderTarget );

    }

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
    var framebuffer, scissor, scissorTest, viewport;

    if ( renderTarget ) {

      var renderTargetProperties = properties.get( renderTarget );

      if ( isCube ) {

        framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

      } else {

        framebuffer = renderTargetProperties.__webglFramebuffer;

      }

      scissor = renderTarget.scissor;
      scissorTest = renderTarget.scissorTest;

      viewport = renderTarget.viewport;

    } else {

      framebuffer = null;

      scissor = _scissor;
      scissorTest = _scissorTest;

      viewport = _viewport;

    }

    if ( framebuffer !== _currentFramebuffer ) {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

      _currentFramebuffer = framebuffer;

    }

    state.scissor( scissor );
    state.setScissorTest( scissorTest );

    state.viewport( viewport );

    if ( isCube ) {

      var textureProperties = properties.get( renderTarget.texture );
      _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, 0 );

    }

    _currentViewport = viewport;

  };

  this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

    if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

      console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
      return;

    }

    var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    if ( framebuffer ) {

      var restore = false;

      if ( framebuffer !== _currentFramebuffer ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

        restore = true;

      }

      try {

        var texture = renderTarget.texture;

        if ( texture.format !== THREE.RGBAFormat
          && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

          console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
          return;

        }

        if ( texture.type !== THREE.UnsignedByteType
          && paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )
          && ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )
          && ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

          console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
          return;

        }

        if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

          _gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

        } else {

          console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

        }

      } finally {

        if ( restore ) {

          _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

        }

      }

    }

  };

  function updateRenderTargetMipmap( renderTarget ) {

    var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    var texture = properties.get( renderTarget.texture ).__webglTexture;

    state.bindTexture( target, texture );
    _gl.generateMipmap( target );
    state.bindTexture( target, null );

  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback ( f ) {

    if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

      return _gl.NEAREST;

    }

    return _gl.LINEAR;

  }

  // Map three.js constants to WebGL constants

  function paramThreeToGL ( p ) {

    var extension;

    if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
    if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    if ( p === THREE.NearestFilter ) return _gl.NEAREST;
    if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    if ( p === THREE.LinearFilter ) return _gl.LINEAR;
    if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    if ( p === THREE.ByteType ) return _gl.BYTE;
    if ( p === THREE.ShortType ) return _gl.SHORT;
    if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    if ( p === THREE.IntType ) return _gl.INT;
    if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
    if ( p === THREE.FloatType ) return _gl.FLOAT;

    extension = extensions.get( 'OES_texture_half_float' );

    if ( extension !== null ) {

      if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

    }

    if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
    if ( p === THREE.RGBFormat ) return _gl.RGB;
    if ( p === THREE.RGBAFormat ) return _gl.RGBA;
    if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
    if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

    if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
    if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
    if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    if ( p === THREE.ZeroFactor ) return _gl.ZERO;
    if ( p === THREE.OneFactor ) return _gl.ONE;
    if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
    if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
    if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
    if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
    if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    }

    extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    }

    extension = extensions.get( 'EXT_blend_minmax' );

    if ( extension !== null ) {

      if ( p === THREE.MinEquation ) return extension.MIN_EXT;
      if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

    }

    return 0;

  }

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
THREE.WebGLRenderTarget = function ( width, height, options ) {

  this.uuid = THREE.Math.generateUUID();

  this.width = width;
  this.height = height;

  this.scissor = new THREE.Vector4( 0, 0, width, height );
  this.scissorTest = false;

  this.viewport = new THREE.Vector4( 0, 0, width, height );

  options = options || {};

  if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

  this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );

  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

};

THREE.WebGLRenderTarget.prototype = {

  constructor: THREE.WebGLRenderTarget,

  setSize: function ( width, height ) {

    if ( this.width !== width || this.height !== height ) {

      this.width = width;
      this.height = height;

      this.dispose();

    }

    this.viewport.set( 0, 0, width, height );
    this.scissor.set( 0, 0, width, height );

  },

  clone: function () {

    return new this.constructor().copy( this );

  },

  copy: function ( source ) {

    this.width = source.width;
    this.height = source.height;

    this.viewport.copy( source.viewport );

    this.texture = source.texture.clone();

    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;

    this.shareDepthFrom = source.shareDepthFrom;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

  THREE.WebGLRenderTarget.call( this, width, height, options );

  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

  var mode;

  function setMode( value ) {

    mode = value;

  }

  function render( start, count ) {

    _gl.drawArrays( mode, start, count );

    _infoRender.calls ++;
    _infoRender.vertices += count;
    if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

  }

  function renderInstances( geometry ) {

    var extension = extensions.get( 'ANGLE_instanced_arrays' );

    if ( extension === null ) {

      console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
      return;

    }

    var position = geometry.attributes.position;

    if ( position instanceof THREE.InterleavedBufferAttribute ) {

      extension.drawArraysInstancedANGLE( mode, 0, position.data.count, geometry.maxInstancedCount );

    } else {

      extension.drawArraysInstancedANGLE( mode, 0, position.count, geometry.maxInstancedCount );

    }

  }

  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

  var mode;

  function setMode( value ) {

    mode = value;

  }

  var type, size;

  function setIndex( index ) {

    if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

      type = _gl.UNSIGNED_INT;
      size = 4;

    } else {

      type = _gl.UNSIGNED_SHORT;
      size = 2;

    }

  }

  function render( start, count ) {

    _gl.drawElements( mode, count, type, start * size );

    _infoRender.calls ++;
    _infoRender.vertices += count;
    if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

  }

  function renderInstances( geometry, start, count ) {

    var extension = extensions.get( 'ANGLE_instanced_arrays' );

    if ( extension === null ) {

      console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
      return;

    }

    extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

  }

  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

  var extensions = {};

  this.get = function ( name ) {

    if ( extensions[ name ] !== undefined ) {

      return extensions[ name ];

    }

    var extension;

    switch ( name ) {

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
        break;

      default:
        extension = gl.getExtension( name );

    }

    if ( extension === null ) {

      console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    }

    extensions[ name ] = extension;

    return extension;

  };

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

  function getMaxPrecision( precision ) {

    if ( precision === 'highp' ) {

      if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
           gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

        return 'highp';

      }

      precision = 'mediump';

    }

    if ( precision === 'mediump' ) {

      if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
           gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

        return 'mediump';

      }

    }

    return 'lowp';

  }

  this.getMaxPrecision = getMaxPrecision;

  this.precision = parameters.precision !== undefined ? parameters.precision : 'highp',
  this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

  this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
  this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
  this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
  this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
  this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
  this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

  this.vertexTextures = this.maxVertexTextures > 0;
  this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
  this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

  var _maxPrecision = getMaxPrecision( this.precision );

  if ( _maxPrecision !== this.precision ) {

    console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
    this.precision = _maxPrecision;

  }

  if ( this.logarithmicDepthBuffer ) {

    this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

  }

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

  var geometries = {};

  function get( object ) {

    var geometry = object.geometry;

    if ( geometries[ geometry.id ] !== undefined ) {

      return geometries[ geometry.id ];

    }

    geometry.addEventListener( 'dispose', onGeometryDispose );

    var buffergeometry;

    if ( geometry instanceof THREE.BufferGeometry ) {

      buffergeometry = geometry;

    } else if ( geometry instanceof THREE.Geometry ) {

      if ( geometry._bufferGeometry === undefined ) {

        geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

      }

      buffergeometry = geometry._bufferGeometry;

    }

    geometries[ geometry.id ] = buffergeometry;

    info.memory.geometries ++;

    return buffergeometry;

  }

  function onGeometryDispose( event ) {

    var geometry = event.target;
    var buffergeometry = geometries[ geometry.id ];

    if ( buffergeometry.index !== null ) {

      deleteAttribute( buffergeometry.index );

    }

    deleteAttributes( buffergeometry.attributes );

    geometry.removeEventListener( 'dispose', onGeometryDispose );

    delete geometries[ geometry.id ];

    // TODO

    var property = properties.get( geometry );

    if ( property.wireframe ) {

      deleteAttribute( property.wireframe );

    }

    properties.delete( geometry );

    var bufferproperty = properties.get( buffergeometry );

    if ( bufferproperty.wireframe ) {

      deleteAttribute( bufferproperty.wireframe );

    }

    properties.delete( buffergeometry );

    //

    info.memory.geometries --;

  }

  function getAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      return properties.get( attribute.data ).__webglBuffer;

    }

    return properties.get( attribute ).__webglBuffer;

  }

  function deleteAttribute( attribute ) {

    var buffer = getAttributeBuffer( attribute );

    if ( buffer !== undefined ) {

      gl.deleteBuffer( buffer );
      removeAttributeBuffer( attribute );

    }

  }

  function deleteAttributes( attributes ) {

    for ( var name in attributes ) {

      deleteAttribute( attributes[ name ] );

    }

  }

  function removeAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      properties.delete( attribute.data );

    } else {

      properties.delete( attribute );

    }

  }

  this.get = get;

};

// File:src/renderers/webgl/WebGLLights.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLLights = function () {

  var lights = {};

  this.get = function ( light ) {

    if ( lights[ light.id ] !== undefined ) {

      return lights[ light.id ];

    }

    var uniforms;

    switch ( light.type ) {

      case 'HemisphereLight':
        uniforms = {
          direction: new THREE.Vector3(),
          skyColor: new THREE.Color(),
          groundColor: new THREE.Color()
        };
        break;

      case 'DirectionalLight':
        uniforms = {
          direction: new THREE.Vector3(),
          color: new THREE.Color(),
          shadow: -1
        };
        break;

      case 'PointLight':
        uniforms = {
          position: new THREE.Vector3(),
          color: new THREE.Color(),
          distance: 0,
          decay: 0,
          shadow: -1
        };
        break;

      case 'SpotLight':
        uniforms = {
          position: new THREE.Vector3(),
          direction: new THREE.Vector3(),
          color: new THREE.Color(),
          distance: 0,
          angleCos: 0,
          exponent: 0,
          decay: 0,
          shadow: -1
        };
        break;

    }

    lights[ light.id ] = uniforms;

    return uniforms;

  };

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

  var geometries = new THREE.WebGLGeometries( gl, properties, info );

  //

  function update( object ) {

    // TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    var geometry = geometries.get( object );

    if ( object.geometry instanceof THREE.Geometry ) {

      geometry.updateFromObject( object );

    }

    var index = geometry.index;
    var attributes = geometry.attributes;

    if ( index !== null ) {

      updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

    }

    for ( var name in attributes ) {

      updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

    }

    // morph targets

    var morphAttributes = geometry.morphAttributes;

    for ( var name in morphAttributes ) {

      var array = morphAttributes[ name ];

      for ( var i = 0, l = array.length; i < l; i ++ ) {

        updateAttribute( array[ i ], gl.ARRAY_BUFFER );

      }

    }

    return geometry;

  }

  function updateAttribute( attribute, bufferType ) {

    var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

    var attributeProperties = properties.get( data );

    if ( attributeProperties.__webglBuffer === undefined ) {

      createBuffer( attributeProperties, data, bufferType );

    } else if ( attributeProperties.version !== data.version ) {

      updateBuffer( attributeProperties, data, bufferType );

    }

  }

  function createBuffer( attributeProperties, data, bufferType ) {

    attributeProperties.__webglBuffer = gl.createBuffer();
    gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

    gl.bufferData( bufferType, data.array, usage );

    attributeProperties.version = data.version;

  }

  function updateBuffer( attributeProperties, data, bufferType ) {

    gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    if ( data.dynamic === false || data.updateRange.count === - 1 ) {

      // Not using update ranges

      gl.bufferSubData( bufferType, 0, data.array );

    } else if ( data.updateRange.count === 0 ) {

      console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

    } else {

      gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

      data.updateRange.count = 0; // reset range

    }

    attributeProperties.version = data.version;

  }

  function getAttributeBuffer( attribute ) {

    if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

      return properties.get( attribute.data ).__webglBuffer;

    }

    return properties.get( attribute ).__webglBuffer;

  }

  function getWireframeAttribute( geometry ) {

    var property = properties.get( geometry );

    if ( property.wireframe !== undefined ) {

      return property.wireframe;

    }

    var indices = [];

    var index = geometry.index;
    var attributes = geometry.attributes;
    var position = attributes.position;

    // console.time( 'wireframe' );

    if ( index !== null ) {

      var edges = {};
      var array = index.array;

      for ( var i = 0, l = array.length; i < l; i += 3 ) {

        var a = array[ i + 0 ];
        var b = array[ i + 1 ];
        var c = array[ i + 2 ];

        if ( checkEdge( edges, a, b ) ) indices.push( a, b );
        if ( checkEdge( edges, b, c ) ) indices.push( b, c );
        if ( checkEdge( edges, c, a ) ) indices.push( c, a );

      }

    } else {

      var array = attributes.position.array;

      for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

        var a = i + 0;
        var b = i + 1;
        var c = i + 2;

        indices.push( a, b, b, c, c, a );

      }

    }

    // console.timeEnd( 'wireframe' );

    var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

    updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

    property.wireframe = attribute;

    return attribute;

  }

  function checkEdge( edges, a, b ) {

    if ( a > b ) {

      var tmp = a;
      a = b;
      b = tmp;

    }

    var list = edges[ a ];

    if ( list === undefined ) {

      edges[ a ] = [ b ];
      return true;

    } else if ( list.indexOf( b ) === -1 ) {

      list.push( b );
      return true;

    }

    return false;

  }

  this.getAttributeBuffer = getAttributeBuffer;
  this.getWireframeAttribute = getWireframeAttribute;

  this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

  var programIdCount = 0;

  // TODO: Combine the regex
  var structRe = /^([\w\d_]+)\.([\w\d_]+)$/;
  var arrayStructRe = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/;
  var arrayRe = /^([\w\d_]+)\[0\]$/;

  function generateExtensions( extensions, parameters, rendererExtensions ) {

    extensions = extensions || {};

    var chunks = [
      ( extensions.derivatives || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
      ( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
      ( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
      ( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    ];

    return chunks.filter( filterEmptyLine ).join( '\n' );

  }

  function generateDefines( defines ) {

    var chunks = [];

    for ( var name in defines ) {

      var value = defines[ name ];

      if ( value === false ) continue;

      chunks.push( '#define ' + name + ' ' + value );

    }

    return chunks.join( '\n' );

  }

  function fetchUniformLocations( gl, program, identifiers ) {

    var uniforms = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveUniform( program, i );
      var name = info.name;
      var location = gl.getUniformLocation( program, name );

      //console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

      var matches = structRe.exec( name );
      if ( matches ) {

        var structName = matches[ 1 ];
        var structProperty = matches[ 2 ];

        var uniformsStruct = uniforms[ structName ];

        if ( ! uniformsStruct ) {

          uniformsStruct = uniforms[ structName ] = {};

        }

        uniformsStruct[ structProperty ] = location;

        continue;

      }

      matches = arrayStructRe.exec( name );

      if ( matches ) {

        var arrayName = matches[ 1 ];
        var arrayIndex = matches[ 2 ];
        var arrayProperty = matches[ 3 ];

        var uniformsArray = uniforms[ arrayName ];

        if ( ! uniformsArray ) {

          uniformsArray = uniforms[ arrayName ] = [];

        }

        var uniformsArrayIndex = uniformsArray[ arrayIndex ];

        if ( ! uniformsArrayIndex ) {

          uniformsArrayIndex = uniformsArray[ arrayIndex ] = {};

        }

        uniformsArrayIndex[ arrayProperty ] = location;

        continue;

      }

      matches = arrayRe.exec( name );

      if ( matches ) {

        var arrayName = matches[ 1 ];

        uniforms[ arrayName ] = location;

        continue;

      }

      uniforms[ name ] = location;

    }

    return uniforms;

  }

  function fetchAttributeLocations( gl, program, identifiers ) {

    var attributes = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveAttrib( program, i );
      var name = info.name;

      // console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

      attributes[ name ] = gl.getAttribLocation( program, name );

    }

    return attributes;

  }

  function filterEmptyLine( string ) {

    return string !== '';

  }

  return function WebGLProgram( renderer, code, material, parameters ) {

    var gl = renderer.context;

    var extensions = material.extensions;
    var defines = material.defines;

    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;

    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    }

    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    if ( parameters.envMap ) {

      switch ( material.envMap.mapping ) {

        case THREE.CubeReflectionMapping:
        case THREE.CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case THREE.EquirectangularReflectionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case THREE.SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;

      }

      switch ( material.envMap.mapping ) {

        case THREE.CubeRefractionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;

      }

      switch ( material.combine ) {

        case THREE.MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case THREE.MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case THREE.AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;

      }

    }

    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    // console.log( 'building new program ' );

    //

    var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

    var customDefines = generateDefines( defines );

    //

    var program = gl.createProgram();

    var prefixVertex, prefixFragment;

    if ( material instanceof THREE.RawShaderMaterial ) {

      prefixVertex = '';
      prefixFragment = '';

    } else {

      prefixVertex = [

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + material.__webglShader.name,

        customDefines,

        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        '#define NUM_DIR_LIGHTS ' + parameters.numDirLights,
        '#define NUM_POINT_LIGHTS ' + parameters.numPointLights,
        '#define NUM_SPOT_LIGHTS ' + parameters.numSpotLights,
        '#define NUM_HEMI_LIGHTS ' + parameters.numHemiLights,

        '#define NUM_SHADOWS ' + parameters.numShadows,

        '#define MAX_BONES ' + parameters.maxBones,

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',


        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',

        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        '#ifdef USE_COLOR',

        ' attribute vec3 color;',

        '#endif',

        '#ifdef USE_MORPHTARGETS',

        ' attribute vec3 morphTarget0;',
        ' attribute vec3 morphTarget1;',
        ' attribute vec3 morphTarget2;',
        ' attribute vec3 morphTarget3;',

        ' #ifdef USE_MORPHNORMALS',

        '   attribute vec3 morphNormal0;',
        '   attribute vec3 morphNormal1;',
        '   attribute vec3 morphNormal2;',
        '   attribute vec3 morphNormal3;',

        ' #else',

        '   attribute vec3 morphTarget4;',
        '   attribute vec3 morphTarget5;',
        '   attribute vec3 morphTarget6;',
        '   attribute vec3 morphTarget7;',

        ' #endif',

        '#endif',

        '#ifdef USE_SKINNING',

        ' attribute vec4 skinIndex;',
        ' attribute vec4 skinWeight;',

        '#endif',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );


      prefixFragment = [

        customExtensions,

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        '#define SHADER_NAME ' + material.__webglShader.name,

        customDefines,

        '#define NUM_DIR_LIGHTS ' + parameters.numDirLights,
        '#define NUM_POINT_LIGHTS ' + parameters.numPointLights,
        '#define NUM_SPOT_LIGHTS ' + parameters.numSpotLights,
        '#define NUM_HEMI_LIGHTS ' + parameters.numHemiLights,

        '#define NUM_SHADOWS ' + parameters.numShadows,

        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
        parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED' : '',

        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

        parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;

    var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    gl.attachShader( program, glVertexShader );
    gl.attachShader( program, glFragmentShader );

    // Force a particular attribute to index 0.

    if ( material.index0AttributeName !== undefined ) {

      gl.bindAttribLocation( program, 0, material.index0AttributeName );

    } else if ( parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0
      gl.bindAttribLocation( program, 0, 'position' );

    }

    gl.linkProgram( program );

    var programLog = gl.getProgramInfoLog( program );
    var vertexLog = gl.getShaderInfoLog( glVertexShader );
    var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    var runnable = true;
    var haveDiagnostics = true;

    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

      runnable = false;

      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    } else if ( programLog !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    } else if ( vertexLog === '' || fragmentLog === '' ) {

      haveDiagnostics = false;

    }

    if ( haveDiagnostics ) {

      this.diagnostics = {

        runnable: runnable,
        material: material,

        programLog: programLog,

        vertexShader: {

          log: vertexLog,
          prefix: prefixVertex

        },

        fragmentShader: {

          log: fragmentLog,
          prefix: prefixFragment

        }

      };

    }

    // clean up

    gl.deleteShader( glVertexShader );
    gl.deleteShader( glFragmentShader );

    // set up caching for uniform locations

    var cachedUniforms;

    this.getUniforms = function() {

      if ( cachedUniforms === undefined ) {

        cachedUniforms = fetchUniformLocations( gl, program );

      }

      return cachedUniforms;

    };

    // set up caching for attribute locations

    var cachedAttributes;

    this.getAttributes = function() {

      if ( cachedAttributes === undefined ) {

        cachedAttributes = fetchAttributeLocations( gl, program );

      }

      return cachedAttributes;

    };

    // free resource

    this.destroy = function() {

      gl.deleteProgram( program );
      this.program = undefined;

    };

    // DEPRECATED

    Object.defineProperties( this, {

      uniforms: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
          return this.getUniforms();

        }
      },

      attributes: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
          return this.getAttributes();

        }
      }

    } );


    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  };

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

  var programs = [];

  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshStandardMaterial: 'standard',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points'
  };

  var parameterNames = [
    "precision", "supportsVertexTextures", "map", "envMap", "envMapMode",
    "lightMap", "aoMap", "emissiveMap", "bumpMap", "normalMap", "displacementMap", "specularMap",
    "roughnessMap", "metalnessMap",
    "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
    "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
    "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
    "maxMorphTargets", "maxMorphNormals",
    "numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
    "numShadows", "shadowMapEnabled", "pointLightShadows",
    "shadowMapType", "shadowMapDebug",
    "alphaTest", "doubleSided", "flipSided"
  ];


  function allocateBones ( object ) {

    if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

      return 1024;

    } else {

      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      var nVertexUniforms = capabilities.maxVertexUniforms;
      var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

      var maxBones = nVertexMatrices;

      if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

        maxBones = Math.min( object.skeleton.bones.length, maxBones );

        if ( maxBones < object.skeleton.bones.length ) {

          console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

        }

      }

      return maxBones;

    }

  }

  this.getParameters = function ( material, lights, fog, object ) {

    var shaderID = shaderIDs[ material.type ];
    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxBones = allocateBones( object );
    var precision = renderer.getPrecision();

    if ( material.precision !== null ) {

      precision = capabilities.getMaxPrecision( material.precision );

      if ( precision !== material.precision ) {

        console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

      }

    }

    var parameters = {

      shaderID: shaderID,

      precision: precision,
      supportsVertexTextures: capabilities.vertexTextures,

      map: !! material.map,
      envMap: !! material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      lightMap: !! material.lightMap,
      aoMap: !! material.aoMap,
      emissiveMap: !! material.emissiveMap,
      bumpMap: !! material.bumpMap,
      normalMap: !! material.normalMap,
      displacementMap: !! material.displacementMap,
      roughnessMap: !! material.roughnessMap,
      metalnessMap: !! material.metalnessMap,
      specularMap: !! material.specularMap,
      alphaMap: !! material.alphaMap,

      combine: material.combine,

      vertexColors: material.vertexColors,

      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,

      flatShading: material.shading === THREE.FlatShading,

      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: renderer.maxMorphTargets,
      maxMorphNormals: renderer.maxMorphNormals,

      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numHemiLights: lights.hemi.length,

      numShadows: lights.shadows.length,
      pointLightShadows: lights.shadowsPointLight,

      shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      shadowMapDebug: renderer.shadowMap.debug,

      alphaTest: material.alphaTest,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide

    };

    return parameters;

  };

  this.getProgramCode = function ( material, parameters ) {

    var chunks = [];

    if ( parameters.shaderID ) {

      chunks.push( parameters.shaderID );

    } else {

      chunks.push( material.fragmentShader );
      chunks.push( material.vertexShader );

    }

    if ( material.defines !== undefined ) {

      for ( var name in material.defines ) {

        chunks.push( name );
        chunks.push( material.defines[ name ] );

      }

    }

    for ( var i = 0; i < parameterNames.length; i ++ ) {

      var parameterName = parameterNames[ i ];
      chunks.push( parameterName );
      chunks.push( parameters[ parameterName ] );

    }

    return chunks.join();

  };

  this.acquireProgram = function ( material, parameters, code ) {

    var program;

    // Check if code has been already compiled
    for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

      var programInfo = programs[ p ];

      if ( programInfo.code === code ) {

        program = programInfo;
        ++ program.usedTimes;

        break;

      }

    }

    if ( program === undefined ) {

      program = new THREE.WebGLProgram( renderer, code, material, parameters );
      programs.push( program );

    }

    return program;

  };

  this.releaseProgram = function( program ) {

    if ( -- program.usedTimes === 0 ) {

      // Remove from unordered set
      var i = programs.indexOf( program );
      programs[ i ] = programs[ programs.length - 1 ];
      programs.pop();

      // Free WebGL resources
      program.destroy();

    }

  };

  // Exposed for resource monitoring & error feedback via renderer.info:
  this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

  var properties = {};

  this.get = function ( object ) {

    var uuid = object.uuid;
    var map = properties[ uuid ];

    if ( map === undefined ) {

      map = {};
      properties[ uuid ] = map;

    }

    return map;

  };

  this.delete = function ( object ) {

    delete properties[ object.uuid ];

  };

  this.clear = function () {

    properties = {};

  };

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

  function addLineNumbers( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  }

  return function WebGLShader( gl, type, string ) {

    var shader = gl.createShader( type );

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

  var _gl = _renderer.context,
  _state = _renderer.state,
  _frustum = new THREE.Frustum(),
  _projScreenMatrix = new THREE.Matrix4(),

  _lookTarget = new THREE.Vector3(),
  _lightPositionWorld = new THREE.Vector3(),

  _renderList = [],

  _MorphingFlag = 1,
  _SkinningFlag = 2,

  _NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

  _depthMaterials = new Array( _NumberOfMaterialVariants ),
  _distanceMaterials = new Array( _NumberOfMaterialVariants );

  var cubeDirections = [
    new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
    new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
  ];

  var cubeUps = [
    new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
    new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, - 1 )
  ];

  var cube2DViewPorts = [
    new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
    new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
  ];

  // init

  var depthShader = THREE.ShaderLib[ "depthRGBA" ];
  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

  var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
  var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

  for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

    var useMorphing = ( i & _MorphingFlag ) !== 0;
    var useSkinning = ( i & _SkinningFlag ) !== 0;

    var depthMaterial = new THREE.ShaderMaterial( {
      uniforms: depthUniforms,
      vertexShader: depthShader.vertexShader,
      fragmentShader: depthShader.fragmentShader,
      morphTargets: useMorphing,
      skinning: useSkinning
    } );

    depthMaterial._shadowPass = true;

    _depthMaterials[ i ] = depthMaterial;

    var distanceMaterial = new THREE.ShaderMaterial( {
      uniforms: distanceUniforms,
      vertexShader: distanceShader.vertexShader,
      fragmentShader: distanceShader.fragmentShader,
      morphTargets: useMorphing,
      skinning: useSkinning
    } );

    distanceMaterial._shadowPass = true;

    _distanceMaterials[ i ] = distanceMaterial;

  }

  //

  var scope = this;

  this.enabled = false;

  this.autoUpdate = true;
  this.needsUpdate = false;

  this.type = THREE.PCFShadowMap;
  this.cullFace = THREE.CullFaceFront;

  this.render = function ( scene, camera ) {

    var faceCount, isPointLight;

    if ( scope.enabled === false ) return;
    if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    // Set GL state for depth map.
    _gl.clearColor( 1, 1, 1, 1 );
    _state.disable( _gl.BLEND );
    _state.enable( _gl.CULL_FACE );
    _gl.frontFace( _gl.CCW );
    _gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );
    _state.setDepthTest( true );
    _state.setScissorTest( false );

    // render depth map

    var shadows = _lights.shadows;

    for ( var i = 0, il = shadows.length; i < il; i ++ ) {

      var light = shadows[ i ];

      var shadow = light.shadow;
      var shadowCamera = shadow.camera;
      var shadowMapSize = shadow.mapSize;

      if ( light instanceof THREE.PointLight ) {

        faceCount = 6;
        isPointLight = true;

        var vpWidth = shadowMapSize.x / 4.0;
        var vpHeight = shadowMapSize.y / 2.0;

        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction

        // positive X
        cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
        // negative X
        cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
        // positive Z
        cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
        // negative Z
        cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
        // positive Y
        cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
        // negative Y
        cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

      } else {

        faceCount = 1;
        isPointLight = false;

      }

      if ( shadow.map === null ) {

        var shadowFilter = THREE.LinearFilter;

        if ( scope.type === THREE.PCFSoftShadowMap ) {

          shadowFilter = THREE.NearestFilter;

        }

        var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

        shadow.map = new THREE.WebGLRenderTarget( shadowMapSize.x, shadowMapSize.y, pars );
        shadow.matrix = new THREE.Matrix4();

        //

        if ( light instanceof THREE.SpotLight ) {

          shadowCamera.aspect = shadowMapSize.x / shadowMapSize.y;

        }

        shadowCamera.updateProjectionMatrix();

      }

      var shadowMap = shadow.map;
      var shadowMatrix = shadow.matrix;

      _lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
      shadowCamera.position.copy( _lightPositionWorld );

      _renderer.setRenderTarget( shadowMap );
      _renderer.clear();

      // render shadow map for each cube face (if omni-directional) or
      // run a single pass if not

      for ( var face = 0; face < faceCount; face ++ ) {

        if ( isPointLight ) {

          _lookTarget.copy( shadowCamera.position );
          _lookTarget.add( cubeDirections[ face ] );
          shadowCamera.up.copy( cubeUps[ face ] );
          shadowCamera.lookAt( _lookTarget );

          var vpDimensions = cube2DViewPorts[ face ];
          _state.viewport( vpDimensions );

        } else {

          _lookTarget.setFromMatrixPosition( light.target.matrixWorld );
          shadowCamera.lookAt( _lookTarget );

        }

        shadowCamera.updateMatrixWorld();
        shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

        // compute shadow matrix

        shadowMatrix.set(
          0.5, 0.0, 0.0, 0.5,
          0.0, 0.5, 0.0, 0.5,
          0.0, 0.0, 0.5, 0.5,
          0.0, 0.0, 0.0, 1.0
        );

        shadowMatrix.multiply( shadowCamera.projectionMatrix );
        shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

        // update camera matrices and frustum

        _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
        _frustum.setFromMatrix( _projScreenMatrix );

        // set object matrices & frustum culling

        _renderList.length = 0;

        projectObject( scene, camera, shadowCamera );

        // render shadow map
        // render regular objects

        for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

          var object = _renderList[ j ];
          var geometry = _objects.update( object );
          var material = object.material;

          if ( material instanceof THREE.MeshFaceMaterial ) {

            var groups = geometry.groups;
            var materials = material.materials;

            for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

              var group = groups[ k ];
              var groupMaterial = materials[ group.materialIndex ];

              if ( groupMaterial.visible === true ) {

                var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
                _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

              }

            }

          } else {

            var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
            _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

          }

        }

      }

      // We must call _renderer.resetGLState() at the end of each iteration of
      // the light loop in order to force material updates for each light.
      _renderer.resetGLState();

    }

    // Restore GL state.
    var clearColor = _renderer.getClearColor(),
    clearAlpha = _renderer.getClearAlpha();
    _renderer.setClearColor( clearColor, clearAlpha );

    _state.enable( _gl.BLEND );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.resetGLState();

    scope.needsUpdate = false;

  };

  function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

    var geometry = object.geometry;

    var newMaterial = null;

    var materialVariants = _depthMaterials;
    var customMaterial = object.customDepthMaterial;

    if ( isPointLight ) {

      materialVariants = _distanceMaterials;
      customMaterial = object.customDistanceMaterial;

    }

    if ( ! customMaterial ) {

      var useMorphing = geometry.morphTargets !== undefined &&
          geometry.morphTargets.length > 0 && material.morphTargets;

      var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

      var variantIndex = 0;

      if ( useMorphing ) variantIndex |= _MorphingFlag;
      if ( useSkinning ) variantIndex |= _SkinningFlag;

      newMaterial = materialVariants[ variantIndex ];

    } else {

      newMaterial = customMaterial;

    }

    newMaterial.visible = material.visible;
    newMaterial.wireframe = material.wireframe;
    newMaterial.wireframeLinewidth = material.wireframeLinewidth;

    if ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {

      newMaterial.uniforms.lightPos.value.copy( lightPositionWorld );

    }

    return newMaterial;

  }

  function projectObject( object, camera, shadowCamera ) {

    if ( object.visible === false ) return;

    if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {

      if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

        var material = object.material;

        if ( material.visible === true ) {

          object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
          _renderList.push( object );

        }

      }

    }

    var children = object.children;

    for ( var i = 0, l = children.length; i < l; i ++ ) {

      projectObject( children[ i ], camera, shadowCamera );

    }

  }

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

  var _this = this;

  var newAttributes = new Uint8Array( 16 );
  var enabledAttributes = new Uint8Array( 16 );
  var attributeDivisors = new Uint8Array( 16 );

  var capabilities = {};

  var compressedTextureFormats = null;

  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;

  var currentDepthFunc = null;
  var currentDepthWrite = null;

  var currentColorWrite = null;

  var currentStencilWrite = null;
  var currentStencilFunc = null;
  var currentStencilRef = null;
  var currentStencilMask = null;
  var currentStencilFail  = null;
  var currentStencilZFail = null;
  var currentStencilZPass = null;

  var currentFlipSided = null;

  var currentLineWidth = null;

  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;

  var currentScissorTest = null;

  var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

  var currentTextureSlot = undefined;
  var currentBoundTextures = {};

  var currentScissor = new THREE.Vector4();
  var currentViewport = new THREE.Vector4();

  this.init = function () {

    gl.clearColor( 0, 0, 0, 1 );
    gl.clearDepth( 1 );
    gl.clearStencil( 0 );

    this.enable( gl.DEPTH_TEST );
    gl.depthFunc( gl.LEQUAL );

    gl.frontFace( gl.CCW );
    gl.cullFace( gl.BACK );
    this.enable( gl.CULL_FACE );

    this.enable( gl.BLEND );
    gl.blendEquation( gl.FUNC_ADD );
    gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );

  };

  this.initAttributes = function () {

    for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

      newAttributes[ i ] = 0;

    }

  };

  this.enableAttribute = function ( attribute ) {

    newAttributes[ attribute ] = 1;

    if ( enabledAttributes[ attribute ] === 0 ) {

      gl.enableVertexAttribArray( attribute );
      enabledAttributes[ attribute ] = 1;

    }

    if ( attributeDivisors[ attribute ] !== 0 ) {

      var extension = extensions.get( 'ANGLE_instanced_arrays' );

      extension.vertexAttribDivisorANGLE( attribute, 0 );
      attributeDivisors[ attribute ] = 0;

    }

  };

  this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

    newAttributes[ attribute ] = 1;

    if ( enabledAttributes[ attribute ] === 0 ) {

      gl.enableVertexAttribArray( attribute );
      enabledAttributes[ attribute ] = 1;

    }

    if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

      extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
      attributeDivisors[ attribute ] = meshPerAttribute;

    }

  };

  this.disableUnusedAttributes = function () {

    for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

      if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

  };

  this.enable = function ( id ) {

    if ( capabilities[ id ] !== true ) {

      gl.enable( id );
      capabilities[ id ] = true;

    }

  };

  this.disable = function ( id ) {

    if ( capabilities[ id ] !== false ) {

      gl.disable( id );
      capabilities[ id ] = false;

    }

  };

  this.getCompressedTextureFormats = function () {

    if ( compressedTextureFormats === null ) {

      compressedTextureFormats = [];

      if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
           extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

        var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

        for ( var i = 0; i < formats.length; i ++ ) {

          compressedTextureFormats.push( formats[ i ] );

        }

      }

    }

    return compressedTextureFormats;

  };

  this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

    if ( blending === THREE.NoBlending ) {

      this.disable( gl.BLEND );

    } else {

      this.enable( gl.BLEND );

    }

    if ( blending !== currentBlending ) {

      if ( blending === THREE.AdditiveBlending ) {

        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

      } else if ( blending === THREE.SubtractiveBlending ) {

        // TODO: Find blendFuncSeparate() combination

        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

      } else if ( blending === THREE.MultiplyBlending ) {

        // TODO: Find blendFuncSeparate() combination

        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

      } else {

        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

      }

      currentBlending = blending;

    }

    if ( blending === THREE.CustomBlending ) {

      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;

      if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

        gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;

      }

      if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

        gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;

      }

    } else {

      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;

    }

  };

  this.setDepthFunc = function ( depthFunc ) {

    if ( currentDepthFunc !== depthFunc ) {

      if ( depthFunc ) {

        switch ( depthFunc ) {

          case THREE.NeverDepth:

            gl.depthFunc( gl.NEVER );
            break;

          case THREE.AlwaysDepth:

            gl.depthFunc( gl.ALWAYS );
            break;

          case THREE.LessDepth:

            gl.depthFunc( gl.LESS );
            break;

          case THREE.LessEqualDepth:

            gl.depthFunc( gl.LEQUAL );
            break;

          case THREE.EqualDepth:

            gl.depthFunc( gl.EQUAL );
            break;

          case THREE.GreaterEqualDepth:

            gl.depthFunc( gl.GEQUAL );
            break;

          case THREE.GreaterDepth:

            gl.depthFunc( gl.GREATER );
            break;

          case THREE.NotEqualDepth:

            gl.depthFunc( gl.NOTEQUAL );
            break;

          default:

            gl.depthFunc( gl.LEQUAL );

        }

      } else {

        gl.depthFunc( gl.LEQUAL );

      }

      currentDepthFunc = depthFunc;

    }

  };

  this.setDepthTest = function ( depthTest ) {

    if ( depthTest ) {

      this.enable( gl.DEPTH_TEST );

    } else {

      this.disable( gl.DEPTH_TEST );

    }

  };

  this.setDepthWrite = function ( depthWrite ) {

    // TODO: Rename to setDepthMask

    if ( currentDepthWrite !== depthWrite ) {

      gl.depthMask( depthWrite );
      currentDepthWrite = depthWrite;

    }

  };

  this.setColorWrite = function ( colorWrite ) {

    // TODO: Rename to setColorMask

    if ( currentColorWrite !== colorWrite ) {

      gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
      currentColorWrite = colorWrite;

    }

  };

  this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {

    if ( currentStencilFunc !== stencilFunc ||
         currentStencilRef  !== stencilRef  ||
         currentStencilMask !== stencilMask ) {

      gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

      currentStencilFunc = stencilFunc;
      currentStencilRef  = stencilRef;
      currentStencilMask = stencilMask;

    }

  };

  this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {

    if ( currentStencilFail  !== stencilFail  ||
         currentStencilZFail !== stencilZFail ||
         currentStencilZPass !== stencilZPass ) {

      gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

      currentStencilFail  = stencilFail;
      currentStencilZFail = stencilZFail;
      currentStencilZPass = stencilZPass;

    }

  };

  this.setStencilTest = function ( stencilTest ) {

    if ( stencilTest ) {

      this.enable( gl.STENCIL_TEST );

    } else {

      this.disable( gl.STENCIL_TEST );

    }

  };

  this.setStencilWrite = function ( stencilWrite ) {

    // TODO: Rename to setStencilMask

    if ( currentStencilWrite !== stencilWrite ) {

      gl.stencilMask( stencilWrite );
      currentStencilWrite = stencilWrite;

    }

  };

  this.setFlipSided = function ( flipSided ) {

    if ( currentFlipSided !== flipSided ) {

      if ( flipSided ) {

        gl.frontFace( gl.CW );

      } else {

        gl.frontFace( gl.CCW );

      }

      currentFlipSided = flipSided;

    }

  };

  this.setLineWidth = function ( width ) {

    if ( width !== currentLineWidth ) {

      gl.lineWidth( width );

      currentLineWidth = width;

    }

  };

  this.setPolygonOffset = function ( polygonOffset, factor, units ) {

    if ( polygonOffset ) {

      this.enable( gl.POLYGON_OFFSET_FILL );

    } else {

      this.disable( gl.POLYGON_OFFSET_FILL );

    }

    if ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

      gl.polygonOffset( factor, units );

      currentPolygonOffsetFactor = factor;
      currentPolygonOffsetUnits = units;

    }

  };

  this.getScissorTest = function () {

    return currentScissorTest;

  };

  this.setScissorTest = function ( scissorTest ) {

    currentScissorTest = scissorTest;

    if ( scissorTest ) {

      this.enable( gl.SCISSOR_TEST );

    } else {

      this.disable( gl.SCISSOR_TEST );

    }

  };

  // texture

  this.activeTexture = function ( webglSlot ) {

    if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    if ( currentTextureSlot !== webglSlot ) {

      gl.activeTexture( webglSlot );
      currentTextureSlot = webglSlot;

    }

  }

  this.bindTexture = function ( webglType, webglTexture ) {

    if ( currentTextureSlot === undefined ) {

      _this.activeTexture();

    }

    var boundTexture = currentBoundTextures[ currentTextureSlot ];

    if ( boundTexture === undefined ) {

      boundTexture = { type: undefined, texture: undefined };
      currentBoundTextures[ currentTextureSlot ] = boundTexture;

    }

    if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

      gl.bindTexture( webglType, webglTexture );

      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;

    }

  };

  this.compressedTexImage2D = function () {

    try {

      gl.compressedTexImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  this.texImage2D = function () {

    try {

      gl.texImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  //

  this.scissor = function ( scissor ) {

    if ( currentScissor.equals( scissor ) === false ) {

      gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
      currentScissor.copy( scissor );

    }

  };

  this.viewport = function ( viewport ) {

    if ( currentViewport.equals( viewport ) === false ) {

      gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
      currentViewport.copy( viewport );

    }

  };

  //

  this.reset = function () {

    for ( var i = 0; i < enabledAttributes.length; i ++ ) {

      if ( enabledAttributes[ i ] === 1 ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

    capabilities = {};

    compressedTextureFormats = null;

    currentBlending = null;

    currentDepthWrite = null;
    currentColorWrite = null;

    currentFlipSided = null;

  };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

  var gl = renderer.context;
  var state = renderer.state;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;

  var tempTexture, occlusionTexture;

  function init() {

    var vertices = new Float32Array( [
      - 1, - 1,  0, 0,
       1, - 1,  1, 0,
       1,  1,  1, 1,
      - 1,  1,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    // buffers

    vertexBuffer     = gl.createBuffer();
    elementBuffer    = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    // textures

    tempTexture      = gl.createTexture();
    occlusionTexture = gl.createTexture();

    state.bindTexture( gl.TEXTURE_2D, tempTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

    var shader;

    if ( hasVertexTexture ) {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "uniform sampler2D occlusionMap;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if ( renderType == 2 ) {",

              "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

              "vVisibility =        visibility.r / 9.0;",
              "vVisibility *= 1.0 - visibility.g / 9.0;",
              "vVisibility *=       visibility.b / 9.0;",
              "vVisibility *= 1.0 - visibility.a / 9.0;",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            // pink square

            "if ( renderType == 0 ) {",

              "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

            // restore

            "} else if ( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * vVisibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    } else {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if ( renderType == 2 ) {",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "precision mediump float;",

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform sampler2D occlusionMap;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",

          "void main() {",

            // pink square

            "if ( renderType == 0 ) {",

              "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

            // restore

            "} else if ( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
              "visibility = ( 1.0 - visibility / 4.0 );",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * visibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    }

    program = createProgram( shader );

    attributes = {
      vertex: gl.getAttribLocation ( program, "position" ),
      uv:     gl.getAttribLocation ( program, "uv" )
    };

    uniforms = {
      renderType:     gl.getUniformLocation( program, "renderType" ),
      map:            gl.getUniformLocation( program, "map" ),
      occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
      opacity:        gl.getUniformLocation( program, "opacity" ),
      color:          gl.getUniformLocation( program, "color" ),
      scale:          gl.getUniformLocation( program, "scale" ),
      rotation:       gl.getUniformLocation( program, "rotation" ),
      screenPosition: gl.getUniformLocation( program, "screenPosition" )
    };

  }

  /*
   * Render lens flares
   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
   *         reads these back and calculates occlusion.
   */

  this.render = function ( scene, camera, viewport ) {

    if ( flares.length === 0 ) return;

    var tempPosition = new THREE.Vector3();

    var invAspect = viewport.w / viewport.z,
      halfViewportWidth = viewport.z * 0.5,
      halfViewportHeight = viewport.w * 0.5;

    var size = 16 / viewport.w,
      scale = new THREE.Vector2( size * invAspect, size );

    var screenPosition = new THREE.Vector3( 1, 1, 0 ),
      screenPositionPixels = new THREE.Vector2( 1, 1 );

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    state.initAttributes();
    state.enableAttribute( attributes.vertex );
    state.enableAttribute( attributes.uv );
    state.disableUnusedAttributes();

    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/uniforms

    gl.uniform1i( uniforms.occlusionMap, 0 );
    gl.uniform1i( uniforms.map, 1 );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    state.disable( gl.CULL_FACE );
    state.setDepthWrite( false );

    for ( var i = 0, l = flares.length; i < l; i ++ ) {

      size = 16 / viewport.w;
      scale.set( size * invAspect, size );

      // calc object screen position

      var flare = flares[ i ];

      tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

      tempPosition.applyMatrix4( camera.matrixWorldInverse );
      tempPosition.applyProjection( camera.projectionMatrix );

      // setup arrays for gl programs

      screenPosition.copy( tempPosition );

      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

      // screen cull

      if ( hasVertexTexture || (
        screenPositionPixels.x > 0 &&
        screenPositionPixels.x < viewport.z &&
        screenPositionPixels.y > 0 &&
        screenPositionPixels.y < viewport.w ) ) {

        // save current RGB to temp texture

        state.activeTexture( gl.TEXTURE0 );
        state.bindTexture( gl.TEXTURE_2D, null );
        state.activeTexture( gl.TEXTURE1 );
        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );


        // render pink quad

        gl.uniform1i( uniforms.renderType, 0 );
        gl.uniform2f( uniforms.scale, scale.x, scale.y );
        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

        state.disable( gl.BLEND );
        state.enable( gl.DEPTH_TEST );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // copy result to occlusionMap

        state.activeTexture( gl.TEXTURE0 );
        state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );


        // restore graphics

        gl.uniform1i( uniforms.renderType, 1 );
        state.disable( gl.DEPTH_TEST );

        state.activeTexture( gl.TEXTURE1 );
        state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // update object positions

        flare.positionScreen.copy( screenPosition );

        if ( flare.customUpdateCallback ) {

          flare.customUpdateCallback( flare );

        } else {

          flare.updateLensFlares();

        }

        // render flares

        gl.uniform1i( uniforms.renderType, 2 );
        state.enable( gl.BLEND );

        for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

          var sprite = flare.lensFlares[ j ];

          if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;

            size = sprite.size * sprite.scale / viewport.w;

            scale.x = size * invAspect;
            scale.y = size;

            gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
            gl.uniform2f( uniforms.scale, scale.x, scale.y );
            gl.uniform1f( uniforms.rotation, sprite.rotation );

            gl.uniform1f( uniforms.opacity, sprite.opacity );
            gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

            state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
            renderer.setTexture( sprite.texture, 1 );

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

          }

        }

      }

    }

    // restore gl

    state.enable( gl.CULL_FACE );
    state.enable( gl.DEPTH_TEST );
    state.setDepthWrite( true );

    renderer.resetGLState();

  };

  function createProgram ( shader ) {

    var program = gl.createProgram();

    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    var prefix = "precision " + renderer.getPrecision() + " float;\n";

    gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    gl.compileShader( fragmentShader );
    gl.compileShader( vertexShader );

    gl.attachShader( program, fragmentShader );
    gl.attachShader( program, vertexShader );

    gl.linkProgram( program );

    return program;

  }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

  var gl = renderer.context;
  var state = renderer.state;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;

  var texture;

  // decompose matrixWorld

  var spritePosition = new THREE.Vector3();
  var spriteRotation = new THREE.Quaternion();
  var spriteScale = new THREE.Vector3();

  function init() {

    var vertices = new Float32Array( [
      - 0.5, - 0.5,  0, 0,
        0.5, - 0.5,  1, 0,
        0.5,   0.5,  1, 1,
      - 0.5,   0.5,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    vertexBuffer  = gl.createBuffer();
    elementBuffer = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    program = createProgram();

    attributes = {
      position:     gl.getAttribLocation ( program, 'position' ),
      uv:         gl.getAttribLocation ( program, 'uv' )
    };

    uniforms = {
      uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),
      uvScale:      gl.getUniformLocation( program, 'uvScale' ),

      rotation:     gl.getUniformLocation( program, 'rotation' ),
      scale:        gl.getUniformLocation( program, 'scale' ),

      color:        gl.getUniformLocation( program, 'color' ),
      map:        gl.getUniformLocation( program, 'map' ),
      opacity:      gl.getUniformLocation( program, 'opacity' ),

      modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),
      projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

      fogType:      gl.getUniformLocation( program, 'fogType' ),
      fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),
      fogNear:      gl.getUniformLocation( program, 'fogNear' ),
      fogFar:       gl.getUniformLocation( program, 'fogFar' ),
      fogColor:     gl.getUniformLocation( program, 'fogColor' ),

      alphaTest:      gl.getUniformLocation( program, 'alphaTest' )
    };

    var canvas = document.createElement( 'canvas' );
    canvas.width = 8;
    canvas.height = 8;

    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 0, 8, 8 );

    texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

  }

  this.render = function ( scene, camera ) {

    if ( sprites.length === 0 ) return;

    // setup gl

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    state.initAttributes();
    state.enableAttribute( attributes.position );
    state.enableAttribute( attributes.uv );
    state.disableUnusedAttributes();

    state.disable( gl.CULL_FACE );
    state.enable( gl.BLEND );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    state.activeTexture( gl.TEXTURE0 );
    gl.uniform1i( uniforms.map, 0 );

    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;

    if ( fog ) {

      gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

      if ( fog instanceof THREE.Fog ) {

        gl.uniform1f( uniforms.fogNear, fog.near );
        gl.uniform1f( uniforms.fogFar, fog.far );

        gl.uniform1i( uniforms.fogType, 1 );
        oldFogType = 1;
        sceneFogType = 1;

      } else if ( fog instanceof THREE.FogExp2 ) {

        gl.uniform1f( uniforms.fogDensity, fog.density );

        gl.uniform1i( uniforms.fogType, 2 );
        oldFogType = 2;
        sceneFogType = 2;

      }

    } else {

      gl.uniform1i( uniforms.fogType, 0 );
      oldFogType = 0;
      sceneFogType = 0;

    }


    // update positions and sort

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];

      sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
      sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    }

    sprites.sort( painterSortStable );

    // render all sprites

    var scale = [];

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];
      var material = sprite.material;

      gl.uniform1f( uniforms.alphaTest, material.alphaTest );
      gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

      sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

      scale[ 0 ] = spriteScale.x;
      scale[ 1 ] = spriteScale.y;

      var fogType = 0;

      if ( scene.fog && material.fog ) {

        fogType = sceneFogType;

      }

      if ( oldFogType !== fogType ) {

        gl.uniform1i( uniforms.fogType, fogType );
        oldFogType = fogType;

      }

      if ( material.map !== null ) {

        gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
        gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

      } else {

        gl.uniform2f( uniforms.uvOffset, 0, 0 );
        gl.uniform2f( uniforms.uvScale, 1, 1 );

      }

      gl.uniform1f( uniforms.opacity, material.opacity );
      gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

      gl.uniform1f( uniforms.rotation, material.rotation );
      gl.uniform2fv( uniforms.scale, scale );

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      state.setDepthTest( material.depthTest );
      state.setDepthWrite( material.depthWrite );

      if ( material.map && material.map.image && material.map.image.width ) {

        renderer.setTexture( material.map, 0 );

      } else {

        renderer.setTexture( texture, 0 );

      }

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    }

    // restore gl

    state.enable( gl.CULL_FACE );

    renderer.resetGLState();

  };

  function createProgram () {

    var program = gl.createProgram();

    var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    gl.shaderSource( vertexShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',

      'attribute vec2 position;',
      'attribute vec2 uv;',

      'varying vec2 vUV;',

      'void main() {',

        'vUV = uvOffset + uv * uvScale;',

        'vec2 alignedPosition = position * scale;',

        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        'vec4 finalPosition;',

        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',

        'gl_Position = finalPosition;',

      '}'

    ].join( '\n' ) );

    gl.shaderSource( fragmentShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',

      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',

      'varying vec2 vUV;',

      'void main() {',

        'vec4 texture = texture2D( map, vUV );',

        'if ( texture.a < alphaTest ) discard;',

        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        'if ( fogType > 0 ) {',

          'float depth = gl_FragCoord.z / gl_FragCoord.w;',
          'float fogFactor = 0.0;',

          'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

          '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

          '}',

          'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

        '}',

      '}'

    ].join( '\n' ) );

    gl.compileShader( vertexShader );
    gl.compileShader( fragmentShader );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    return program;

  }

  function painterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return b.id - a.id;

    }

  }

};

// File:src/Three.Legacy.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

Object.defineProperties( THREE.Box2.prototype, {
  empty: {
    value: function () {
      console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
      return this.isEmpty();
    }
  },
  isIntersectionBox: {
    value: function ( box ) {
      console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );
    }
  }
} );

Object.defineProperties( THREE.Box3.prototype, {
  empty: {
    value: function () {
      console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
      return this.isEmpty();
    }
  },
  isIntersectionBox: {
    value: function ( box ) {
      console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );
    }
  },
  isIntersectionSphere: {
    value: function ( sphere ) {
      console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
      return this.intersectsSphere( sphere );
    }
  }
} );

Object.defineProperties( THREE.Matrix3.prototype, {
  multiplyVector3: {
    value: function ( vector ) {
      console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
      return vector.applyMatrix3( this );
    }
  },
  multiplyVector3Array: {
    value: function ( a ) {
      console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
      return this.applyToVector3Array( a );
    }
  }
} );

Object.defineProperties( THREE.Matrix4.prototype, {
  extractPosition: {
    value: function ( m ) {
      console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
      return this.copyPosition( m );
    }
  },
  setRotationFromQuaternion: {
    value: function ( q ) {
      console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
      return this.makeRotationFromQuaternion( q );
    }
  },
  multiplyVector3: {
    value: function ( vector ) {
      console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
      return vector.applyProjection( this );
    }
  },
  multiplyVector4: {
    value: function ( vector ) {
      console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
      return vector.applyMatrix4( this );
    }
  },
  multiplyVector3Array: {
    value: function ( a ) {
      console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
      return this.applyToVector3Array( a );
    }
  },
  rotateAxis: {
    value: function ( v ) {
      console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
      v.transformDirection( this );
    }
  },
  crossVector: {
    value: function ( vector ) {
      console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
      return vector.applyMatrix4( this );
    }
  },
  translate: {
    value: function ( v ) {
      console.error( 'THREE.Matrix4: .translate() has been removed.' );
    }
  },
  rotateX: {
    value: function ( angle ) {
      console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    }
  },
  rotateY: {
    value: function ( angle ) {
      console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    }
  },
  rotateZ: {
    value: function ( angle ) {
      console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    }
  },
  rotateByAxis: {
    value: function ( axis, angle ) {
      console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    }
  }
} );

Object.defineProperties( THREE.Plane.prototype, {
  isIntersectionLine: {
    value: function ( line ) {
      console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
      return this.intersectsLine( line );
    }
  }
} );

Object.defineProperties( THREE.Quaternion.prototype, {
  multiplyVector3: {
    value: function ( vector ) {
      console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
      return vector.applyQuaternion( this );
    }
  }
} );

Object.defineProperties( THREE.Ray.prototype, {
  isIntersectionBox: {
    value: function ( box ) {
      console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
      return this.intersectsBox( box );
    }
  },
  isIntersectionPlane: {
    value: function ( plane ) {
      console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
      return this.intersectsPlane( plane );
    }
  },
  isIntersectionSphere: {
    value: function ( sphere ) {
      console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
      return this.intersectsSphere( sphere );
    }
  }
} );

Object.defineProperties( THREE.Vector3.prototype, {
  setEulerFromRotationMatrix: {
    value: function () {
      console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    }
  },
  setEulerFromQuaternion: {
    value: function () {
      console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    }
  },
  getPositionFromMatrix: {
    value: function ( m ) {
      console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
      return this.setFromMatrixPosition( m );
    }
  },
  getScaleFromMatrix: {
    value: function ( m ) {
      console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
      return this.setFromMatrixScale( m );
    }
  },
  getColumnFromMatrix: {
    value: function ( index, matrix ) {
      console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
      return this.setFromMatrixColumn( index, matrix );
    }
  }
} );

//

Object.defineProperties( THREE.Object3D.prototype, {
  eulerOrder: {
    get: function () {
      console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
      return this.rotation.order;
    },
    set: function ( value ) {
      console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
      this.rotation.order = value;
    }
  },
  getChildByName: {
    value: function ( name ) {
      console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
      return this.getObjectByName( name );
    }
  },
  renderDepth: {
    set: function ( value ) {
      console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    }
  },
  translate: {
    value: function ( distance, axis ) {
      console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
      return this.translateOnAxis( axis, distance );
    }
  },
  useQuaternion: {
    get: function () {
      console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    },
    set: function ( value ) {
      console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    }
  }
} );

//

Object.defineProperties( THREE, {
  PointCloud: {
    value: function ( geometry, material ) {
      console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
      return new THREE.Points( geometry, material );
    }
  },
  ParticleSystem: {
    value: function ( geometry, material ) {
      console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
      return new THREE.Points( geometry, material );
    }
  }
} );

//

Object.defineProperties( THREE.Light.prototype, {
  onlyShadow: {
    set: function ( value ) {
      console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    }
  },
  shadowCameraFov: {
    set: function ( value ) {
      this.shadow.camera.fov = value;
    }
  },
  shadowCameraLeft: {
    set: function ( value ) {
      this.shadow.camera.left = value;
    }
  },
  shadowCameraRight: {
    set: function ( value ) {
      this.shadow.camera.right = value;
    }
  },
  shadowCameraTop: {
    set: function ( value ) {
      this.shadow.camera.top = value;
    }
  },
  shadowCameraBottom: {
    set: function ( value ) {
      this.shadow.camera.bottom = value;
    }
  },
  shadowCameraNear: {
    set: function ( value ) {
      this.shadow.camera.near = value;
    }
  },
  shadowCameraFar: {
    set: function ( value ) {
      this.shadow.camera.far = value;
    }
  },
  shadowCameraVisible: {
    set: function ( value ) {
      console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    }
  },
  shadowBias: {
    set: function ( value ) {
      this.shadow.bias = value;
    }
  },
  shadowDarkness: {
    set: function ( value ) {
      this.shadow.darkness = value;
    }
  },
  shadowMapWidth: {
    set: function ( value ) {
      this.shadow.mapSize.width = value;
    }
  },
  shadowMapHeight: {
    set: function ( value ) {
      this.shadow.mapSize.height = value;
    }
  }
} );

//

Object.defineProperties( THREE.BufferAttribute.prototype, {
  length: {
    get: function () {
      console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
      return this.array.length;
    }
  }
} );

Object.defineProperties( THREE.BufferGeometry.prototype, {
  drawcalls: {
    get: function () {
      console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
      return this.groups;
    }
  },
  offsets: {
    get: function () {
      console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
      return this.groups;
    }
  },
  addIndex: {
    value: function ( index ) {
      console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
      this.setIndex( index );
    }
  },
  addDrawCall: {
    value: function ( start, count, indexOffset ) {
      if ( indexOffset !== undefined ) {
        console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
      }
      console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
      this.addGroup( start, count );
    }
  },
  clearDrawCalls: {
    value: function () {
      console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
      this.clearGroups();
    }
  },
  computeTangents: {
    value: function () {
      console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    }
  },
  computeOffsets: {
    value: function () {
      console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    }
  }
} );

//

Object.defineProperties( THREE.Material.prototype, {
  wrapAround: {
    get: function () {
      console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    },
    set: function ( value ) {
      console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    }
  },
  wrapRGB: {
    get: function () {
      console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
      return new THREE.Color();
    }
  }
} );

Object.defineProperties( THREE, {
  PointCloudMaterial: {
    value: function ( parameters ) {
      console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
      return new THREE.PointsMaterial( parameters );
    }
  },
  ParticleBasicMaterial: {
    value: function ( parameters ) {
      console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
      return new THREE.PointsMaterial( parameters );
    }
  },
  ParticleSystemMaterial:{
    value: function ( parameters ) {
      console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
      return new THREE.PointsMaterial( parameters );
    }
  }
} );

Object.defineProperties( THREE.MeshPhongMaterial.prototype, {
  metal: {
    get: function () {
      console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
      return false;
    },
    set: function ( value ) {
      console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    }
  }
} );

Object.defineProperties( THREE.ShaderMaterial.prototype, {
  derivatives: {
    get: function () {
      console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
      return this.extensions.derivatives;
    },
    set: function ( value ) {
      console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
      this.extensions.derivatives = value;
    }
  }
} );

//

Object.defineProperties( THREE.WebGLRenderer.prototype, {
  supportsFloatTextures: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
      return this.extensions.get( 'OES_texture_float' );
    }
  },
  supportsHalfFloatTextures: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
      return this.extensions.get( 'OES_texture_half_float' );
    }
  },
  supportsStandardDerivatives: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
      return this.extensions.get( 'OES_standard_derivatives' );
    }
  },
  supportsCompressedTextureS3TC: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
      return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    }
  },
  supportsCompressedTexturePVRTC: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
      return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    }
  },
  supportsBlendMinMax: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
      return this.extensions.get( 'EXT_blend_minmax' );
    }
  },
  supportsVertexTextures: {
    value: function () {
      return this.capabilities.vertexTextures;
    }
  },
  supportsInstancedArrays: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
      return this.extensions.get( 'ANGLE_instanced_arrays' );
    }
  },
  enableScissorTest: {
    value: function ( boolean ) {
      console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
      this.setScissorTest( boolean );
    }
  },
  initMaterial: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    }
  },
  addPrePlugin: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    }
  },
  addPostPlugin: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    }
  },
  updateShadowMap: {
    value: function () {
      console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    }
  },
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
      this.shadowMap.enabled = value;
    }
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
      this.shadowMap.type = value;
    }
  },
  shadowMapCullFace: {
    get: function () {
      return this.shadowMap.cullFace;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
      this.shadowMap.cullFace = value;
    }
  },
  shadowMapDebug: {
    get: function () {
      return this.shadowMap.debug;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
      this.shadowMap.debug = value;
    }
  }
} );

//

Object.defineProperties( THREE.WebGLRenderTarget.prototype, {
  wrapS: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
      return this.texture.wrapS;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
      this.texture.wrapS = value;
    }
  },
  wrapT: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
      return this.texture.wrapT;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
      this.texture.wrapT = value;
    }
  },
  magFilter: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
      return this.texture.magFilter;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
      this.texture.magFilter = value;
    }
  },
  minFilter: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
      return this.texture.minFilter;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
      this.texture.minFilter = value;
    }
  },
  anisotropy: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
      return this.texture.anisotropy;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
      this.texture.anisotropy = value;
    }
  },
  offset: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
      return this.texture.offset;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
      this.texture.offset = value;
    }
  },
  repeat: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
      return this.texture.repeat;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
      this.texture.repeat = value;
    }
  },
  format: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
      return this.texture.format;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
      this.texture.format = value;
    }
  },
  type: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
      return this.texture.type;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
      this.texture.type = value;
    }
  },
  generateMipmaps: {
    get: function () {
      console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
      return this.texture.generateMipmaps;
    },
    set: function ( value ) {
      console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
      this.texture.generateMipmaps = value;
    }
  }
} );

//

THREE.GeometryUtils = {

  merge: function ( geometry1, geometry2, materialIndexOffset ) {

    console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    var matrix;

    if ( geometry2 instanceof THREE.Mesh ) {

      geometry2.matrixAutoUpdate && geometry2.updateMatrix();

      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;

    }

    geometry1.merge( geometry2, matrix, materialIndexOffset );

  },

  center: function ( geometry ) {

    console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    return geometry.center();

  }

};

THREE.ImageUtils = {

  crossOrigin: undefined,

  loadTexture: function ( url, mapping, onLoad, onError ) {

    console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

    var loader = new THREE.TextureLoader();
    loader.setCrossOrigin( this.crossOrigin );

    var texture = loader.load( url, onLoad, undefined, onError );

    if ( mapping ) texture.mapping = mapping;

    return texture;

  },

  loadTextureCube: function ( urls, mapping, onLoad, onError ) {

    console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

    var loader = new THREE.CubeTextureLoader();
    loader.setCrossOrigin( this.crossOrigin );

    var texture = loader.load( urls, onLoad, undefined, onError );

    if ( mapping ) texture.mapping = mapping;

    return texture;

  },

  loadCompressedTexture: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

  },

  loadCompressedTextureCube: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

  }

};

//

THREE.Projector = function () {

  console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function ( vector, camera ) {

    console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  };

};

//

THREE.CanvasRenderer = function () {

  console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

  this.domElement = document.createElement( 'canvas' );
  this.clear = function () {};
  this.render = function () {};
  this.setClearColor = function () {};
  this.setSize = function () {};

};

//

THREE.TextGeometry = function () {

  console.error( 'THREE.TextGeometry has been moved to /examples/js/geometries/TextGeometry.js' );
  console.error( 'THREE.FontUtils has been moved to /examples/js/utils/FontUtils.js' );

};

//

THREE.MeshFaceMaterial = THREE.MultiMaterial;

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

  tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

  },

  // Puay Bing, thanks for helping with this derivative!

  tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
      3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
      6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
      3 * t * t * p3;

  },

  tangentSpline: function ( t, p0, p1, p2, p3 ) {

    // To check if my formulas are correct

    var h00 = 6 * t * t - 6 * t;  // derived from 2t^3 − 3t^2 + 1
    var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    var h01 = - 6 * t * t + 6 * t;  // − 2t3 + 3t2
    var h11 = 3 * t * t - 2 * t;  // t3 − t2

    return h00 + h10 + h01 + h11;

  },

  // Catmull-Rom

  interpolate: function( p0, p1, p2, p3, t ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

  createMultiMaterialObject: function ( geometry, materials ) {

    var group = new THREE.Group();

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      group.add( new THREE.Mesh( geometry, materials[ i ] ) );

    }

    return group;

  },

  detach: function ( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  },

  attach: function ( child, scene, parent ) {

    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse( parent.matrixWorld );
    child.applyMatrix( matrixWorldInverse );

    scene.remove( child );
    parent.add( child );

  }

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

  // calculate area of the contour polygon

  area: function ( contour ) {

    var n = contour.length;
    var a = 0.0;

    for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

      a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    }

    return a * 0.5;

  },

  triangulate: ( function () {

    /**
     * This code is a quick port of code written in C++ which was submitted to
     * flipcode.com by John W. Ratcliff  // July 22, 2000
     * See original code and more information here:
     * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     *
     * ported to actionscript by Zevan Rosser
     * www.actionsnippet.com
     *
     * ported to javascript by Joshua Koo
     * http://www.lab4games.net/zz85/blog
     *
     */

    function snip( contour, u, v, w, n, verts ) {

      var p;
      var ax, ay, bx, by;
      var cx, cy, px, py;

      ax = contour[ verts[ u ] ].x;
      ay = contour[ verts[ u ] ].y;

      bx = contour[ verts[ v ] ].x;
      by = contour[ verts[ v ] ].y;

      cx = contour[ verts[ w ] ].x;
      cy = contour[ verts[ w ] ].y;

      if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

      var aX, aY, bX, bY, cX, cY;
      var apx, apy, bpx, bpy, cpx, cpy;
      var cCROSSap, bCROSScp, aCROSSbp;

      aX = cx - bx;  aY = cy - by;
      bX = ax - cx;  bY = ay - cy;
      cX = bx - ax;  cY = by - ay;

      for ( p = 0; p < n; p ++ ) {

        px = contour[ verts[ p ] ].x;
        py = contour[ verts[ p ] ].y;

        if ( ( ( px === ax ) && ( py === ay ) ) ||
           ( ( px === bx ) && ( py === by ) ) ||
           ( ( px === cx ) && ( py === cy ) ) ) continue;

        apx = px - ax;  apy = py - ay;
        bpx = px - bx;  bpy = py - by;
        cpx = px - cx;  cpy = py - cy;

        // see if p is inside triangle abc

        aCROSSbp = aX * bpy - aY * bpx;
        cCROSSap = cX * apy - cY * apx;
        bCROSScp = bX * cpy - bY * cpx;

        if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

      }

      return true;

    }

    // takes in an contour array and returns

    return function ( contour, indices ) {

      var n = contour.length;

      if ( n < 3 ) return null;

      var result = [],
        verts = [],
        vertIndices = [];

      /* we want a counter-clockwise polygon in verts */

      var u, v, w;

      if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

        for ( v = 0; v < n; v ++ ) verts[ v ] = v;

      } else {

        for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

      }

      var nv = n;

      /*  remove nv - 2 vertices, creating 1 triangle every time */

      var count = 2 * nv;   /* error detection */

      for ( v = nv - 1; nv > 2; ) {

        /* if we loop, it is probably a non-simple polygon */

        if ( ( count -- ) <= 0 ) {

          //** Triangulate: ERROR - probable bad polygon!

          //throw ( "Warning, unable to triangulate polygon!" );
          //return null;
          // Sometimes warning is fine, especially polygons are triangulated in reverse.
          console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

          if ( indices ) return vertIndices;
          return result;

        }

        /* three consecutive vertices in current polygon, <u,v,w> */

        u = v;    if ( nv <= u ) u = 0;     /* previous */
        v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
        w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

        if ( snip( contour, u, v, w, nv, verts ) ) {

          var a, b, c, s, t;

          /* true names of the vertices */

          a = verts[ u ];
          b = verts[ v ];
          c = verts[ w ];

          /* output Triangle */

          result.push( [ contour[ a ],
            contour[ b ],
            contour[ c ] ] );


          vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

          /* remove v from the remaining polygon */

          for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

            verts[ s ] = verts[ t ];

          }

          nv --;

          /* reset error detection counter */

          count = 2 * nv;

        }

      }

      if ( indices ) return vertIndices;
      return result;

    }

  } )(),

  triangulateShape: function ( contour, holes ) {

    function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

      // inOtherPt needs to be collinear to the inSegment
      if ( inSegPt1.x !== inSegPt2.x ) {

        if ( inSegPt1.x < inSegPt2.x ) {

          return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

        } else {

          return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

        }

      } else {

        if ( inSegPt1.y < inSegPt2.y ) {

          return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

        } else {

          return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

        }

      }

    }

    function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

      var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

      if ( Math.abs( limit ) > Number.EPSILON ) {

        // not parallel

        var perpSeg2;
        if ( limit > 0 ) {

          if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];

        } else {

          if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];

        }

        // i.e. to reduce rounding errors
        // intersection at endpoint of segment#1?
        if ( perpSeg2 === 0 ) {

          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt1 ];

        }
        if ( perpSeg2 === limit ) {

          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt2 ];

        }
        // intersection at endpoint of segment#2?
        if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];
        if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

        // return real intersection point
        var factorSeg1 = perpSeg2 / limit;
        return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

      } else {

        // parallel or collinear
        if ( ( perpSeg1 !== 0 ) ||
           ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];

        // they are collinear or degenerate
        var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );  // segment1 is just a point?
        var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );  // segment2 is just a point?
        // both segments are points
        if ( seg1Pt && seg2Pt ) {

          if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
             ( inSeg1Pt1.y !== inSeg2Pt1.y ) )    return [];  // they are distinct  points
          return [ inSeg1Pt1 ];                             // they are the same point

        }
        // segment#1  is a single point
        if ( seg1Pt ) {

          if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )   return [];    // but not in segment#2
          return [ inSeg1Pt1 ];

        }
        // segment#2  is a single point
        if ( seg2Pt ) {

          if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )   return [];    // but not in segment#1
          return [ inSeg2Pt1 ];

        }

        // they are collinear segments, which might overlap
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if ( seg1dx !== 0 ) {

          // the segments are NOT on a vertical line
          if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

          } else {

            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

          }
          if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

          } else {

            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

          }

        } else {

          // the segments are on a vertical line
          if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

          } else {

            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

          }
          if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

          } else {

            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

          }

        }
        if ( seg1minVal <= seg2minVal ) {

          if ( seg1maxVal <  seg2minVal ) return [];
          if ( seg1maxVal === seg2minVal )  {

            if ( inExcludeAdjacentSegs )    return [];
            return [ seg2min ];

          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
          return  [ seg2min, seg2max ];

        } else {

          if ( seg1minVal >  seg2maxVal ) return [];
          if ( seg1minVal === seg2maxVal )  {

            if ( inExcludeAdjacentSegs )    return [];
            return [ seg1min ];

          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
          return  [ seg1min, seg2max ];

        }

      }

    }

    function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

      // The order of legs is important

      // translation of all points, so that Vertex is at (0,0)
      var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;
      var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;

      // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
      var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

      if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

        // angle != 180 deg.

        var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

        if ( from2toAngle > 0 ) {

          // main angle < 180 deg.
          return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

        } else {

          // main angle > 180 deg.
          return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

        }

      } else {

        // angle == 180 deg.
        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
        return  ( from2otherAngle > 0 );

      }

    }


    function removeHoles( contour, holes ) {

      var shape = contour.concat(); // work on this shape
      var hole;

      function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

        // Check if hole point lies within angle around shape point
        var lastShapeIdx = shape.length - 1;

        var prevShapeIdx = inShapeIdx - 1;
        if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

        var nextShapeIdx = inShapeIdx + 1;
        if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

        var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
        if ( ! insideAngle ) {

          // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
          return  false;

        }

        // Check if shape point lies within angle around hole point
        var lastHoleIdx = hole.length - 1;

        var prevHoleIdx = inHoleIdx - 1;
        if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

        var nextHoleIdx = inHoleIdx + 1;
        if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

        insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
        if ( ! insideAngle ) {

          // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
          return  false;

        }

        return  true;

      }

      function intersectsShapeEdge( inShapePt, inHolePt ) {

        // checks for intersections with shape edges
        var sIdx, nextIdx, intersection;
        for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

          nextIdx = sIdx + 1; nextIdx %= shape.length;
          intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
          if ( intersection.length > 0 )    return  true;

        }

        return  false;

      }

      var indepHoles = [];

      function intersectsHoleEdge( inShapePt, inHolePt ) {

        // checks for intersections with hole edges
        var ihIdx, chkHole,
          hIdx, nextIdx, intersection;
        for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

          chkHole = holes[ indepHoles[ ihIdx ]];
          for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

            nextIdx = hIdx + 1; nextIdx %= chkHole.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
            if ( intersection.length > 0 )    return  true;

          }

        }
        return  false;

      }

      var holeIndex, shapeIndex,
        shapePt, holePt,
        holeIdx, cutKey, failedCuts = [],
        tmpShape1, tmpShape2,
        tmpHole1, tmpHole2;

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        indepHoles.push( h );

      }

      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while ( indepHoles.length > 0 ) {

        counter --;
        if ( counter < 0 ) {

          console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
          break;

        }

        // search for shape-vertex and hole-vertex,
        // which can be connected without intersections
        for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

          shapePt = shape[ shapeIndex ];
          holeIndex = - 1;

          // search for hole which can be reached without intersections
          for ( var h = 0; h < indepHoles.length; h ++ ) {

            holeIdx = indepHoles[ h ];

            // prevent multiple checks
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if ( failedCuts[ cutKey ] !== undefined )     continue;

            hole = holes[ holeIdx ];
            for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

              holePt = hole[ h2 ];
              if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )    continue;
              if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
              if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

              holeIndex = h2;
              indepHoles.splice( h, 1 );

              tmpShape1 = shape.slice( 0, shapeIndex + 1 );
              tmpShape2 = shape.slice( shapeIndex );
              tmpHole1 = hole.slice( holeIndex );
              tmpHole2 = hole.slice( 0, holeIndex + 1 );

              shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

              minShapeIndex = shapeIndex;

              // Debug only, to show the selected cuts
              // glob_CutLines.push( [ shapePt, holePt ] );

              break;

            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

            failedCuts[ cutKey ] = true;      // remember failure

          }
          if ( holeIndex >= 0 ) break;    // hole-vertex found

        }

      }

      return shape;       /* shape with no holes */

    }


    var i, il, f, face,
      key, index,
      allPointsMap = {};

    // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    var allpoints = contour.concat();

    for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

      Array.prototype.push.apply( allpoints, holes[ h ] );

    }

    //console.log( "allpoints",allpoints, allpoints.length );

    // prepare all points map

    for ( i = 0, il = allpoints.length; i < il; i ++ ) {

      key = allpoints[ i ].x + ":" + allpoints[ i ].y;

      if ( allPointsMap[ key ] !== undefined ) {

        console.warn( "THREE.Shape: Duplicate point", key );

      }

      allPointsMap[ key ] = i;

    }

    // remove holes by cutting paths to holes and adding them to the shape
    var shapeWithoutHoles = removeHoles( contour, holes );

    var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    //console.log( "triangles",triangles, triangles.length );

    // check all face vertices against all points map

    for ( i = 0, il = triangles.length; i < il; i ++ ) {

      face = triangles[ i ];

      for ( f = 0; f < 3; f ++ ) {

        key = face[ f ].x + ":" + face[ f ].y;

        index = allPointsMap[ key ];

        if ( index !== undefined ) {

          face[ f ] = index;

        }

      }

    }

    return triangles.concat();

  },

  isClockWise: function ( pts ) {

    return THREE.ShapeUtils.area( pts ) < 0;

  },

  // Bezier Curves formulas obtained from
  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

  // Quad Bezier Functions

  b2: ( function () {

    function b2p0( t, p ) {

      var k = 1 - t;
      return k * k * p;

    }

    function b2p1( t, p ) {

      return 2 * ( 1 - t ) * t * p;

    }

    function b2p2( t, p ) {

      return t * t * p;

    }

    return function ( t, p0, p1, p2 ) {

      return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

    };

  } )(),

  // Cubic Bezier Functions

  b3: ( function () {

    function b3p0( t, p ) {

      var k = 1 - t;
      return k * k * k * p;

    }

    function b3p1( t, p ) {

      var k = 1 - t;
      return 3 * k * k * t * p;

    }

    function b3p2( t, p ) {

      var k = 1 - t;
      return 3 * k * t * t * p;

    }

    function b3p3( t, p ) {

      return t * t * t * p;

    }

    return function ( t, p0, p1, p2, p3 ) {

      return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

    };

  } )()

};

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *  Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

  constructor: THREE.Curve,

  // Virtual base class method to overwrite and implement in subclasses
  //  - t [0 .. 1]

  getPoint: function ( t ) {

    console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    return null;

  },

  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]

  getPointAt: function ( u ) {

    var t = this.getUtoTmapping( u );
    return this.getPoint( t );

  },

  // Get sequence of points using getPoint( t )

  getPoints: function ( divisions ) {

    if ( ! divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d ++ ) {

      pts.push( this.getPoint( d / divisions ) );

    }

    return pts;

  },

  // Get sequence of points using getPointAt( u )

  getSpacedPoints: function ( divisions ) {

    if ( ! divisions ) divisions = 5;

    var d, pts = [];

    for ( d = 0; d <= divisions; d ++ ) {

      pts.push( this.getPointAt( d / divisions ) );

    }

    return pts;

  },

  // Get total curve arc length

  getLength: function () {

    var lengths = this.getLengths();
    return lengths[ lengths.length - 1 ];

  },

  // Get list of cumulative segment lengths

  getLengths: function ( divisions ) {

    if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    if ( this.cacheArcLengths
      && ( this.cacheArcLengths.length === divisions + 1 )
      && ! this.needsUpdate ) {

      //console.log( "cached", this.cacheArcLengths );
      return this.cacheArcLengths;

    }

    this.needsUpdate = false;

    var cache = [];
    var current, last = this.getPoint( 0 );
    var p, sum = 0;

    cache.push( 0 );

    for ( p = 1; p <= divisions; p ++ ) {

      current = this.getPoint ( p / divisions );
      sum += current.distanceTo( last );
      cache.push( sum );
      last = current;

    }

    this.cacheArcLengths = cache;

    return cache; // { sums: cache, sum:sum }; Sum is in the last element.

  },

  updateArcLengths: function() {

    this.needsUpdate = true;
    this.getLengths();

  },

  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

  getUtoTmapping: function ( u, distance ) {

    var arcLengths = this.getLengths();

    var i = 0, il = arcLengths.length;

    var targetArcLength; // The targeted u distance value to get

    if ( distance ) {

      targetArcLength = distance;

    } else {

      targetArcLength = u * arcLengths[ il - 1 ];

    }

    //var time = Date.now();

    // binary search for the index with largest value smaller than target u distance

    var low = 0, high = il - 1, comparison;

    while ( low <= high ) {

      i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

      comparison = arcLengths[ i ] - targetArcLength;

      if ( comparison < 0 ) {

        low = i + 1;

      } else if ( comparison > 0 ) {

        high = i - 1;

      } else {

        high = i;
        break;

        // DONE

      }

    }

    i = high;

    //console.log('b' , i, low, high, Date.now()- time);

    if ( arcLengths[ i ] === targetArcLength ) {

      var t = i / ( il - 1 );
      return t;

    }

    // we could get finer grain at lengths, or use simple interpolation between two points

    var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il - 1 );

    return t;

  },

  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation

  getTangent: function( t ) {

    var delta = 0.0001;
    var t1 = t - delta;
    var t2 = t + delta;

    // Capping in case of danger

    if ( t1 < 0 ) t1 = 0;
    if ( t2 > 1 ) t2 = 1;

    var pt1 = this.getPoint( t1 );
    var pt2 = this.getPoint( t2 );

    var vec = pt2.clone().sub( pt1 );
    return vec.normalize();

  },

  getTangentAt: function ( u ) {

    var t = this.getUtoTmapping( u );
    return this.getTangent( t );

  }

}

THREE.Curve.Utils = THREE.CurveUtils; // backwards compatibility

// TODO: Transformation for Curves?

/**************************************************************
 *  3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

  constructor.prototype = Object.create( THREE.Curve.prototype );
  constructor.prototype.constructor = constructor;
  constructor.prototype.getPoint = getPointFunc;

  return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

  this.curves = [];

  this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

  this.curves.push( curve );

};

/*
THREE.CurvePath.prototype.checkConnection = function() {
  // TODO
  // If the ending of curve is not connected to the starting
  // or the next curve, then, this is not a real path
};
*/

THREE.CurvePath.prototype.closePath = function() {

  // TODO Test
  // and verify for vector3 (needs to implement equals)
  // Add a line curve if start and end of lines are not connected
  var startPoint = this.curves[ 0 ].getPoint( 0 );
  var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

  if ( ! startPoint.equals( endPoint ) ) {

    this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

  }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0;

  // To think about boundaries points.

  while ( i < curveLengths.length ) {

    if ( curveLengths[ i ] >= d ) {

      var diff = curveLengths[ i ] - d;
      var curve = this.curves[ i ];

      var u = 1 - diff / curve.getLength();

      return curve.getPointAt( u );

    }

    i ++;

  }

  return null;

  // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};
*/

// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

  var lens = this.getCurveLengths();
  return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

  // We use cache values if curves and cache array are same length

  if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    return this.cacheLengths;

  }

  // Get length of sub-curve
  // Push sums into cached array

  var lengths = [], sums = 0;

  for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

    sums += this.curves[ i ].getLength();
    lengths.push( sums );

  }

  this.cacheLengths = lengths;

  return lengths;

};



/**************************************************************
 *  Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

  var pts = this.getPoints( divisions );
  return this.createGeometry( pts );

};

// Generate geometry from equidistant sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

  var pts = this.getSpacedPoints( divisions );
  return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

  var geometry = new THREE.Geometry();

  for ( var i = 0, l = points.length; i < l; i ++ ) {

    var point = points[ i ];
    geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

  }

  return geometry;

};

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

  THREE.CurvePath.call( this );

  this.actions = [];

  if ( points ) {

    this.fromPoints( points );

  }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

  this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  for ( var i = 1, l = vectors.length; i < l; i ++ ) {

    this.lineTo( vectors[ i ].x, vectors[ i ].y );

  }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

  this.actions.push( { action: 'moveTo', args: [ x, y ] } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
  this.curves.push( curve );

  this.actions.push( { action: 'lineTo', args: [ x, y ] } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.QuadraticBezierCurve(
    new THREE.Vector2( x0, y0 ),
    new THREE.Vector2( aCPx, aCPy ),
    new THREE.Vector2( aX, aY )
  );

  this.curves.push( curve );

  this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.CubicBezierCurve(
    new THREE.Vector2( x0, y0 ),
    new THREE.Vector2( aCP1x, aCP1y ),
    new THREE.Vector2( aCP2x, aCP2y ),
    new THREE.Vector2( aX, aY )
  );

  this.curves.push( curve );

  this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var npts = [ new THREE.Vector2( x0, y0 ) ];
  Array.prototype.push.apply( npts, pts );

  var curve = new THREE.SplineCurve( npts );
  this.curves.push( curve );

  this.actions.push( { action: 'splineThru', args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absarc( aX + x0, aY + y0, aRadius,
    aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  var lastargs = this.actions[ this.actions.length - 1 ].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  var args = [
    aX, aY,
    xRadius, yRadius,
    aStartAngle, aEndAngle,
    aClockwise,
    aRotation || 0 // aRotation is optional.
  ];

  var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
  this.curves.push( curve );

  var lastPoint = curve.getPoint( 1 );
  args.push( lastPoint.x );
  args.push( lastPoint.y );

  this.actions.push( { action: 'ellipse', args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 40;

  var points = [];

  for ( var i = 0; i < divisions; i ++ ) {

    points.push( this.getPoint( i / divisions ) );

    //if ( !this.getPoint( i / divisions ) ) throw "DIE";

  }

  if ( this.autoClose ) {

    points.push( points[ 0 ] );

  }

  return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions ) {

  divisions = divisions || 12;

  var b2 = THREE.ShapeUtils.b2;
  var b3 = THREE.ShapeUtils.b3;

  var points = [];

  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
    laste, tx, ty;

  for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

    var item = this.actions[ i ];

    var action = item.action;
    var args = item.args;

    switch ( action ) {

    case 'moveTo':

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case 'lineTo':

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case 'quadraticCurveTo':

      cpx  = args[ 2 ];
      cpy  = args[ 3 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }

      for ( var j = 1; j <= divisions; j ++ ) {

        var t = j / divisions;

        tx = b2( t, cpx0, cpx1, cpx );
        ty = b2( t, cpy0, cpy1, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case 'bezierCurveTo':

      cpx  = args[ 4 ];
      cpy  = args[ 5 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      cpx2 = args[ 2 ];
      cpy2 = args[ 3 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }


      for ( var j = 1; j <= divisions; j ++ ) {

        var t = j / divisions;

        tx = b3( t, cpx0, cpx1, cpx2, cpx );
        ty = b3( t, cpy0, cpy1, cpy2, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case 'splineThru':

      laste = this.actions[ i - 1 ].args;

      var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
      var spts = [ last ];

      var n = divisions * args[ 0 ].length;

      spts = spts.concat( args[ 0 ] );

      var spline = new THREE.SplineCurve( spts );

      for ( var j = 1; j <= n; j ++ ) {

        points.push( spline.getPointAt( j / n ) );

      }

      break;

    case 'arc':

      var aX = args[ 0 ], aY = args[ 1 ],
        aRadius = args[ 2 ],
        aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
        aClockwise = !! args[ 5 ];

      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( var j = 1; j <= tdivisions; j ++ ) {

        var t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + aRadius * Math.cos( angle );
        ty = aY + aRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    case 'ellipse':

      var aX = args[ 0 ], aY = args[ 1 ],
        xRadius = args[ 2 ],
        yRadius = args[ 3 ],
        aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
        aClockwise = !! args[ 6 ],
        aRotation = args[ 7 ];


      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      var cos, sin;
      if ( aRotation !== 0 ) {

        cos = Math.cos( aRotation );
        sin = Math.sin( aRotation );

      }

      for ( var j = 1; j <= tdivisions; j ++ ) {

        var t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + xRadius * Math.cos( angle );
        ty = aY + yRadius * Math.sin( angle );

        if ( aRotation !== 0 ) {

          var x = tx, y = ty;

          // Rotate the point about the center of the ellipse.
          tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
          ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

        }

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    } // end switch

  }



  // Normalize to remove the closing point by default.
  var lastPoint = points[ points.length - 1 ];
  if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
       Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
    points.splice( points.length - 1, 1 );

  if ( this.autoClose ) {

    points.push( points[ 0 ] );

  }

  return points;

};

//
// Breaks path into shapes
//
//  Assumptions (if parameter isCCW==true the opposite holds):
//  - solid shapes are defined clockwise (CW)
//  - holes are defined counterclockwise (CCW)
//
//  If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

  function extractSubpaths( inActions ) {

    var subPaths = [], lastPath = new THREE.Path();

    for ( var i = 0, l = inActions.length; i < l; i ++ ) {

      var item = inActions[ i ];

      var args = item.args;
      var action = item.action;

      if ( action === 'moveTo' ) {

        if ( lastPath.actions.length !== 0 ) {

          subPaths.push( lastPath );
          lastPath = new THREE.Path();

        }

      }

      lastPath[ action ].apply( lastPath, args );

    }

    if ( lastPath.actions.length !== 0 ) {

      subPaths.push( lastPath );

    }

    // console.log(subPaths);

    return  subPaths;

  }

  function toShapesNoHoles( inSubpaths ) {

    var shapes = [];

    for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

      var tmpPath = inSubpaths[ i ];

      var tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;

      shapes.push( tmpShape );

    }

    //console.log("shape", shapes);

    return shapes;

  }

  function isPointInsidePolygon( inPt, inPolygon ) {

    var polyLen = inPolygon.length;

    // inPt on polygon contour => immediate success    or
    // toggling of inside/outside at every single! intersection point of an edge
    //  with the horizontal line through inPt, left of inPt
    //  not counting lowerY endpoints of edges and whole edges on that line
    var inside = false;
    for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

      var edgeLowPt  = inPolygon[ p ];
      var edgeHighPt = inPolygon[ q ];

      var edgeDx = edgeHighPt.x - edgeLowPt.x;
      var edgeDy = edgeHighPt.y - edgeLowPt.y;

      if ( Math.abs( edgeDy ) > Number.EPSILON ) {

        // not parallel
        if ( edgeDy < 0 ) {

          edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
          edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

        }
        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

        if ( inPt.y === edgeLowPt.y ) {

          if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?
          // continue;        // no intersection or edgeLowPt => doesn't count !!!

        } else {

          var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
          if ( perpEdge === 0 )       return  true;   // inPt is on contour ?
          if ( perpEdge < 0 )         continue;
          inside = ! inside;    // true intersection left of inPt

        }

      } else {

        // parallel or collinear
        if ( inPt.y !== edgeLowPt.y )     continue;     // parallel
        // edge lies on the same horizontal line as inPt
        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
           ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
        // continue;

      }

    }

    return  inside;

  }

  var isClockWise = THREE.ShapeUtils.isClockWise;

  var subPaths = extractSubpaths( this.actions );
  if ( subPaths.length === 0 ) return [];

  if ( noHoles === true ) return  toShapesNoHoles( subPaths );


  var solid, tmpPath, tmpShape, shapes = [];

  if ( subPaths.length === 1 ) {

    tmpPath = subPaths[ 0 ];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push( tmpShape );
    return shapes;

  }

  var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
  holesFirst = isCCW ? ! holesFirst : holesFirst;

  // console.log("Holes first", holesFirst);

  var betterShapeHoles = [];
  var newShapes = [];
  var newShapeHoles = [];
  var mainIdx = 0;
  var tmpPoints;

  newShapes[ mainIdx ] = undefined;
  newShapeHoles[ mainIdx ] = [];

  for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

    tmpPath = subPaths[ i ];
    tmpPoints = tmpPath.getPoints();
    solid = isClockWise( tmpPoints );
    solid = isCCW ? ! solid : solid;

    if ( solid ) {

      if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) ) mainIdx ++;

      newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
      newShapes[ mainIdx ].s.actions = tmpPath.actions;
      newShapes[ mainIdx ].s.curves = tmpPath.curves;

      if ( holesFirst ) mainIdx ++;
      newShapeHoles[ mainIdx ] = [];

      //console.log('cw', i);

    } else {

      newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

      //console.log('ccw', i);

    }

  }

  // only Holes? -> probably all Shapes with wrong orientation
  if ( ! newShapes[ 0 ] ) return  toShapesNoHoles( subPaths );


  if ( newShapes.length > 1 ) {

    var ambiguous = false;
    var toChange = [];

    for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

      betterShapeHoles[ sIdx ] = [];

    }

    for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

      var sho = newShapeHoles[ sIdx ];

      for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

        var ho = sho[ hIdx ];
        var hole_unassigned = true;

        for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

          if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

            if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
            if ( hole_unassigned ) {

              hole_unassigned = false;
              betterShapeHoles[ s2Idx ].push( ho );

            } else {

              ambiguous = true;

            }

          }

        }
        if ( hole_unassigned ) {

          betterShapeHoles[ sIdx ].push( ho );

        }

      }

    }
    // console.log("ambiguous: ", ambiguous);
    if ( toChange.length > 0 ) {

      // console.log("to change: ", toChange);
      if ( ! ambiguous )  newShapeHoles = betterShapeHoles;

    }

  }

  var tmpHoles;

  for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

    tmpShape = newShapes[ i ].s;
    shapes.push( tmpShape );
    tmpHoles = newShapeHoles[ i ];

    for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

      tmpShape.holes.push( tmpHoles[ j ].h );

    }

  }

  //console.log("shape", shapes);

  return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

  THREE.Path.apply( this, arguments );

  this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

  return new THREE.ExtrudeGeometry( this, options );

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

  return new THREE.ShapeGeometry( this, options );

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

  var holesPts = [];

  for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getPoints( divisions );

  }

  return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

  return {

    shape: this.getPoints( divisions ),
    holes: this.getPointsHoles( divisions )

  };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

  return this.extractAllPoints( divisions );

};

THREE.Shape.Utils = THREE.ShapeUtils; // backwards compatibility

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *  Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

  this.v1 = v1;
  this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

  var point = this.v2.clone().sub( this.v1 );
  point.multiplyScalar( t ).add( this.v1 );

  return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

  return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

  var tangent = this.v2.clone().sub( this.v1 );

  return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  var b2 = THREE.ShapeUtils.b2;

  return new THREE.Vector2(
    b2( t, this.v0.x, this.v1.x, this.v2.x ),
    b2( t, this.v0.y, this.v1.y, this.v2.y )
  );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

  var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

  return new THREE.Vector2(
    tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
    tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
  ).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

  var b3 = THREE.ShapeUtils.b3;

  return new THREE.Vector2(
    b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
  );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

  var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

  return new THREE.Vector2(
    tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
  ).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *  Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

  this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

  var points = this.points;
  var point = ( points.length - 1 ) * t;

  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  var point1 = points[ intPoint ];
  var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  var interpolate = THREE.CurveUtils.interpolate;

  return new THREE.Vector2(
    interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    interpolate( point0.y, point1.y, point2.y, point3.y, weight )
  );

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *  Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

  this.aX = aX;
  this.aY = aY;

  this.xRadius = xRadius;
  this.yRadius = yRadius;

  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;

  this.aClockwise = aClockwise;

  this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

  var deltaAngle = this.aEndAngle - this.aStartAngle;

  if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
  if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

  var angle;

  if ( this.aClockwise === true ) {

    angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

  } else {

    angle = this.aStartAngle + t * deltaAngle;

  }

  var x = this.aX + this.xRadius * Math.cos( angle );
  var y = this.aY + this.yRadius * Math.sin( angle );

  if ( this.aRotation !== 0 ) {

    var cos = Math.cos( this.aRotation );
    var sin = Math.sin( this.aRotation );

    var tx = x, ty = y;

    // Rotate the point about the center of the ellipse.
    x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
    y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

  }

  return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *  Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *  Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

  function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var b2 = THREE.ShapeUtils.b2;

    return new THREE.Vector3(
      b2( t, this.v0.x, this.v1.x, this.v2.x ),
      b2( t, this.v0.y, this.v1.y, this.v2.y ),
      b2( t, this.v0.z, this.v1.z, this.v2.z )
    );

  }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  },

  function ( t ) {

    var b3 = THREE.ShapeUtils.b3;

    return new THREE.Vector3(
      b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
      b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
      b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
    );

  }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *  Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */ ) {

    console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var interpolate = THREE.CurveUtils.interpolate;

    return new THREE.Vector3(
      interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
      interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
      interpolate( point0.z, point1.z, point2.z, point3.z, weight )
    );

  }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

  var
    tmp = new THREE.Vector3(),
    px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  }

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    this.c0 = x0;
    this.c1 = t0;
    this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

  };

  CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    // compute tangents when parameterized in [t1,t2]
    var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    // rescale tangents for parametrization in [0,1]
    t1 *= dt1;
    t2 *= dt1;

    // initCubicPoly
    this.init( x1, x2, t1, t2 );

  };

  // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
  CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  };

  CubicPoly.prototype.calc = function( t ) {

    var t2 = t * t;
    var t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

  };

  // Subclass Three.js curve
  return THREE.Curve.create(

    function ( p /* array of Vector3 */ ) {

      this.points = p || [];
      this.closed = false;

    },

    function ( t ) {

      var points = this.points,
        point, intPoint, weight, l;

      l = points.length;

      if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

      point = ( l - ( this.closed ? 0 : 1 ) ) * t;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      if ( this.closed ) {

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

      } else if ( weight === 0 && intPoint === l - 1 ) {

        intPoint = l - 2;
        weight = 1;

      }

      var p0, p1, p2, p3; // 4 points

      if ( this.closed || intPoint > 0 ) {

        p0 = points[ ( intPoint - 1 ) % l ];

      } else {

        // extrapolate first point
        tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
        p0 = tmp;

      }

      p1 = points[ intPoint % l ];
      p2 = points[ ( intPoint + 1 ) % l ];

      if ( this.closed || intPoint + 2 < l ) {

        p3 = points[ ( intPoint + 2 ) % l ];

      } else {

        // extrapolate last point
        tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
        p3 = tmp;

      }

      if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

        // init Centripetal / Chordal Catmull-Rom
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
        var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
        var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

        // safety check for repeated points
        if ( dt1 < 1e-4 ) dt1 = 1.0;
        if ( dt0 < 1e-4 ) dt0 = dt1;
        if ( dt2 < 1e-4 ) dt2 = dt1;

        px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
        py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
        pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

      } else if ( this.type === 'catmullrom' ) {

        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
        py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
        pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

      }

      var v = new THREE.Vector3(
        px.calc( weight ),
        py.calc( weight ),
        pz.calc( weight )
      );

      return v;

    }

  );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = function ( points ) {

  console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

  THREE.CatmullRomCurve3.call( this, points );
  this.type = 'catmullrom';
  this.closed = true;

};

THREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  THREE.Geometry.call( this );

  this.type = 'BoxGeometry';

  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };

  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;

  var scope = this;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
  buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
  buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
  buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
  buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
  buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

  function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

    var w, ix, iy,
    gridX = scope.widthSegments,
    gridY = scope.heightSegments,
    width_half = width / 2,
    height_half = height / 2,
    offset = scope.vertices.length;

    if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

      w = 'z';

    } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

      w = 'y';
      gridY = scope.depthSegments;

    } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

      w = 'x';
      gridX = scope.depthSegments;

    }

    var gridX1 = gridX + 1,
    gridY1 = gridY + 1,
    segment_width = width / gridX,
    segment_height = height / gridY,
    normal = new THREE.Vector3();

    normal[ w ] = depth > 0 ? 1 : - 1;

    for ( iy = 0; iy < gridY1; iy ++ ) {

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var vector = new THREE.Vector3();
        vector[ u ] = ( ix * segment_width - width_half ) * udir;
        vector[ v ] = ( iy * segment_height - height_half ) * vdir;
        vector[ w ] = depth;

        scope.vertices.push( vector );

      }

    }

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
        var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
        var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
        var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

        var face = new THREE.Face3( a + offset, b + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

        face = new THREE.Face3( b + offset, c + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
        face.materialIndex = materialIndex;

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

      }

    }

  }

  this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CircleGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'CircleBufferGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var vertices = segments + 2;

  var positions = new Float32Array( vertices * 3 );
  var normals = new Float32Array( vertices * 3 );
  var uvs = new Float32Array( vertices * 2 );

  // center data is already zero, but need to set a few extras
  normals[ 2 ] = 1.0;
  uvs[ 0 ] = 0.5;
  uvs[ 1 ] = 0.5;

  for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    var segment = thetaStart + s / segments * thetaLength;

    positions[ i ] = radius * Math.cos( segment );
    positions[ i + 1 ] = radius * Math.sin( segment );

    normals[ i + 2 ] = 1; // normal z

    uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

  }

  var indices = [];

  for ( var i = 1; i <= segments; i ++ ) {

    indices.push( i, i + 1, 0 );

  }

  this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CylinderGeometry';

  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  radialSegments = radialSegments || 8;
  heightSegments = heightSegments || 1;

  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

  var heightHalf = height / 2;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    var v = y / heightSegments;
    var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    for ( x = 0; x <= radialSegments; x ++ ) {

      var u = x / radialSegments;

      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
      vertex.y = - v * height + heightHalf;
      vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  var tanTheta = ( radiusBottom - radiusTop ) / height;
  var na, nb;

  for ( x = 0; x < radialSegments; x ++ ) {

    if ( radiusTop !== 0 ) {

      na = this.vertices[ vertices[ 0 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

    } else {

      na = this.vertices[ vertices[ 1 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

    }

    na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
    nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

    for ( y = 0; y < heightSegments; y ++ ) {

      var v1 = vertices[ y ][ x ];
      var v2 = vertices[ y + 1 ][ x ];
      var v3 = vertices[ y + 1 ][ x + 1 ];
      var v4 = vertices[ y ][ x + 1 ];

      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();

      var uv1 = uvs[ y ][ x ].clone();
      var uv2 = uvs[ y + 1 ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
      var uv4 = uvs[ y ][ x + 1 ].clone();

      this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

      this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

    }

  }

  // top cap

  if ( openEnded === false && radiusTop > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ 0 ][ x ];
      var v2 = vertices[ 0 ][ x + 1 ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, 1, 0 );
      var n2 = new THREE.Vector3( 0, 1, 0 );
      var n3 = new THREE.Vector3( 0, 1, 0 );

      var uv1 = uvs[ 0 ][ x ].clone();
      var uv2 = uvs[ 0 ][ x + 1 ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 0 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 1 ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  // bottom cap

  if ( openEnded === false && radiusBottom > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ heightSegments ][ x + 1 ];
      var v2 = vertices[ heightSegments ][ x ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, - 1, 0 );
      var n2 = new THREE.Vector3( 0, - 1, 0 );
      var n3 = new THREE.Vector3( 0, - 1, 0 );

      var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
      var uv2 = uvs[ heightSegments ][ x ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 1 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ], undefined, 2 ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

  THREE.BufferGeometry.call( this );

  thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

  var edge = [ 0, 0 ], hash = {};

  function sortFunction( a, b ) {

    return a - b;

  }

  var keys = [ 'a', 'b', 'c' ];

  var geometry2;

  if ( geometry instanceof THREE.BufferGeometry ) {

    geometry2 = new THREE.Geometry();
    geometry2.fromBufferGeometry( geometry );

  } else {

    geometry2 = geometry.clone();

  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();

  var vertices = geometry2.vertices;
  var faces = geometry2.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0; j < 3; j ++ ) {

      edge[ 0 ] = face[ keys[ j ] ];
      edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
      edge.sort( sortFunction );

      var key = edge.toString();

      if ( hash[ key ] === undefined ) {

        hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

      } else {

        hash[ key ].face2 = i;

      }

    }

  }

  var coords = [];

  for ( var key in hash ) {

    var h = hash[ key ];

    if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

      var vertex = vertices[ h.vert1 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

      vertex = vertices[ h.vert2 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

    }

  }

  this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

  if ( typeof( shapes ) === "undefined" ) {

    shapes = [];
    return;

  }

  THREE.Geometry.call( this );

  this.type = 'ExtrudeGeometry';

  shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

  // can't really use automatic vertex normals
  // as then front and back sides get smoothed too
  // should do separate smoothing just for sides

  //this.computeVertexNormals();

  //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

  var sl = shapes.length;

  for ( var s = 0; s < sl; s ++ ) {

    var shape = shapes[ s ];
    this.addShape( shape, options );

  }

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

  var amount = options.amount !== undefined ? options.amount : 100;

  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var steps = options.steps !== undefined ? options.steps : 1;

  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;

  // Use default WorldUVGenerator if no UV generators are specified.
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

  var splineTube, binormal, normal, position2;
  if ( extrudePath ) {

    extrudePts = extrudePath.getSpacedPoints( steps );

    extrudeByPath = true;
    bevelEnabled = false; // bevels not supported for path extrusion

    // SETUP TNB variables

    // Reuse TNB from TubeGeomtry for now.
    // TODO1 - have a .isClosed in spline?

    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();

  }

  // Safeguards if bevels are not enabled

  if ( ! bevelEnabled ) {

    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;

  }

  // Variables initialization

  var ahole, h, hl; // looping of holes
  var scope = this;

  var shapesOffset = this.vertices.length;

  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe ...

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

        holes[ h ] = ahole.reverse();

      }

    }

    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  }


  var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

  /* Vertices */

  var contour = vertices; // vertices has all points but contour has only points of circumference

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    vertices = vertices.concat( ahole );

  }


  function scalePt2 ( pt, vec, size ) {

    if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    return vec.clone().multiplyScalar( size ).add( pt );

  }

  var b, bs, t, z,
    vert, vlen = vertices.length,
    face, flen = faces.length;


  // Find directions for point movement


  function getBevelVec( inPt, inPrev, inNext ) {

    // computes for inPt the corresponding point inPt' on a new contour
    //   shifted by 1 unit (length of normalized vector) to the left
    // if we walk along contour clockwise, this new contour is outside the old one
    //
    // inPt' is the intersection of the two lines parallel to the two
    //  adjacent edges of inPt at a distance of 1 unit on the left side.

    var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt

    // good reading for geometry algorithms (here: line-line intersection)
    // http://geomalgorithms.com/a05-_intersect-1.html

    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    // check for collinear edges
    var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    if ( Math.abs( collinear0 ) > Number.EPSILON ) {

      // not collinear

      // length of vectors for normalizing

      var v_prev_len = Math.sqrt( v_prev_lensq );
      var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

      // shift adjacent points by unit vectors to the left

      var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
      var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

      var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
      var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

      // scaling factor for v_prev to intersection point

      var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
            ( v_prev_x * v_next_y - v_prev_y * v_next_x );

      // vector from inPt to intersection point

      v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
      v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

      // Don't normalize!, otherwise sharp corners become ugly
      //  but prevent crazy spikes
      var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
      if ( v_trans_lensq <= 2 ) {

        return  new THREE.Vector2( v_trans_x, v_trans_y );

      } else {

        shrink_by = Math.sqrt( v_trans_lensq / 2 );

      }

    } else {

      // handle special case of collinear edges

      var direction_eq = false;   // assumes: opposite
      if ( v_prev_x > Number.EPSILON ) {

        if ( v_next_x > Number.EPSILON ) {

          direction_eq = true;

        }

      } else {

        if ( v_prev_x < - Number.EPSILON ) {

          if ( v_next_x < - Number.EPSILON ) {

            direction_eq = true;

          }

        } else {

          if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

            direction_eq = true;

          }

        }

      }

      if ( direction_eq ) {

        // console.log("Warning: lines are a straight sequence");
        v_trans_x = - v_prev_y;
        v_trans_y =  v_prev_x;
        shrink_by = Math.sqrt( v_prev_lensq );

      } else {

        // console.log("Warning: lines are a straight spike");
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt( v_prev_lensq / 2 );

      }

    }

    return  new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  }


  var contourMovements = [];

  for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    if ( j === il ) j = 0;
    if ( k === il ) k = 0;

    //  (j)---(i)---(k)
    // console.log('i,j,k', i, j , k)

    contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  }

  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    oneHoleMovements = [];

    for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    }

    holesMovements.push( oneHoleMovements );
    verticesMovements = verticesMovements.concat( oneHoleMovements );

  }


  // Loop bevelSegments, 1 for the front, 1 for the back

  for ( b = 0; b < bevelSegments; b ++ ) {

    //for ( b = bevelSegments; b > 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );

    //z = bevelThickness * t;
    bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
    //bs = bevelSize * t; // linear

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

      v( vert.x, vert.y,  - z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        v( vert.x, vert.y,  - z );

      }

    }

  }

  bs = bevelSize;

  // Back facing vertices

  for ( i = 0; i < vlen; i ++ ) {

    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    if ( ! extrudeByPath ) {

      v( vert.x, vert.y, 0 );

    } else {

      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

      normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
      binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

      position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

      v( position2.x, position2.y, position2.z );

    }

  }

  // Add stepped vertices...
  // Including front facing vertices

  var s;

  for ( s = 1; s <= steps; s ++ ) {

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, amount / steps * s );

      } else {

        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

        normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

  }


  // Add bevel segments planes

  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for ( b = bevelSegments - 1; b >= 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );
    //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
    bs = bevelSize * Math.sin ( t * Math.PI / 2 );

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
      v( vert.x, vert.y,  amount + z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y,  amount + z );

        } else {

          v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

        }

      }

    }

  }

  /* Faces */

  // Top and bottom faces

  buildLidFaces();

  // Sides faces

  buildSideFaces();


  /////  Internal functions

  function buildLidFaces() {

    if ( bevelEnabled ) {

      var layer = 0; // steps + 1
      var offset = vlen * layer;

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

      }

      layer = steps + bevelSegments * 2;
      offset = vlen * layer;

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

      }

    } else {

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

      }

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

      }

    }

  }

  // Create faces for the z-sides of the shape

  function buildSideFaces() {

    var layeroffset = 0;
    sidewalls( contour, layeroffset );
    layeroffset += contour.length;

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      sidewalls( ahole, layeroffset );

      //, true
      layeroffset += ahole.length;

    }

  }

  function sidewalls( contour, layeroffset ) {

    var j, k;
    i = contour.length;

    while ( -- i >= 0 ) {

      j = i;
      k = i - 1;
      if ( k < 0 ) k = contour.length - 1;

      //console.log('b', i,j, i-1, k,vertices.length);

      var s = 0, sl = steps  + bevelSegments * 2;

      for ( s = 0; s < sl; s ++ ) {

        var slen1 = vlen * s;
        var slen2 = vlen * ( s + 1 );

        var a = layeroffset + j + slen1,
          b = layeroffset + k + slen1,
          c = layeroffset + k + slen2,
          d = layeroffset + j + slen2;

        f4( a, b, c, d, contour, s, sl, j, k );

      }

    }

  }


  function v( x, y, z ) {

    scope.vertices.push( new THREE.Vector3( x, y, z ) );

  }

  function f3( a, b, c ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

    var uvs = uvgen.generateTopUV( scope, a, b, c );

    scope.faceVertexUvs[ 0 ].push( uvs );

  }

  function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
    scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

    var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

  }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

  generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];

    return [
      new THREE.Vector2( a.x, a.y ),
      new THREE.Vector2( b.x, b.y ),
      new THREE.Vector2( c.x, c.y )
    ];

  },

  generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];
    var d = vertices[ indexD ];

    if ( Math.abs( a.y - b.y ) < 0.01 ) {

      return [
        new THREE.Vector2( a.x, 1 - a.z ),
        new THREE.Vector2( b.x, 1 - b.z ),
        new THREE.Vector2( c.x, 1 - c.z ),
        new THREE.Vector2( d.x, 1 - d.z )
      ];

    } else {

      return [
        new THREE.Vector2( a.y, 1 - a.z ),
        new THREE.Vector2( b.y, 1 - b.z ),
        new THREE.Vector2( c.y, 1 - c.z ),
        new THREE.Vector2( d.y, 1 - d.z )
      ];

    }

  }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

  THREE.Geometry.call( this );

  this.type = 'ShapeGeometry';

  if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

  for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    this.addShape( shapes[ i ], options );

  }

  return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

  if ( options === undefined ) options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

  //

  var i, l, hole;

  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe...

    for ( i = 0, l = holes.length; i < l; i ++ ) {

      hole = holes[ i ];

      if ( THREE.ShapeUtils.isClockWise( hole ) ) {

        holes[ i ] = hole.reverse();

      }

    }

    reverse = false;

  }

  var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

  // Vertices

  for ( i = 0, l = holes.length; i < l; i ++ ) {

    hole = holes[ i ];
    vertices = vertices.concat( hole );

  }

  //

  var vert, vlen = vertices.length;
  var face, flen = faces.length;

  for ( i = 0; i < vlen; i ++ ) {

    vert = vertices[ i ];

    this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

  }

  for ( i = 0; i < flen; i ++ ) {

    face = faces[ i ];

    var a = face[ 0 ] + shapesOffset;
    var b = face[ 1 ] + shapesOffset;
    var c = face[ 2 ] + shapesOffset;

    this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
    this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

  }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

  THREE.Geometry.call( this );

  this.type = 'LatheGeometry';

  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };

  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  var inversePointLength = 1.0 / ( points.length - 1 );
  var inverseSegments = 1.0 / segments;

  for ( var i = 0, il = segments; i <= il; i ++ ) {

    var phi = phiStart + i * inverseSegments * phiLength;

    var c = Math.cos( phi ),
      s = Math.sin( phi );

    for ( var j = 0, jl = points.length; j < jl; j ++ ) {

      var pt = points[ j ];

      var vertex = new THREE.Vector3();

      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;

      this.vertices.push( vertex );

    }

  }

  var np = points.length;

  for ( var i = 0, il = segments; i < il; i ++ ) {

    for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;

      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;

      this.faces.push( new THREE.Face3( a, b, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u0, v0 ),
        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u0, v1 )

      ] );

      this.faces.push( new THREE.Face3( b, c, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u1, v1 ),
        new THREE.Vector2( u0, v1 )

      ] );


    }

  }

  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.Geometry.call( this );

  this.type = 'PlaneGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.BufferGeometry.call( this );

  this.type = 'PlaneBufferGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  var width_half = width / 2;
  var height_half = height / 2;

  var gridX = Math.floor( widthSegments ) || 1;
  var gridY = Math.floor( heightSegments ) || 1;

  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;

  var segment_width = width / gridX;
  var segment_height = height / gridY;

  var vertices = new Float32Array( gridX1 * gridY1 * 3 );
  var normals = new Float32Array( gridX1 * gridY1 * 3 );
  var uvs = new Float32Array( gridX1 * gridY1 * 2 );

  var offset = 0;
  var offset2 = 0;

  for ( var iy = 0; iy < gridY1; iy ++ ) {

    var y = iy * segment_height - height_half;

    for ( var ix = 0; ix < gridX1; ix ++ ) {

      var x = ix * segment_width - width_half;

      vertices[ offset ] = x;
      vertices[ offset + 1 ] = - y;

      normals[ offset + 2 ] = 1;

      uvs[ offset2 ] = ix / gridX;
      uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

      offset += 3;
      offset2 += 2;

    }

  }

  offset = 0;

  var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

  for ( var iy = 0; iy < gridY; iy ++ ) {

    for ( var ix = 0; ix < gridX; ix ++ ) {

      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * ( iy + 1 );
      var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
      var d = ( ix + 1 ) + gridX1 * iy;

      indices[ offset ] = a;
      indices[ offset + 1 ] = b;
      indices[ offset + 2 ] = d;

      indices[ offset + 3 ] = b;
      indices[ offset + 4 ] = c;
      indices[ offset + 5 ] = d;

      offset += 6;

    }

  }

  this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'RingGeometry';

  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

  var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

  for ( i = 0; i < phiSegments + 1; i ++ ) {

    // concentric circles inside ring

    for ( o = 0; o < thetaSegments + 1; o ++ ) {

      // number of segments per circle

      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      this.vertices.push( vertex );
      uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );

    }

    radius += radiusStep;

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 0; i < phiSegments; i ++ ) {

    // concentric circles inside ring

    var thetaSegment = i * ( thetaSegments + 1 );

    for ( o = 0; o < thetaSegments ; o ++ ) {

      // number of segments per circle

      var segment = o + thetaSegment;

      var v1 = segment;
      var v2 = segment + thetaSegments + 1;
      var v3 = segment + thetaSegments + 2;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

      v1 = segment;
      v2 = segment + thetaSegments + 2;
      v3 = segment + 1;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ] );

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'SphereGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'SphereBufferGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var thetaEnd = thetaStart + thetaLength;

  var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

  var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

  var index = 0, vertices = [], normal = new THREE.Vector3();

  for ( var y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];

    var v = y / heightSegments;

    for ( var x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;

      var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      var py = radius * Math.cos( thetaStart + v * thetaLength );
      var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      normal.set( px, py, pz ).normalize();

      positions.setXYZ( index, px, py, pz );
      normals.setXYZ( index, normal.x, normal.y, normal.z );
      uvs.setXY( index, u, 1 - v );

      verticesRow.push( index );

      index ++;

    }

    vertices.push( verticesRow );

  }

  var indices = [];

  for ( var y = 0; y < heightSegments; y ++ ) {

    for ( var x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
      if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    }

  }

  this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
  this.addAttribute( 'position', positions );
  this.addAttribute( 'normal', normals );
  this.addAttribute( 'uv', uvs );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

  THREE.Geometry.call( this );

  this.type = 'TorusGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 8;
  tubularSegments = tubularSegments || 6;
  arc = arc || Math.PI * 2;

  var center = new THREE.Vector3(), uvs = [], normals = [];

  for ( var j = 0; j <= radialSegments; j ++ ) {

    for ( var i = 0; i <= tubularSegments; i ++ ) {

      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;

      center.x = radius * Math.cos( u );
      center.y = radius * Math.sin( u );

      var vertex = new THREE.Vector3();
      vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
      vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
      vertex.z = tube * Math.sin( v );

      this.vertices.push( vertex );

      uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
      normals.push( vertex.clone().sub( center ).normalize() );

    }

  }

  for ( var j = 1; j <= radialSegments; j ++ ) {

    for ( var i = 1; i <= tubularSegments; i ++ ) {

      var a = ( tubularSegments + 1 ) * j + i - 1;
      var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
      var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
      var d = ( tubularSegments + 1 ) * j + i;

      var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

      face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

    }

  }

  this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

  THREE.Geometry.call( this );

  this.type = 'TorusKnotGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    p: p,
    q: q,
    heightScale: heightScale
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 64;
  tubularSegments = tubularSegments || 8;
  p = p || 2;
  q = q || 3;
  heightScale = heightScale || 1;

  var grid = new Array( radialSegments );
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();

  for ( var i = 0; i < radialSegments; ++ i ) {

    grid[ i ] = new Array( tubularSegments );
    var u = i / radialSegments * 2 * p * Math.PI;
    var p1 = getPos( u, q, p, radius, heightScale );
    var p2 = getPos( u + 0.01, q, p, radius, heightScale );
    tang.subVectors( p2, p1 );
    n.addVectors( p2, p1 );

    bitan.crossVectors( tang, n );
    n.crossVectors( bitan, tang );
    bitan.normalize();
    n.normalize();

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var v = j / tubularSegments * 2 * Math.PI;
      var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      var cy = tube * Math.sin( v );

      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;

      grid[ i ][ j ] = this.vertices.push( pos ) - 1;

    }

  }

  for ( var i = 0; i < radialSegments; ++ i ) {

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var ip = ( i + 1 ) % radialSegments;
      var jp = ( j + 1 ) % tubularSegments;

      var a = grid[ i ][ j ];
      var b = grid[ ip ][ j ];
      var c = grid[ ip ][ jp ];
      var d = grid[ i ][ jp ];

      var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
      var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
      var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
      var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  this.computeFaceNormals();
  this.computeVertexNormals();

  function getPos( u, in_q, in_p, radius, heightScale ) {

    var cu = Math.cos( u );
    var su = Math.sin( u );
    var quOverP = in_q / in_p * u;
    var cs = Math.cos( quOverP );

    var tx = radius * ( 2 + cs ) * 0.5 * cu;
    var ty = radius * ( 2 + cs ) * su * 0.5;
    var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

    return new THREE.Vector3( tx, ty, tz );

  }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

  THREE.Geometry.call( this );

  this.type = 'TubeGeometry';

  this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed,
    taper: taper
  };

  segments = segments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  taper = taper || THREE.TubeGeometry.NoTaper;

  var grid = [];

  var scope = this,

    tangent,
    normal,
    binormal,

    numpoints = segments + 1,

    u, v, r,

    cx, cy,
    pos, pos2 = new THREE.Vector3(),
    i, j,
    ip, jp,
    a, b, c, d,
    uva, uvb, uvc, uvd;

  var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
    tangents = frames.tangents,
    normals = frames.normals,
    binormals = frames.binormals;

  // proxy internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  function vert( x, y, z ) {

    return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

  }

  // construct the grid

  for ( i = 0; i < numpoints; i ++ ) {

    grid[ i ] = [];

    u = i / ( numpoints - 1 );

    pos = path.getPointAt( u );

    tangent = tangents[ i ];
    normal = normals[ i ];
    binormal = binormals[ i ];

    r = radius * taper( u );

    for ( j = 0; j < radialSegments; j ++ ) {

      v = j / radialSegments * 2 * Math.PI;

      cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      cy = r * Math.sin( v );

      pos2.copy( pos );
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;

      grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    }

  }


  // construct the mesh

  for ( i = 0; i < segments; i ++ ) {

    for ( j = 0; j < radialSegments; j ++ ) {

      ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
      jp = ( j + 1 ) % radialSegments;

      a = grid[ i ][ j ];   // *** NOT NECESSARILY PLANAR ! ***
      b = grid[ ip ][ j ];
      c = grid[ ip ][ jp ];
      d = grid[ i ][ jp ];

      uva = new THREE.Vector2( i / segments, j / radialSegments );
      uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
      uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
      uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

  return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

  return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

  var normal = new THREE.Vector3(),

    tangents = [],
    normals = [],
    binormals = [],

    vec = new THREE.Vector3(),
    mat = new THREE.Matrix4(),

    numpoints = segments + 1,
    theta,
    smallest,

    tx, ty, tz,
    i, u;


  // expose internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  // compute the tangent vectors for each segment on the path

  for ( i = 0; i < numpoints; i ++ ) {

    u = i / ( numpoints - 1 );

    tangents[ i ] = path.getTangentAt( u );
    tangents[ i ].normalize();

  }

  initialNormal3();

  /*
  function initialNormal1(lastBinormal) {
    // fixed start binormal. Has dangers of 0 vectors
    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
  }

  function initialNormal2() {

    // This uses the Frenet-Serret formula for deriving binormal
    var t2 = path.getTangentAt( epsilon );

    normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

  }
  */

  function initialNormal3() {

    // select an initial normal vector perpendicular to the first tangent vector,
    // and in the direction of the smallest tangent xyz component

    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs( tangents[ 0 ].x );
    ty = Math.abs( tangents[ 0 ].y );
    tz = Math.abs( tangents[ 0 ].z );

    if ( tx <= smallest ) {

      smallest = tx;
      normal.set( 1, 0, 0 );

    }

    if ( ty <= smallest ) {

      smallest = ty;
      normal.set( 0, 1, 0 );

    }

    if ( tz <= smallest ) {

      normal.set( 0, 0, 1 );

    }

    vec.crossVectors( tangents[ 0 ], normal ).normalize();

    normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

  }


  // compute the slowly-varying normal and binormal vectors for each segment on the path

  for ( i = 1; i < numpoints; i ++ ) {

    normals[ i ] = normals[ i - 1 ].clone();

    binormals[ i ] = binormals[ i - 1 ].clone();

    vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    if ( vec.length() > Number.EPSILON ) {

      vec.normalize();

      theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

      normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    }

    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  }


  // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  if ( closed ) {

    theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    theta /= ( numpoints - 1 );

    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

      theta = - theta;

    }

    for ( i = 1; i < numpoints; i ++ ) {

      // twist a little...
      normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
      binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }

  }

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

  THREE.Geometry.call( this );

  this.type = 'PolyhedronGeometry';

  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };

  radius = radius || 1;
  detail = detail || 0;

  var that = this;

  for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

  }

  var p = this.vertices;

  var faces = [];

  for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    var v1 = p[ indices[ i ] ];
    var v2 = p[ indices[ i + 1 ] ];
    var v3 = p[ indices[ i + 2 ] ];

    faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );

  }

  var centroid = new THREE.Vector3();

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    subdivide( faces[ i ], detail );

  }


  // Handle case when face straddles the seam

  for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    var uvs = this.faceVertexUvs[ 0 ][ i ];

    var x0 = uvs[ 0 ].x;
    var x1 = uvs[ 1 ].x;
    var x2 = uvs[ 2 ].x;

    var max = Math.max( x0, x1, x2 );
    var min = Math.min( x0, x1, x2 );

    if ( max > 0.9 && min < 0.1 ) {

      // 0.9 is somewhat arbitrary

      if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
      if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
      if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    }

  }


  // Apply radius

  for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    this.vertices[ i ].multiplyScalar( radius );

  }


  // Merge vertices

  this.mergeVertices();

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


  // Project vector onto sphere's surface

  function prepare( vector ) {

    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push( vertex ) - 1;

    // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    var v = inclination( vector ) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2( u, 1 - v );

    return vertex;

  }


  // Approximate a curved face with recursively sub-divided triangles.

  function make( v1, v2, v3, materialIndex ) {

    var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );
    that.faces.push( face );

    centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    var azi = azimuth( centroid );

    that.faceVertexUvs[ 0 ].push( [
      correctUV( v1.uv, v1, azi ),
      correctUV( v2.uv, v2, azi ),
      correctUV( v3.uv, v3, azi )
    ] );

  }


  // Analytically subdivide a face to the required detail level.

  function subdivide( face, detail ) {

    var cols = Math.pow( 2, detail );
    var a = prepare( that.vertices[ face.a ] );
    var b = prepare( that.vertices[ face.b ] );
    var c = prepare( that.vertices[ face.c ] );
    var v = [];

    var materialIndex = face.materialIndex;

    // Construct all of the vertices for this subdivision.

    for ( var i = 0 ; i <= cols; i ++ ) {

      v[ i ] = [];

      var aj = prepare( a.clone().lerp( c, i / cols ) );
      var bj = prepare( b.clone().lerp( c, i / cols ) );
      var rows = cols - i;

      for ( var j = 0; j <= rows; j ++ ) {

        if ( j === 0 && i === cols ) {

          v[ i ][ j ] = aj;

        } else {

          v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

        }

      }

    }

    // Construct all of the faces.

    for ( var i = 0; i < cols ; i ++ ) {

      for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

        var k = Math.floor( j / 2 );

        if ( j % 2 === 0 ) {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1 ][ k ],
            v[ i ][ k ],
            materialIndex
          );

        } else {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1 ][ k + 1 ],
            v[ i + 1 ][ k ],
            materialIndex
          );

        }

      }

    }

  }


  // Angle around the Y axis, counter-clockwise when looking from above.

  function azimuth( vector ) {

    return Math.atan2( vector.z, - vector.x );

  }


  // Angle above the XZ plane.

  function inclination( vector ) {

    return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  }


  // Texture fixing helper. Spheres have some odd behaviours.

  function correctUV( uv, vector, azimuth ) {

    if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
    if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    return uv.clone();

  }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  var r = 1 / t;

  var vertices = [

    // (±1, ±1, ±1)
    - 1, - 1, - 1,    - 1, - 1,  1,
    - 1,  1, - 1,    - 1,  1,  1,
     1, - 1, - 1,     1, - 1,  1,
     1,  1, - 1,     1,  1,  1,

    // (0, ±1/φ, ±φ)
     0, - r, - t,     0, - r,  t,
     0,  r, - t,     0,  r,  t,

    // (±1/φ, ±φ, 0)
    - r, - t,  0,    - r,  t,  0,
     r, - t,  0,     r,  t,  0,

    // (±φ, 0, ±1/φ)
    - t,  0, - r,     t,  0, - r,
    - t,  0,  r,     t,  0,  r
  ];

  var indices = [
     3, 11,  7,      3,  7, 15,      3, 15, 13,
     7, 19, 17,      7, 17,  6,      7,  6, 15,
    17,  4,  8,     17,  8, 10,     17, 10,  6,
     8,  0, 16,      8, 16,  2,      8,  2, 10,
     0, 12,  1,      0,  1, 18,      0, 18, 16,
     6, 10,  2,      6,  2, 13,      6, 13, 15,
     2, 16, 18,      2, 18,  3,      2,  3, 13,
    18,  1,  9,     18,  9, 11,     18, 11,  3,
     4, 14, 12,      4, 12,  0,      4,  0,  8,
    11,  9,  5,     11,  5, 19,     11, 19,  7,
    19,  5, 14,     19, 14,  4,     19,  4, 17,
     1, 12, 14,      1, 14,  5,      1,  5,  9
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'DodecahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

  var vertices = [
    1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
  ];

  var indices = [
    0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'OctahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

  var vertices = [
     1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  ];

  var indices = [
     2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'TetrahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

  THREE.Geometry.call( this );

  this.type = 'ParametricGeometry';

  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[ 0 ];

  var i, j, p;
  var u, v;

  var sliceCount = slices + 1;

  for ( i = 0; i <= stacks; i ++ ) {

    v = i / stacks;

    for ( j = 0; j <= slices; j ++ ) {

      u = j / slices;

      p = func( u, v );
      verts.push( p );

    }

  }

  var a, b, c, d;
  var uva, uvb, uvc, uvd;

  for ( i = 0; i < stacks; i ++ ) {

    for ( j = 0; j < slices; j ++ ) {

      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = ( i + 1 ) * sliceCount + j + 1;
      d = ( i + 1 ) * sliceCount + j;

      uva = new THREE.Vector2( j / slices, i / stacks );
      uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
      uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
      uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

      faces.push( new THREE.Face3( a, b, d ) );
      uvs.push( [ uva, uvb, uvd ] );

      faces.push( new THREE.Face3( b, c, d ) );
      uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  // console.log(this);

  // magic bullet
  // var diff = this.mergeVertices();
  // console.log('removed ', diff, ' vertices by merging');

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

  THREE.BufferGeometry.call( this );

  var edge = [ 0, 0 ], hash = {};

  function sortFunction( a, b ) {

    return a - b;

  }

  var keys = [ 'a', 'b', 'c' ];

  if ( geometry instanceof THREE.Geometry ) {

    var vertices = geometry.vertices;
    var faces = geometry.faces;
    var numEdges = 0;

    // allocate maximal size
    var edges = new Uint32Array( 6 * faces.length );

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge[ 0 ] = face[ keys[ j ] ];
        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
        edge.sort( sortFunction );

        var key = edge.toString();

        if ( hash[ key ] === undefined ) {

          edges[ 2 * numEdges ] = edge[ 0 ];
          edges[ 2 * numEdges + 1 ] = edge[ 1 ];
          hash[ key ] = true;
          numEdges ++;

        }

      }

    }

    var coords = new Float32Array( numEdges * 2 * 3 );

    for ( var i = 0, l = numEdges; i < l; i ++ ) {

      for ( var j = 0; j < 2; j ++ ) {

        var vertex = vertices[ edges [ 2 * i + j ] ];

        var index = 6 * i + 3 * j;
        coords[ index + 0 ] = vertex.x;
        coords[ index + 1 ] = vertex.y;
        coords[ index + 2 ] = vertex.z;

      }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  } else if ( geometry instanceof THREE.BufferGeometry ) {

    if ( geometry.index !== null ) {

      // Indexed BufferGeometry

      var indices = geometry.index.array;
      var vertices = geometry.attributes.position;
      var groups = geometry.groups;
      var numEdges = 0;

      if ( groups.length === 0 ) {

        geometry.addGroup( 0, indices.length );

      }

      // allocate maximal size
      var edges = new Uint32Array( 2 * indices.length );

      for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

        var group = groups[ o ];

        var start = group.start;
        var count = group.count;

        for ( var i = start, il = start + count; i < il; i += 3 ) {

          for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = indices[ i + j ];
            edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

              edges[ 2 * numEdges ] = edge[ 0 ];
              edges[ 2 * numEdges + 1 ] = edge[ 1 ];
              hash[ key ] = true;
              numEdges ++;

            }

          }

        }

      }

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numEdges; i < l; i ++ ) {

        for ( var j = 0; j < 2; j ++ ) {

          var index = 6 * i + 3 * j;
          var index2 = edges[ 2 * i + j ];

          coords[ index + 0 ] = vertices.getX( index2 );
          coords[ index + 1 ] = vertices.getY( index2 );
          coords[ index + 2 ] = vertices.getZ( index2 );

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else {

      // non-indexed BufferGeometry

      var vertices = geometry.attributes.position.array;
      var numEdges = vertices.length / 3;
      var numTris = numEdges / 3;

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numTris; i < l; i ++ ) {

        for ( var j = 0; j < 3; j ++ ) {

          var index = 18 * i + 6 * j;

          var index1 = 9 * i + 3 * j;
          coords[ index + 0 ] = vertices[ index1 ];
          coords[ index + 1 ] = vertices[ index1 + 1 ];
          coords[ index + 2 ] = vertices[ index1 + 2 ];

          var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
          coords[ index + 3 ] = vertices[ index2 ];
          coords[ index + 4 ] = vertices[ index2 + 1 ];
          coords[ index + 5 ] = vertices[ index2 + 2 ];

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }

  }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

  size = size || 1;

  var vertices = new Float32Array( [
    0, 0, 0,  size, 0, 0,
    0, 0, 0,  0, size, 0,
    0, 0, 0,  0, 0, size
  ] );

  var colors = new Float32Array( [
    1, 0, 0,  1, 0.6, 0,
    0, 1, 0,  0.6, 1, 0,
    0, 0, 1,  0, 0.6, 1
  ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

  var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
  coneGeometry.translate( 0, - 0.5, 0 );

  return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    THREE.Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.position.copy( origin );

    this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

  var axis = new THREE.Vector3();
  var radians;

  return function setDirection( dir ) {

    // dir is assumed to be normalized

    if ( dir.y > 0.99999 ) {

      this.quaternion.set( 0, 0, 0, 1 );

    } else if ( dir.y < - 0.99999 ) {

      this.quaternion.set( 1, 0, 0, 0 );

    } else {

      axis.set( dir.z, 0, - dir.x ).normalize();

      radians = Math.acos( dir.y );

      this.quaternion.setFromAxisAngle( axis, radians );

    }

  };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  if ( headLength === undefined ) headLength = 0.2 * length;
  if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
  this.line.updateMatrix();

  this.cone.scale.set( headWidth, headLength, headWidth );
  this.cone.position.y = length;
  this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

  this.line.material.color.set( color );
  this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

  var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
  var positions = new Float32Array( 8 * 3 );

  var geometry = new THREE.BufferGeometry();
  geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

  if ( object !== undefined ) {

    this.update( object );

  }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

  var box = new THREE.Box3();

  return function ( object ) {

    box.setFromObject( object );

    if ( box.isEmpty() ) return;

    var min = box.min;
    var max = box.max;

    /*
      5____4
    1/___0/|
    | 6__|_7
    2/___3/

    0: max.x, max.y, max.z
    1: min.x, max.y, max.z
    2: min.x, min.y, max.z
    3: max.x, min.y, max.z
    4: max.x, max.y, min.z
    5: min.x, max.y, min.z
    6: min.x, min.y, min.z
    7: max.x, min.y, min.z
    */

    var position = this.geometry.attributes.position;
    var array = position.array;

    array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
    array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
    array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
    array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
    array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
    array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
    array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
    array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

    position.needsUpdate = true;

    this.geometry.computeBoundingSphere();

  };

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0x888888;

  this.object = object;

  this.box = new THREE.Box3();

  THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

  this.box.setFromObject( this.object );

  this.box.size( this.scale );

  this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *  - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

  var pointMap = {};

  // colors

  var hexFrustum = 0xffaa00;
  var hexCone = 0xff0000;
  var hexUp = 0x00aaff;
  var hexTarget = 0xffffff;
  var hexCross = 0x333333;

  // near

  addLine( "n1", "n2", hexFrustum );
  addLine( "n2", "n4", hexFrustum );
  addLine( "n4", "n3", hexFrustum );
  addLine( "n3", "n1", hexFrustum );

  // far

  addLine( "f1", "f2", hexFrustum );
  addLine( "f2", "f4", hexFrustum );
  addLine( "f4", "f3", hexFrustum );
  addLine( "f3", "f1", hexFrustum );

  // sides

  addLine( "n1", "f1", hexFrustum );
  addLine( "n2", "f2", hexFrustum );
  addLine( "n3", "f3", hexFrustum );
  addLine( "n4", "f4", hexFrustum );

  // cone

  addLine( "p", "n1", hexCone );
  addLine( "p", "n2", hexCone );
  addLine( "p", "n3", hexCone );
  addLine( "p", "n4", hexCone );

  // up

  addLine( "u1", "u2", hexUp );
  addLine( "u2", "u3", hexUp );
  addLine( "u3", "u1", hexUp );

  // target

  addLine( "c", "t", hexTarget );
  addLine( "p", "c", hexCross );

  // cross

  addLine( "cn1", "cn2", hexCross );
  addLine( "cn3", "cn4", hexCross );

  addLine( "cf1", "cf2", hexCross );
  addLine( "cf3", "cf4", hexCross );

  function addLine( a, b, hex ) {

    addPoint( a, hex );
    addPoint( b, hex );

  }

  function addPoint( id, hex ) {

    geometry.vertices.push( new THREE.Vector3() );
    geometry.colors.push( new THREE.Color( hex ) );

    if ( pointMap[ id ] === undefined ) {

      pointMap[ id ] = [];

    }

    pointMap[ id ].push( geometry.vertices.length - 1 );

  }

  THREE.LineSegments.call( this, geometry, material );

  this.camera = camera;
  this.camera.updateProjectionMatrix();

  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;

  this.pointMap = pointMap;

  this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

  var geometry, pointMap;

  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();

  function setPoint( point, x, y, z ) {

    vector.set( x, y, z ).unproject( camera );

    var points = pointMap[ point ];

    if ( points !== undefined ) {

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        geometry.vertices[ points[ i ] ].copy( vector );

      }

    }

  }

  return function () {

    geometry = this.geometry;
    pointMap = this.pointMap;

    var w = 1, h = 1;

    // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy( this.camera.projectionMatrix );

    // center / target

    setPoint( "c", 0, 0, - 1 );
    setPoint( "t", 0, 0,  1 );

    // near

    setPoint( "n1", - w, - h, - 1 );
    setPoint( "n2",   w, - h, - 1 );
    setPoint( "n3", - w,   h, - 1 );
    setPoint( "n4",   w,   h, - 1 );

    // far

    setPoint( "f1", - w, - h, 1 );
    setPoint( "f2",   w, - h, 1 );
    setPoint( "f3", - w,   h, 1 );
    setPoint( "f4",   w,   h, 1 );

    // up

    setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    setPoint( "u3",         0, h * 2,   - 1 );

    // cross

    setPoint( "cf1", - w,   0, 1 );
    setPoint( "cf2",   w,   0, 1 );
    setPoint( "cf3",   0, - h, 1 );
    setPoint( "cf4",   0,   h, 1 );

    setPoint( "cn1", - w,   0, - 1 );
    setPoint( "cn2",   w,   0, - 1 );
    setPoint( "cn3",   0, - h, - 1 );
    setPoint( "cn4",   0,   h, - 1 );

    geometry.verticesNeedUpdate = true;

  };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  size = size || 1;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3( - size,   size, 0 ),
    new THREE.Vector3(   size,   size, 0 ),
    new THREE.Vector3(   size, - size, 0 ),
    new THREE.Vector3( - size, - size, 0 ),
    new THREE.Vector3( - size,   size, 0 )
  );

  var material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.lightPlane = new THREE.Line( geometry, material );
  this.add( this.lightPlane );

  geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(),
    new THREE.Vector3()
  );

  material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.targetLine = new THREE.Line( geometry, material );
  this.add( this.targetLine );

  this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var v3 = new THREE.Vector3();

  return function () {

    v1.setFromMatrixPosition( this.light.matrixWorld );
    v2.setFromMatrixPosition( this.light.target.matrixWorld );
    v3.subVectors( v2, v1 );

    this.lightPlane.lookAt( v3 );
    this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine.geometry.vertices[ 1 ].copy( v3 );
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy( this.lightPlane.material.color );

  };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

  // FaceNormalsHelper only supports THREE.Geometry

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xffff00;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  //

  var nNormals = 0;

  var objGeometry = this.object.geometry;

  if ( objGeometry instanceof THREE.Geometry ) {

    nNormals = objGeometry.faces.length;

  } else {

    console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

  }

  //

  var geometry = new THREE.BufferGeometry();

  var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

  geometry.addAttribute( 'position', positions );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  //

  this.matrixAutoUpdate = false;
  this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var normalMatrix = new THREE.Matrix3();

  return function update() {

    this.object.updateMatrixWorld( true );

    normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var matrixWorld = this.object.matrixWorld;

    var position = this.geometry.attributes.position;

    //

    var objGeometry = this.object.geometry;

    var vertices = objGeometry.vertices;

    var faces = objGeometry.faces;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      var normal = face.normal;

      v1.copy( vertices[ face.a ] )
        .add( vertices[ face.b ] )
        .add( vertices[ face.c ] )
        .divideScalar( 3 )
        .applyMatrix4( matrixWorld );

      v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

      position.setXYZ( idx, v1.x, v1.y, v1.z );

      idx = idx + 1;

      position.setXYZ( idx, v2.x, v2.y, v2.z );

      idx = idx + 1;

    }

    position.needsUpdate = true;

    return this;

  }

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  this.color1 = new THREE.Color( 0x444444 );
  this.color2 = new THREE.Color( 0x888888 );

  for ( var i = - size; i <= size; i += step ) {

    geometry.vertices.push(
      new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
      new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
    );

    var color = i === 0 ? this.color1 : this.color2;

    geometry.colors.push( color, color, color, color );

  }

  THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

  this.color1.set( colorCenterLine );
  this.color2.set( colorGrid );

  this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  this.colors = [ new THREE.Color(), new THREE.Color() ];

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  geometry.rotateX( - Math.PI / 2 );

  for ( var i = 0, il = 8; i < il; i ++ ) {

    geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

  }

  var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

  this.lightSphere = new THREE.Mesh( geometry, material );
  this.add( this.lightSphere );

  this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();

  return function () {

    this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    this.lightSphere.geometry.colorsNeedUpdate = true;

  }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

  this.light = light;
  this.light.updateMatrixWorld();

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  THREE.Mesh.call( this, geometry, material );

  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;

  /*
  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  var d = light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.scale.set( d, d, d );

  }

  this.add( this.lightDistance );
  */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

  this.geometry.dispose();
  this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

  this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  /*
  var d = this.light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.visible = true;
    this.lightDistance.scale.set( d, d, d );

  }
  */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

  this.bones = this.getBoneList( object );

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );
      geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
      geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

    }

  }

  geometry.dynamic = true;

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  THREE.LineSegments.call( this, geometry, material );

  this.root = object;

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

  this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

  var boneList = [];

  if ( object instanceof THREE.Bone ) {

    boneList.push( object );

  }

  for ( var i = 0; i < object.children.length; i ++ ) {

    boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  }

  return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

  var geometry = this.geometry;

  var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

  var boneMatrix = new THREE.Matrix4();

  var j = 0;

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
      geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
      geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

      j += 2;

    }

  }

  geometry.verticesNeedUpdate = true;

  geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

  geometry.translate( 0, - 0.5, 0 );
  geometry.rotateX( - Math.PI / 2 );

  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

  this.cone = new THREE.Mesh( geometry, material );
  this.add( this.cone );

  this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

  this.cone.geometry.dispose();
  this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();

  return function () {

    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan( this.light.angle );

    this.cone.scale.set( coneWidth, coneWidth, coneLength );

    vector.setFromMatrixPosition( this.light.matrixWorld );
    vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    this.cone.lookAt( vector2.sub( vector ) );

    this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xff0000;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  //

  var nNormals = 0;

  var objGeometry = this.object.geometry;

  if ( objGeometry instanceof THREE.Geometry ) {

    nNormals = objGeometry.faces.length * 3;

  } else if ( objGeometry instanceof THREE.BufferGeometry ) {

    nNormals = objGeometry.attributes.normal.count

  }

  //

  var geometry = new THREE.BufferGeometry();

  var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

  geometry.addAttribute( 'position', positions );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  //

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var normalMatrix = new THREE.Matrix3();

  return function update() {

    var keys = [ 'a', 'b', 'c' ];

    this.object.updateMatrixWorld( true );

    normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var matrixWorld = this.object.matrixWorld;

    var position = this.geometry.attributes.position;

    //

    var objGeometry = this.object.geometry;

    if ( objGeometry instanceof THREE.Geometry ) {

      var vertices = objGeometry.vertices;

      var faces = objGeometry.faces;

      var idx = 0;

      for ( var i = 0, l = faces.length; i < l; i ++ ) {

        var face = faces[ i ];

        for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

          var vertex = vertices[ face[ keys[ j ] ] ];

          var normal = face.vertexNormals[ j ];

          v1.copy( vertex ).applyMatrix4( matrixWorld );

          v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

          position.setXYZ( idx, v1.x, v1.y, v1.z );

          idx = idx + 1;

          position.setXYZ( idx, v2.x, v2.y, v2.z );

          idx = idx + 1;

        }

      }

    } else if ( objGeometry instanceof THREE.BufferGeometry ) {

      var objPos = objGeometry.attributes.position;

      var objNorm = objGeometry.attributes.normal;

      var idx = 0;

      // for simplicity, ignore index and drawcalls, and render every normal

      for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

        v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

        v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

        v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

        position.setXYZ( idx, v1.x, v1.y, v1.z );

        idx = idx + 1;

        position.setXYZ( idx, v2.x, v2.y, v2.z );

        idx = idx + 1;

      }

    }

    position.needsUpdate = true;

    return this;

  }

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

  THREE.Object3D.call( this );

  this.material = material;
  this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.animationsMap = {};
  this.animationsList = [];

  // prepare default animation
  // (all frames played together in 1 second)

  var numFrames = this.geometry.morphTargets.length;

  var name = "__default";

  var startFrame = 0;
  var endFrame = numFrames - 1;

  var fps = numFrames / 1;

  this.createAnimation( name, startFrame, endFrame, fps );
  this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  var animation = {

    start: start,
    end: end,

    length: end - start + 1,

    fps: fps,
    duration: ( end - start ) / fps,

    lastFrame: 0,
    currentFrame: 0,

    active: false,

    time: 0,
    direction: 1,
    weight: 1,

    directionBackwards: false,
    mirroredLoop: false

  };

  this.animationsMap[ name ] = animation;
  this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  var pattern = /([a-z]+)_?(\d+)/i;

  var firstAnimation, frameRanges = {};

  var geometry = this.geometry;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var chunks = morph.name.match( pattern );

    if ( chunks && chunks.length > 1 ) {

      var name = chunks[ 1 ];

      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

      var range = frameRanges[ name ];

      if ( i < range.start ) range.start = i;
      if ( i > range.end ) range.end = i;

      if ( ! firstAnimation ) firstAnimation = name;

    }

  }

  for ( var name in frameRanges ) {

    var range = frameRanges[ name ];
    this.createAnimation( name, range.start, range.end, fps );

  }

  this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = 1;
    animation.directionBackwards = false;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = - 1;
    animation.directionBackwards = true;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.fps = fps;
    animation.duration = ( animation.end - animation.start ) / animation.fps;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.duration = duration;
    animation.fps = ( animation.end - animation.start ) / animation.duration;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.weight = weight;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = time;

  }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  var time = 0;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    time = animation.time;

  }

  return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  var duration = - 1;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    duration = animation.duration;

  }

  return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = 0;
    animation.active = true;

  } else {

    console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.active = false;

  }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

  for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    var animation = this.animationsList[ i ];

    if ( ! animation.active ) continue;

    var frameTime = animation.duration / animation.length;

    animation.time += animation.direction * delta;

    if ( animation.mirroredLoop ) {

      if ( animation.time > animation.duration || animation.time < 0 ) {

        animation.direction *= - 1;

        if ( animation.time > animation.duration ) {

          animation.time = animation.duration;
          animation.directionBackwards = true;

        }

        if ( animation.time < 0 ) {

          animation.time = 0;
          animation.directionBackwards = false;

        }

      }

    } else {

      animation.time = animation.time % animation.duration;

      if ( animation.time < 0 ) animation.time += animation.duration;

    }

    var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    var weight = animation.weight;

    if ( keyframe !== animation.currentFrame ) {

      this.morphTargetInfluences[ animation.lastFrame ] = 0;
      this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

      this.morphTargetInfluences[ keyframe ] = 0;

      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;

    }

    var mix = ( animation.time % frameTime ) / frameTime;

    if ( animation.directionBackwards ) mix = 1 - mix;

    if ( animation.currentFrame !== animation.lastFrame ) {

      this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
      this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    } else {

      this.morphTargetInfluences[ animation.currentFrame ] = weight;

    }

  }

};


},{}],20:[function(_dereq_,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 */

THREE.VRControls = function ( object, onError ) {

  var scope = this;

  var vrInputs = [];

  function filterInvalidDevices( devices ) {

    // Exclude Cardboard position sensor if Oculus exists.

    var oculusDevices = devices.filter( function ( device ) {

      return device.deviceName.toLowerCase().indexOf( 'oculus' ) !== - 1;

    } );

    if ( oculusDevices.length >= 1 ) {

      return devices.filter( function ( device ) {

        return device.deviceName.toLowerCase().indexOf( 'cardboard' ) === - 1;

      } );

    } else {

      return devices;

    }

  }

  function gotVRDevices( devices ) {

    devices = filterInvalidDevices( devices );

    for ( var i = 0; i < devices.length; i ++ ) {

      if ( devices[ i ] instanceof PositionSensorVRDevice ) {

        vrInputs.push( devices[ i ] );

      }

    }

    if ( onError ) onError( 'HMD not available' );

  }

  if ( navigator.getVRDevices ) {

    navigator.getVRDevices().then( gotVRDevices );

  }

  // the Rift SDK returns the position in meters
  // this scale factor allows the user to define how meters
  // are converted to scene units.

  this.scale = 1;

  this.update = function () {

    for ( var i = 0; i < vrInputs.length; i ++ ) {

      var vrInput = vrInputs[ i ];

      var state = vrInput.getState();

      if ( state.orientation !== null ) {

        object.quaternion.copy( state.orientation );

      }

      if ( state.position !== null ) {

        object.position.copy( state.position ).multiplyScalar( scope.scale );

      }

    }

  };

  this.resetSensor = function () {

    for ( var i = 0; i < vrInputs.length; i ++ ) {

      var vrInput = vrInputs[ i ];

      if ( vrInput.resetSensor !== undefined ) {

        vrInput.resetSensor();

      } else if ( vrInput.zeroSensor !== undefined ) {

        vrInput.zeroSensor();

      }

    }

  };

  this.zeroSensor = function () {

    console.warn( 'THREE.VRControls: .zeroSensor() is now .resetSensor().' );
    this.resetSensor();

  };

  this.dispose = function () {

    vrInputs = [];

  };

};

},{}],21:[function(_dereq_,module,exports){
/**
 * @author dmarcos / https://github.com/dmarcos
 * @author mrdoob / http://mrdoob.com
 *
 * WebVR Spec: http://mozvr.github.io/webvr-spec/webvr.html
 *
 * Firefox: http://mozvr.com/downloads/
 * Chromium: https://drive.google.com/folderview?id=0BzudLt22BqGRbW9WTHMtOWMzNjQ&usp=sharing#list
 *
 */

THREE.VREffect = function ( renderer, onError ) {

  var vrHMD;
  var eyeTranslationL, eyeFOVL;
  var eyeTranslationR, eyeFOVR;

  function gotVRDevices( devices ) {

    for ( var i = 0; i < devices.length; i ++ ) {

      if ( devices[ i ] instanceof HMDVRDevice ) {

        vrHMD = devices[ i ];

        break; // We keep the first we encounter

      }

    }

    if ( vrHMD === undefined ) {

      if ( onError ) onError( 'HMD not available' );

    }

  }

  if ( navigator.getVRDevices ) {

    navigator.getVRDevices().then( gotVRDevices );

  }

  //

  this.scale = 1;

  this.setSize = function( width, height ) {

    renderer.setSize( width, height );

  };

  // fullscreen

  var isFullscreen = false;

  var canvas = renderer.domElement;
  var fullscreenchange = canvas.mozRequestFullScreen ? 'mozfullscreenchange' : 'webkitfullscreenchange';

  document.addEventListener( fullscreenchange, function ( event ) {

    isFullscreen = document.mozFullScreenElement || document.webkitFullscreenElement;

  }, false );

  this.setFullScreen = function ( boolean ) {

    if ( vrHMD === undefined ) return;
    if ( isFullscreen === boolean ) return;

    if ( canvas.mozRequestFullScreen ) {

      canvas.mozRequestFullScreen( { vrDisplay: vrHMD } );

    } else if ( canvas.webkitRequestFullscreen ) {

      canvas.webkitRequestFullscreen( { vrDisplay: vrHMD } );

    }

  };

  // render

  var cameraL = new THREE.PerspectiveCamera();
  cameraL.layers.enable( 1 );

  var cameraR = new THREE.PerspectiveCamera();
  cameraR.layers.enable( 2 );

  this.render = function ( scene, camera ) {

    if ( vrHMD ) {

      var eyeParamsL = vrHMD.getEyeParameters( 'left' );
      var eyeParamsR = vrHMD.getEyeParameters( 'right' );

      eyeTranslationL = eyeParamsL.eyeTranslation;
      eyeTranslationR = eyeParamsR.eyeTranslation;
      eyeFOVL = eyeParamsL.recommendedFieldOfView;
      eyeFOVR = eyeParamsR.recommendedFieldOfView;

      if ( Array.isArray( scene ) ) {

        console.warn( 'THREE.VREffect.render() no longer supports arrays. Use object.layers instead.' );
        scene = scene[ 0 ];

      }

      var size = renderer.getSize();
      size.width /= 2;

      renderer.setScissorTest( true );
      renderer.clear();

      if ( camera.parent === null ) camera.updateMatrixWorld();

      cameraL.projectionMatrix = fovToProjection( eyeFOVL, true, camera.near, camera.far );
      cameraR.projectionMatrix = fovToProjection( eyeFOVR, true, camera.near, camera.far );

      camera.matrixWorld.decompose( cameraL.position, cameraL.quaternion, cameraL.scale );
      camera.matrixWorld.decompose( cameraR.position, cameraR.quaternion, cameraR.scale );

      cameraL.translateX( eyeTranslationL.x * this.scale );
      cameraR.translateX( eyeTranslationR.x * this.scale );

      // render left eye
      renderer.setViewport( 0, 0, size.width, size.height );
      renderer.setScissor( 0, 0, size.width, size.height );
      renderer.render( scene, cameraL );

      // render right eye
      renderer.setViewport( size.width, 0, size.width, size.height );
      renderer.setScissor( size.width, 0, size.width, size.height );
      renderer.render( scene, cameraR );

      renderer.setScissorTest( false );

      return;

    }

    // Regular render mode if not HMD

    renderer.render( scene, camera );

  };

  //

  function fovToNDCScaleOffset( fov ) {

    var pxscale = 2.0 / ( fov.leftTan + fov.rightTan );
    var pxoffset = ( fov.leftTan - fov.rightTan ) * pxscale * 0.5;
    var pyscale = 2.0 / ( fov.upTan + fov.downTan );
    var pyoffset = ( fov.upTan - fov.downTan ) * pyscale * 0.5;
    return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };

  }

  function fovPortToProjection( fov, rightHanded, zNear, zFar ) {

    rightHanded = rightHanded === undefined ? true : rightHanded;
    zNear = zNear === undefined ? 0.01 : zNear;
    zFar = zFar === undefined ? 10000.0 : zFar;

    var handednessScale = rightHanded ? - 1.0 : 1.0;

    // start with an identity matrix
    var mobj = new THREE.Matrix4();
    var m = mobj.elements;

    // and with scale/offset info for normalized device coords
    var scaleAndOffset = fovToNDCScaleOffset( fov );

    // X result, map clip edges to [-w,+w]
    m[ 0 * 4 + 0 ] = scaleAndOffset.scale[ 0 ];
    m[ 0 * 4 + 1 ] = 0.0;
    m[ 0 * 4 + 2 ] = scaleAndOffset.offset[ 0 ] * handednessScale;
    m[ 0 * 4 + 3 ] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[ 1 * 4 + 0 ] = 0.0;
    m[ 1 * 4 + 1 ] = scaleAndOffset.scale[ 1 ];
    m[ 1 * 4 + 2 ] = - scaleAndOffset.offset[ 1 ] * handednessScale;
    m[ 1 * 4 + 3 ] = 0.0;

    // Z result (up to the app)
    m[ 2 * 4 + 0 ] = 0.0;
    m[ 2 * 4 + 1 ] = 0.0;
    m[ 2 * 4 + 2 ] = zFar / ( zNear - zFar ) * - handednessScale;
    m[ 2 * 4 + 3 ] = ( zFar * zNear ) / ( zNear - zFar );

    // W result (= Z in)
    m[ 3 * 4 + 0 ] = 0.0;
    m[ 3 * 4 + 1 ] = 0.0;
    m[ 3 * 4 + 2 ] = handednessScale;
    m[ 3 * 4 + 3 ] = 0.0;

    mobj.transpose();

    return mobj;

  }

  function fovToProjection( fov, rightHanded, zNear, zFar ) {

    var DEG2RAD = Math.PI / 180.0;

    var fovPort = {
      upTan: Math.tan( fov.upDegrees * DEG2RAD ),
      downTan: Math.tan( fov.downDegrees * DEG2RAD ),
      leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
      rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
    };

    return fovPortToProjection( fovPort, rightHanded, zNear, zFar );

  }

};

},{}],22:[function(_dereq_,module,exports){
/**
* @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com
* @author Tony Parisi / http://www.tonyparisi.com/
*/

THREE.ColladaLoader = function () {

  var COLLADA = null;
  var scene = null;
  var visualScene;
  var kinematicsModel;

  var readyCallbackFunc = null;

  var sources = {};
  var images = {};
  var animations = {};
  var controllers = {};
  var geometries = {};
  var materials = {};
  var effects = {};
  var cameras = {};
  var lights = {};

  var animData;
  var kinematics;
  var visualScenes;
  var kinematicsModels;
  var baseUrl;
  var morphs;
  var skins;

  var flip_uv = true;
  var preferredShading = THREE.SmoothShading;

  var options = {
    // Force Geometry to always be centered at the local origin of the
    // containing Mesh.
    centerGeometry: false,

    // Axis conversion is done for geometries, animations, and controllers.
    // If we ever pull cameras or lights out of the COLLADA file, they'll
    // need extra work.
    convertUpAxis: false,

    subdivideFaces: true,

    upAxis: 'Y',

    // For reflective or refractive materials we'll use this cubemap
    defaultEnvMap: null

  };

  var colladaUnit = 1.0;
  var colladaUp = 'Y';
  var upConversion = null;

  function load ( url, readyCallback, progressCallback, failCallback ) {

    var length = 0;

    if ( document.implementation && document.implementation.createDocument ) {

      var request = new XMLHttpRequest();

      request.onreadystatechange = function() {

        if ( request.readyState === 4 ) {

          if ( request.status === 0 || request.status === 200 ) {

            if ( request.response ) {

              readyCallbackFunc = readyCallback;
              parse( request.response, undefined, url );

            } else {

              if ( failCallback ) {

                failCallback();

              } else {

                console.error( "ColladaLoader: Empty or non-existing file (" + url + ")" );

              }

            }

          }

        } else if ( request.readyState === 3 ) {

          if ( progressCallback ) {

            if ( length === 0 ) {

              length = request.getResponseHeader( "Content-Length" );

            }

            progressCallback( { total: length, loaded: request.responseText.length } );

          }

        }

      };

      request.open( "GET", url, true );
      request.send( null );

    } else {

      alert( "Don't know how to parse XML!" );

    }

  }

  function parse( text, callBack, url ) {

    COLLADA = new DOMParser().parseFromString( text, 'text/xml' );
    callBack = callBack || readyCallbackFunc;

    if ( url !== undefined ) {

      var parts = url.split( '/' );
      parts.pop();
      baseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

    }

    parseAsset();
    setUpConversion();
    images = parseLib( "library_images image", _Image, "image" );
    materials = parseLib( "library_materials material", Material, "material" );
    effects = parseLib( "library_effects effect", Effect, "effect" );
    geometries = parseLib( "library_geometries geometry", Geometry, "geometry" );
    cameras = parseLib( "library_cameras camera", Camera, "camera" );
    lights = parseLib( "library_lights light", Light, "light" );
    controllers = parseLib( "library_controllers controller", Controller, "controller" );
    animations = parseLib( "library_animations animation", Animation, "animation" );
    visualScenes = parseLib( "library_visual_scenes visual_scene", VisualScene, "visual_scene" );
    kinematicsModels = parseLib( "library_kinematics_models kinematics_model", KinematicsModel, "kinematics_model" );

    morphs = [];
    skins = [];

    visualScene = parseScene();
    scene = new THREE.Group();

    for ( var i = 0; i < visualScene.nodes.length; i ++ ) {

      scene.add( createSceneGraph( visualScene.nodes[ i ] ) );

    }

    // unit conversion
    scene.scale.multiplyScalar( colladaUnit );

    createAnimations();

    kinematicsModel = parseKinematicsModel();
    createKinematics();

    var result = {

      scene: scene,
      morphs: morphs,
      skins: skins,
      animations: animData,
      kinematics: kinematics,
      dae: {
        images: images,
        materials: materials,
        cameras: cameras,
        lights: lights,
        effects: effects,
        geometries: geometries,
        controllers: controllers,
        animations: animations,
        visualScenes: visualScenes,
        visualScene: visualScene,
        scene: visualScene,
        kinematicsModels: kinematicsModels,
        kinematicsModel: kinematicsModel
      }

    };

    if ( callBack ) {

      callBack( result );

    }

    return result;

  }

  function setPreferredShading ( shading ) {

    preferredShading = shading;

  }

  function parseAsset () {

    var elements = COLLADA.querySelectorAll('asset');

    var element = elements[0];

    if ( element && element.childNodes ) {

      for ( var i = 0; i < element.childNodes.length; i ++ ) {

        var child = element.childNodes[ i ];

        switch ( child.nodeName ) {

          case 'unit':

            var meter = child.getAttribute( 'meter' );

            if ( meter ) {

              colladaUnit = parseFloat( meter );

            }

            break;

          case 'up_axis':

            colladaUp = child.textContent.charAt(0);
            break;

        }

      }

    }

  }

  function parseLib ( q, classSpec, prefix ) {

    var elements = COLLADA.querySelectorAll(q);

    var lib = {};

    var i = 0;

    var elementsLength = elements.length;

    for ( var j = 0; j < elementsLength; j ++ ) {

      var element = elements[j];
      var daeElement = ( new classSpec() ).parse( element );

      if ( !daeElement.id || daeElement.id.length === 0 ) daeElement.id = prefix + ( i ++ );
      lib[ daeElement.id ] = daeElement;

    }

    return lib;

  }

  function parseScene() {

    var sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];

    if ( sceneElement ) {

      var url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );
      return visualScenes[ url.length > 0 ? url : 'visual_scene0' ];

    } else {

      return null;

    }

  }

  function parseKinematicsModel() {

    var kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];

    if ( kinematicsModelElement ) {

      var url = kinematicsModelElement.getAttribute( 'url' ).replace(/^#/, '');
      return kinematicsModels[ url.length > 0 ? url : 'kinematics_model0' ];

    } else {

      return null;

    }

  }

  function createAnimations() {

    animData = [];

    // fill in the keys
    recurseHierarchy( scene );

  }

  function recurseHierarchy( node ) {

    var n = visualScene.getChildById( node.colladaId, true ),
      newData = null;

    if ( n && n.keys ) {

      newData = {
        fps: 60,
        hierarchy: [ {
          node: n,
          keys: n.keys,
          sids: n.sids
        } ],
        node: node,
        name: 'animation_' + node.name,
        length: 0
      };

      animData.push(newData);

      for ( var i = 0, il = n.keys.length; i < il; i ++ ) {

        newData.length = Math.max( newData.length, n.keys[i].time );

      }

    } else {

      newData = {
        hierarchy: [ {
          keys: [],
          sids: []
        } ]
      }

    }

    for ( var i = 0, il = node.children.length; i < il; i ++ ) {

      var d = recurseHierarchy( node.children[i] );

      for ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {

        newData.hierarchy.push( {
          keys: [],
          sids: []
        } );

      }

    }

    return newData;

  }

  function calcAnimationBounds () {

    var start = 1000000;
    var end = -start;
    var frames = 0;
    var ID;
    for ( var id in animations ) {

      var animation = animations[ id ];
      ID = ID || animation.id;
      for ( var i = 0; i < animation.sampler.length; i ++ ) {

        var sampler = animation.sampler[ i ];

        sampler.create();

        start = Math.min( start, sampler.startTime );
        end = Math.max( end, sampler.endTime );
        frames = Math.max( frames, sampler.input.length );

      }

    }

    return { start:start, end:end, frames:frames,ID:ID };

  }

  function createMorph ( geometry, ctrl ) {

    var morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;

    if ( !morphCtrl || !morphCtrl.morph ) {

      console.log("could not find morph controller!");
      return;

    }

    var morph = morphCtrl.morph;

    for ( var i = 0; i < morph.targets.length; i ++ ) {

      var target_id = morph.targets[ i ];
      var daeGeometry = geometries[ target_id ];

      if ( !daeGeometry.mesh ||
         !daeGeometry.mesh.primitives ||
         !daeGeometry.mesh.primitives.length ) {
         continue;
      }

      var target = daeGeometry.mesh.primitives[ 0 ].geometry;

      if ( target.vertices.length === geometry.vertices.length ) {

        geometry.morphTargets.push( { name: "target_1", vertices: target.vertices } );

      }

    }

    geometry.morphTargets.push( { name: "target_Z", vertices: geometry.vertices } );

  }

  function createSkin ( geometry, ctrl, applyBindShape ) {

    var skinCtrl = controllers[ ctrl.url ];

    if ( !skinCtrl || !skinCtrl.skin ) {

      console.log( "could not find skin controller!" );
      return;

    }

    if ( !ctrl.skeleton || !ctrl.skeleton.length ) {

      console.log( "could not find the skeleton for the skin!" );
      return;

    }

    var skin = skinCtrl.skin;
    var skeleton = visualScene.getChildById( ctrl.skeleton[ 0 ] );
    var hierarchy = [];

    applyBindShape = applyBindShape !== undefined ? applyBindShape : true;

    var bones = [];
    geometry.skinWeights = [];
    geometry.skinIndices = [];

    //createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );
    //createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );

    /*
    geometry.animation = {
      name: 'take_001',
      fps: 30,
      length: 2,
      JIT: true,
      hierarchy: hierarchy
    };
    */

    if ( applyBindShape ) {

      for ( var i = 0; i < geometry.vertices.length; i ++ ) {

        geometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );

      }

    }

  }

  function setupSkeleton ( node, bones, frame, parent ) {

    node.world = node.world || new THREE.Matrix4();
    node.localworld = node.localworld || new THREE.Matrix4();
    node.world.copy( node.matrix );
    node.localworld.copy( node.matrix );

    if ( node.channels && node.channels.length ) {

      var channel = node.channels[ 0 ];
      var m = channel.sampler.output[ frame ];

      if ( m instanceof THREE.Matrix4 ) {

        node.world.copy( m );
        node.localworld.copy(m);
        if (frame === 0)
          node.matrix.copy(m);
      }

    }

    if ( parent ) {

      node.world.multiplyMatrices( parent, node.world );

    }

    bones.push( node );

    for ( var i = 0; i < node.nodes.length; i ++ ) {

      setupSkeleton( node.nodes[ i ], bones, frame, node.world );

    }

  }

  function setupSkinningMatrices ( bones, skin ) {

    // FIXME: this is dumb...

    for ( var i = 0; i < bones.length; i ++ ) {

      var bone = bones[ i ];
      var found = -1;

      if ( bone.type != 'JOINT' ) continue;

      for ( var j = 0; j < skin.joints.length; j ++ ) {

        if ( bone.sid === skin.joints[ j ] ) {

          found = j;
          break;

        }

      }

      if ( found >= 0 ) {

        var inv = skin.invBindMatrices[ found ];

        bone.invBindMatrix = inv;
        bone.skinningMatrix = new THREE.Matrix4();
        bone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)
        bone.animatrix = new THREE.Matrix4();

        bone.animatrix.copy(bone.localworld);
        bone.weights = [];

        for ( var j = 0; j < skin.weights.length; j ++ ) {

          for (var k = 0; k < skin.weights[ j ].length; k ++ ) {

            var w = skin.weights[ j ][ k ];

            if ( w.joint === found ) {

              bone.weights.push( w );

            }

          }

        }

      } else {

        console.warn( "ColladaLoader: Could not find joint '" + bone.sid + "'." );

        bone.skinningMatrix = new THREE.Matrix4();
        bone.weights = [];

      }
    }

  }

  //Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix
  function flattenSkeleton(skeleton) {

    var list = [];
    var walk = function(parentid, node, list) {

      var bone = {};
      bone.name = node.sid;
      bone.parent = parentid;
      bone.matrix = node.matrix;
      var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];
      bone.matrix.decompose(data[0], data[1], data[2]);

      bone.pos = [ data[0].x,data[0].y,data[0].z ];

      bone.scl = [ data[2].x,data[2].y,data[2].z ];
      bone.rotq = [ data[1].x,data[1].y,data[1].z,data[1].w ];
      list.push(bone);

      for (var i in node.nodes) {

        walk(node.sid, node.nodes[i], list);

      }

    };

    walk(-1, skeleton, list);
    return list;

  }

  //Move the vertices into the pose that is proper for the start of the animation
  function skinToBindPose(geometry,skeleton,skinController) {

    var bones = [];
    setupSkeleton( skeleton, bones, -1 );
    setupSkinningMatrices( bones, skinController.skin );
    var v = new THREE.Vector3();
    var skinned = [];

    for (var i = 0; i < geometry.vertices.length; i ++) {

      skinned.push(new THREE.Vector3());

    }

    for ( i = 0; i < bones.length; i ++ ) {

      if ( bones[ i ].type != 'JOINT' ) continue;

      for ( var j = 0; j < bones[ i ].weights.length; j ++ ) {

        var w = bones[ i ].weights[ j ];
        var vidx = w.index;
        var weight = w.weight;

        var o = geometry.vertices[vidx];
        var s = skinned[vidx];

        v.x = o.x;
        v.y = o.y;
        v.z = o.z;

        v.applyMatrix4( bones[i].skinningMatrix );

        s.x += (v.x * weight);
        s.y += (v.y * weight);
        s.z += (v.z * weight);
      }

    }

    for (var i = 0; i < geometry.vertices.length; i ++) {

      geometry.vertices[i] = skinned[i];

    }

  }

  function applySkin ( geometry, instanceCtrl, frame ) {

    var skinController = controllers[ instanceCtrl.url ];

    frame = frame !== undefined ? frame : 40;

    if ( !skinController || !skinController.skin ) {

      console.log( 'ColladaLoader: Could not find skin controller.' );
      return;

    }

    if ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {

      console.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );
      return;

    }

    var animationBounds = calcAnimationBounds();
    var skeleton = visualScene.getChildById( instanceCtrl.skeleton[0], true ) || visualScene.getChildBySid( instanceCtrl.skeleton[0], true );

    //flatten the skeleton into a list of bones
    var bonelist = flattenSkeleton(skeleton);
    var joints = skinController.skin.joints;

    //sort that list so that the order reflects the order in the joint list
    var sortedbones = [];
    for (var i = 0; i < joints.length; i ++) {

      for (var j = 0; j < bonelist.length; j ++) {

        if (bonelist[j].name === joints[i]) {

          sortedbones[i] = bonelist[j];

        }

      }

    }

    //hook up the parents by index instead of name
    for (var i = 0; i < sortedbones.length; i ++) {

      for (var j = 0; j < sortedbones.length; j ++) {

        if (sortedbones[i].parent === sortedbones[j].name) {

          sortedbones[i].parent = j;

        }

      }

    }


    var i, j, w, vidx, weight;
    var v = new THREE.Vector3(), o, s;

    // move vertices to bind shape
    for ( i = 0; i < geometry.vertices.length; i ++ ) {
      geometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );
    }

    var skinIndices = [];
    var skinWeights = [];
    var weights = skinController.skin.weights;

    // hook up the skin weights
    // TODO - this might be a good place to choose greatest 4 weights
    for ( var i =0; i < weights.length; i ++ ) {

      var indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0,weights[i][1] ? weights[i][1].joint : 0,weights[i][2] ? weights[i][2].joint : 0,weights[i][3] ? weights[i][3].joint : 0);
      var weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0,weights[i][1] ? weights[i][1].weight : 0,weights[i][2] ? weights[i][2].weight : 0,weights[i][3] ? weights[i][3].weight : 0);

      skinIndices.push(indicies);
      skinWeights.push(weight);

    }

    geometry.skinIndices = skinIndices;
    geometry.skinWeights = skinWeights;
    geometry.bones = sortedbones;
    // process animation, or simply pose the rig if no animation

    //create an animation for the animated bones
    //NOTE: this has no effect when using morphtargets
    var animationdata = { "name":animationBounds.ID,"fps":30,"length":animationBounds.frames / 30,"hierarchy":[] };

    for (var j = 0; j < sortedbones.length; j ++) {

      animationdata.hierarchy.push({ parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[] });

    }

    console.log( 'ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.' );



    skinToBindPose(geometry, skeleton, skinController);


    for ( frame = 0; frame < animationBounds.frames; frame ++ ) {

      var bones = [];
      var skinned = [];
      // process the frame and setup the rig with a fresh
      // transform, possibly from the bone's animation channel(s)

      setupSkeleton( skeleton, bones, frame );
      setupSkinningMatrices( bones, skinController.skin );

      for (var i = 0; i < bones.length; i ++) {

        for (var j = 0; j < animationdata.hierarchy.length; j ++) {

          if (animationdata.hierarchy[j].name === bones[i].sid) {

            var key = {};
            key.time = (frame / 30);
            key.matrix = bones[i].animatrix;

            if (frame === 0)
              bones[i].matrix = key.matrix;

            var data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];
            key.matrix.decompose(data[0], data[1], data[2]);

            key.pos = [ data[0].x,data[0].y,data[0].z ];

            key.scl = [ data[2].x,data[2].y,data[2].z ];
            key.rot = data[1];

            animationdata.hierarchy[j].keys.push(key);

          }

        }

      }

      geometry.animation = animationdata;

    }

  }

  function createKinematics() {

    if ( kinematicsModel && kinematicsModel.joints.length === 0 ) {
      kinematics = undefined;
      return;
    }

    var jointMap = {};

    var _addToMap = function( jointIndex, parentVisualElement ) {

      var parentVisualElementId = parentVisualElement.getAttribute( 'id' );
      var colladaNode = visualScene.getChildById( parentVisualElementId, true );
      var joint = kinematicsModel.joints[ jointIndex ];

      scene.traverse(function( node ) {

        if ( node.colladaId == parentVisualElementId ) {

          jointMap[ jointIndex ] = {
            node: node,
            transforms: colladaNode.transforms,
            joint: joint,
            position: joint.zeroPosition
          };

        }

      });

    };

    kinematics = {

      joints: kinematicsModel && kinematicsModel.joints,

      getJointValue: function( jointIndex ) {

        var jointData = jointMap[ jointIndex ];

        if ( jointData ) {

          return jointData.position;

        } else {

          console.log( 'getJointValue: joint ' + jointIndex + ' doesn\'t exist' );

        }

      },

      setJointValue: function( jointIndex, value ) {

        var jointData = jointMap[ jointIndex ];

        if ( jointData ) {

          var joint = jointData.joint;

          if ( value > joint.limits.max || value < joint.limits.min ) {

            console.log( 'setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')' );

          } else if ( joint.static ) {

            console.log( 'setJointValue: joint ' + jointIndex + ' is static' );

          } else {

            var threejsNode = jointData.node;
            var axis = joint.axis;
            var transforms = jointData.transforms;

            var matrix = new THREE.Matrix4();

            for (i = 0; i < transforms.length; i ++ ) {

              var transform = transforms[ i ];

              // kinda ghetto joint detection
              if ( transform.sid && transform.sid.indexOf( 'joint' + jointIndex ) !== -1 ) {

                // apply actual joint value here
                switch ( joint.type ) {

                  case 'revolute':

                    matrix.multiply( m1.makeRotationAxis( axis, THREE.Math.degToRad(value) ) );
                    break;

                  case 'prismatic':

                    matrix.multiply( m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value ) );
                    break;

                  default:

                    console.warn( 'setJointValue: unknown joint type: ' + joint.type );
                    break;

                }

              } else {

                var m1 = new THREE.Matrix4();

                switch ( transform.type ) {

                  case 'matrix':

                    matrix.multiply( transform.obj );

                    break;

                  case 'translate':

                    matrix.multiply( m1.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );

                    break;

                  case 'rotate':

                    matrix.multiply( m1.makeRotationAxis( transform.obj, transform.angle ) );

                    break;

                }
              }
            }

            // apply the matrix to the threejs node
            var elementsFloat32Arr = matrix.elements;
            var elements = Array.prototype.slice.call( elementsFloat32Arr );

            var elementsRowMajor = [
              elements[ 0 ],
              elements[ 4 ],
              elements[ 8 ],
              elements[ 12 ],
              elements[ 1 ],
              elements[ 5 ],
              elements[ 9 ],
              elements[ 13 ],
              elements[ 2 ],
              elements[ 6 ],
              elements[ 10 ],
              elements[ 14 ],
              elements[ 3 ],
              elements[ 7 ],
              elements[ 11 ],
              elements[ 15 ]
            ];

            threejsNode.matrix.set.apply( threejsNode.matrix, elementsRowMajor );
            threejsNode.matrix.decompose( threejsNode.position, threejsNode.quaternion, threejsNode.scale );
          }

        } else {

          console.log( 'setJointValue: joint ' + jointIndex + ' doesn\'t exist' );

        }

      }

    };

    var element = COLLADA.querySelector('scene instance_kinematics_scene');

    if ( element ) {

      for ( var i = 0; i < element.childNodes.length; i ++ ) {

        var child = element.childNodes[ i ];

        if ( child.nodeType != 1 ) continue;

        switch ( child.nodeName ) {

          case 'bind_joint_axis':

            var visualTarget = child.getAttribute( 'target' ).split( '/' ).pop();
            var axis = child.querySelector('axis param').textContent;
            var jointIndex = parseInt( axis.split( 'joint' ).pop().split( '.' )[0] );
            var visualTargetElement = COLLADA.querySelector( '[sid="' + visualTarget + '"]' );

            if ( visualTargetElement ) {
              var parentVisualElement = visualTargetElement.parentElement;
              _addToMap(jointIndex, parentVisualElement);
            }

            break;

          default:

            break;

        }

      }
    }

  }

  function createSceneGraph ( node, parent ) {

    var obj = new THREE.Object3D();
    var skinned = false;
    var skinController;
    var morphController;
    var i, j;

    // FIXME: controllers

    for ( i = 0; i < node.controllers.length; i ++ ) {

      var controller = controllers[ node.controllers[ i ].url ];

      switch ( controller.type ) {

        case 'skin':

          if ( geometries[ controller.skin.source ] ) {

            var inst_geom = new InstanceGeometry();

            inst_geom.url = controller.skin.source;
            inst_geom.instance_material = node.controllers[ i ].instance_material;

            node.geometries.push( inst_geom );
            skinned = true;
            skinController = node.controllers[ i ];

          } else if ( controllers[ controller.skin.source ] ) {

            // urgh: controller can be chained
            // handle the most basic case...

            var second = controllers[ controller.skin.source ];
            morphController = second;
          //  skinController = node.controllers[i];

            if ( second.morph && geometries[ second.morph.source ] ) {

              var inst_geom = new InstanceGeometry();

              inst_geom.url = second.morph.source;
              inst_geom.instance_material = node.controllers[ i ].instance_material;

              node.geometries.push( inst_geom );

            }

          }

          break;

        case 'morph':

          if ( geometries[ controller.morph.source ] ) {

            var inst_geom = new InstanceGeometry();

            inst_geom.url = controller.morph.source;
            inst_geom.instance_material = node.controllers[ i ].instance_material;

            node.geometries.push( inst_geom );
            morphController = node.controllers[ i ];

          }

          console.log( 'ColladaLoader: Morph-controller partially supported.' );

        default:
          break;

      }

    }

    // geometries

    var double_sided_materials = {};

    for ( i = 0; i < node.geometries.length; i ++ ) {

      var instance_geometry = node.geometries[i];
      var instance_materials = instance_geometry.instance_material;
      var geometry = geometries[ instance_geometry.url ];
      var used_materials = {};
      var used_materials_array = [];
      var num_materials = 0;
      var first_material;

      if ( geometry ) {

        if ( !geometry.mesh || !geometry.mesh.primitives )
          continue;

        if ( obj.name.length === 0 ) {

          obj.name = geometry.id;

        }

        // collect used fx for this geometry-instance

        if ( instance_materials ) {

          for ( j = 0; j < instance_materials.length; j ++ ) {

            var instance_material = instance_materials[ j ];
            var mat = materials[ instance_material.target ];
            var effect_id = mat.instance_effect.url;
            var shader = effects[ effect_id ].shader;
            var material3js = shader.material;

            if ( geometry.doubleSided ) {

              if ( !( instance_material.symbol in double_sided_materials ) ) {

                var _copied_material = material3js.clone();
                _copied_material.side = THREE.DoubleSide;
                double_sided_materials[ instance_material.symbol ] = _copied_material;

              }

              material3js = double_sided_materials[ instance_material.symbol ];

            }

            material3js.opacity = !material3js.opacity ? 1 : material3js.opacity;
            used_materials[ instance_material.symbol ] = num_materials;
            used_materials_array.push( material3js );
            first_material = material3js;
            first_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;
            num_materials ++;

          }

        }

        var mesh;
        var material = first_material || new THREE.MeshLambertMaterial( { color: 0xdddddd, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );
        var geom = geometry.mesh.geometry3js;

        if ( num_materials > 1 ) {

          material = new THREE.MeshFaceMaterial( used_materials_array );

        }

        if ( skinController !== undefined ) {


          applySkin( geom, skinController );

          if ( geom.morphTargets.length > 0 ) {

            material.morphTargets = true;
            material.skinning = false;

          } else {

            material.morphTargets = false;
            material.skinning = true;

          }


          mesh = new THREE.SkinnedMesh( geom, material, false );


          //mesh.skeleton = skinController.skeleton;
          //mesh.skinController = controllers[ skinController.url ];
          //mesh.skinInstanceController = skinController;
          mesh.name = 'skin_' + skins.length;



          //mesh.animationHandle.setKey(0);
          skins.push( mesh );

        } else if ( morphController !== undefined ) {

          createMorph( geom, morphController );

          material.morphTargets = true;

          mesh = new THREE.Mesh( geom, material );
          mesh.name = 'morph_' + morphs.length;

          morphs.push( mesh );

        } else {

          if ( geom.isLineStrip === true ) {

            mesh = new THREE.Line( geom );

          } else {

            mesh = new THREE.Mesh( geom, material );

          }

        }

        obj.add(mesh);

      }

    }

    for ( i = 0; i < node.cameras.length; i ++ ) {

      var instance_camera = node.cameras[i];
      var cparams = cameras[instance_camera.url];

      var cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio),
          parseFloat(cparams.znear), parseFloat(cparams.zfar));

      obj.add(cam);
    }

    for ( i = 0; i < node.lights.length; i ++ ) {

      var light = null;
      var instance_light = node.lights[i];
      var lparams = lights[instance_light.url];

      if ( lparams && lparams.technique ) {

        var color = lparams.color.getHex();
        var intensity = lparams.intensity;
        var distance = lparams.distance;
        var angle = lparams.falloff_angle;
        var exponent; // Intentionally undefined, don't know what this is yet

        switch ( lparams.technique ) {

          case 'directional':

            light = new THREE.DirectionalLight( color, intensity, distance );
            light.position.set(0, 0, 1);
            break;

          case 'point':

            light = new THREE.PointLight( color, intensity, distance );
            break;

          case 'spot':

            light = new THREE.SpotLight( color, intensity, distance, angle, exponent );
            light.position.set(0, 0, 1);
            break;

          case 'ambient':

            light = new THREE.AmbientLight( color );
            break;

        }

      }

      if (light) {
        obj.add(light);
      }
    }

    obj.name = node.name || node.id || "";
    obj.colladaId = node.id || "";
    obj.layer = node.layer || "";
    obj.matrix = node.matrix;
    obj.matrix.decompose( obj.position, obj.quaternion, obj.scale );

    if ( options.centerGeometry && obj.geometry ) {

      var delta = obj.geometry.center();
      delta.multiply( obj.scale );
      delta.applyQuaternion( obj.quaternion );

      obj.position.sub( delta );

    }

    for ( i = 0; i < node.nodes.length; i ++ ) {

      obj.add( createSceneGraph( node.nodes[i], node ) );

    }

    return obj;

  }

  function getJointId( skin, id ) {

    for ( var i = 0; i < skin.joints.length; i ++ ) {

      if ( skin.joints[ i ] === id ) {

        return i;

      }

    }

  }

  function getLibraryNode( id ) {

    var nodes = COLLADA.querySelectorAll('library_nodes node');

    for ( var i = 0; i < nodes.length; i++ ) {

      var attObj = nodes[i].attributes.getNamedItem('id');

      if ( attObj && attObj.value === id ) {

        return nodes[i];

      }

    }

    return undefined;

  }

  function getChannelsForNode ( node ) {

    var channels = [];
    var startTime = 1000000;
    var endTime = -1000000;

    for ( var id in animations ) {

      var animation = animations[id];

      for ( var i = 0; i < animation.channel.length; i ++ ) {

        var channel = animation.channel[i];
        var sampler = animation.sampler[i];
        var id = channel.target.split('/')[0];

        if ( id == node.id ) {

          sampler.create();
          channel.sampler = sampler;
          startTime = Math.min(startTime, sampler.startTime);
          endTime = Math.max(endTime, sampler.endTime);
          channels.push(channel);

        }

      }

    }

    if ( channels.length ) {

      node.startTime = startTime;
      node.endTime = endTime;

    }

    return channels;

  }

  function calcFrameDuration( node ) {

    var minT = 10000000;

    for ( var i = 0; i < node.channels.length; i ++ ) {

      var sampler = node.channels[i].sampler;

      for ( var j = 0; j < sampler.input.length - 1; j ++ ) {

        var t0 = sampler.input[ j ];
        var t1 = sampler.input[ j + 1 ];
        minT = Math.min( minT, t1 - t0 );

      }
    }

    return minT;

  }

  function calcMatrixAt( node, t ) {

    var animated = {};

    var i, j;

    for ( i = 0; i < node.channels.length; i ++ ) {

      var channel = node.channels[ i ];
      animated[ channel.sid ] = channel;

    }

    var matrix = new THREE.Matrix4();

    for ( i = 0; i < node.transforms.length; i ++ ) {

      var transform = node.transforms[ i ];
      var channel = animated[ transform.sid ];

      if ( channel !== undefined ) {

        var sampler = channel.sampler;
        var value;

        for ( j = 0; j < sampler.input.length - 1; j ++ ) {

          if ( sampler.input[ j + 1 ] > t ) {

            value = sampler.output[ j ];
            //console.log(value.flatten)
            break;

          }

        }

        if ( value !== undefined ) {

          if ( value instanceof THREE.Matrix4 ) {

            matrix.multiplyMatrices( matrix, value );

          } else {

            // FIXME: handle other types

            matrix.multiplyMatrices( matrix, transform.matrix );

          }

        } else {

          matrix.multiplyMatrices( matrix, transform.matrix );

        }

      } else {

        matrix.multiplyMatrices( matrix, transform.matrix );

      }

    }

    return matrix;

  }

  function bakeAnimations ( node ) {

    if ( node.channels && node.channels.length ) {

      var keys = [],
        sids = [];

      for ( var i = 0, il = node.channels.length; i < il; i ++ ) {

        var channel = node.channels[i],
          fullSid = channel.fullSid,
          sampler = channel.sampler,
          input = sampler.input,
          transform = node.getTransformBySid( channel.sid ),
          member;

        if ( channel.arrIndices ) {

          member = [];

          for ( var j = 0, jl = channel.arrIndices.length; j < jl; j ++ ) {

            member[ j ] = getConvertedIndex( channel.arrIndices[ j ] );

          }

        } else {

          member = getConvertedMember( channel.member );

        }

        if ( transform ) {

          if ( sids.indexOf( fullSid ) === -1 ) {

            sids.push( fullSid );

          }

          for ( var j = 0, jl = input.length; j < jl; j ++ ) {

            var time = input[j],
              data = sampler.getData( transform.type, j, member ),
              key = findKey( keys, time );

            if ( !key ) {

              key = new Key( time );
              var timeNdx = findTimeNdx( keys, time );
              keys.splice( timeNdx === -1 ? keys.length : timeNdx, 0, key );

            }

            key.addTarget( fullSid, transform, member, data );

          }

        } else {

          console.log( 'Could not find transform "' + channel.sid + '" in node ' + node.id );

        }

      }

      // post process
      for ( var i = 0; i < sids.length; i ++ ) {

        var sid = sids[ i ];

        for ( var j = 0; j < keys.length; j ++ ) {

          var key = keys[ j ];

          if ( !key.hasTarget( sid ) ) {

            interpolateKeys( keys, key, j, sid );

          }

        }

      }

      node.keys = keys;
      node.sids = sids;

    }

  }

  function findKey ( keys, time) {

    var retVal = null;

    for ( var i = 0, il = keys.length; i < il && retVal === null; i ++ ) {

      var key = keys[i];

      if ( key.time === time ) {

        retVal = key;

      } else if ( key.time > time ) {

        break;

      }

    }

    return retVal;

  }

  function findTimeNdx ( keys, time) {

    var ndx = -1;

    for ( var i = 0, il = keys.length; i < il && ndx === -1; i ++ ) {

      var key = keys[i];

      if ( key.time >= time ) {

        ndx = i;

      }

    }

    return ndx;

  }

  function interpolateKeys ( keys, key, ndx, fullSid ) {

    var prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx - 1 : 0 ),
      nextKey = getNextKeyWith( keys, fullSid, ndx + 1 );

    if ( prevKey && nextKey ) {

      var scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),
        prevTarget = prevKey.getTarget( fullSid ),
        nextData = nextKey.getTarget( fullSid ).data,
        prevData = prevTarget.data,
        data;

      if ( prevTarget.type === 'matrix' ) {

        data = prevData;

      } else if ( prevData.length ) {

        data = [];

        for ( var i = 0; i < prevData.length; ++ i ) {

          data[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;

        }

      } else {

        data = prevData + ( nextData - prevData ) * scale;

      }

      key.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );

    }

  }

  // Get next key with given sid

  function getNextKeyWith( keys, fullSid, ndx ) {

    for ( ; ndx < keys.length; ndx ++ ) {

      var key = keys[ ndx ];

      if ( key.hasTarget( fullSid ) ) {

        return key;

      }

    }

    return null;

  }

  // Get previous key with given sid

  function getPrevKeyWith( keys, fullSid, ndx ) {

    ndx = ndx >= 0 ? ndx : ndx + keys.length;

    for ( ; ndx >= 0; ndx -- ) {

      var key = keys[ ndx ];

      if ( key.hasTarget( fullSid ) ) {

        return key;

      }

    }

    return null;

  }

  function _Image() {

    this.id = "";
    this.init_from = "";

  }

  _Image.prototype.parse = function(element) {

    this.id = element.getAttribute('id');

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      if ( child.nodeName === 'init_from' ) {

        this.init_from = child.textContent;

      }

    }

    return this;

  };

  function Controller() {

    this.id = "";
    this.name = "";
    this.type = "";
    this.skin = null;
    this.morph = null;

  }

  Controller.prototype.parse = function( element ) {

    this.id = element.getAttribute('id');
    this.name = element.getAttribute('name');
    this.type = "none";

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      switch ( child.nodeName ) {

        case 'skin':

          this.skin = (new Skin()).parse(child);
          this.type = child.nodeName;
          break;

        case 'morph':

          this.morph = (new Morph()).parse(child);
          this.type = child.nodeName;
          break;

        default:
          break;

      }
    }

    return this;

  };

  function Morph() {

    this.method = null;
    this.source = null;
    this.targets = null;
    this.weights = null;

  }

  Morph.prototype.parse = function( element ) {

    var sources = {};
    var inputs = [];
    var i;

    this.method = element.getAttribute( 'method' );
    this.source = element.getAttribute( 'source' ).replace( /^#/, '' );

    for ( i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'source':

          var source = ( new Source() ).parse( child );
          sources[ source.id ] = source;
          break;

        case 'targets':

          inputs = this.parseInputs( child );
          break;

        default:

          console.log( child.nodeName );
          break;

      }

    }

    for ( i = 0; i < inputs.length; i ++ ) {

      var input = inputs[ i ];
      var source = sources[ input.source ];

      switch ( input.semantic ) {

        case 'MORPH_TARGET':

          this.targets = source.read();
          break;

        case 'MORPH_WEIGHT':

          this.weights = source.read();
          break;

        default:
          break;

      }
    }

    return this;

  };

  Morph.prototype.parseInputs = function(element) {

    var inputs = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1) continue;

      switch ( child.nodeName ) {

        case 'input':

          inputs.push( (new Input()).parse(child) );
          break;

        default:
          break;
      }
    }

    return inputs;

  };

  function Skin() {

    this.source = "";
    this.bindShapeMatrix = null;
    this.invBindMatrices = [];
    this.joints = [];
    this.weights = [];

  }

  Skin.prototype.parse = function( element ) {

    var sources = {};
    var joints, weights;

    this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
    this.invBindMatrices = [];
    this.joints = [];
    this.weights = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'bind_shape_matrix':

          var f = _floats(child.textContent);
          this.bindShapeMatrix = getConvertedMat4( f );
          break;

        case 'source':

          var src = new Source().parse(child);
          sources[ src.id ] = src;
          break;

        case 'joints':

          joints = child;
          break;

        case 'vertex_weights':

          weights = child;
          break;

        default:

          console.log( child.nodeName );
          break;

      }
    }

    this.parseJoints( joints, sources );
    this.parseWeights( weights, sources );

    return this;

  };

  Skin.prototype.parseJoints = function ( element, sources ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'input':

          var input = ( new Input() ).parse( child );
          var source = sources[ input.source ];

          if ( input.semantic === 'JOINT' ) {

            this.joints = source.read();

          } else if ( input.semantic === 'INV_BIND_MATRIX' ) {

            this.invBindMatrices = source.read();

          }

          break;

        default:
          break;
      }

    }

  };

  Skin.prototype.parseWeights = function ( element, sources ) {

    var v, vcount, inputs = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'input':

          inputs.push( ( new Input() ).parse( child ) );
          break;

        case 'v':

          v = _ints( child.textContent );
          break;

        case 'vcount':

          vcount = _ints( child.textContent );
          break;

        default:
          break;

      }

    }

    var index = 0;

    for ( var i = 0; i < vcount.length; i ++ ) {

      var numBones = vcount[i];
      var vertex_weights = [];

      for ( var j = 0; j < numBones; j ++ ) {

        var influence = {};

        for ( var k = 0; k < inputs.length; k ++ ) {

          var input = inputs[ k ];
          var value = v[ index + input.offset ];

          switch ( input.semantic ) {

            case 'JOINT':

              influence.joint = value;//this.joints[value];
              break;

            case 'WEIGHT':

              influence.weight = sources[ input.source ].data[ value ];
              break;

            default:
              break;

          }

        }

        vertex_weights.push( influence );
        index += inputs.length;
      }

      for ( var j = 0; j < vertex_weights.length; j ++ ) {

        vertex_weights[ j ].index = i;

      }

      this.weights.push( vertex_weights );

    }

  };

  function VisualScene () {

    this.id = "";
    this.name = "";
    this.nodes = [];
    this.scene = new THREE.Group();

  }

  VisualScene.prototype.getChildById = function( id, recursive ) {

    for ( var i = 0; i < this.nodes.length; i ++ ) {

      var node = this.nodes[ i ].getChildById( id, recursive );

      if ( node ) {

        return node;

      }

    }

    return null;

  };

  VisualScene.prototype.getChildBySid = function( sid, recursive ) {

    for ( var i = 0; i < this.nodes.length; i ++ ) {

      var node = this.nodes[ i ].getChildBySid( sid, recursive );

      if ( node ) {

        return node;

      }

    }

    return null;

  };

  VisualScene.prototype.parse = function( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );
    this.nodes = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'node':

          this.nodes.push( ( new Node() ).parse( child ) );
          break;

        default:
          break;

      }

    }

    return this;

  };

  function Node() {

    this.id = "";
    this.name = "";
    this.sid = "";
    this.nodes = [];
    this.controllers = [];
    this.transforms = [];
    this.geometries = [];
    this.channels = [];
    this.matrix = new THREE.Matrix4();

  }

  Node.prototype.getChannelForTransform = function( transformSid ) {

    for ( var i = 0; i < this.channels.length; i ++ ) {

      var channel = this.channels[i];
      var parts = channel.target.split('/');
      var id = parts.shift();
      var sid = parts.shift();
      var dotSyntax = (sid.indexOf(".") >= 0);
      var arrSyntax = (sid.indexOf("(") >= 0);
      var arrIndices;
      var member;

      if ( dotSyntax ) {

        parts = sid.split(".");
        sid = parts.shift();
        member = parts.shift();

      } else if ( arrSyntax ) {

        arrIndices = sid.split("(");
        sid = arrIndices.shift();

        for ( var j = 0; j < arrIndices.length; j ++ ) {

          arrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\)/, '' ) );

        }

      }

      if ( sid === transformSid ) {

        channel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };
        return channel;

      }

    }

    return null;

  };

  Node.prototype.getChildById = function ( id, recursive ) {

    if ( this.id === id ) {

      return this;

    }

    if ( recursive ) {

      for ( var i = 0; i < this.nodes.length; i ++ ) {

        var n = this.nodes[ i ].getChildById( id, recursive );

        if ( n ) {

          return n;

        }

      }

    }

    return null;

  };

  Node.prototype.getChildBySid = function ( sid, recursive ) {

    if ( this.sid === sid ) {

      return this;

    }

    if ( recursive ) {

      for ( var i = 0; i < this.nodes.length; i ++ ) {

        var n = this.nodes[ i ].getChildBySid( sid, recursive );

        if ( n ) {

          return n;

        }

      }
    }

    return null;

  };

  Node.prototype.getTransformBySid = function ( sid ) {

    for ( var i = 0; i < this.transforms.length; i ++ ) {

      if ( this.transforms[ i ].sid === sid ) return this.transforms[ i ];

    }

    return null;

  };

  Node.prototype.parse = function( element ) {

    var url;

    this.id = element.getAttribute('id');
    this.sid = element.getAttribute('sid');
    this.name = element.getAttribute('name');
    this.type = element.getAttribute('type');
    this.layer = element.getAttribute('layer');

    this.type = this.type === 'JOINT' ? this.type : 'NODE';

    this.nodes = [];
    this.transforms = [];
    this.geometries = [];
    this.cameras = [];
    this.lights = [];
    this.controllers = [];
    this.matrix = new THREE.Matrix4();

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'node':

          this.nodes.push( ( new Node() ).parse( child ) );
          break;

        case 'instance_camera':

          this.cameras.push( ( new InstanceCamera() ).parse( child ) );
          break;

        case 'instance_controller':

          this.controllers.push( ( new InstanceController() ).parse( child ) );
          break;

        case 'instance_geometry':

          this.geometries.push( ( new InstanceGeometry() ).parse( child ) );
          break;

        case 'instance_light':

          this.lights.push( ( new InstanceLight() ).parse( child ) );
          break;

        case 'instance_node':

          url = child.getAttribute( 'url' ).replace( /^#/, '' );
          var iNode = getLibraryNode( url );

          if ( iNode ) {

            this.nodes.push( ( new Node() ).parse( iNode )) ;

          }

          break;

        case 'rotate':
        case 'translate':
        case 'scale':
        case 'matrix':
        case 'lookat':
        case 'skew':

          this.transforms.push( ( new Transform() ).parse( child ) );
          break;

        case 'extra':
          break;

        default:

          console.log( child.nodeName );
          break;

      }

    }

    this.channels = getChannelsForNode( this );
    bakeAnimations( this );

    this.updateMatrix();

    return this;

  };

  Node.prototype.updateMatrix = function () {

    this.matrix.identity();

    for ( var i = 0; i < this.transforms.length; i ++ ) {

      this.transforms[ i ].apply( this.matrix );

    }

  };

  function Transform () {

    this.sid = "";
    this.type = "";
    this.data = [];
    this.obj = null;

  }

  Transform.prototype.parse = function ( element ) {

    this.sid = element.getAttribute( 'sid' );
    this.type = element.nodeName;
    this.data = _floats( element.textContent );
    this.convert();

    return this;

  };

  Transform.prototype.convert = function () {

    switch ( this.type ) {

      case 'matrix':

        this.obj = getConvertedMat4( this.data );
        break;

      case 'rotate':

        this.angle = THREE.Math.degToRad( this.data[3] );

      case 'translate':

        fixCoords( this.data, -1 );
        this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
        break;

      case 'scale':

        fixCoords( this.data, 1 );
        this.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );
        break;

      default:
        console.log( 'Can not convert Transform of type ' + this.type );
        break;

    }

  };

  Transform.prototype.apply = function () {

    var m1 = new THREE.Matrix4();

    return function ( matrix ) {

      switch ( this.type ) {

        case 'matrix':

          matrix.multiply( this.obj );

          break;

        case 'translate':

          matrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );

          break;

        case 'rotate':

          matrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );

          break;

        case 'scale':

          matrix.scale( this.obj );

          break;

      }

    };

  }();

  Transform.prototype.update = function ( data, member ) {

    var members = [ 'X', 'Y', 'Z', 'ANGLE' ];

    switch ( this.type ) {

      case 'matrix':

        if ( ! member ) {

          this.obj.copy( data );

        } else if ( member.length === 1 ) {

          switch ( member[ 0 ] ) {

            case 0:

              this.obj.n11 = data[ 0 ];
              this.obj.n21 = data[ 1 ];
              this.obj.n31 = data[ 2 ];
              this.obj.n41 = data[ 3 ];

              break;

            case 1:

              this.obj.n12 = data[ 0 ];
              this.obj.n22 = data[ 1 ];
              this.obj.n32 = data[ 2 ];
              this.obj.n42 = data[ 3 ];

              break;

            case 2:

              this.obj.n13 = data[ 0 ];
              this.obj.n23 = data[ 1 ];
              this.obj.n33 = data[ 2 ];
              this.obj.n43 = data[ 3 ];

              break;

            case 3:

              this.obj.n14 = data[ 0 ];
              this.obj.n24 = data[ 1 ];
              this.obj.n34 = data[ 2 ];
              this.obj.n44 = data[ 3 ];

              break;

          }

        } else if ( member.length === 2 ) {

          var propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );
          this.obj[ propName ] = data;

        } else {

          console.log('Incorrect addressing of matrix in transform.');

        }

        break;

      case 'translate':
      case 'scale':

        if ( Object.prototype.toString.call( member ) === '[object Array]' ) {

          member = members[ member[ 0 ] ];

        }

        switch ( member ) {

          case 'X':

            this.obj.x = data;
            break;

          case 'Y':

            this.obj.y = data;
            break;

          case 'Z':

            this.obj.z = data;
            break;

          default:

            this.obj.x = data[ 0 ];
            this.obj.y = data[ 1 ];
            this.obj.z = data[ 2 ];
            break;

        }

        break;

      case 'rotate':

        if ( Object.prototype.toString.call( member ) === '[object Array]' ) {

          member = members[ member[ 0 ] ];

        }

        switch ( member ) {

          case 'X':

            this.obj.x = data;
            break;

          case 'Y':

            this.obj.y = data;
            break;

          case 'Z':

            this.obj.z = data;
            break;

          case 'ANGLE':

            this.angle = THREE.Math.degToRad( data );
            break;

          default:

            this.obj.x = data[ 0 ];
            this.obj.y = data[ 1 ];
            this.obj.z = data[ 2 ];
            this.angle = THREE.Math.degToRad( data[ 3 ] );
            break;

        }
        break;

    }

  };

  function InstanceController() {

    this.url = "";
    this.skeleton = [];
    this.instance_material = [];

  }

  InstanceController.prototype.parse = function ( element ) {

    this.url = element.getAttribute('url').replace(/^#/, '');
    this.skeleton = [];
    this.instance_material = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType !== 1 ) continue;

      switch ( child.nodeName ) {

        case 'skeleton':

          this.skeleton.push( child.textContent.replace(/^#/, '') );
          break;

        case 'bind_material':

          var instances = child.querySelectorAll('instance_material');

          for ( var j = 0; j < instances.length; j ++ ) {

            var instance = instances[j];
            this.instance_material.push( (new InstanceMaterial()).parse(instance) );

          }


          break;

        case 'extra':
          break;

        default:
          break;

      }
    }

    return this;

  };

  function InstanceMaterial () {

    this.symbol = "";
    this.target = "";

  }

  InstanceMaterial.prototype.parse = function ( element ) {

    this.symbol = element.getAttribute('symbol');
    this.target = element.getAttribute('target').replace(/^#/, '');
    return this;

  };

  function InstanceGeometry() {

    this.url = "";
    this.instance_material = [];

  }

  InstanceGeometry.prototype.parse = function ( element ) {

    this.url = element.getAttribute('url').replace(/^#/, '');
    this.instance_material = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1 ) continue;

      if ( child.nodeName === 'bind_material' ) {

        var instances = child.querySelectorAll('instance_material');

        for ( var j = 0; j < instances.length; j ++ ) {

          var instance = instances[j];
          this.instance_material.push( (new InstanceMaterial()).parse(instance) );

        }

        break;

      }

    }

    return this;

  };

  function Geometry() {

    this.id = "";
    this.mesh = null;

  }

  Geometry.prototype.parse = function ( element ) {

    this.id = element.getAttribute('id');

    extractDoubleSided( this, element );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];

      switch ( child.nodeName ) {

        case 'mesh':

          this.mesh = (new Mesh(this)).parse(child);
          break;

        case 'extra':

          // console.log( child );
          break;

        default:
          break;
      }
    }

    return this;

  };

  function Mesh( geometry ) {

    this.geometry = geometry.id;
    this.primitives = [];
    this.vertices = null;
    this.geometry3js = null;

  }

  Mesh.prototype.parse = function ( element ) {

    this.primitives = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      switch ( child.nodeName ) {

        case 'source':

          _source( child );
          break;

        case 'vertices':

          this.vertices = ( new Vertices() ).parse( child );
          break;

        case 'linestrips':

          this.primitives.push( ( new LineStrips().parse( child ) ) );
          break;

        case 'triangles':

          this.primitives.push( ( new Triangles().parse( child ) ) );
          break;

        case 'polygons':

          this.primitives.push( ( new Polygons().parse( child ) ) );
          break;

        case 'polylist':

          this.primitives.push( ( new Polylist().parse( child ) ) );
          break;

        default:
          break;

      }

    }

    this.geometry3js = new THREE.Geometry();

    if ( this.vertices === null ) {

      // TODO (mrdoob): Study case when this is null (carrier.dae)

      return this;

    }

    var vertexData = sources[ this.vertices.input['POSITION'].source ].data;

    for ( var i = 0; i < vertexData.length; i += 3 ) {

      this.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );

    }

    for ( var i = 0; i < this.primitives.length; i ++ ) {

      var primitive = this.primitives[ i ];
      primitive.setVertices( this.vertices );
      this.handlePrimitive( primitive, this.geometry3js );

    }

    if ( this.geometry3js.calcNormals ) {

      this.geometry3js.computeVertexNormals();
      delete this.geometry3js.calcNormals;

    }

    return this;

  };

  Mesh.prototype.handlePrimitive = function ( primitive, geom ) {

    if ( primitive instanceof LineStrips ) {

      // TODO: Handle indices. Maybe easier with BufferGeometry?

      geom.isLineStrip = true;
      return;

    }

    var j, k, pList = primitive.p, inputs = primitive.inputs;
    var input, index, idx32;
    var source, numParams;
    var vcIndex = 0, vcount = 3, maxOffset = 0;
    var texture_sets = [];

    for ( j = 0; j < inputs.length; j ++ ) {

      input = inputs[ j ];

      var offset = input.offset + 1;
      maxOffset = (maxOffset < offset) ? offset : maxOffset;

      switch ( input.semantic ) {

        case 'TEXCOORD':
          texture_sets.push( input.set );
          break;

      }

    }

    for ( var pCount = 0; pCount < pList.length; ++ pCount ) {

      var p = pList[ pCount ], i = 0;

      while ( i < p.length ) {

        var vs = [];
        var ns = [];
        var ts = null;
        var cs = [];

        if ( primitive.vcount ) {

          vcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;

        } else {

          vcount = p.length / maxOffset;

        }


        for ( j = 0; j < vcount; j ++ ) {

          for ( k = 0; k < inputs.length; k ++ ) {

            input = inputs[ k ];
            source = sources[ input.source ];

            index = p[ i + ( j * maxOffset ) + input.offset ];
            numParams = source.accessor.params.length;
            idx32 = index * numParams;

            switch ( input.semantic ) {

              case 'VERTEX':

                vs.push( index );

                break;

              case 'NORMAL':

                ns.push( getConvertedVec3( source.data, idx32 ) );

                break;

              case 'TEXCOORD':

                ts = ts || { };
                if ( ts[ input.set ] === undefined ) ts[ input.set ] = [];
                // invert the V
                ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );

                break;

              case 'COLOR':

                cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

                break;

              default:

                break;

            }

          }

        }

        if ( ns.length === 0 ) {

          // check the vertices inputs
          input = this.vertices.input.NORMAL;

          if ( input ) {

            source = sources[ input.source ];
            numParams = source.accessor.params.length;

            for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {

              ns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );

            }

          } else {

            geom.calcNormals = true;

          }

        }

        if ( !ts ) {

          ts = { };
          // check the vertices inputs
          input = this.vertices.input.TEXCOORD;

          if ( input ) {

            texture_sets.push( input.set );
            source = sources[ input.source ];
            numParams = source.accessor.params.length;

            for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {

              idx32 = vs[ ndx ] * numParams;
              if ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];
              // invert the V
              ts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );

            }

          }

        }

        if ( cs.length === 0 ) {

          // check the vertices inputs
          input = this.vertices.input.COLOR;

          if ( input ) {

            source = sources[ input.source ];
            numParams = source.accessor.params.length;

            for ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {

              idx32 = vs[ ndx ] * numParams;
              cs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );

            }

          }

        }

        var face = null, faces = [], uv, uvArr;

        if ( vcount === 3 ) {

          faces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );

        } else if ( vcount === 4 ) {

          faces.push( new THREE.Face3( vs[0], vs[1], vs[3], [ ns[0].clone(), ns[1].clone(), ns[3].clone() ], cs.length ? [ cs[0], cs[1], cs[3] ] : new THREE.Color() ) );

          faces.push( new THREE.Face3( vs[1], vs[2], vs[3], [ ns[1].clone(), ns[2].clone(), ns[3].clone() ], cs.length ? [ cs[1], cs[2], cs[3] ] : new THREE.Color() ) );

        } else if ( vcount > 4 && options.subdivideFaces ) {

          var clr = cs.length ? cs : new THREE.Color(),
            vec1, vec2, vec3, v1, v2, norm;

          // subdivide into multiple Face3s

          for ( k = 1; k < vcount - 1; ) {

            faces.push( new THREE.Face3( vs[0], vs[k], vs[k + 1], [ ns[0].clone(), ns[k ++].clone(), ns[k].clone() ], clr ) );

          }

        }

        if ( faces.length ) {

          for ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {

            face = faces[ndx];
            face.daeMaterial = primitive.material;
            geom.faces.push( face );

            for ( k = 0; k < texture_sets.length; k ++ ) {

              uv = ts[ texture_sets[k] ];

              if ( vcount > 4 ) {

                // Grab the right UVs for the vertices in this face
                uvArr = [ uv[0], uv[ndx + 1], uv[ndx + 2] ];

              } else if ( vcount === 4 ) {

                if ( ndx === 0 ) {

                  uvArr = [ uv[0], uv[1], uv[3] ];

                } else {

                  uvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];

                }

              } else {

                uvArr = [ uv[0], uv[1], uv[2] ];

              }

              if ( geom.faceVertexUvs[k] === undefined ) {

                geom.faceVertexUvs[k] = [];

              }

              geom.faceVertexUvs[k].push( uvArr );

            }

          }

        } else {

          console.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );

        }

        i += maxOffset * vcount;

      }

    }

  };

  function Polygons () {

    this.material = "";
    this.count = 0;
    this.inputs = [];
    this.vcount = null;
    this.p = [];
    this.geometry = new THREE.Geometry();

  }

  Polygons.prototype.setVertices = function ( vertices ) {

    for ( var i = 0; i < this.inputs.length; i ++ ) {

      if ( this.inputs[ i ].source === vertices.id ) {

        this.inputs[ i ].source = vertices.input[ 'POSITION' ].source;

      }

    }

  };

  Polygons.prototype.parse = function ( element ) {

    this.material = element.getAttribute( 'material' );
    this.count = _attr_as_int( element, 'count', 0 );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      switch ( child.nodeName ) {

        case 'input':

          this.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );
          break;

        case 'vcount':

          this.vcount = _ints( child.textContent );
          break;

        case 'p':

          this.p.push( _ints( child.textContent ) );
          break;

        case 'ph':

          console.warn( 'polygon holes not yet supported!' );
          break;

        default:
          break;

      }

    }

    return this;

  };

  function Polylist () {

    Polygons.call( this );

    this.vcount = [];

  }

  Polylist.prototype = Object.create( Polygons.prototype );
  Polylist.prototype.constructor = Polylist;

  function LineStrips() {

    Polygons.call( this );

    this.vcount = 1;

  }

  LineStrips.prototype = Object.create( Polygons.prototype );
  LineStrips.prototype.constructor = LineStrips;

  function Triangles () {

    Polygons.call( this );

    this.vcount = 3;

  }

  Triangles.prototype = Object.create( Polygons.prototype );
  Triangles.prototype.constructor = Triangles;

  function Accessor() {

    this.source = "";
    this.count = 0;
    this.stride = 0;
    this.params = [];

  }

  Accessor.prototype.parse = function ( element ) {

    this.params = [];
    this.source = element.getAttribute( 'source' );
    this.count = _attr_as_int( element, 'count', 0 );
    this.stride = _attr_as_int( element, 'stride', 0 );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      if ( child.nodeName === 'param' ) {

        var param = {};
        param[ 'name' ] = child.getAttribute( 'name' );
        param[ 'type' ] = child.getAttribute( 'type' );
        this.params.push( param );

      }

    }

    return this;

  };

  function Vertices() {

    this.input = {};

  }

  Vertices.prototype.parse = function ( element ) {

    this.id = element.getAttribute('id');

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      if ( element.childNodes[i].nodeName === 'input' ) {

        var input = ( new Input() ).parse( element.childNodes[ i ] );
        this.input[ input.semantic ] = input;

      }

    }

    return this;

  };

  function Input () {

    this.semantic = "";
    this.offset = 0;
    this.source = "";
    this.set = 0;

  }

  Input.prototype.parse = function ( element ) {

    this.semantic = element.getAttribute('semantic');
    this.source = element.getAttribute('source').replace(/^#/, '');
    this.set = _attr_as_int(element, 'set', -1);
    this.offset = _attr_as_int(element, 'offset', 0);

    if ( this.semantic === 'TEXCOORD' && this.set < 0 ) {

      this.set = 0;

    }

    return this;

  };

  function Source ( id ) {

    this.id = id;
    this.type = null;

  }

  Source.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];

      switch ( child.nodeName ) {

        case 'bool_array':

          this.data = _bools( child.textContent );
          this.type = child.nodeName;
          break;

        case 'float_array':

          this.data = _floats( child.textContent );
          this.type = child.nodeName;
          break;

        case 'int_array':

          this.data = _ints( child.textContent );
          this.type = child.nodeName;
          break;

        case 'IDREF_array':
        case 'Name_array':

          this.data = _strings( child.textContent );
          this.type = child.nodeName;
          break;

        case 'technique_common':

          for ( var j = 0; j < child.childNodes.length; j ++ ) {

            if ( child.childNodes[ j ].nodeName === 'accessor' ) {

              this.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );
              break;

            }
          }
          break;

        default:
          // console.log(child.nodeName);
          break;

      }

    }

    return this;

  };

  Source.prototype.read = function () {

    var result = [];

    //for (var i = 0; i < this.accessor.params.length; i++) {

    var param = this.accessor.params[ 0 ];

      //console.log(param.name + " " + param.type);

    switch ( param.type ) {

      case 'IDREF':
      case 'Name': case 'name':
      case 'float':

        return this.data;

      case 'float4x4':

        for ( var j = 0; j < this.data.length; j += 16 ) {

          var s = this.data.slice( j, j + 16 );
          var m = getConvertedMat4( s );
          result.push( m );
        }

        break;

      default:

        console.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );
        break;

    }

    //}

    return result;

  };

  function Material () {

    this.id = "";
    this.name = "";
    this.instance_effect = null;

  }

  Material.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      if ( element.childNodes[ i ].nodeName === 'instance_effect' ) {

        this.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );
        break;

      }

    }

    return this;

  };

  function ColorOrTexture () {

    this.color = new THREE.Color();
    this.color.setRGB( Math.random(), Math.random(), Math.random() );
    this.color.a = 1.0;

    this.texture = null;
    this.texcoord = null;
    this.texOpts = null;

  }

  ColorOrTexture.prototype.isColor = function () {

    return ( this.texture === null );

  };

  ColorOrTexture.prototype.isTexture = function () {

    return ( this.texture != null );

  };

  ColorOrTexture.prototype.parse = function ( element ) {

    if (element.nodeName === 'transparent') {

      this.opaque = element.getAttribute('opaque');

    }

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'color':

          var rgba = _floats( child.textContent );
          this.color = new THREE.Color();
          this.color.setRGB( rgba[0], rgba[1], rgba[2] );
          this.color.a = rgba[3];
          break;

        case 'texture':

          this.texture = child.getAttribute('texture');
          this.texcoord = child.getAttribute('texcoord');
          // Defaults from:
          // https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension
          this.texOpts = {
            offsetU: 0,
            offsetV: 0,
            repeatU: 1,
            repeatV: 1,
            wrapU: 1,
            wrapV: 1
          };
          this.parseTexture( child );
          break;

        default:
          break;

      }

    }

    return this;

  };

  ColorOrTexture.prototype.parseTexture = function ( element ) {

    if ( ! element.childNodes ) return this;

    // This should be supported by Maya, 3dsMax, and MotionBuilder

    if ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {

      element = element.childNodes[1];

      if ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {

        element = element.childNodes[1];

      }

    }

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      switch ( child.nodeName ) {

        case 'offsetU':
        case 'offsetV':
        case 'repeatU':
        case 'repeatV':

          this.texOpts[ child.nodeName ] = parseFloat( child.textContent );

          break;

        case 'wrapU':
        case 'wrapV':

          // some dae have a value of true which becomes NaN via parseInt

          if ( child.textContent.toUpperCase() === 'TRUE' ) {

            this.texOpts[ child.nodeName ] = 1;

          } else {

            this.texOpts[ child.nodeName ] = parseInt( child.textContent );

          }
          break;

        default:

          this.texOpts[ child.nodeName ] = child.textContent;

          break;

      }

    }

    return this;

  };

  function Shader ( type, effect ) {

    this.type = type;
    this.effect = effect;
    this.material = null;

  }

  Shader.prototype.parse = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'emission':
        case 'diffuse':
        case 'specular':
        case 'transparent':

          this[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );
          break;

        case 'bump':

          // If 'bumptype' is 'heightfield', create a 'bump' property
          // Else if 'bumptype' is 'normalmap', create a 'normal' property
          // (Default to 'bump')
          var bumpType = child.getAttribute( 'bumptype' );
          if ( bumpType ) {
            if ( bumpType.toLowerCase() === "heightfield" ) {
              this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
            } else if ( bumpType.toLowerCase() === "normalmap" ) {
              this[ 'normal' ] = ( new ColorOrTexture() ).parse( child );
            } else {
              console.error( "Shader.prototype.parse: Invalid value for attribute 'bumptype' (" + bumpType + ") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'" );
              this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
            }
          } else {
            console.warn( "Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'" );
            this[ 'bump' ] = ( new ColorOrTexture() ).parse( child );
          }

          break;

        case 'shininess':
        case 'reflectivity':
        case 'index_of_refraction':
        case 'transparency':

          var f = child.querySelectorAll('float');

          if ( f.length > 0 )
            this[ child.nodeName ] = parseFloat( f[ 0 ].textContent );

          break;

        default:
          break;

      }

    }

    this.create();
    return this;

  };

  Shader.prototype.create = function() {

    var props = {};

    var transparent = false;

    if (this['transparency'] !== undefined && this['transparent'] !== undefined) {
      // convert transparent color RBG to average value
      var transparentColor = this['transparent'];
      var transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;

      if (transparencyLevel > 0) {
        transparent = true;
        props[ 'transparent' ] = true;
        props[ 'opacity' ] = 1 - transparencyLevel;

      }

    }

    var keys = {
      'diffuse':'map',
      'ambient':'lightMap',
      'specular':'specularMap',
      'emission':'emissionMap',
      'bump':'bumpMap',
      'normal':'normalMap'
      };

    for ( var prop in this ) {

      switch ( prop ) {

        case 'ambient':
        case 'emission':
        case 'diffuse':
        case 'specular':
        case 'bump':
        case 'normal':

          var cot = this[ prop ];

          if ( cot instanceof ColorOrTexture ) {

            if ( cot.isTexture() ) {

              var samplerId = cot.texture;
              var surfaceId = this.effect.sampler[samplerId];

              if ( surfaceId !== undefined && surfaceId.source !== undefined ) {

                var surface = this.effect.surface[surfaceId.source];

                if ( surface !== undefined ) {

                  var image = images[ surface.init_from ];

                  if ( image ) {

                    var url = baseUrl + image.init_from;

                    var texture;
                    var loader = THREE.Loader.Handlers.get( url );

                    if ( loader !== null ) {

                      texture = loader.load( url );

                    } else {

                      texture = new THREE.Texture();

                      loadTextureImage( texture, url );

                    }

                    texture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                    texture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;
                    texture.offset.x = cot.texOpts.offsetU;
                    texture.offset.y = cot.texOpts.offsetV;
                    texture.repeat.x = cot.texOpts.repeatU;
                    texture.repeat.y = cot.texOpts.repeatV;
                    props[keys[prop]] = texture;

                    // Texture with baked lighting?
                    if (prop === 'emission') props['emissive'] = 0xffffff;

                  }

                }

              }

            } else if ( prop === 'diffuse' || !transparent ) {

              if ( prop === 'emission' ) {

                props[ 'emissive' ] = cot.color.getHex();

              } else {

                props[ prop ] = cot.color.getHex();

              }

            }

          }

          break;

        case 'shininess':

          props[ prop ] = this[ prop ];
          break;

        case 'reflectivity':

          props[ prop ] = this[ prop ];
          if ( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;
          props['combine'] = THREE.MixOperation;  //mix regular shading with reflective component
          break;

        case 'index_of_refraction':

          props[ 'refractionRatio' ] = this[ prop ]; //TODO: "index_of_refraction" becomes "refractionRatio" in shader, but I'm not sure if the two are actually comparable
          if ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;
          break;

        case 'transparency':
          // gets figured out up top
          break;

        default:
          break;

      }

    }

    props[ 'shading' ] = preferredShading;
    props[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;

    if ( props.diffuse !== undefined ) {

      props.color = props.diffuse;
      delete props.diffuse;

    }

    switch ( this.type ) {

      case 'constant':

        if (props.emissive != undefined) props.color = props.emissive;
        this.material = new THREE.MeshBasicMaterial( props );
        break;

      case 'phong':
      case 'blinn':

        this.material = new THREE.MeshPhongMaterial( props );
        break;

      case 'lambert':
      default:

        this.material = new THREE.MeshLambertMaterial( props );
        break;

    }

    return this.material;

  };

  function Surface ( effect ) {

    this.effect = effect;
    this.init_from = null;
    this.format = null;

  }

  Surface.prototype.parse = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'init_from':

          this.init_from = child.textContent;
          break;

        case 'format':

          this.format = child.textContent;
          break;

        default:

          console.log( "unhandled Surface prop: " + child.nodeName );
          break;

      }

    }

    return this;

  };

  function Sampler2D ( effect ) {

    this.effect = effect;
    this.source = null;
    this.wrap_s = null;
    this.wrap_t = null;
    this.minfilter = null;
    this.magfilter = null;
    this.mipfilter = null;

  }

  Sampler2D.prototype.parse = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'source':

          this.source = child.textContent;
          break;

        case 'minfilter':

          this.minfilter = child.textContent;
          break;

        case 'magfilter':

          this.magfilter = child.textContent;
          break;

        case 'mipfilter':

          this.mipfilter = child.textContent;
          break;

        case 'wrap_s':

          this.wrap_s = child.textContent;
          break;

        case 'wrap_t':

          this.wrap_t = child.textContent;
          break;

        default:

          console.log( "unhandled Sampler2D prop: " + child.nodeName );
          break;

      }

    }

    return this;

  };

  function Effect () {

    this.id = "";
    this.name = "";
    this.shader = null;
    this.surface = {};
    this.sampler = {};

  }

  Effect.prototype.create = function () {

    if ( this.shader === null ) {

      return null;

    }

  };

  Effect.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );

    extractDoubleSided( this, element );

    this.shader = null;

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'profile_COMMON':

          this.parseTechnique( this.parseProfileCOMMON( child ) );
          break;

        default:
          break;

      }

    }

    return this;

  };

  Effect.prototype.parseNewparam = function ( element ) {

    var sid = element.getAttribute( 'sid' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'surface':

          this.surface[sid] = ( new Surface( this ) ).parse( child );
          break;

        case 'sampler2D':

          this.sampler[sid] = ( new Sampler2D( this ) ).parse( child );
          break;

        case 'extra':

          break;

        default:

          console.log( child.nodeName );
          break;

      }

    }

  };

  Effect.prototype.parseProfileCOMMON = function ( element ) {

    var technique;

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'profile_COMMON':

          this.parseProfileCOMMON( child );
          break;

        case 'technique':

          technique = child;
          break;

        case 'newparam':

          this.parseNewparam( child );
          break;

        case 'image':

          var _image = ( new _Image() ).parse( child );
          images[ _image.id ] = _image;
          break;

        case 'extra':
          break;

        default:

          console.log( child.nodeName );
          break;

      }

    }

    return technique;

  };

  Effect.prototype.parseTechnique = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'constant':
        case 'lambert':
        case 'blinn':
        case 'phong':

          this.shader = ( new Shader( child.nodeName, this ) ).parse( child );
          break;
        case 'extra':
          this.parseExtra(child);
          break;
        default:
          break;

      }

    }

  };

  Effect.prototype.parseExtra = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'technique':
          this.parseExtraTechnique( child );
          break;
        default:
          break;

      }

    }

  };

  Effect.prototype.parseExtraTechnique = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[i];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'bump':
          this.shader.parse( element );
          break;
        default:
          break;

      }

    }

  };

  function InstanceEffect () {

    this.url = "";

  }

  InstanceEffect.prototype.parse = function ( element ) {

    this.url = element.getAttribute( 'url' ).replace( /^#/, '' );
    return this;

  };

  function Animation() {

    this.id = "";
    this.name = "";
    this.source = {};
    this.sampler = [];
    this.channel = [];

  }

  Animation.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );
    this.source = {};

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'animation':

          var anim = ( new Animation() ).parse( child );

          for ( var src in anim.source ) {

            this.source[ src ] = anim.source[ src ];

          }

          for ( var j = 0; j < anim.channel.length; j ++ ) {

            this.channel.push( anim.channel[ j ] );
            this.sampler.push( anim.sampler[ j ] );

          }

          break;

        case 'source':

          var src = ( new Source() ).parse( child );
          this.source[ src.id ] = src;
          break;

        case 'sampler':

          this.sampler.push( ( new Sampler( this ) ).parse( child ) );
          break;

        case 'channel':

          this.channel.push( ( new Channel( this ) ).parse( child ) );
          break;

        default:
          break;

      }

    }

    return this;

  };

  function Channel( animation ) {

    this.animation = animation;
    this.source = "";
    this.target = "";
    this.fullSid = null;
    this.sid = null;
    this.dotSyntax = null;
    this.arrSyntax = null;
    this.arrIndices = null;
    this.member = null;

  }

  Channel.prototype.parse = function ( element ) {

    this.source = element.getAttribute( 'source' ).replace( /^#/, '' );
    this.target = element.getAttribute( 'target' );

    var parts = this.target.split( '/' );

    var id = parts.shift();
    var sid = parts.shift();

    var dotSyntax = ( sid.indexOf(".") >= 0 );
    var arrSyntax = ( sid.indexOf("(") >= 0 );

    if ( dotSyntax ) {

      parts = sid.split(".");
      this.sid = parts.shift();
      this.member = parts.shift();

    } else if ( arrSyntax ) {

      var arrIndices = sid.split("(");
      this.sid = arrIndices.shift();

      for (var j = 0; j < arrIndices.length; j ++ ) {

        arrIndices[j] = parseInt( arrIndices[j].replace(/\)/, '') );

      }

      this.arrIndices = arrIndices;

    } else {

      this.sid = sid;

    }

    this.fullSid = sid;
    this.dotSyntax = dotSyntax;
    this.arrSyntax = arrSyntax;

    return this;

  };

  function Sampler ( animation ) {

    this.id = "";
    this.animation = animation;
    this.inputs = [];
    this.input = null;
    this.output = null;
    this.strideOut = null;
    this.interpolation = null;
    this.startTime = null;
    this.endTime = null;
    this.duration = 0;

  }

  Sampler.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.inputs = [];

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'input':

          this.inputs.push( (new Input()).parse( child ) );
          break;

        default:
          break;

      }

    }

    return this;

  };

  Sampler.prototype.create = function () {

    for ( var i = 0; i < this.inputs.length; i ++ ) {

      var input = this.inputs[ i ];
      var source = this.animation.source[ input.source ];

      switch ( input.semantic ) {

        case 'INPUT':

          this.input = source.read();
          break;

        case 'OUTPUT':

          this.output = source.read();
          this.strideOut = source.accessor.stride;
          break;

        case 'INTERPOLATION':

          this.interpolation = source.read();
          break;

        case 'IN_TANGENT':

          break;

        case 'OUT_TANGENT':

          break;

        default:

          console.log(input.semantic);
          break;

      }

    }

    this.startTime = 0;
    this.endTime = 0;
    this.duration = 0;

    if ( this.input.length ) {

      this.startTime = 100000000;
      this.endTime = -100000000;

      for ( var i = 0; i < this.input.length; i ++ ) {

        this.startTime = Math.min( this.startTime, this.input[ i ] );
        this.endTime = Math.max( this.endTime, this.input[ i ] );

      }

      this.duration = this.endTime - this.startTime;

    }

  };

  Sampler.prototype.getData = function ( type, ndx, member ) {

    var data;

    if ( type === 'matrix' && this.strideOut === 16 ) {

      data = this.output[ ndx ];

    } else if ( this.strideOut > 1 ) {

      data = [];
      ndx *= this.strideOut;

      for ( var i = 0; i < this.strideOut; ++ i ) {

        data[ i ] = this.output[ ndx + i ];

      }

      if ( this.strideOut === 3 ) {

        switch ( type ) {

          case 'rotate':
          case 'translate':

            fixCoords( data, -1 );
            break;

          case 'scale':

            fixCoords( data, 1 );
            break;

        }

      } else if ( this.strideOut === 4 && type === 'matrix' ) {

        fixCoords( data, -1 );

      }

    } else {

      data = this.output[ ndx ];

      if ( member && type === 'translate' ) {
        data = getConvertedTranslation( member, data );
      }

    }

    return data;

  };

  function Key ( time ) {

    this.targets = [];
    this.time = time;

  }

  Key.prototype.addTarget = function ( fullSid, transform, member, data ) {

    this.targets.push( {
      sid: fullSid,
      member: member,
      transform: transform,
      data: data
    } );

  };

  Key.prototype.apply = function ( opt_sid ) {

    for ( var i = 0; i < this.targets.length; ++ i ) {

      var target = this.targets[ i ];

      if ( !opt_sid || target.sid === opt_sid ) {

        target.transform.update( target.data, target.member );

      }

    }

  };

  Key.prototype.getTarget = function ( fullSid ) {

    for ( var i = 0; i < this.targets.length; ++ i ) {

      if ( this.targets[ i ].sid === fullSid ) {

        return this.targets[ i ];

      }

    }

    return null;

  };

  Key.prototype.hasTarget = function ( fullSid ) {

    for ( var i = 0; i < this.targets.length; ++ i ) {

      if ( this.targets[ i ].sid === fullSid ) {

        return true;

      }

    }

    return false;

  };

  // TODO: Currently only doing linear interpolation. Should support full COLLADA spec.
  Key.prototype.interpolate = function ( nextKey, time ) {

    for ( var i = 0, l = this.targets.length; i < l; i ++ ) {

      var target = this.targets[ i ],
        nextTarget = nextKey.getTarget( target.sid ),
        data;

      if ( target.transform.type !== 'matrix' && nextTarget ) {

        var scale = ( time - this.time ) / ( nextKey.time - this.time ),
          nextData = nextTarget.data,
          prevData = target.data;

        if ( scale < 0 ) scale = 0;
        if ( scale > 1 ) scale = 1;

        if ( prevData.length ) {

          data = [];

          for ( var j = 0; j < prevData.length; ++ j ) {

            data[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;

          }

        } else {

          data = prevData + ( nextData - prevData ) * scale;

        }

      } else {

        data = target.data;

      }

      target.transform.update( data, target.member );

    }

  };

  // Camera
  function Camera() {

    this.id = "";
    this.name = "";
    this.technique = "";

  }

  Camera.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'optics':

          this.parseOptics( child );
          break;

        default:
          break;

      }

    }

    return this;

  };

  Camera.prototype.parseOptics = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      if ( element.childNodes[ i ].nodeName === 'technique_common' ) {

        var technique = element.childNodes[ i ];

        for ( var j = 0; j < technique.childNodes.length; j ++ ) {

          this.technique = technique.childNodes[ j ].nodeName;

          if ( this.technique === 'perspective' ) {

            var perspective = technique.childNodes[ j ];

            for ( var k = 0; k < perspective.childNodes.length; k ++ ) {

              var param = perspective.childNodes[ k ];

              switch ( param.nodeName ) {

                case 'yfov':
                  this.yfov = param.textContent;
                  break;
                case 'xfov':
                  this.xfov = param.textContent;
                  break;
                case 'znear':
                  this.znear = param.textContent;
                  break;
                case 'zfar':
                  this.zfar = param.textContent;
                  break;
                case 'aspect_ratio':
                  this.aspect_ratio = param.textContent;
                  break;

              }

            }

          } else if ( this.technique === 'orthographic' ) {

            var orthographic = technique.childNodes[ j ];

            for ( var k = 0; k < orthographic.childNodes.length; k ++ ) {

              var param = orthographic.childNodes[ k ];

              switch ( param.nodeName ) {

                case 'xmag':
                  this.xmag = param.textContent;
                  break;
                case 'ymag':
                  this.ymag = param.textContent;
                  break;
                case 'znear':
                  this.znear = param.textContent;
                  break;
                case 'zfar':
                  this.zfar = param.textContent;
                  break;
                case 'aspect_ratio':
                  this.aspect_ratio = param.textContent;
                  break;

              }

            }

          }

        }

      }

    }

    return this;

  };

  function InstanceCamera() {

    this.url = "";

  }

  InstanceCamera.prototype.parse = function ( element ) {

    this.url = element.getAttribute('url').replace(/^#/, '');

    return this;

  };

  // Light

  function Light() {

    this.id = "";
    this.name = "";
    this.technique = "";

  }

  Light.prototype.parse = function ( element ) {

    this.id = element.getAttribute( 'id' );
    this.name = element.getAttribute( 'name' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'technique_common':

          this.parseCommon( child );
          break;

        case 'technique':

          this.parseTechnique( child );
          break;

        default:
          break;

      }

    }

    return this;

  };

  Light.prototype.parseCommon = function ( element ) {

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      switch ( element.childNodes[ i ].nodeName ) {

        case 'directional':
        case 'point':
        case 'spot':
        case 'ambient':

          this.technique = element.childNodes[ i ].nodeName;

          var light = element.childNodes[ i ];

          for ( var j = 0; j < light.childNodes.length; j ++ ) {

            var child = light.childNodes[j];

            switch ( child.nodeName ) {

              case 'color':

                var rgba = _floats( child.textContent );
                this.color = new THREE.Color(0);
                this.color.setRGB( rgba[0], rgba[1], rgba[2] );
                this.color.a = rgba[3];
                break;

              case 'falloff_angle':

                this.falloff_angle = parseFloat( child.textContent );
                break;

              case 'quadratic_attenuation':
                var f = parseFloat( child.textContent );
                this.distance = f ? Math.sqrt( 1 / f ) : 0;
            }

          }

      }

    }

    return this;

  };

  Light.prototype.parseTechnique = function ( element ) {

    this.profile = element.getAttribute( 'profile' );

    for ( var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];

      switch ( child.nodeName ) {

        case 'intensity':

          this.intensity = parseFloat(child.textContent);
          break;

      }

    }

    return this;

  };

  function InstanceLight() {

    this.url = "";

  }

  InstanceLight.prototype.parse = function ( element ) {

    this.url = element.getAttribute('url').replace(/^#/, '');

    return this;

  };

  function KinematicsModel( ) {

    this.id = '';
    this.name = '';
    this.joints = [];
    this.links = [];

  }

  KinematicsModel.prototype.parse = function( element ) {

    this.id = element.getAttribute('id');
    this.name = element.getAttribute('name');
    this.joints = [];
    this.links = [];

    for (var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'technique_common':

          this.parseCommon(child);
          break;

        default:
          break;

      }

    }

    return this;

  };

  KinematicsModel.prototype.parseCommon = function( element ) {

    for (var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( element.childNodes[ i ].nodeName ) {

        case 'joint':
          this.joints.push( (new Joint()).parse(child) );
          break;

        case 'link':
          this.links.push( (new Link()).parse(child) );
          break;

        default:
          break;

      }

    }

    return this;

  };

  function Joint( ) {

    this.sid = '';
    this.name = '';
    this.axis = new THREE.Vector3();
    this.limits = {
      min: 0,
      max: 0
    };
    this.type = '';
    this.static = false;
    this.zeroPosition = 0.0;
    this.middlePosition = 0.0;

  }

  Joint.prototype.parse = function( element ) {

    this.sid = element.getAttribute('sid');
    this.name = element.getAttribute('name');
    this.axis = new THREE.Vector3();
    this.limits = {
      min: 0,
      max: 0
    };
    this.type = '';
    this.static = false;
    this.zeroPosition = 0.0;
    this.middlePosition = 0.0;

    var axisElement = element.querySelector('axis');
    var _axis = _floats(axisElement.textContent);
    this.axis = getConvertedVec3(_axis, 0);

    var min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;
    var max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;

    this.limits = {
      min: min,
      max: max
    };

    var jointTypes = [ 'prismatic', 'revolute' ];
    for (var i = 0; i < jointTypes.length; i ++ ) {

      var type = jointTypes[ i ];

      var jointElement = element.querySelector(type);

      if ( jointElement ) {

        this.type = type;

      }

    }

    // if the min is equal to or somehow greater than the max, consider the joint static
    if ( this.limits.min >= this.limits.max ) {

      this.static = true;

    }

    this.middlePosition = (this.limits.min + this.limits.max) / 2.0;
    return this;

  };

  function Link( ) {

    this.sid = '';
    this.name = '';
    this.transforms = [];
    this.attachments = [];

  }

  Link.prototype.parse = function( element ) {

    this.sid = element.getAttribute('sid');
    this.name = element.getAttribute('name');
    this.transforms = [];
    this.attachments = [];

    for (var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'attachment_full':
          this.attachments.push( (new Attachment()).parse(child) );
          break;

        case 'rotate':
        case 'translate':
        case 'matrix':

          this.transforms.push( (new Transform()).parse(child) );
          break;

        default:

          break;

      }

    }

    return this;

  };

  function Attachment( ) {

    this.joint = '';
    this.transforms = [];
    this.links = [];

  }

  Attachment.prototype.parse = function( element ) {

    this.joint = element.getAttribute('joint').split('/').pop();
    this.links = [];

    for (var i = 0; i < element.childNodes.length; i ++ ) {

      var child = element.childNodes[ i ];
      if ( child.nodeType != 1 ) continue;

      switch ( child.nodeName ) {

        case 'link':
          this.links.push( (new Link()).parse(child) );
          break;

        case 'rotate':
        case 'translate':
        case 'matrix':

          this.transforms.push( (new Transform()).parse(child) );
          break;

        default:

          break;

      }

    }

    return this;

  };

  function _source( element ) {

    var id = element.getAttribute( 'id' );

    if ( sources[ id ] != undefined ) {

      return sources[ id ];

    }

    sources[ id ] = ( new Source(id )).parse( element );
    return sources[ id ];

  }

  function _nsResolver( nsPrefix ) {

    if ( nsPrefix === "dae" ) {

      return "http://www.collada.org/2005/11/COLLADASchema";

    }

    return null;

  }

  function _bools( str ) {

    var raw = _strings( str );
    var data = [];

    for ( var i = 0, l = raw.length; i < l; i ++ ) {

      data.push( (raw[i] === 'true' || raw[i] === '1') ? true : false );

    }

    return data;

  }

  function _floats( str ) {

    var raw = _strings(str);
    var data = [];

    for ( var i = 0, l = raw.length; i < l; i ++ ) {

      data.push( parseFloat( raw[ i ] ) );

    }

    return data;

  }

  function _ints( str ) {

    var raw = _strings( str );
    var data = [];

    for ( var i = 0, l = raw.length; i < l; i ++ ) {

      data.push( parseInt( raw[ i ], 10 ) );

    }

    return data;

  }

  function _strings( str ) {

    return ( str.length > 0 ) ? _trimString( str ).split( /\s+/ ) : [];

  }

  function _trimString( str ) {

    return str.replace( /^\s+/, "" ).replace( /\s+$/, "" );

  }

  function _attr_as_float( element, name, defaultValue ) {

    if ( element.hasAttribute( name ) ) {

      return parseFloat( element.getAttribute( name ) );

    } else {

      return defaultValue;

    }

  }

  function _attr_as_int( element, name, defaultValue ) {

    if ( element.hasAttribute( name ) ) {

      return parseInt( element.getAttribute( name ), 10) ;

    } else {

      return defaultValue;

    }

  }

  function _attr_as_string( element, name, defaultValue ) {

    if ( element.hasAttribute( name ) ) {

      return element.getAttribute( name );

    } else {

      return defaultValue;

    }

  }

  function _format_float( f, num ) {

    if ( f === undefined ) {

      var s = '0.';

      while ( s.length < num + 2 ) {

        s += '0';

      }

      return s;

    }

    num = num || 2;

    var parts = f.toString().split( '.' );
    parts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : "0";

    while ( parts[ 1 ].length < num ) {

      parts[ 1 ] += '0';

    }

    return parts.join( '.' );

  }

  function loadTextureImage ( texture, url ) {

    var loader = new THREE.ImageLoader();

    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

    } );

  }

  function extractDoubleSided( obj, element ) {

    obj.doubleSided = false;

    var node = element.querySelectorAll('extra double_sided')[0];

    if ( node ) {

      if ( node && parseInt( node.textContent, 10 ) === 1 ) {

        obj.doubleSided = true;

      }

    }

  }

  // Up axis conversion

  function setUpConversion() {

    if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {

      upConversion = null;

    } else {

      switch ( colladaUp ) {

        case 'X':

          upConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';
          break;

        case 'Y':

          upConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';
          break;

        case 'Z':

          upConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';
          break;

      }

    }

  }

  function fixCoords( data, sign ) {

    if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {

      return;

    }

    switch ( upConversion ) {

      case 'XtoY':

        var tmp = data[ 0 ];
        data[ 0 ] = sign * data[ 1 ];
        data[ 1 ] = tmp;
        break;

      case 'XtoZ':

        var tmp = data[ 2 ];
        data[ 2 ] = data[ 1 ];
        data[ 1 ] = data[ 0 ];
        data[ 0 ] = tmp;
        break;

      case 'YtoX':

        var tmp = data[ 0 ];
        data[ 0 ] = data[ 1 ];
        data[ 1 ] = sign * tmp;
        break;

      case 'YtoZ':

        var tmp = data[ 1 ];
        data[ 1 ] = sign * data[ 2 ];
        data[ 2 ] = tmp;
        break;

      case 'ZtoX':

        var tmp = data[ 0 ];
        data[ 0 ] = data[ 1 ];
        data[ 1 ] = data[ 2 ];
        data[ 2 ] = tmp;
        break;

      case 'ZtoY':

        var tmp = data[ 1 ];
        data[ 1 ] = data[ 2 ];
        data[ 2 ] = sign * tmp;
        break;

    }

  }

  function getConvertedTranslation( axis, data ) {

    if ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {

      return data;

    }

    switch ( axis ) {
      case 'X':
        data = upConversion === 'XtoY' ? data * -1 : data;
        break;
      case 'Y':
        data = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;
        break;
      case 'Z':
        data = upConversion === 'ZtoY' ? data * -1 : data ;
        break;
      default:
        break;
    }

    return data;
  }

  function getConvertedVec3( data, offset ) {

    var arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];
    fixCoords( arr, -1 );
    return new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );

  }

  function getConvertedMat4( data ) {

    if ( options.convertUpAxis ) {

      // First fix rotation and scale

      // Columns first
      var arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];
      fixCoords( arr, -1 );
      data[ 0 ] = arr[ 0 ];
      data[ 4 ] = arr[ 1 ];
      data[ 8 ] = arr[ 2 ];
      arr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];
      fixCoords( arr, -1 );
      data[ 1 ] = arr[ 0 ];
      data[ 5 ] = arr[ 1 ];
      data[ 9 ] = arr[ 2 ];
      arr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];
      fixCoords( arr, -1 );
      data[ 2 ] = arr[ 0 ];
      data[ 6 ] = arr[ 1 ];
      data[ 10 ] = arr[ 2 ];
      // Rows second
      arr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];
      fixCoords( arr, -1 );
      data[ 0 ] = arr[ 0 ];
      data[ 1 ] = arr[ 1 ];
      data[ 2 ] = arr[ 2 ];
      arr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];
      fixCoords( arr, -1 );
      data[ 4 ] = arr[ 0 ];
      data[ 5 ] = arr[ 1 ];
      data[ 6 ] = arr[ 2 ];
      arr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];
      fixCoords( arr, -1 );
      data[ 8 ] = arr[ 0 ];
      data[ 9 ] = arr[ 1 ];
      data[ 10 ] = arr[ 2 ];

      // Now fix translation
      arr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];
      fixCoords( arr, -1 );
      data[ 3 ] = arr[ 0 ];
      data[ 7 ] = arr[ 1 ];
      data[ 11 ] = arr[ 2 ];

    }

    return new THREE.Matrix4().set(
      data[0], data[1], data[2], data[3],
      data[4], data[5], data[6], data[7],
      data[8], data[9], data[10], data[11],
      data[12], data[13], data[14], data[15]
      );

  }

  function getConvertedIndex( index ) {

    if ( index > -1 && index < 3 ) {

      var members = [ 'X', 'Y', 'Z' ],
        indices = { X: 0, Y: 1, Z: 2 };

      index = getConvertedMember( members[ index ] );
      index = indices[ index ];

    }

    return index;

  }

  function getConvertedMember( member ) {

    if ( options.convertUpAxis ) {

      switch ( member ) {

        case 'X':

          switch ( upConversion ) {

            case 'XtoY':
            case 'XtoZ':
            case 'YtoX':

              member = 'Y';
              break;

            case 'ZtoX':

              member = 'Z';
              break;

          }

          break;

        case 'Y':

          switch ( upConversion ) {

            case 'XtoY':
            case 'YtoX':
            case 'ZtoX':

              member = 'X';
              break;

            case 'XtoZ':
            case 'YtoZ':
            case 'ZtoY':

              member = 'Z';
              break;

          }

          break;

        case 'Z':

          switch ( upConversion ) {

            case 'XtoZ':

              member = 'X';
              break;

            case 'YtoZ':
            case 'ZtoX':
            case 'ZtoY':

              member = 'Y';
              break;

          }

          break;

      }

    }

    return member;

  }

  return {

    load: load,
    parse: parse,
    setPreferredShading: setPreferredShading,
    applySkin: applySkin,
    geometries : geometries,
    options: options

  };

};

},{}],23:[function(_dereq_,module,exports){
/**
 * Loads a Wavefront .mtl file specifying materials
 *
 * @author angelxuanchang
 */

THREE.MTLLoader = function( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MTLLoader.prototype = {

  constructor: THREE.MTLLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( this.manager );
    loader.setPath( this.path );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  setPath: function ( value ) {

    this.path = value;

  },

  setBaseUrl: function( value ) {

    // TODO: Merge with setPath()? Or rename to setTexturePath?

    this.baseUrl = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setMaterialOptions: function ( value ) {

    this.materialOptions = value;

  },

  /**
   * Parses loaded MTL file
   * @param text - Content of MTL file
   * @return {THREE.MTLLoader.MaterialCreator}
   */
  parse: function ( text ) {

    var lines = text.split( "\n" );
    var info = {};
    var delimiter_pattern = /\s+/;
    var materialsInfo = {};

    for ( var i = 0; i < lines.length; i ++ ) {

      var line = lines[ i ];
      line = line.trim();

      if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

        // Blank line or comment ignore
        continue;

      }

      var pos = line.indexOf( ' ' );

      var key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;
      key = key.toLowerCase();

      var value = ( pos >= 0 ) ? line.substring( pos + 1 ) : "";
      value = value.trim();

      if ( key === "newmtl" ) {

        // New material

        info = { name: value };
        materialsInfo[ value ] = info;

      } else if ( info ) {

        if ( key === "ka" || key === "kd" || key === "ks" ) {

          var ss = value.split( delimiter_pattern, 3 );
          info[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];

        } else {

          info[ key ] = value;

        }

      }

    }

    var materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.materialOptions );
    materialCreator.setCrossOrigin( this.crossOrigin );
    materialCreator.setManager( this.manager );
    materialCreator.setMaterials( materialsInfo );
    return materialCreator;

  }

};

/**
 * Create a new THREE-MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */

THREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {

  this.baseUrl = baseUrl;
  this.options = options;
  this.materialsInfo = {};
  this.materials = {};
  this.materialsArray = [];
  this.nameLookup = {};

  this.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;
  this.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;

};

THREE.MTLLoader.MaterialCreator.prototype = {

  constructor: THREE.MTLLoader.MaterialCreator,

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  setManager: function ( value ) {

    this.manager = value;

  },

  setMaterials: function( materialsInfo ) {

    this.materialsInfo = this.convert( materialsInfo );
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};

  },

  convert: function( materialsInfo ) {

    if ( ! this.options ) return materialsInfo;

    var converted = {};

    for ( var mn in materialsInfo ) {

      // Convert materials info into normalized form based on options

      var mat = materialsInfo[ mn ];

      var covmat = {};

      converted[ mn ] = covmat;

      for ( var prop in mat ) {

        var save = true;
        var value = mat[ prop ];
        var lprop = prop.toLowerCase();

        switch ( lprop ) {

          case 'kd':
          case 'ka':
          case 'ks':

            // Diffuse color (color under white light) using RGB values

            if ( this.options && this.options.normalizeRGB ) {

              value = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];

            }

            if ( this.options && this.options.ignoreZeroRGBs ) {

              if ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {

                // ignore

                save = false;

              }

            }

            break;

          default:

            break;
        }

        if ( save ) {

          covmat[ lprop ] = value;

        }

      }

    }

    return converted;

  },

  preload: function () {

    for ( var mn in this.materialsInfo ) {

      this.create( mn );

    }

  },

  getIndex: function( materialName ) {

    return this.nameLookup[ materialName ];

  },

  getAsArray: function() {

    var index = 0;

    for ( var mn in this.materialsInfo ) {

      this.materialsArray[ index ] = this.create( mn );
      this.nameLookup[ mn ] = index;
      index ++;

    }

    return this.materialsArray;

  },

  create: function ( materialName ) {

    if ( this.materials[ materialName ] === undefined ) {

      this.createMaterial_( materialName );

    }

    return this.materials[ materialName ];

  },

  createMaterial_: function ( materialName ) {

    // Create material

    var mat = this.materialsInfo[ materialName ];
    var params = {

      name: materialName,
      side: this.side

    };

    for ( var prop in mat ) {

      var value = mat[ prop ];

      if ( value === '' ) {
        continue;
      }

      switch ( prop.toLowerCase() ) {

        // Ns is material specular exponent

        case 'kd':

          // Diffuse color (color under white light) using RGB values

          params[ 'color' ] = new THREE.Color().fromArray( value );

          break;

        case 'ks':

          // Specular color (color when light is reflected from shiny surface) using RGB values
          params[ 'specular' ] = new THREE.Color().fromArray( value );

          break;

        case 'map_kd':

          // Diffuse texture map

          params[ 'map' ] = this.loadTexture( this.baseUrl + value );
          params[ 'map' ].wrapS = this.wrap;
          params[ 'map' ].wrapT = this.wrap;

          break;

        case 'ns':

          // The specular exponent (defines the focus of the specular highlight)
          // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.

          params[ 'shininess' ] = parseFloat( value );

          break;

        case 'd':

          if ( value < 1 ) {

            params[ 'opacity' ] = value;
            params[ 'transparent' ] = true;

          }

          break;

        case 'Tr':

          if ( value > 0 ) {

            params[ 'opacity' ] = 1 - value;
            params[ 'transparent' ] = true;

          }

          break;

        case 'map_bump':
        case 'bump':

          // Bump texture map

          if ( params[ 'bumpMap' ] ) break; // Avoid loading twice.

          params[ 'bumpMap' ] = this.loadTexture( this.baseUrl + value );
          params[ 'bumpMap' ].wrapS = this.wrap;
          params[ 'bumpMap' ].wrapT = this.wrap;

          break;

        default:
          break;

      }

    }

    this.materials[ materialName ] = new THREE.MeshPhongMaterial( params );
    return this.materials[ materialName ];

  },


  loadTexture: function ( url, mapping, onLoad, onProgress, onError ) {

    var texture;
    var loader = THREE.Loader.Handlers.get( url );
    var manager = ( this.manager !== undefined ) ? this.manager : THREE.DefaultLoadingManager;

    if ( loader === null ) {

      loader = new THREE.TextureLoader( manager );

    }

    if ( loader.setCrossOrigin ) loader.setCrossOrigin( this.crossOrigin );
    texture = loader.load( url, onLoad, onProgress, onError );

    if ( mapping !== undefined ) texture.mapping = mapping;

    return texture;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.MTLLoader.prototype );

},{}],24:[function(_dereq_,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.OBJLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

  this.materials = null;

};

THREE.OBJLoader.prototype = {

  constructor: THREE.OBJLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setPath( this.path );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( text ) );

    }, onProgress, onError );

  },

  setPath: function ( value ) {

    this.path = value;

  },

  setMaterials: function ( materials ) {

    this.materials = materials;

  },

  parse: function ( text ) {

    console.time( 'OBJLoader' );

    var objects = [];
    var object;
    var foundObjects = false;
    var vertices = [];
    var normals = [];
    var uvs = [];

    function addObject(name) {

      var geometry = {
        vertices: [],
        normals: [],
        uvs: []
      };

      var material = {
        name: '',
        smooth: true
      };

      object = {
        name: name,
        geometry: geometry,
        material: material
      };

      objects.push( object );

    }

    function parseVertexIndex( value ) {

      var index = parseInt( value );

      return ( index >= 0 ? index - 1 : index + vertices.length / 3 ) * 3;

    }

    function parseNormalIndex( value ) {

      var index = parseInt( value );

      return ( index >= 0 ? index - 1 : index + normals.length / 3 ) * 3;

    }

    function parseUVIndex( value ) {

      var index = parseInt( value );

      return ( index >= 0 ? index - 1 : index + uvs.length / 2 ) * 2;

    }

    function addVertex( a, b, c ) {

      object.geometry.vertices.push(
        vertices[ a ], vertices[ a + 1 ], vertices[ a + 2 ],
        vertices[ b ], vertices[ b + 1 ], vertices[ b + 2 ],
        vertices[ c ], vertices[ c + 1 ], vertices[ c + 2 ]
      );

    }

    function addNormal( a, b, c ) {

      object.geometry.normals.push(
        normals[ a ], normals[ a + 1 ], normals[ a + 2 ],
        normals[ b ], normals[ b + 1 ], normals[ b + 2 ],
        normals[ c ], normals[ c + 1 ], normals[ c + 2 ]
      );

    }

    function addUV( a, b, c ) {

      object.geometry.uvs.push(
        uvs[ a ], uvs[ a + 1 ],
        uvs[ b ], uvs[ b + 1 ],
        uvs[ c ], uvs[ c + 1 ]
      );

    }

    function addFace( a, b, c, d,  ua, ub, uc, ud, na, nb, nc, nd ) {

      var ia = parseVertexIndex( a );
      var ib = parseVertexIndex( b );
      var ic = parseVertexIndex( c );
      var id;

      if ( d === undefined ) {

        addVertex( ia, ib, ic );

      } else {

        id = parseVertexIndex( d );

        addVertex( ia, ib, id );
        addVertex( ib, ic, id );

      }

      if ( ua !== undefined ) {

        ia = parseUVIndex( ua );
        ib = parseUVIndex( ub );
        ic = parseUVIndex( uc );

        if ( d === undefined ) {

          addUV( ia, ib, ic );

        } else {

          id = parseUVIndex( ud );

          addUV( ia, ib, id );
          addUV( ib, ic, id );

        }

      }

      if ( na !== undefined ) {

        ia = parseNormalIndex( na );
        ib = parseNormalIndex( nb );
        ic = parseNormalIndex( nc );

        if ( d === undefined ) {

          addNormal( ia, ib, ic );

        } else {

          id = parseNormalIndex( nd );

          addNormal( ia, ib, id );
          addNormal( ib, ic, id );

        }

      }

    }

    addObject("");

    // v float float float
    var vertex_pattern = /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;

    // vn float float float
    var normal_pattern = /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;

    // vt float float
    var uv_pattern = /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/;

    // f vertex vertex vertex ...
    var face_pattern1 = /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/;

    // f vertex/uv vertex/uv vertex/uv ...
    var face_pattern2 = /^f\s+((-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+))(?:\s+((-?\d+)\/(-?\d+)))?/;

    // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
    var face_pattern3 = /^f\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))\s+((-?\d+)\/(-?\d+)\/(-?\d+))(?:\s+((-?\d+)\/(-?\d+)\/(-?\d+)))?/;

    // f vertex//normal vertex//normal vertex//normal ...
    var face_pattern4 = /^f\s+((-?\d+)\/\/(-?\d+))\s+((-?\d+)\/\/(-?\d+))\s+((-?\d+)\/\/(-?\d+))(?:\s+((-?\d+)\/\/(-?\d+)))?/;

    var object_pattern = /^[og]\s+(.+)/;

    var smoothing_pattern = /^s\s+([01]|on|off)/;

    //

    var lines = text.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      var line = lines[ i ];
      line = line.trim();

      var result;

      if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

        continue;

      } else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {

        // ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

        vertices.push(
          parseFloat( result[ 1 ] ),
          parseFloat( result[ 2 ] ),
          parseFloat( result[ 3 ] )
        );

      } else if ( ( result = normal_pattern.exec( line ) ) !== null ) {

        // ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

        normals.push(
          parseFloat( result[ 1 ] ),
          parseFloat( result[ 2 ] ),
          parseFloat( result[ 3 ] )
        );

      } else if ( ( result = uv_pattern.exec( line ) ) !== null ) {

        // ["vt 0.1 0.2", "0.1", "0.2"]

        uvs.push(
          parseFloat( result[ 1 ] ),
          parseFloat( result[ 2 ] )
        );

      } else if ( ( result = face_pattern1.exec( line ) ) !== null ) {

        // ["f 1 2 3", "1", "2", "3", undefined]

        addFace(
          result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
        );

      } else if ( ( result = face_pattern2.exec( line ) ) !== null ) {

        // ["f 1/1 2/2 3/3", " 1/1", "1", "1", " 2/2", "2", "2", " 3/3", "3", "3", undefined, undefined, undefined]

        addFace(
          result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
          result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
        );

      } else if ( ( result = face_pattern3.exec( line ) ) !== null ) {

        // ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]

        addFace(
          result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ],
          result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ],
          result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ]
        );

      } else if ( ( result = face_pattern4.exec( line ) ) !== null ) {

        // ["f 1//1 2//2 3//3", " 1//1", "1", "1", " 2//2", "2", "2", " 3//3", "3", "3", undefined, undefined, undefined]

        addFace(
          result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
          undefined, undefined, undefined, undefined,
          result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
        );

      } else if ( ( result = object_pattern.exec( line ) ) !== null ) {

        // o object_name
        // or
        // g group_name

        var name = result[1].trim();

        if ( foundObjects === false ) {

          foundObjects = true;
          object.name = name;

        } else {

          addObject(name);

        }

      } else if ( /^usemtl /.test( line ) ) {

        // material

        object.material.name = line.substring( 7 ).trim();

      } else if ( /^mtllib /.test( line ) ) {

        // mtl file

      } else if ( ( result = smoothing_pattern.exec( line ) ) !== null ) {

        // smooth shading

        object.material.smooth = result[ 1 ] === "1" || result[ 1 ] === "on";

      } else {

        // console.log( "THREE.OBJLoader: Unhandled line " + line );

      }

    }

    var container = new THREE.Group();

    for ( var i = 0, l = objects.length; i < l; i ++ ) {

      object = objects[ i ];
      var geometry = object.geometry;

      var buffergeometry = new THREE.BufferGeometry();

      buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

      if ( geometry.normals.length > 0 ) {

        buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );

      } else {

        buffergeometry.computeVertexNormals();

      }

      if ( geometry.uvs.length > 0 ) {

        buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );

      }

      var material;

      if ( this.materials !== null ) {

        material = this.materials.create( object.material.name );

      }

      if ( !material ) {

        material = new THREE.MeshPhongMaterial();
        material.name = object.material.name;

      }

      material.shading = object.material.smooth ? THREE.SmoothShading : THREE.FlatShading;

      var mesh = new THREE.Mesh( buffergeometry, material );
      mesh.name = object.name;

      container.add( mesh );

    }

    console.timeEnd( 'OBJLoader' );

    return container;

  }

};

},{}],25:[function(_dereq_,module,exports){
'use strict';

module.exports = (function() {
  var perf = window && window.performance;
  if (perf && perf.now) {
    return perf.now.bind(perf);
  } else {
    return function() {
      return new Date().getTime();
    };
  }
}());

},{}],26:[function(_dereq_,module,exports){
/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/sole/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/sole/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

// performance.now polyfill
( function ( root ) {

  if ( 'performance' in root === false ) {
    root.performance = {};
  }

  // IE 8
  Date.now = ( Date.now || function () {
    return new Date().getTime();
  } );

  if ( 'now' in root.performance === false ) {
    var offset = root.performance.timing && root.performance.timing.navigationStart ? performance.timing.navigationStart
                                                                                    : Date.now();

    root.performance.now = function () {
      return Date.now() - offset;
    };
  }

} )( this );

var TWEEN = TWEEN || ( function () {

  var _tweens = [];

  return {

    REVISION: '14',

    getAll: function () {

      return _tweens;

    },

    removeAll: function () {

      _tweens = [];

    },

    add: function ( tween ) {

      _tweens.push( tween );

    },

    remove: function ( tween ) {

      var i = _tweens.indexOf( tween );

      if ( i !== -1 ) {

        _tweens.splice( i, 1 );

      }

    },

    update: function ( time ) {

      if ( _tweens.length === 0 ) return false;

      var i = 0;

      time = time !== undefined ? time : window.performance.now();

      while ( i < _tweens.length ) {

        if ( _tweens[ i ].update( time ) ) {

          i++;

        } else {

          _tweens.splice( i, 1 );

        }

      }

      return true;

    }
  };

} )();

TWEEN.Tween = function ( object ) {

  var _object = object;
  var _valuesStart = {};
  var _valuesEnd = {};
  var _valuesStartRepeat = {};
  var _duration = 1000;
  var _repeat = 0;
  var _yoyo = false;
  var _isPlaying = false;
  var _reversed = false;
  var _delayTime = 0;
  var _startTime = null;
  var _easingFunction = TWEEN.Easing.Linear.None;
  var _interpolationFunction = TWEEN.Interpolation.Linear;
  var _chainedTweens = [];
  var _onStartCallback = null;
  var _onStartCallbackFired = false;
  var _onUpdateCallback = null;
  var _onCompleteCallback = null;
  var _onStopCallback = null;

  // Set all starting values present on the target object
  for ( var field in object ) {

    _valuesStart[ field ] = parseFloat(object[field], 10);

  }

  this.to = function ( properties, duration ) {

    if ( duration !== undefined ) {

      _duration = duration;

    }

    _valuesEnd = properties;

    return this;

  };

  this.start = function ( time ) {

    TWEEN.add( this );

    _isPlaying = true;

    _onStartCallbackFired = false;

    _startTime = time !== undefined ? time : window.performance.now();
    _startTime += _delayTime;

    for ( var property in _valuesEnd ) {

      // check if an Array was provided as property value
      if ( _valuesEnd[ property ] instanceof Array ) {

        if ( _valuesEnd[ property ].length === 0 ) {

          continue;

        }

        // create a local copy of the Array with the start value at the front
        _valuesEnd[ property ] = [ _object[ property ] ].concat( _valuesEnd[ property ] );

      }

      _valuesStart[ property ] = _object[ property ];

      if( ( _valuesStart[ property ] instanceof Array ) === false ) {
        _valuesStart[ property ] *= 1.0; // Ensures we're using numbers, not strings
      }

      _valuesStartRepeat[ property ] = _valuesStart[ property ] || 0;

    }

    return this;

  };

  this.stop = function () {

    if ( !_isPlaying ) {
      return this;
    }

    TWEEN.remove( this );
    _isPlaying = false;

    if ( _onStopCallback !== null ) {

      _onStopCallback.call( _object );

    }

    this.stopChainedTweens();
    return this;

  };

  this.stopChainedTweens = function () {

    for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

      _chainedTweens[ i ].stop();

    }

  };

  this.delay = function ( amount ) {

    _delayTime = amount;
    return this;

  };

  this.repeat = function ( times ) {

    _repeat = times;
    return this;

  };

  this.yoyo = function( yoyo ) {

    _yoyo = yoyo;
    return this;

  };


  this.easing = function ( easing ) {

    _easingFunction = easing;
    return this;

  };

  this.interpolation = function ( interpolation ) {

    _interpolationFunction = interpolation;
    return this;

  };

  this.chain = function () {

    _chainedTweens = arguments;
    return this;

  };

  this.onStart = function ( callback ) {

    _onStartCallback = callback;
    return this;

  };

  this.onUpdate = function ( callback ) {

    _onUpdateCallback = callback;
    return this;

  };

  this.onComplete = function ( callback ) {

    _onCompleteCallback = callback;
    return this;

  };

  this.onStop = function ( callback ) {

    _onStopCallback = callback;
    return this;

  };

  this.update = function ( time ) {

    var property;

    if ( time < _startTime ) {

      return true;

    }

    if ( _onStartCallbackFired === false ) {

      if ( _onStartCallback !== null ) {

        _onStartCallback.call( _object );

      }

      _onStartCallbackFired = true;

    }

    var elapsed = ( time - _startTime ) / _duration;
    elapsed = elapsed > 1 ? 1 : elapsed;

    var value = _easingFunction( elapsed );

    for ( property in _valuesEnd ) {

      var start = _valuesStart[ property ] || 0;
      var end = _valuesEnd[ property ];

      if ( end instanceof Array ) {

        _object[ property ] = _interpolationFunction( end, value );

      } else {

        // Parses relative end values with start as base (e.g.: +10, -3)
        if ( typeof(end) === "string" ) {
          end = start + parseFloat(end, 10);
        }

        // protect against non numeric properties.
        if ( typeof(end) === "number" ) {
          _object[ property ] = start + ( end - start ) * value;
        }

      }

    }

    if ( _onUpdateCallback !== null ) {

      _onUpdateCallback.call( _object, value );

    }

    if ( elapsed == 1 ) {

      if ( _repeat > 0 ) {

        if( isFinite( _repeat ) ) {
          _repeat--;
        }

        // reassign starting values, restart by making startTime = now
        for( property in _valuesStartRepeat ) {

          if ( typeof( _valuesEnd[ property ] ) === "string" ) {
            _valuesStartRepeat[ property ] = _valuesStartRepeat[ property ] + parseFloat(_valuesEnd[ property ], 10);
          }

          if (_yoyo) {
            var tmp = _valuesStartRepeat[ property ];
            _valuesStartRepeat[ property ] = _valuesEnd[ property ];
            _valuesEnd[ property ] = tmp;
          }

          _valuesStart[ property ] = _valuesStartRepeat[ property ];

        }

        if (_yoyo) {
          _reversed = !_reversed;
        }

        _startTime = time + _delayTime;

        return true;

      } else {

        if ( _onCompleteCallback !== null ) {

          _onCompleteCallback.call( _object );

        }

        for ( var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++ ) {

          _chainedTweens[ i ].start( time );

        }

        return false;

      }

    }

    return true;

  };

};


TWEEN.Easing = {

  Linear: {

    None: function ( k ) {

      return k;

    }

  },

  Quadratic: {

    In: function ( k ) {

      return k * k;

    },

    Out: function ( k ) {

      return k * ( 2 - k );

    },

    InOut: function ( k ) {

      if ( ( k *= 2 ) < 1 ) return 0.5 * k * k;
      return - 0.5 * ( --k * ( k - 2 ) - 1 );

    }

  },

  Cubic: {

    In: function ( k ) {

      return k * k * k;

    },

    Out: function ( k ) {

      return --k * k * k + 1;

    },

    InOut: function ( k ) {

      if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k;
      return 0.5 * ( ( k -= 2 ) * k * k + 2 );

    }

  },

  Quartic: {

    In: function ( k ) {

      return k * k * k * k;

    },

    Out: function ( k ) {

      return 1 - ( --k * k * k * k );

    },

    InOut: function ( k ) {

      if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k;
      return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 );

    }

  },

  Quintic: {

    In: function ( k ) {

      return k * k * k * k * k;

    },

    Out: function ( k ) {

      return --k * k * k * k * k + 1;

    },

    InOut: function ( k ) {

      if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k;
      return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 );

    }

  },

  Sinusoidal: {

    In: function ( k ) {

      return 1 - Math.cos( k * Math.PI / 2 );

    },

    Out: function ( k ) {

      return Math.sin( k * Math.PI / 2 );

    },

    InOut: function ( k ) {

      return 0.5 * ( 1 - Math.cos( Math.PI * k ) );

    }

  },

  Exponential: {

    In: function ( k ) {

      return k === 0 ? 0 : Math.pow( 1024, k - 1 );

    },

    Out: function ( k ) {

      return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k );

    },

    InOut: function ( k ) {

      if ( k === 0 ) return 0;
      if ( k === 1 ) return 1;
      if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 );
      return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 );

    }

  },

  Circular: {

    In: function ( k ) {

      return 1 - Math.sqrt( 1 - k * k );

    },

    Out: function ( k ) {

      return Math.sqrt( 1 - ( --k * k ) );

    },

    InOut: function ( k ) {

      if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1);
      return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1);

    }

  },

  Elastic: {

    In: function ( k ) {

      var s, a = 0.1, p = 0.4;
      if ( k === 0 ) return 0;
      if ( k === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );

    },

    Out: function ( k ) {

      var s, a = 0.1, p = 0.4;
      if ( k === 0 ) return 0;
      if ( k === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 );

    },

    InOut: function ( k ) {

      var s, a = 0.1, p = 0.4;
      if ( k === 0 ) return 0;
      if ( k === 1 ) return 1;
      if ( !a || a < 1 ) { a = 1; s = p / 4; }
      else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI );
      if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) );
      return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1;

    }

  },

  Back: {

    In: function ( k ) {

      var s = 1.70158;
      return k * k * ( ( s + 1 ) * k - s );

    },

    Out: function ( k ) {

      var s = 1.70158;
      return --k * k * ( ( s + 1 ) * k + s ) + 1;

    },

    InOut: function ( k ) {

      var s = 1.70158 * 1.525;
      if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) );
      return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 );

    }

  },

  Bounce: {

    In: function ( k ) {

      return 1 - TWEEN.Easing.Bounce.Out( 1 - k );

    },

    Out: function ( k ) {

      if ( k < ( 1 / 2.75 ) ) {

        return 7.5625 * k * k;

      } else if ( k < ( 2 / 2.75 ) ) {

        return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75;

      } else if ( k < ( 2.5 / 2.75 ) ) {

        return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375;

      } else {

        return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375;

      }

    },

    InOut: function ( k ) {

      if ( k < 0.5 ) return TWEEN.Easing.Bounce.In( k * 2 ) * 0.5;
      return TWEEN.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5;

    }

  }

};

TWEEN.Interpolation = {

  Linear: function ( v, k ) {

    var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.Linear;

    if ( k < 0 ) return fn( v[ 0 ], v[ 1 ], f );
    if ( k > 1 ) return fn( v[ m ], v[ m - 1 ], m - f );

    return fn( v[ i ], v[ i + 1 > m ? m : i + 1 ], f - i );

  },

  Bezier: function ( v, k ) {

    var b = 0, n = v.length - 1, pw = Math.pow, bn = TWEEN.Interpolation.Utils.Bernstein, i;

    for ( i = 0; i <= n; i++ ) {
      b += pw( 1 - k, n - i ) * pw( k, i ) * v[ i ] * bn( n, i );
    }

    return b;

  },

  CatmullRom: function ( v, k ) {

    var m = v.length - 1, f = m * k, i = Math.floor( f ), fn = TWEEN.Interpolation.Utils.CatmullRom;

    if ( v[ 0 ] === v[ m ] ) {

      if ( k < 0 ) i = Math.floor( f = m * ( 1 + k ) );

      return fn( v[ ( i - 1 + m ) % m ], v[ i ], v[ ( i + 1 ) % m ], v[ ( i + 2 ) % m ], f - i );

    } else {

      if ( k < 0 ) return v[ 0 ] - ( fn( v[ 0 ], v[ 0 ], v[ 1 ], v[ 1 ], -f ) - v[ 0 ] );
      if ( k > 1 ) return v[ m ] - ( fn( v[ m ], v[ m ], v[ m - 1 ], v[ m - 1 ], f - m ) - v[ m ] );

      return fn( v[ i ? i - 1 : 0 ], v[ i ], v[ m < i + 1 ? m : i + 1 ], v[ m < i + 2 ? m : i + 2 ], f - i );

    }

  },

  Utils: {

    Linear: function ( p0, p1, t ) {

      return ( p1 - p0 ) * t + p0;

    },

    Bernstein: function ( n , i ) {

      var fc = TWEEN.Interpolation.Utils.Factorial;
      return fc( n ) / fc( i ) / fc( n - i );

    },

    Factorial: ( function () {

      var a = [ 1 ];

      return function ( n ) {

        var s = 1, i;
        if ( a[ n ] ) return a[ n ];
        for ( i = n; i > 1; i-- ) s *= i;
        return a[ n ] = s;

      };

    } )(),

    CatmullRom: function ( p0, p1, p2, p3, t ) {

      var v0 = ( p2 - p0 ) * 0.5, v1 = ( p3 - p1 ) * 0.5, t2 = t * t, t3 = t * t2;
      return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    }

  }

};

// UMD (Universal Module Definition)
( function ( root ) {

  if ( typeof define === 'function' && define.amd ) {

    // AMD
    define( [], function () {
      return TWEEN;
    } );

  } else if ( typeof exports === 'object' ) {

    // Node.js
    module.exports = TWEEN;

  } else {

    // Global variable
    root.TWEEN = TWEEN;

  }

} )( this );

},{}],27:[function(_dereq_,module,exports){
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The base class for all VR devices.
 */
function VRDevice() {
  this.hardwareUnitId = 'webvr-polyfill hardwareUnitId';
  this.deviceId = 'webvr-polyfill deviceId';
  this.deviceName = 'webvr-polyfill deviceName';
}

/**
 * The base class for all VR HMD devices.
 */
function HMDVRDevice() {
}
HMDVRDevice.prototype = new VRDevice();

/**
 * The base class for all VR position sensor devices.
 */
function PositionSensorVRDevice() {
}
PositionSensorVRDevice.prototype = new VRDevice();

module.exports.VRDevice = VRDevice;
module.exports.HMDVRDevice = HMDVRDevice;
module.exports.PositionSensorVRDevice = PositionSensorVRDevice;

},{}],2:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;

// Constants from vrtoolkit: https://github.com/googlesamples/cardboard-java.
var INTERPUPILLARY_DISTANCE = 0.06;
var DEFAULT_MAX_FOV_LEFT_RIGHT = 40;
var DEFAULT_MAX_FOV_BOTTOM = 40;
var DEFAULT_MAX_FOV_TOP = 40;

/**
 * The HMD itself, providing rendering parameters.
 */
function CardboardHMDVRDevice() {
  // From com/google/vrtoolkit/cardboard/FieldOfView.java.
  this.fov = {
    upDegrees: DEFAULT_MAX_FOV_TOP,
    downDegrees: DEFAULT_MAX_FOV_BOTTOM,
    leftDegrees: DEFAULT_MAX_FOV_LEFT_RIGHT,
    rightDegrees: DEFAULT_MAX_FOV_LEFT_RIGHT
  };
  // Set display constants.
  this.eyeTranslationLeft = {
    x: INTERPUPILLARY_DISTANCE * -0.5,
    y: 0,
    z: 0
  };
  this.eyeTranslationRight = {
    x: INTERPUPILLARY_DISTANCE * 0.5,
    y: 0,
    z: 0
  };
}
CardboardHMDVRDevice.prototype = new HMDVRDevice();

CardboardHMDVRDevice.prototype.getEyeParameters = function(whichEye) {
  var eyeTranslation;
  if (whichEye == 'left') {
    eyeTranslation = this.eyeTranslationLeft;
  } else if (whichEye == 'right') {
    eyeTranslation = this.eyeTranslationRight;
  } else {
    console.error('Invalid eye provided: %s', whichEye);
    return null;
  }
  return {
    recommendedFieldOfView: this.fov,
    eyeTranslation: eyeTranslation
  };
};

module.exports = CardboardHMDVRDevice;

},{"./base.js":1}],3:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO: Fix up all "new THREE" instantiations to improve performance.
 */
var SensorSample = _dereq_('./sensor-sample.js');
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

var DEBUG = false;

/**
 * An implementation of a simple complementary filter, which fuses gyroscope and
 * accelerometer data from the 'devicemotion' event.
 *
 * Accelerometer data is very noisy, but stable over the long term.
 * Gyroscope data is smooth, but tends to drift over the long term.
 *
 * This fusion is relatively simple:
 * 1. Get orientation estimates from accelerometer by applying a low-pass filter
 *    on that data.
 * 2. Get orientation estimates from gyroscope by integrating over time.
 * 3. Combine the two estimates, weighing (1) in the long term, but (2) for the
 *    short term.
 */
function ComplementaryFilter(kFilter) {
  this.kFilter = kFilter;

  // Raw sensor measurements.
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();

  // Current filter orientation
  this.filterQ = new THREE.Quaternion();
  this.previousFilterQ = new THREE.Quaternion();

  // Orientation based on the accelerometer.
  this.accelQ = new THREE.Quaternion();
  // Whether or not the orientation has been initialized.
  this.isOrientationInitialized = false;
  // Running estimate of gravity based on the current orientation.
  this.estimatedGravity = new THREE.Vector3();
  // Measured gravity based on accelerometer.
  this.measuredGravity = new THREE.Vector3();

  // Debug only quaternion of gyro-based orientation.
  this.gyroIntegralQ = new THREE.Quaternion();
}

ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};

ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);

  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (Util.isTimestampDeltaValid(deltaT)) {
    this.run_();
  }

  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};

ComplementaryFilter.prototype.run_ = function() {

  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }

  var deltaT = this.currentGyroMeasurement.timestampS -
      this.previousGyroMeasurement.timestampS;

  // Convert gyro rotation vector to a quaternion delta.
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);

  // filter_1 = K * (filter_0 + gyro * dT) + (1 - K) * accel.
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);

  // Calculate the delta between the current estimated gravity and the real
  // gravity vector from accelerometer.
  var invFilterQ = new THREE.Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();

  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();

  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();

  // Compare estimated gravity with measured gravity, get the delta quaternion
  // between the two.
  var deltaQ = new THREE.Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();

  if (DEBUG) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)',
                THREE.Math.radToDeg(Util.getQuaternionAngle(deltaQ)),
                (this.estimatedGravity.x).toFixed(1),
                (this.estimatedGravity.y).toFixed(1),
                (this.estimatedGravity.z).toFixed(1),
                (this.measuredGravity.x).toFixed(1),
                (this.measuredGravity.y).toFixed(1),
                (this.measuredGravity.z).toFixed(1));
  }

  // Calculate the SLERP target: current orientation plus the measured-estimated
  // quaternion delta.
  var targetQ = new THREE.Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);

  // SLERP factor: 0 is pure gyro, 1 is pure accel.
  this.filterQ.slerp(targetQ, 1 - this.kFilter);

  this.previousFilterQ.copy(this.filterQ);
};

ComplementaryFilter.prototype.getOrientation = function() {
  return this.filterQ;
};

ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
  var normAccel = new THREE.Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new THREE.Quaternion();
  quat.setFromUnitVectors(new THREE.Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};

ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
  // Extract axis and angle from the gyroscope data.
  var quat = new THREE.Quaternion();
  var axis = new THREE.Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};


module.exports = ComplementaryFilter;

},{"./sensor-sample.js":8,"./three-math.js":9,"./util.js":11}],4:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;

var ComplementaryFilter = _dereq_('./complementary-filter.js');
var PosePredictor = _dereq_('./pose-predictor.js');
var TouchPanner = _dereq_('./touch-panner.js');
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

/**
 * The positional sensor, implemented using DeviceMotion APIs.
 */
function FusionPositionSensorVRDevice() {
  this.deviceId = 'webvr-polyfill:fused';
  this.deviceName = 'VR Position Device (webvr-polyfill:fused)';

  this.accelerometer = new THREE.Vector3();
  this.gyroscope = new THREE.Vector3();

  window.addEventListener('devicemotion', this.onDeviceMotionChange_.bind(this));
  window.addEventListener('orientationchange', this.onScreenOrientationChange_.bind(this));

  this.filter = new ComplementaryFilter(WebVRConfig.K_FILTER || 0.98);
  this.posePredictor = new PosePredictor(WebVRConfig.PREDICTION_TIME_S || 0.040);
  this.touchPanner = new TouchPanner();

  this.filterToWorldQ = new THREE.Quaternion();

  // Set the filter to world transform, depending on OS.
  if (Util.isIOS()) {
    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI/2);
  } else {
    this.filterToWorldQ.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2);
  }

  this.worldToScreenQ = new THREE.Quaternion();
  this.setScreenTransform_();

  // Keep track of a reset transform for resetSensor.
  this.resetQ = new THREE.Quaternion();

  this.isFirefoxAndroid = Util.isFirefoxAndroid();
  this.isIOS = Util.isIOS();
}
FusionPositionSensorVRDevice.prototype = new PositionSensorVRDevice();

/**
 * Returns {orientation: {x,y,z,w}, position: null}.
 * Position is not supported since we can't do 6DOF.
 */
FusionPositionSensorVRDevice.prototype.getState = function() {
  return {
    hasOrientation: true,
    orientation: this.getOrientation(),
    hasPosition: false,
    position: null
  }
};

FusionPositionSensorVRDevice.prototype.getOrientation = function() {
  // Convert from filter space to the the same system used by the
  // deviceorientation event.
  var orientation = this.filter.getOrientation();

  // Predict orientation.
  this.predictedQ = this.posePredictor.getPrediction(orientation, this.gyroscope, this.previousTimestampS);

  // Convert to THREE coordinate system: -Z forward, Y up, X right.
  var out = new THREE.Quaternion();
  out.copy(this.filterToWorldQ);
  out.multiply(this.resetQ);
  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
    out.multiply(this.touchPanner.getOrientation());
  }
  out.multiply(this.predictedQ);
  out.multiply(this.worldToScreenQ);

  // Handle the yaw-only case.
  if (WebVRConfig.YAW_ONLY) {
    // Make a quaternion that only turns around the Y-axis.
    out.x = 0;
    out.z = 0;
    out.normalize();
  }
  return out;
};

FusionPositionSensorVRDevice.prototype.resetSensor = function() {
  var euler = new THREE.Euler();
  euler.setFromQuaternion(this.filter.getOrientation());
  var yaw = euler.y;
  console.log('resetSensor with yaw: %f', yaw);
  this.resetQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -yaw);
  if (!WebVRConfig.TOUCH_PANNER_DISABLED) {
    this.touchPanner.resetSensor();
  }
};

FusionPositionSensorVRDevice.prototype.onDeviceMotionChange_ = function(deviceMotion) {
  var accGravity = deviceMotion.accelerationIncludingGravity;
  var rotRate = deviceMotion.rotationRate;
  var timestampS = deviceMotion.timeStamp / 1000;

  // Firefox Android timeStamp returns one thousandth of a millisecond.
  if (this.isFirefoxAndroid) {
    timestampS /= 1000;
  }

  var deltaS = timestampS - this.previousTimestampS;
  if (deltaS <= Util.MIN_TIMESTEP || deltaS > Util.MAX_TIMESTEP) {
    console.warn('Invalid timestamps detected. Time step between successive ' +
                 'gyroscope sensor samples is very small or not monotonic');
    this.previousTimestampS = timestampS;
    return;
  }
  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
  this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);

  // With iOS and Firefox Android, rotationRate is reported in degrees,
  // so we first convert to radians.
  if (this.isIOS || this.isFirefoxAndroid) {
    this.gyroscope.multiplyScalar(Math.PI / 180);
  }

  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
  this.filter.addGyroMeasurement(this.gyroscope, timestampS);

  this.previousTimestampS = timestampS;
};

FusionPositionSensorVRDevice.prototype.onScreenOrientationChange_ =
    function(screenOrientation) {
  this.setScreenTransform_();
};

FusionPositionSensorVRDevice.prototype.setScreenTransform_ = function() {
  this.worldToScreenQ.set(0, 0, 0, 1);
  switch (window.orientation) {
    case 0:
      break;
    case 90:
      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI/2);
      break;
    case -90:
      this.worldToScreenQ.setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI/2);
      break;
    case 180:
      // TODO.
      break;
  }
};


module.exports = FusionPositionSensorVRDevice;

},{"./base.js":1,"./complementary-filter.js":3,"./pose-predictor.js":7,"./three-math.js":9,"./touch-panner.js":10,"./util.js":11}],5:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var WebVRPolyfill = _dereq_('./webvr-polyfill.js');

// Initialize a WebVRConfig just in case.
window.WebVRConfig = window.WebVRConfig || {};
new WebVRPolyfill();

},{"./webvr-polyfill.js":12}],6:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

// How much to rotate per key stroke.
var KEY_SPEED = 0.15;
var KEY_ANIMATION_DURATION = 80;

// How much to rotate for mouse events.
var MOUSE_SPEED_X = 0.5;
var MOUSE_SPEED_Y = 0.3;

/**
 * A virtual position sensor, implemented using keyboard and
 * mouse APIs. This is designed as for desktops/laptops where no Device*
 * events work.
 */
function MouseKeyboardPositionSensorVRDevice() {
  this.deviceId = 'webvr-polyfill:mouse-keyboard';
  this.deviceName = 'VR Position Device (webvr-polyfill:mouse-keyboard)';

  // Attach to mouse and keyboard events.
  window.addEventListener('keydown', this.onKeyDown_.bind(this));
  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
  window.addEventListener('mousedown', this.onMouseDown_.bind(this));
  window.addEventListener('mouseup', this.onMouseUp_.bind(this));

  this.phi = 0;
  this.theta = 0;

  // Variables for keyboard-based rotation animation.
  this.targetAngle = null;

  // State variables for calculations.
  this.euler = new THREE.Euler();
  this.orientation = new THREE.Quaternion();

  // Variables for mouse-based rotation.
  this.rotateStart = new THREE.Vector2();
  this.rotateEnd = new THREE.Vector2();
  this.rotateDelta = new THREE.Vector2();
}
MouseKeyboardPositionSensorVRDevice.prototype = new PositionSensorVRDevice();

/**
 * Returns {orientation: {x,y,z,w}, position: null}.
 * Position is not supported for parity with other PositionSensors.
 */
MouseKeyboardPositionSensorVRDevice.prototype.getState = function() {
  this.euler.set(this.phi, this.theta, 0, 'YXZ');
  this.orientation.setFromEuler(this.euler);

  return {
    hasOrientation: true,
    orientation: this.orientation,
    hasPosition: false,
    position: null
  }
};

MouseKeyboardPositionSensorVRDevice.prototype.onKeyDown_ = function(e) {
  // Track WASD and arrow keys.
  if (e.keyCode == 38) { // Up key.
    this.animatePhi_(this.phi + KEY_SPEED);
  } else if (e.keyCode == 39) { // Right key.
    this.animateTheta_(this.theta - KEY_SPEED);
  } else if (e.keyCode == 40) { // Down key.
    this.animatePhi_(this.phi - KEY_SPEED);
  } else if (e.keyCode == 37) { // Left key.
    this.animateTheta_(this.theta + KEY_SPEED);
  }
};

MouseKeyboardPositionSensorVRDevice.prototype.animateTheta_ = function(targetAngle) {
  this.animateKeyTransitions_('theta', targetAngle);
};

MouseKeyboardPositionSensorVRDevice.prototype.animatePhi_ = function(targetAngle) {
  // Prevent looking too far up or down.
  targetAngle = Util.clamp(targetAngle, -Math.PI/2, Math.PI/2);
  this.animateKeyTransitions_('phi', targetAngle);
};

/**
 * Start an animation to transition an angle from one value to another.
 */
MouseKeyboardPositionSensorVRDevice.prototype.animateKeyTransitions_ = function(angleName, targetAngle) {
  // If an animation is currently running, cancel it.
  if (this.angleAnimation) {
    clearInterval(this.angleAnimation);
  }
  var startAngle = this[angleName];
  var startTime = new Date();
  // Set up an interval timer to perform the animation.
  this.angleAnimation = setInterval(function() {
    // Once we're finished the animation, we're done.
    var elapsed = new Date() - startTime;
    if (elapsed >= KEY_ANIMATION_DURATION) {
      this[angleName] = targetAngle;
      clearInterval(this.angleAnimation);
      return;
    }
    // Linearly interpolate the angle some amount.
    var percent = elapsed / KEY_ANIMATION_DURATION;
    this[angleName] = startAngle + (targetAngle - startAngle) * percent;
  }.bind(this), 1000/60);
};

MouseKeyboardPositionSensorVRDevice.prototype.onMouseDown_ = function(e) {
  this.rotateStart.set(e.clientX, e.clientY);
  this.isDragging = true;
};

// Very similar to https://gist.github.com/mrflix/8351020
MouseKeyboardPositionSensorVRDevice.prototype.onMouseMove_ = function(e) {
  if (!this.isDragging && !this.isPointerLocked_()) {
    return;
  }
  // Support pointer lock API.
  if (this.isPointerLocked_()) {
    var movementX = e.movementX || e.mozMovementX || 0;
    var movementY = e.movementY || e.mozMovementY || 0;
    this.rotateEnd.set(this.rotateStart.x - movementX, this.rotateStart.y - movementY);
  } else {
    this.rotateEnd.set(e.clientX, e.clientY);
  }
  // Calculate how much we moved in mouse space.
  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
  this.rotateStart.copy(this.rotateEnd);

  // Keep track of the cumulative euler angles.
  var element = document.body;
  this.phi += 2 * Math.PI * this.rotateDelta.y / element.clientHeight * MOUSE_SPEED_Y;
  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * MOUSE_SPEED_X;

  // Prevent looking too far up or down.
  this.phi = Util.clamp(this.phi, -Math.PI/2, Math.PI/2);
};

MouseKeyboardPositionSensorVRDevice.prototype.onMouseUp_ = function(e) {
  this.isDragging = false;
};

MouseKeyboardPositionSensorVRDevice.prototype.isPointerLocked_ = function() {
  var el = document.pointerLockElement || document.mozPointerLockElement ||
      document.webkitPointerLockElement;
  return el !== undefined;
};

MouseKeyboardPositionSensorVRDevice.prototype.resetSensor = function() {
  console.error('Not implemented yet.');
};

module.exports = MouseKeyboardPositionSensorVRDevice;

},{"./base.js":1,"./three-math.js":9,"./util.js":11}],7:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var THREE = _dereq_('./three-math.js');

var DEBUG = false;

/**
 * Given an orientation and the gyroscope data, predicts the future orientation
 * of the head. This makes rendering appear faster.
 *
 * Also see: http://msl.cs.uiuc.edu/~lavalle/papers/LavYerKatAnt14.pdf
 *
 * @param {Number} predictionTimeS time from head movement to the appearance of
 * the corresponding image.
 */
function PosePredictor(predictionTimeS) {
  this.predictionTimeS = predictionTimeS;

  // The quaternion corresponding to the previous state.
  this.previousQ = new THREE.Quaternion();
  // Previous time a prediction occurred.
  this.previousTimestampS = null;

  // The delta quaternion that adjusts the current pose.
  this.deltaQ = new THREE.Quaternion();
  // The output quaternion.
  this.outQ = new THREE.Quaternion();
}

PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }

  // Calculate axis and angle based on gyroscope rotation rate data.
  var axis = new THREE.Vector3();
  axis.copy(gyro);
  axis.normalize();

  var angularSpeed = gyro.length();

  // If we're rotating slowly, don't do prediction.
  if (angularSpeed < THREE.Math.degToRad(20)) {
    if (DEBUG) {
      console.log('Moving slowly, at %s deg/s: no prediction',
                  THREE.Math.radToDeg(angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }

  // Get the predicted angle based on the time delta and latency.
  var deltaT = timestampS - this.previousTimestampS;
  var predictAngle = angularSpeed * this.predictionTimeS;

  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);

  this.previousQ.copy(currentQ);

  return this.outQ;
};


module.exports = PosePredictor;

},{"./three-math.js":9}],8:[function(_dereq_,module,exports){
function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
};

SensorSample.prototype.set = function(sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};

SensorSample.prototype.copy = function(sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};

module.exports = SensorSample;

},{}],9:[function(_dereq_,module,exports){
/*
 * A subset of THREE.js, providing mostly quaternion and euler-related
 * operations, manually lifted from
 * https://github.com/mrdoob/three.js/tree/master/src/math, as of 9c30286b38df039fca389989ff06ea1c15d6bad1
 */

// Only use if the real THREE is not provided.
var THREE = window.THREE || {};

// If some piece of THREE is missing, fill it in here.
if (!THREE.Quaternion || !THREE.Vector3 || !THREE.Vector2 || !THREE.Euler || !THREE.Math) {
console.log('No THREE.js found.');


/*** START Quaternion ***/

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  _x: 0,_y: 0, _z: 0, _w: 0,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    if ( euler.order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    }

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Quaternion( this._x, this._y, this._z, this._w );

  }

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

  return qm.copy( qa ).slerp( qb, t );

}

/*** END Quaternion ***/
/*** START Vector2 ***/
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.x *= s;
    this.y *= s;

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    return this;
  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

      if ( offset === undefined ) offset = 0;

      index = index * attribute.itemSize + offset;

      this.x = attribute.array[ index ];
      this.y = attribute.array[ index + 1 ];

      return this;

  },

  clone: function () {

    return new THREE.Vector2( this.x, this.y );

  }

};
/*** END Vector2 ***/
/*** START Vector3 ***/

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function ( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function ( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength  ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function ( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function ( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function ( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( this.length() * v.length() );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function ( m, order ) {

    console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  },

  setEulerFromQuaternion: function ( q, order ) {

    console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  },

  getPositionFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

    return this.setFromMatrixPosition( m );

  },

  getScaleFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

    return this.setFromMatrixScale( m );
  },

  getColumnFromMatrix: function ( index, matrix ) {

    console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

    return this.setFromMatrixColumn( index, matrix );

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;
  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

      if ( offset === undefined ) offset = 0;

      index = index * attribute.itemSize + offset;

      this.x = attribute.array[ index ];
      this.y = attribute.array[ index + 1 ];
      this.z = attribute.array[ index + 2 ];

      return this;

  },

  clone: function () {

    return new THREE.Vector3( this.x, this.y, this.z );

  }

};
/*** END Vector3 ***/
/*** START Euler ***/
/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order, update ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function () {

    var matrix;

    return function ( q, order, update ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion( q );
      this.setFromRotationMatrix( matrix, order, update );

      return this;

    };

  }(),

  setFromVector3: function ( v, order ) {

    return this.set( v.x, v.y, v.z, order || this._order );

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };

  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function () {

    return [ this._x, this._y, this._z, this._order ];

  },

  toVector3: function ( optionalResult ) {

    if ( optionalResult ) {

      return optionalResult.set( this._x, this._y, this._z );

    } else {

      return new THREE.Vector3( this._x, this._y, this._z );

    }

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Euler( this._x, this._y, this._z, this._order );

  }

};
/*** END Euler ***/
/*** START Math ***/
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

          uuid[ i ] = '-';

        } else if ( i == 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }
      }

      return uuid.join( '' );

    };

  }(),

  // Clamp value to range <a, b>

  clamp: function ( x, a, b ) {

    return ( x < a ) ? a : ( ( x > b ) ? b : x );

  },

  // Clamp value to range <a, inf)

  clampBottom: function ( x, a ) {

    return x < a ? a : x;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  // Random float from <0, 1> with 16 bits of randomness
  // (standard Math.random() creates repetitive patterns when applied over larger space)

  random16: function () {

    return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return Math.floor( this.randFloat( low, high ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  },

  nextPowerOfTwo: function ( value ) {

    value --;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value ++;

    return value;
  }

};

/*** END Math ***/

}

module.exports = THREE;

},{}],10:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var THREE = _dereq_('./three-math.js');
var Util = _dereq_('./util.js');

var ROTATE_SPEED = 0.5;
/**
 * Provides a quaternion responsible for pre-panning the scene before further
 * transformations due to device sensors.
 */
function TouchPanner() {
  window.addEventListener('touchstart', this.onTouchStart_.bind(this));
  window.addEventListener('touchmove', this.onTouchMove_.bind(this));
  window.addEventListener('touchend', this.onTouchEnd_.bind(this));

  this.isTouching = false;
  this.rotateStart = new THREE.Vector2();
  this.rotateEnd = new THREE.Vector2();
  this.rotateDelta = new THREE.Vector2();

  this.theta = 0;
  this.orientation = new THREE.Quaternion();
}

TouchPanner.prototype.getOrientation = function() {
  this.orientation.setFromEuler(new THREE.Euler(0, 0, this.theta));
  return this.orientation;
};

TouchPanner.prototype.resetSensor = function() {
  this.theta = 0;
};

TouchPanner.prototype.onTouchStart_ = function(e) {
  // Only respond if there is exactly one touch.
  if (e.touches.length != 1) {
    return;
  }
  this.rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);
  this.isTouching = true;
};

TouchPanner.prototype.onTouchMove_ = function(e) {
  if (!this.isTouching) {
    return;
  }
  this.rotateEnd.set(e.touches[0].pageX, e.touches[0].pageY);
  this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
  this.rotateStart.copy(this.rotateEnd);

  // On iOS, direction is inverted.
  if (Util.isIOS()) {
    this.rotateDelta.x *= -1;
  }

  var element = document.body;
  this.theta += 2 * Math.PI * this.rotateDelta.x / element.clientWidth * ROTATE_SPEED;
};

TouchPanner.prototype.onTouchEnd_ = function(e) {
  this.isTouching = false;
};

module.exports = TouchPanner;

},{"./three-math.js":9,"./util.js":11}],11:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Util = window.Util || {};

Util.MIN_TIMESTEP = 0.001;
Util.MAX_TIMESTEP = 1;

Util.clamp = function(value, min, max) {
  return Math.min(Math.max(min, value), max);
};

Util.isIOS = function() {
  return /iPad|iPhone|iPod/.test(navigator.platform);
};

Util.isFirefoxAndroid = function() {
  return navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
}

// Helper method to validate the time steps of sensor timestamps.
Util.isTimestampDeltaValid = function(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= Util.MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > Util.MAX_TIMESTEP) {
    return false;
  }
  return true;
}

module.exports = Util;

},{}],12:[function(_dereq_,module,exports){
/*
 * Copyright 2015 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CardboardHMDVRDevice = _dereq_('./cardboard-hmd-vr-device.js');
//var OrientationPositionSensorVRDevice = require('./orientation-position-sensor-vr-device.js');
var FusionPositionSensorVRDevice = _dereq_('./fusion-position-sensor-vr-device.js');
var MouseKeyboardPositionSensorVRDevice = _dereq_('./mouse-keyboard-position-sensor-vr-device.js');
// Uncomment to add positional tracking via webcam.
//var WebcamPositionSensorVRDevice = require('./webcam-position-sensor-vr-device.js');
var HMDVRDevice = _dereq_('./base.js').HMDVRDevice;
var PositionSensorVRDevice = _dereq_('./base.js').PositionSensorVRDevice;

function WebVRPolyfill() {
  this.devices = [];

  if (!this.isWebVRAvailable()) {
    this.enablePolyfill();
  }
}

WebVRPolyfill.prototype.isWebVRAvailable = function() {
  return ('getVRDevices' in navigator) || ('mozGetVRDevices' in navigator);
};


WebVRPolyfill.prototype.enablePolyfill = function() {
  // Initialize our virtual VR devices.
  if (this.isCardboardCompatible()) {
    this.devices.push(new CardboardHMDVRDevice());
  }

  // Polyfill using the right position sensor.
  if (this.isMobile()) {
    //this.devices.push(new OrientationPositionSensorVRDevice());
    this.devices.push(new FusionPositionSensorVRDevice());
  } else {
    if (!WebVRConfig.MOUSE_KEYBOARD_CONTROLS_DISABLED) {
      this.devices.push(new MouseKeyboardPositionSensorVRDevice());
    }
    // Uncomment to add positional tracking via webcam.
    //this.devices.push(new WebcamPositionSensorVRDevice());
  }

  // Provide navigator.getVRDevices.
  navigator.getVRDevices = this.getVRDevices.bind(this);

  // Provide the CardboardHMDVRDevice and PositionSensorVRDevice objects.
  window.HMDVRDevice = HMDVRDevice;
  window.PositionSensorVRDevice = PositionSensorVRDevice;
};

WebVRPolyfill.prototype.getVRDevices = function() {
  var devices = this.devices;
  return new Promise(function(resolve, reject) {
    try {
      resolve(devices);
    } catch (e) {
      reject(e);
    }
  });
};

/**
 * Determine if a device is mobile.
 */
WebVRPolyfill.prototype.isMobile = function() {
  return /Android/i.test(navigator.userAgent) ||
      /iPhone|iPad|iPod/i.test(navigator.userAgent);
};

WebVRPolyfill.prototype.isCardboardCompatible = function() {
  // For now, support all iOS and Android devices.
  // Also enable the WebVRConfig.FORCE_VR flag for debugging.
  return this.isMobile() || WebVRConfig.FORCE_ENABLE_VR;
};

module.exports = WebVRPolyfill;

},{"./base.js":1,"./cardboard-hmd-vr-device.js":2,"./fusion-position-sensor-vr-device.js":4,"./mouse-keyboard-position-sensor-vr-device.js":6}]},{},[5]);

},{}],28:[function(_dereq_,module,exports){
module.exports={
  "name": "aframe",
  "version": "0.1.1",
  "description": "Building blocks for the VR Web",
  "main": "src/index.js",
  "scripts": {
    "browserify": "browserify src/index.js -s 'AFRAME' -p browserify-derequire",
    "build": "mkdirp build/ && npm run browserify -- --debug -o build/aframe.js",
    "dev": "npm run build && node ./scripts/budo",
    "dist": "mkdirp dist/ && npm run browserify -s -- --debug | exorcist dist/aframe.js.map > dist/aframe.js && uglifyjs dist/aframe.js -c warnings=false -m -o dist/aframe.min.js",
    "gh-pages": "npm run ghpages",
    "ghpages": "node ./scripts/gh-pages",
    "lint": "semistandard -v $(git ls-files '*.js') | standard-reporter --stylish",
    "precommit": "npm run lint",
    "preghpages": "npm run dist && rimraf gh-pages && mkdirp gh-pages && cp -r {.nojekyll,dist,lib,examples,index.html,style} gh-pages/. 2>/dev/null || : && git checkout dist/ && replace 'build/aframe.js' 'dist/aframe.min.js' gh-pages/ -r --silent",
    "release:bump": "npm run dist && git commit -am 'bump dist' && npm version patch --preminor",
    "release:push": "npm login && npm publish && git push --follow-tags",
    "start": "npm run dev",
    "test": "karma start ./tests/karma.conf.js",
    "test:ci": "TEST_ENV=ci karma start ./tests/karma.conf.js --single-run",
    "version": "npm run dist"
  },
  "repository": "aframevr/aframe",
  "license": "MIT",
  "dependencies": {
    "browserify-css": "^0.8.2",
    "debug": "^2.2.0",
    "document-register-element": "^0.5.2",
    "es6-promise": "^3.0.2",
    "object-assign": "^4.0.1",
    "present": "0.0.6",
    "request-interval": "^1.0.0",
    "style-attr": "^1.0.1",
    "three-dev": "^0.74.0-beta8",
    "tween.js": "^15.0.0",
    "webvr-polyfill": "borismus/webvr-polyfill#3f47796"
  },
  "devDependencies": {
    "browserify": "^11.0.1",
    "browserify-css": "^0.8.2",
    "browserify-derequire": "^0.9.4",
    "budo": "^7.0.2",
    "chai-shallow-deep-equal": "^1.3.0",
    "copyfiles": "0.2.1",
    "exorcist": "^0.4.0",
    "gh-pages": "^0.6.0",
    "html-minifier": "^0.8.0",
    "husky": "^0.10.1",
    "karma": "^0.13.15",
    "karma-browserify": "^4.4.0",
    "karma-chai-shallow-deep-equal": "0.0.4",
    "karma-env-preprocessor": "^0.1.1",
    "karma-firefox-launcher": "^0.1.6",
    "karma-mocha": "^0.2.0",
    "karma-mocha-reporter": "^1.1.0",
    "karma-sinon-chai": "^1.1.0",
    "mkdirp": "0.5.1",
    "mocha": "^2.3.3",
    "mozilla-download": "^1.0.5",
    "ncp": "2.0.0",
    "open": "0.0.5",
    "polymerize": "^1.0.0",
    "replace": "^0.3.0",
    "rimraf": "2.5.0",
    "semistandard": "^7.0.2",
    "standard-reporter": "^1.0.5",
    "uglifyjs": "^2.4.10"
  },
  "link": true,
  "browserify": {
    "transform": [
      "browserify-css",
      [
        "polymerize",
        {
          "match": ".*.html$"
        }
      ]
    ]
  },
  "semistandard": {
    "ignore": [
      "build/**",
      "dist/**",
      "examples/_js/**",
      "lib/vendor/**"
    ]
  },
  "keywords": [
    "aframe",
    "vr",
    "webvr",
    "3d",
    "three",
    "components",
    "elements"
  ],
  "browserify-css": {
    "minify": true
  },
  "engines": {
    "node": ">= 0.12.7",
    "npm": ">= 2.12.1"
  }
}

},{}],29:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

module.exports.Component = registerComponent('camera', {
  schema: {
    active: { default: true },
    far: { default: 10000 },
    fov: { default: 80, min: 0 },
    near: { default: 0.5, min: 0 }
  },

  /**
   * Initializes three.js camera, adding it to the entity.
   * Adds a reference from the scene to this entity as the camera.
   */
  init: function () {
    var camera = this.camera = new THREE.PerspectiveCamera();
    var el = this.el;
    el.setObject3D('camera', camera);
  },

  /**
   * Remove camera on remove (callback).
   */
  remove: function () {
    this.el.setObject3D('camera');
  },

  /**
   * Updates three.js camera.
   */
  update: function (oldData) {
    var el = this.el;
    var sceneEl = el.sceneEl;
    var data = this.data;
    var camera = this.camera;
    camera.aspect = data.aspect || (window.innerWidth / window.innerHeight);
    camera.far = data.far;
    camera.fov = data.fov;
    camera.near = data.near;
    camera.updateProjectionMatrix();
    // If the active property has changes or on first update call
    if (!oldData || oldData.active !== data.active) {
      if (data.active) {
        sceneEl.setActiveCamera(camera);
      } else if (sceneEl.camera === camera) {
        // If the camera is disabled and is the current active one
        sceneEl.setActiveCamera();
      }
    }
  }
});

},{"../../lib/three":1,"../core/component":55}],30:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;
var utils = _dereq_('../utils/');

module.exports.Component = registerComponent('cursor', {
  schema: {
    timeout: { default: 1500, min: 0 },
    maxDistance: { default: 5, min: 0 },
    fuse: { default: false }
  },

  dependencies: [ 'raycaster' ],

  init: function () {
    this.raycaster = this.el.components.raycaster;
    // The cursor defaults to fuse in mobile environments
    this.schema.fuse.default = utils.isMobile();
    this.attachEventListeners();
  },

  attachEventListeners: function () {
    var el = this.el;
    var canvas = el.sceneEl.canvas;

    canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
    canvas.addEventListener('mouseup', this.onMouseUp.bind(this));

    el.addEventListener('intersection', this.onIntersection.bind(this));
    el.addEventListener('intersectioncleared', this.onIntersectionCleared.bind(this));
  },

  onMouseDown: function (evt) {
    this.emit('mousedown');
    this.mouseDownEl = this.intersectedEl;
  },

  onMouseUp: function () {
    this.emit('mouseup');
    if (this.data.fuse) { return; }
    if (!this.intersectedEl) { return; }
    if (this.mouseDownEl === this.intersectedEl) {
      this.emit('click');
    }
  },

  emit: function (evt) {
    var intersectedEl = this.intersectedEl;
    this.el.emit(evt);
    if (intersectedEl) { intersectedEl.emit(evt); }
  },

  emitter: function (evt) {
    return function () {
      this.emit(evt);
    }.bind(this);
  },

  onIntersection: function (evt) {
    var self = this;
    var data = this.data;
    var el = evt.detail.el;
    var distance = evt.detail.distance;
    if (this.intersectedEl === el) { return; }
    if (distance >= this.data.maxDistance) { return; }
    this.intersectedEl = el;
    el.addState('hovered');
    el.emit('mouseenter');
    this.el.addState('hovering');
    if (data.timeout === 0) { return; }
    if (!data.fuse) { return; }
    this.el.addState('fusing');
    this.fuseTimeout = setTimeout(fuse, data.timeout);
    function fuse () {
      self.el.removeState('fusing');
      self.emit('click');
    }
  },

  onIntersectionCleared: function (evt) {
    var el = evt.detail.el;
    if (!el || !this.intersectedEl) { return; }
    this.intersectedEl = null;
    el.removeState('hovered');
    el.emit('mouseleave');
    this.el.removeState('hovering');
    this.el.removeState('fusing');
    clearTimeout(this.fuseTimeout);
  }
});

},{"../core/component":55,"../utils/":90}],31:[function(_dereq_,module,exports){
var register = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');
var debug = _dereq_('../utils/debug');

var warn = debug('components:fog:warn');

/**
 * Fog component.
 * Applies only to the scene entity.
 */
module.exports.Component = register('fog', {
  schema: {
    color: { default: '#000' },
    density: { default: 0.00025 },
    far: { default: 1000, min: 0 },
    near: { default: 1, min: 0 },
    type: { default: 'linear', oneOf: ['linear', 'exponential'] }
  },

  update: function () {
    var data = this.data;
    var el = this.el;
    var fog = this.el.object3D.fog;

    if (!el.isScene) {
      warn('Fog component can only be applied to <a-scene>');
      return;
    }

    // (Re)create fog if fog doesn't exist or fog type changed.
    if (!fog || data.type !== fog.name) {
      el.object3D.fog = getFog(data);
      el.updateMaterials();
      return;
    }

    // Fog data changed. Update fog.
    Object.keys(this.schema).forEach(function (key) {
      var value = data[key];
      if (key === 'color') { value = new THREE.Color(value); }
      fog[key] = value;
    });
  },

  /**
   * Remove fog on remove (callback).
   */
  remove: function () {
    var fog = this.el.object3D.fog;
    if (fog) {
      fog.density = 0;
      fog.far = 0;
      fog.near = 0;
    }
  }
});

/**
 * Creates a fog object. Sets fog.name to be able to detect fog type changes.
 *
 * @param {object} data - Fog data.
 * @returns {object} fog
 */
function getFog (data) {
  var fog;
  if (data.type === 'exponential') {
    fog = new THREE.FogExp2(data.color, data.density);
  } else {
    fog = new THREE.Fog(data.color, data.near, data.far);
  }
  fog.name = data.type;
  return fog;
}

},{"../../lib/three":1,"../core/component":55,"../utils/debug":89}],32:[function(_dereq_,module,exports){
var debug = _dereq_('../utils/debug');
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');
var utils = _dereq_('../utils');

var DEFAULT_RADIUS = 1;
var helperMatrix = new THREE.Matrix4();
var degToRad = THREE.Math.degToRad;
var warn = debug('components:geometry:warn');

/**
 * Geometry component. Combined with material component to make a mesh in 3D object.
 *
 * @param {number} [arc=360] -
 *   Used by torus. A central angle that determines arc length of the torus. In degrees.
 * @param {number} [depth=2] - Used by box. Depth of the sides on the Z axis.
 * @param {number} [height=2] -
 *   Used by box, cylinder, plane. Height of the sides on the Y axis.
 * @param {bool} [openEnded=false] - Used by cylinder.
 * @param {number} [p=2] - Used by torusKnot. Coprime of q.
 * @param {number} [primitive=null] - type of shape (e.g., box, sphere).
 * @param {number} [q=3] - Used by torusKnot. Coprime of p.
 * @param {number} [radius=1] - Used by circle, cylinder, ring, sphere, torus, torusKnot.
 * @param {number} [radiusBottom=1] - Used by cylinder.
 * @param {number} [radiusInner=0.8] - Used by ring.
 * @param {number} [radiusOuter=1.2] - Used by ring.
 * @param {number} [radiusTop=1] - Used by cylinder.
 * @param {number} [radiusTube=0.2] - Used by torus. Tube radius.
 * @param {number} [scaleHeight=1] - Used by torusKnot.
 * @param {number} [segments=8] - Used by circle. Number of segments.
 * @param {number} [segmentsHeight=18] - Used by cylinder, sphere. Number of segments.
 * @param {number} [segmentsPhi=8] - Used by ring.
 * @param {number} [segmentsRadial=36] - Used by cylinder. Number of segments.
 * @param {number} [segmentsTheta=8] -
 *   Used by ring. Number of segments. A higher number means the ring will be more round.
 *   Minimum is 3.
 * @param {number} [segmentsTubular=8] - Used by torus, torusKnot. Number of segments.
 * @param {number} [segmentsWidth=36] - Used by sphere.
 * @param {number} [thetaLength=360] - Used by circle, cylinder, ring. In degrees.
 * @param {number} [thetaStart=0] - Used by circle, cylinder, ring. In degrees.
 * @param {string} translate -
 *   Defined as a coordinate (e.g., `-1 0 5`) that translates geometry vertices. Useful for
 *   effectively changing the pivot point.
 * @param {number} [width=2] - Used by box, plane.
 */
module.exports.Component = registerComponent('geometry', {
  schema: {
    arc: { default: 360, if: { primitive: ['torus'] } },
    depth: { default: 2, min: 0, if: { primitive: ['box'] } },
    height: { default: 2, min: 0, if: { primitive: ['box', 'plane'] } },
    openEnded: { default: false, if: { primitive: ['cylinder'] } },
    p: { default: 2, if: { primitive: ['torusKnot'] }, type: 'int' },
    primitive: {
      default: '',
      oneOf: ['', 'box', 'circle', 'cylinder', 'plane',
              'ring', 'sphere', 'torus', 'torusKnot'] },
    q: { default: 3, if: { primitive: ['torusKnot'] }, type: 'int' },
    phiLength: { default: 360, if: { primitive: ['sphere'] } },
    phiStart: { default: 0, min: 0, if: { primitive: ['sphere'] } },
    radius: { default: DEFAULT_RADIUS, min: 0, if: { primitive: ['circle', 'cylinder', 'sphere', 'torus', 'torusKnot'] } },
    radiusBottom: { default: DEFAULT_RADIUS, min: 0, if: { primitive: ['cylinder'] } },
    radiusInner: { default: 0.8, min: 0, if: { primitive: ['ring'] } },
    radiusOuter: { default: 1.2, min: 0, if: { primitive: ['ring'] } },
    radiusTop: { default: DEFAULT_RADIUS, if: { primitive: ['cylinder'] } },
    radiusTubular: { default: 0.2, min: 0, if: { primitive: ['torus'] } },
    scaleHeight: { default: 1, min: 0, if: { primitive: ['torusKnot'] } },
    segments: { default: 8, min: 0, if: { primitive: ['circle'] }, type: 'int' },
    segmentsHeight: { default: 18, min: 0, if: { primitive: ['cylinder', 'sphere'] }, type: 'int' },
    segmentsPhi: { default: 8, min: 0, if: { primitive: ['ring'] }, type: 'int' },
    segmentsRadial: { default: 36, min: 0, if: { primitive: ['cylinder'] }, type: 'int' },
    segmentsTheta: { default: 8, min: 0, if: { primitive: ['ring'] }, type: 'int' },
    segmentsTubular: { default: 8, min: 0, if: { primitive: ['torus', 'torusKnot'] }, type: 'int' },
    segmentsWidth: { default: 36, min: 0, if: { primitive: ['sphere'] }, type: 'int' },
    thetaLength: { default: 360, min: 0, if: { primitive: ['circle', 'cylinder', 'ring',
                                                           'sphere'] } },
    thetaStart: { default: 0, if: { primitive: ['circle', 'cylinder', 'ring', 'sphere'] } },
    translate: { type: 'vec3' },
    width: { default: 2, min: 0, if: { primitive: ['box', 'plane'] } }
  },

  /**
   * Creates a new geometry on every update as there's not an easy way to
   * update a geometry that would be faster than just creating a new one.
   */
  update: function (previousData) {
    previousData = previousData || {};
    var data = this.data;
    var currentTranslate = previousData.translate || this.schema.translate.default;
    var diff = utils.diff(previousData, data);
    var mesh = this.el.getOrCreateObject3D('mesh', THREE.Mesh);
    var geometry = mesh.geometry;
    var geometryNeedsUpdate = !(Object.keys(diff).length === 1 && 'translate' in diff);
    var translateNeedsUpdate = !utils.deepEqual(data.translate, currentTranslate);

    if (geometryNeedsUpdate) {
      geometry = mesh.geometry = getGeometry(this.data, this.schema);
    }
    if (translateNeedsUpdate) {
      applyTranslate(geometry, data.translate, currentTranslate);
    }
  },

  /**
   * Removes geometry on remove (callback).
   */
  remove: function () {
    this.el.getObject3D('mesh').geometry = new THREE.Geometry();
  }
});

/**
 * Creates a three.js geometry.
 *
 * @param {object} data
 * @param {object} schema
 * @returns {object} geometry
 */
function getGeometry (data, schema) {
  if (data.primitive === 'cube') {
    warn('geometry.primitive="cube" should be "box"');
  }

  switch (data.primitive) {
    case 'box': {
      return new THREE.BoxGeometry(data.width, data.height, data.depth);
    }
    case 'circle': {
      return new THREE.CircleGeometry(
        data.radius, data.segments, degToRad(data.thetaStart), degToRad(data.thetaLength));
    }
    case 'cone': {
      return new THREE.CylinderGeometry(
        data.radiusTop, data.radiusBottom, data.height,
        data.segmentsRadial, data.segmentsHeight,
        data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
    }
    case 'cylinder': {
      return new THREE.CylinderGeometry(
        data.radius, data.radius, data.height,
        data.segmentsRadial, data.segmentsHeight,
        data.openEnded, degToRad(data.thetaStart), degToRad(data.thetaLength));
    }
    case 'plane': {
      return new THREE.PlaneBufferGeometry(data.width, data.height);
    }
    case 'ring': {
      return new THREE.RingGeometry(
        data.radiusInner, data.radiusOuter, data.segmentsTheta, data.segmentsPhi,
        degToRad(data.thetaStart), degToRad(data.thetaLength));
    }
    case 'sphere': {
      // thetaLength's default for spheres is different from those of the other geometries.
      // For now, we detect if thetaLength is exactly 360 to switch to a different default.
      if (data.thetaLength === 360) { data.thetaLength = 180; }
      return new THREE.SphereBufferGeometry(
        data.radius, data.segmentsWidth, data.segmentsHeight, degToRad(data.phiStart),
        degToRad(data.phiLength), degToRad(data.thetaStart), degToRad(data.thetaLength));
    }
    case 'torus': {
      return new THREE.TorusGeometry(
        data.radius, data.radiusTubular * 2, data.segmentsRadial, data.segmentsTubular,
        degToRad(data.arc));
    }
    case 'torusKnot': {
      return new THREE.TorusKnotGeometry(
        data.radius, data.radiusTubular * 2, data.segmentsRadial, data.segmentsTubular,
        data.p, data.q, data.scaleHeight);
    }
    default: {
      warn('Primitive type not supported: ' + data.primitive);
      return new THREE.Geometry();
    }
  }
}

/**
 * Translates geometry vertices.
 *
 * @param {object} geometry - three.js geometry.
 * @param {object} translate - New translation.
 * @param {object} currentTranslate - Currently applied translation.
 */
function applyTranslate (geometry, translate, currentTranslate) {
  var translation = helperMatrix.makeTranslation(
    translate.x - currentTranslate.x,
    translate.y - currentTranslate.y,
    translate.z - currentTranslate.z
  );
  geometry.applyMatrix(translation);
  geometry.verticesNeedsUpdate = true;
}

},{"../../lib/three":1,"../core/component":55,"../utils":90,"../utils/debug":89}],33:[function(_dereq_,module,exports){
_dereq_('../components/camera');
_dereq_('../components/cursor');
_dereq_('../components/fog');
_dereq_('../components/geometry');
_dereq_('../components/light');
_dereq_('../components/loader');
_dereq_('../components/look-at');
_dereq_('../components/look-controls');
_dereq_('../components/material');
_dereq_('../components/position');
_dereq_('../components/raycaster');
_dereq_('../components/rotation');
_dereq_('../components/scale');
_dereq_('../components/sound');
_dereq_('../components/visible');
_dereq_('../components/wasd-controls');

},{"../components/camera":29,"../components/cursor":30,"../components/fog":31,"../components/geometry":32,"../components/light":34,"../components/loader":35,"../components/look-at":36,"../components/look-controls":37,"../components/material":38,"../components/position":39,"../components/raycaster":40,"../components/rotation":41,"../components/scale":42,"../components/sound":43,"../components/visible":44,"../components/wasd-controls":45}],34:[function(_dereq_,module,exports){
var diff = _dereq_('../utils').diff;
var debug = _dereq_('../utils/debug');
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

var degToRad = THREE.Math.degToRad;
var warn = debug('components:light:warn');

/**
 * Light component.
 *
 * @namespace light
 * @param {number} [angle=60] - maximum extent of light from its direction,
          in degrees. For spot lights.
 * @param {string} [color=#FFF] - light color. For every light.
 * @param {number} [decay=1] - amount the light dims along the distance of the
          light. For point and spot lights.
 * @param {number} [exponent=10.0] - rapidity of falloff of light from its
          target direction. For spot lights.
 * @param {string} [groundColor=#FFF] - ground light color. For hemisphere
          lights.
 * @param {number} [intensity=1.0] - light strength. For every light except
          ambient.
 * @param {string} [type=directional] - light type (ambient, directional,
          hemisphere, point, spot).
 */
module.exports.Component = registerComponent('light', {
  schema: {
    angle: { default: 60, if: { type: ['spot'] } },
    color: { default: '#FFF' },
    groundColor: { default: '#FFF', if: { type: ['hemisphere'] } },
    decay: { default: 1, if: { type: ['point', 'spot'] } },
    distance: { default: 0.0, min: 0, if: { type: ['point', 'spot'] } },
    exponent: { default: 10.0, if: { type: ['spot'] } },
    intensity: { default: 1.0, min: 0, if: { type: ['directional', 'hemisphere', 'point', 'spot'] } },
    type: { default: 'directional',
            oneOf: ['ambient', 'directional', 'hemisphere', 'point', 'spot']
    }
  },

  /**
   * Notifies scene a light has been added to remove default lighting.
   */
  init: function () {
    var el = this.el;
    this.light = null;
    el.sceneEl.registerLight(el);
  },

  /**
   * (Re)create or update light.
   */
  update: function (oldData) {
    var data = this.data;
    var diffData = diff(data, oldData || {});
    var light = this.light;

    // Existing light.
    if (light && !('type' in diffData)) {
      // Light type has not changed. Update light.
      Object.keys(diffData).forEach(function (key) {
        var value = data[key];
        if (['color', 'groundColor'].indexOf(key) !== -1) {
          value = new THREE.Color(value);
        }
        light[key] = value;
      });
      return;
    }

    // No light yet or light type has changed. Create and add light.
    this.setLight(this.data);
  },

  setLight: function (data) {
    var el = this.el;

    var newLight = getLight(data);
    if (newLight) {
      if (this.light) {
        el.setObject3D('light');
      }

      this.light = newLight;
      this.light.el = el;
      el.setObject3D('light', this.light);
    }
  },

  /**
   * Remove light on remove (callback).
   */
  remove: function () {
    this.el.setObject3D('light');
  }
});

/**
 * Creates a new three.js light object given data object defining the light.
 *
 * @param {object} data
 */
function getLight (data) {
  var angle = data.angle;
  var color = new THREE.Color(data.color).getHex();
  var decay = data.decay;
  var distance = data.distance;
  var groundColor = new THREE.Color(data.groundColor).getHex();
  var intensity = data.intensity;
  var type = data.type;

  switch (type.toLowerCase()) {
    case 'ambient': {
      return new THREE.AmbientLight(color);
    }
    case 'directional': {
      return new THREE.DirectionalLight(color, intensity);
    }
    case 'hemisphere': {
      return new THREE.HemisphereLight(color, groundColor, intensity);
    }
    case 'point': {
      return new THREE.PointLight(color, intensity, distance, decay);
    }
    case 'spot': {
      return new THREE.SpotLight(color, intensity, distance, degToRad(angle), data.exponent,
                                 decay);
    }
    default: {
      warn('%s is not a valid light type. ' +
           'Choose from ambient, directional, hemisphere, point, spot.', type);
    }
  }
}

},{"../../lib/three":1,"../core/component":55,"../utils":90,"../utils/debug":89}],35:[function(_dereq_,module,exports){
var debug = _dereq_('../utils/debug');
var registerComponent = _dereq_('../core/component').registerComponent;
var parseUrl = _dereq_('../utils/src-loader').parseUrl;
var THREE = _dereq_('../../lib/three');

var warn = debug('components:loader:warn');

module.exports.Component = registerComponent('loader', {
  dependencies: [ 'material' ],

  schema: {
    src: { default: '' },
    mtl: { default: '' },
    format: {
      default: 'obj',
      oneOf: ['obj', 'collada']
    }
  },

  update: function () {
    var el = this.el;
    var data = this.data;
    var model = this.model;
    var url = parseUrl(data.src);
    var mtlUrl = parseUrl(data.mtl);
    var format = data.format;
    if (model) { el.setObject3D('mesh'); }
    if (!url) {
      warn('Model URL not provided');
      return;
    }
    switch (format) {
      case 'obj':
        this.loadObj(url, mtlUrl);
        break;
      case 'collada':
        this.loadCollada(url);
        break;
      default:
        warn('Model format not supported');
    }
  },

  loadObj: function (objUrl, mtlUrl) {
    var self = this;
    var el = this.el;
    var objLoader = new THREE.OBJLoader();
    if (mtlUrl) {
      // .OBJ + .MTL assets.
      if (el.components.material) {
        warn('Material component is ignored when a .MTL is provided');
      }
      var mtlLoader = new THREE.MTLLoader(objLoader.manager);
      mtlLoader.setBaseUrl(mtlUrl.substr(0, mtlUrl.lastIndexOf('/') + 1));
      mtlLoader.load(mtlUrl, function (materials) {
        materials.preload();
        objLoader.setMaterials(materials);
        objLoader.load(objUrl, function (object) {
          self.model = object;
          el.setObject3D('mesh', object);
        });
      });
    } else {
      // .OBJ asset only.
      objLoader.load(objUrl, function (object) {
        self.model = object;
        self.applyMaterial();
        el.setObject3D('mesh', object);
      });
    }
  },

  applyMaterial: function () {
    var material = this.el.components.material.material;
    if (!this.model) { return; }
    this.model.traverse(function (child) {
      if (child instanceof THREE.Mesh) {
        child.material = material;
      }
    });
  },

  loadCollada: function (url) {
    var self = this;
    var el = this.el;
    var loader = new THREE.ColladaLoader();
    loader.options.convertUpAxis = true;
    loader.load(url, function (collada) {
      self.model = collada.scene;
      el.setObject3D('mesh', collada.scene);
    });
  }
});

},{"../../lib/three":1,"../core/component":55,"../utils/debug":89,"../utils/src-loader":91}],36:[function(_dereq_,module,exports){
var debug = _dereq_('../utils/debug');
var coordinates = _dereq_('../utils/coordinates');
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

var warn = debug('components:look-at:warn');
var isCoordinate = coordinates.isCoordinate;

/**
 * Look-at component.
 * Modifies rotation to either track another entity OR do a one-time turn towards a position
 * vector.
 *
 * If tracking an object via setting the component value via a selector, look-at will register
 * a behavior to the scene to update rotation on every tick.
 *
 * Examples:
 *
 * look-at="#the-mirror"
 * look-at="0 5 -2"
 *
 * @param Look-at either takes a target selector pointing to another object or a
 *        position.
 * @member {object} target3D - object3D of targeted element that look-at is currently
           tracking.
 * @member {object} vector - Helper vector to do matrix transformations.
 */
module.exports.Component = registerComponent('look-at', {
  schema: { default: '' },

  init: function () {
    this.target3D = null;
    this.vector = new THREE.Vector3();
  },

  /**
   * If tracking an object, this will be called on every tick.
   * If looking at a position vector, this will only be called once (until further updates).
   */
  update: function () {
    var self = this;
    var target = self.data;
    var object3D = self.el.object3D;
    var target3D = self.target3D;
    var targetEl;

    // Track target object position. Depends on parent object keeping global transforms up
    // to state with updateMatrixWorld(). In practice, this is handled by the renderer.
    if (target3D) {
      return object3D.lookAt(self.vector.setFromMatrixPosition(target3D.matrixWorld));
    }

    // No longer looking at anything (i.e., look-at="").
    if (!target ||
        (typeof target === 'object' && !Object.keys(target).length)) {
      return self.remove();
    }

    // Look at a position.
    if (typeof target === 'object') {
      return object3D.lookAt(new THREE.Vector3(target.x, target.y, target.z));
    }

    // Assume target is a string.
    // Query for the element, grab its object3D, then register a behavior on the scene to
    // track the target on every tick.
    targetEl = self.el.sceneEl.querySelector(target);
    if (!targetEl) {
      warn('"' + target + '" does not point to a valid entity to look-at');
      return;
    }
    if (!targetEl.hasLoaded) {
      return targetEl.addEventListener('loaded', function () {
        self.beginTracking(targetEl);
      });
    }
    return self.beginTracking(targetEl);
  },

  /**
   * Remove follow behavior on remove (callback).
   */
  remove: function () {
    if (this.target3D) {
      this.el.sceneEl.removeBehavior(this);
      this.target3D = null;
    }
  },

  parse: function (value) {
    if (isCoordinate(value) || typeof value === 'object') {
      return coordinates.parse(value);
    }
    return value;
  },

  stringify: function (data) {
    return coordinates.stringify(data);
  },

  beginTracking: function (targetEl) {
    this.target3D = targetEl.object3D;
    this.el.sceneEl.addBehavior(this);
  }
});

},{"../../lib/three":1,"../core/component":55,"../utils/coordinates":88,"../utils/debug":89}],37:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

// To avoid recalculation at every mouse movement tick
var PI_2 = Math.PI / 2;

module.exports.Component = registerComponent('look-controls', {
  dependencies: ['position', 'rotation'],

  schema: {
    enabled: { default: true }
  },

  init: function () {
    this.previousPosition = new THREE.Vector3();
    this.deltaPosition = new THREE.Vector3();
    this.setupMouseControls();
    this.setupHMDControls();
    this.bindMethods();
  },

  bindMethods: function () {
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.releaseMouse = this.releaseMouse.bind(this);
    this.onTouchStart = this.onTouchStart.bind(this);
    this.onTouchMove = this.onTouchMove.bind(this);
    this.onTouchEnd = this.onTouchEnd.bind(this);
  },

  play: function () {
    var scene = this.el.sceneEl;
    this.previousPosition.set(0, 0, 0);
    this.addEventListeners();
    scene.addBehavior(this);
  },

  pause: function () {
    var scene = this.el.sceneEl;
    this.removeEventListeners();
    scene.removeBehavior(this);
  },

  remove: function () {
    this.pause();
  },

  setupMouseControls: function () {
    // The canvas where the scene is painted
    this.mouseDown = false;
    this.pitchObject = new THREE.Object3D();
    this.yawObject = new THREE.Object3D();
    this.yawObject.position.y = 10;
    this.yawObject.add(this.pitchObject);
  },

  setupHMDControls: function () {
    this.dolly = new THREE.Object3D();
    this.euler = new THREE.Euler();
    this.controls = new THREE.VRControls(this.dolly);
    this.zeroQuaternion = new THREE.Quaternion();
  },

  addEventListeners: function () {
    var canvasEl = document.querySelector('a-scene').canvas;

    // Mouse Events
    canvasEl.addEventListener('mousedown', this.onMouseDown, false);
    canvasEl.addEventListener('mousemove', this.onMouseMove, false);
    canvasEl.addEventListener('mouseup', this.releaseMouse, false);
    canvasEl.addEventListener('mouseout', this.releaseMouse, false);

    // Touch events
    canvasEl.addEventListener('touchstart', this.onTouchStart);
    canvasEl.addEventListener('touchmove', this.onTouchMove);
    canvasEl.addEventListener('touchend', this.onTouchEnd);
  },

  removeEventListeners: function () {
    var sceneEl = document.querySelector('a-scene');
    var canvasEl = sceneEl && sceneEl.canvas;
    if (!canvasEl) { return; }

    // Mouse Events
    canvasEl.removeEventListener('mousedown', this.onMouseDown);
    canvasEl.removeEventListener('mousemove', this.onMouseMove);
    canvasEl.removeEventListener('mouseup', this.releaseMouse);
    canvasEl.removeEventListener('mouseout', this.releaseMouse);

    // Touch events
    canvasEl.removeEventListener('touchstart', this.onTouchStart);
    canvasEl.removeEventListener('touchmove', this.onTouchMove);
    canvasEl.removeEventListener('touchend', this.onTouchEnd);
  },

  update: function () {
    if (!this.data.enabled) { return; }
    this.controls.update();
    this.updateOrientation();
    this.updatePosition();
  },

  updateOrientation: (function () {
    var hmdEuler = new THREE.Euler();
    hmdEuler.order = 'YXZ';
    return function () {
      var pitchObject = this.pitchObject;
      var yawObject = this.yawObject;
      var hmdQuaternion = this.calculateHMDQuaternion();
      hmdEuler.setFromQuaternion(hmdQuaternion);
      this.el.setAttribute('rotation', {
        x: THREE.Math.radToDeg(hmdEuler.x) + THREE.Math.radToDeg(pitchObject.rotation.x),
        y: THREE.Math.radToDeg(hmdEuler.y) + THREE.Math.radToDeg(yawObject.rotation.y),
        z: THREE.Math.radToDeg(hmdEuler.z)
      });
    };
  })(),

  calculateHMDQuaternion: (function () {
    var hmdQuaternion = new THREE.Quaternion();
    return function () {
      var dolly = this.dolly;
      if (!this.zeroed && !dolly.quaternion.equals(this.zeroQuaternion)) {
        this.zeroOrientation();
        this.zeroed = true;
      }
      hmdQuaternion.copy(this.zeroQuaternion).multiply(dolly.quaternion);
      return hmdQuaternion;
    };
  })(),

  updatePosition: (function () {
    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();
    var scale = new THREE.Vector3();
    return function () {
      var el = this.el;
      var deltaPosition = this.calculateDeltaPosition();
      var currentPosition = el.getComputedAttribute('position');
      this.el.object3D.matrixWorld.decompose(position, quaternion, scale);
      deltaPosition.applyQuaternion(quaternion);
      el.setAttribute('position', {
        x: currentPosition.x + deltaPosition.x,
        y: currentPosition.y + deltaPosition.y,
        z: currentPosition.z + deltaPosition.z
      });
    };
  })(),

  calculateDeltaPosition: function () {
    var dolly = this.dolly;
    var deltaPosition = this.deltaPosition;
    var previousPosition = this.previousPosition;
    deltaPosition.copy(dolly.position);
    deltaPosition.sub(previousPosition);
    previousPosition.copy(dolly.position);
    return deltaPosition;
  },

  updateHMDQuaternion: (function () {
    var hmdQuaternion = new THREE.Quaternion();
    return function () {
      var dolly = this.dolly;
      this.controls.update();
      if (!this.zeroed && !dolly.quaternion.equals(this.zeroQuaternion)) {
        this.zeroOrientation();
        this.zeroed = true;
      }
      hmdQuaternion.copy(this.zeroQuaternion).multiply(dolly.quaternion);
      return hmdQuaternion;
    };
  })(),

  zeroOrientation: function () {
    var euler = new THREE.Euler();
    euler.setFromQuaternion(this.dolly.quaternion.clone().inverse());
    // Cancel out roll and pitch. We want to only reset yaw
    euler.z = 0;
    euler.x = 0;
    this.zeroQuaternion.setFromEuler(euler);
  },

  onMouseMove: function (event) {
    var pitchObject = this.pitchObject;
    var yawObject = this.yawObject;
    var previousMouseEvent = this.previousMouseEvent;

    if (!this.mouseDown || !this.data.enabled) { return; }

    var movementX = event.movementX || event.mozMovementX;
    var movementY = event.movementY || event.mozMovementY;

    if (movementX === undefined || movementY === undefined) {
      movementX = event.screenX - previousMouseEvent.screenX;
      movementY = event.screenY - previousMouseEvent.screenY;
    }
    this.previousMouseEvent = event;

    yawObject.rotation.y -= movementX * 0.002;
    pitchObject.rotation.x -= movementY * 0.002;
    pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
  },

  onMouseDown: function (event) {
    this.mouseDown = true;
    this.previousMouseEvent = event;
  },

  releaseMouse: function () {
    this.mouseDown = false;
  },

  onTouchStart: function (e) {
    if (e.touches.length !== 1) { return; }
    this.touchStart = {
      x: e.touches[0].pageX,
      y: e.touches[0].pageY
    };
    this.touchStarted = true;
  },

  onTouchMove: function (e) {
    var deltaY;
    var yawObject = this.yawObject;
    if (!this.touchStarted) { return; }
    deltaY = 2 * Math.PI * (e.touches[0].pageX - this.touchStart.x) / this.canvasEl.clientWidth;
    // Limits touch orientaion to to yaw (y axis)
    yawObject.rotation.y -= deltaY * 0.5;
    this.touchStart = {
      x: e.touches[0].pageX,
      y: e.touches[0].pageY
    };
  },

  onTouchEnd: function () {
    this.touchStarted = false;
  }
});

},{"../../lib/three":1,"../core/component":55}],38:[function(_dereq_,module,exports){
/* global Promise */
var debug = _dereq_('../utils/debug');
var diff = _dereq_('../utils').diff;
var registerComponent = _dereq_('../core/component').registerComponent;
var srcLoader = _dereq_('../utils/src-loader');
var THREE = _dereq_('../../lib/three');

var CubeLoader = new THREE.CubeTextureLoader();
var error = debug('components:material:error');
var TextureLoader = new THREE.TextureLoader();
var texturePromises = {};
var warn = debug('components:material:warn');

var MATERIAL_TYPE_BASIC = 'MeshBasicMaterial';
var MATERIAL_TYPE_STANDARD = 'MeshStandardMaterial';

/**
 * Material component.
 *
 * @namespace material
 * @param {string} color - Diffuse color.
 * @param {string} envMap - To load a environment cubemap. Takes a selector
 *         to an element containing six img elements, or a comma-separated
 *         string of direct url()s.
 * @param {boolean} fog - Whether or not to be affected by fog.
 * @param {number} height - Height to render texture.
 * @param {number} metalness - Parameter for physical/standard material.
 * @param {number} opacity - [0-1].
 * @param {string} repeat - X and Y value for size of texture repeating
 *         (in UV units).
 * @param {number} roughness - Parameter for physical/standard material.
 * @param {string} [side=front] - Which side(s) to render (i.e., front, back,
 *         both).
 * @param {string} shader - Determines how material is shaded. Defaults to `standard`,
 *         three.js's implementation of PBR. Another option is `flat` where we use
 *         MeshBasicMaterial.
 * @param {string} src - To load a texture. takes a selector to an img/video
 *         element or a direct url().
 * @param {boolean} transparent - Whether to render transparent the alpha
 *         channel of a texture (e.g., .png).
 * @param {number} width - Width to render texture.
 */
module.exports.Component = registerComponent('material', {
  schema: {
    color: { default: '#FFF' },
    envMap: { default: '' },
    fog: { default: true },
    height: { default: 360 },
    metalness: { default: 0.0, min: 0.0, max: 1.0, if: { shader: ['standard'] } },
    opacity: { default: 1.0, min: 0.0, max: 1.0 },
    repeat: { default: '' },
    roughness: { default: 0.5, min: 0.0, max: 1.0, if: { shader: ['standard'] } },
    shader: { default: 'standard', oneOf: ['flat', 'standard'] },
    side: { default: 'front', oneOf: ['front', 'back', 'double'] },
    src: { default: '' },
    transparent: { default: false },
    width: { default: 640 }
  },

  init: function () {
    this.isLoadingEnvMap = false;
    this.material = null;
    this.textureSrc = null;
  },

  /**
   * Update or create material.
   *
   * Material type depends on shader:
   *   shader=flat - MeshBasicMaterial.
   *   shader=XXX - MeshStandardMaterial.
   *
   * @param {object|null} oldData
   */
  update: function (oldData) {
    var data = this.data;
    var material;
    var materialType = getMaterialType(data);
    var src = data.src;

    if (!oldData || getMaterialType(oldData) !== materialType) {
      material = this.createMaterial(getMaterialData(data), materialType);
    } else {
      material = this.updateMaterial(processMaterialData(diff(oldData, data)));
    }

    // Load textures and/or cubemaps.
    if (material.type === MATERIAL_TYPE_STANDARD) { this.updateEnvMap(); }
    this.updateTexture(src);
  },

  /**
   * Remove material on remove (callback).
   */
  remove: function () {
    var el = this.el;
    var defaultColor = this.schema.color.default;
    var defaultMaterial = new THREE.MeshBasicMaterial({ color: defaultColor });
    var object3D = el.getObject3D('mesh');
    if (object3D) { object3D.material = defaultMaterial; }
    el.sceneEl.unregisterMaterial(this.material);
  },

  /**
   * (Re)create new material. Has side-effects of setting `this.material` and updating
   * material registration in scene.
   *
   * @param {object} data - Material component data.
   * @param {object} type - Material type to create.
   * @returns {object} Material.
   */
  createMaterial: function (data, type) {
    var material;
    var mesh = this.el.getOrCreateObject3D('mesh', THREE.Mesh);
    var sceneEl = this.el.sceneEl;
    if (this.material) { sceneEl.unregisterMaterial(this.material); }
    material = this.material = mesh.material = new THREE[type](data);
    sceneEl.registerMaterial(material);
    return material;
  },

  /**
   * Updating existing material.
   *
   * @param {object} data - Material component data.
   * @returns {object} Material.
   */
  updateMaterial: function (data) {
    var material = this.material;
    Object.keys(data).forEach(function (key) {
      material[key] = data[key];
    });
    return material;
  },

  /**
   * Handle environment cubemap. Textures are cached in texturePromises.
   */
  updateEnvMap: function () {
    var self = this;
    var material = this.material;
    var envMap = this.data.envMap;
    // Environment cubemaps.
    if (!envMap || this.isLoadingEnvMap) {
      material.envMap = null;
      material.needsUpdate = true;
      return;
    }
    this.isLoadingEnvMap = true;
    if (texturePromises[envMap]) {
      // Another material is already loading this texture. Wait on promise.
      texturePromises[envMap].then(function (cube) {
        self.isLoadingEnvMap = false;
        material.envMap = cube;
        material.needsUpdate = true;
      });
    } else {
      // Material is first to load this texture. Load and resolve texture.
      texturePromises[envMap] = new Promise(function (resolve) {
        srcLoader.validateCubemapSrc(envMap, function loadEnvMap (urls) {
          CubeLoader.load(urls, function (cube) {
            // Texture loaded.
            self.isLoadingEnvMap = false;
            material.envMap = cube;
            resolve(cube);
          });
        });
      });
    }
  },

  /*
   * Updates material texture map.
   *
   * @param {string|object} src - An <img> / <video> element or url to an image/video file.
   */
  updateTexture: function (src) {
    var data = this.data;
    var material = this.material;
    if (src) {
      if (src !== this.textureSrc) {
        // Texture added or changed.
        this.textureSrc = src;
        srcLoader.validateSrc(src, loadImage, loadVideo);
      }
    } else {
      // Texture removed.
      material.map = null;
      material.needsUpdate = true;
    }
    function loadImage (src) { loadImageTexture(material, src, data.repeat); }
    function loadVideo (src) { loadVideoTexture(material, src, data.width, data.height); }
  }
});

/**
 * Sets image texture on material as `map`.
 *
 * @param {object} material - three.js material.
 * @param {string|object} src - An <img> element or url to an image file.
 * @param {string} repeat - X and Y value for size of texture repeating (in UV units).
 */
function loadImageTexture (material, src, repeat) {
  var isEl = typeof src !== 'string';

  var onLoad = createTexture;
  var onProgress = function () {};
  var onError = function (xhr) {
    error('The URL "$s" could not be fetched (Error code: %s; Response: %s)',
          xhr.status, xhr.statusText);
  };

  if (isEl) {
    createTexture(src);
  } else {
    TextureLoader.load(src, onLoad, onProgress, onError);
  }

  function createTexture (texture) {
    if (!(texture instanceof THREE.Texture)) { texture = new THREE.Texture(texture); }
    var repeatXY;
    if (repeat) {
      repeatXY = repeat.split(' ');
      if (repeatXY.length === 2) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(parseInt(repeatXY[0], 10),
                           parseInt(repeatXY[1], 10));
      }
    }
    material.map = texture;
    texture.needsUpdate = true;
    material.needsUpdate = true;
  }
}

/**
 * Creates a video element to be used as a texture.
 *
 * @param {object} material - three.js material.
 * @param {string} src - Url to a video file.
 * @param {number} width - Width of the video.
 * @param {number} height - Height of the video.
 * @returns {Element} Video element.
 */
function createVideoEl (material, src, width, height) {
  var el = material.videoEl || document.createElement('video');
  function onError () {
    warn('The URL "$s" is not a valid image or video', src);
  }
  el.width = width;
  el.height = height;
  // Attach event listeners if brand new video element.
  if (el !== this.videoEl) {
    el.autoplay = true;
    el.loop = true;
    el.crossOrigin = true;
    el.addEventListener('error', onError, true);
    material.videoEl = el;
  }
  el.src = src;
  return el;
}

/**
 * Sets video texture on material as map.
 *
 * @param {object} material - three.js material.
 * @param {string} src - Url to a video file.
 * @param {number} width - Width of the video.
 * @param {number} height - Height of the video.
*/
function loadVideoTexture (material, src, height, width) {
  // three.js video texture loader requires a <video>.
  var videoEl = typeof src !== 'string' ? fixVideoAttributes(src) : createVideoEl(material, src, height, width);
  var texture = new THREE.VideoTexture(videoEl);
  texture.minFilter = THREE.LinearFilter;
  texture.needsUpdate = true;
  material.map = texture;
  material.needsUpdate = true;
}

/**
 * Fixes a video element's attributes to prevent developers from accidentally
 * passing the wrong attribute values to commonly misused video attributes.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#Attributes
 * @param {Element} videoEl - Video element.
 * @returns {Element} Video element with the correct properties updated.
 */
function fixVideoAttributes (videoEl) {
  // The `<video>` element treats `loop` and `muted` as boolean attributes, but
  // of course does not with `autoplay`, `controls`, `preload` (and `crossorigin`).
  // If we get passed a `<video autoplay="false">`, let's assume the dev wanted
  // `autoplay` to be disabled.
  videoEl.autoplay = videoEl.getAttribute('autoplay') !== 'false';
  videoEl.controls = videoEl.getAttribute('controls') !== 'false';
  if (videoEl.getAttribute('preload') === 'false') {
    videoEl.preload = 'none';
  }
  return videoEl;
}

/**
 * Builds and normalize material data, normalizing stuff along the way.
 *
 * @param {object} data - Material data.
 * @returns {object} data - Processed material data.
 */
function getMaterialData (data) {
  var materialData = {
    color: data.color,
    side: data.side,
    opacity: data.opacity,
    transparent: data.transparent !== false || data.opacity < 1.0
  };
  if (getMaterialType(data) === MATERIAL_TYPE_STANDARD) {
    // Attach standard material parameters.
    materialData.metalness = data.metalness;
    materialData.roughness = data.roughness;
  }
  return processMaterialData(materialData);
}

/**
 * Necessary transforms to material data before passing to three.js.
 *
 * @param {object} data - Material data.
 * @returns {object} Processed material data.
 */
function processMaterialData (data) {
  if ('color' in data) {
    data.color = new THREE.Color(data.color);
  }
  if ('opacity' in data && data.opacity < 1) {
    data.transparent = true;
  }
  if ('side' in data) {
    data.side = getSide(data.side);
  }
  return data;
}

/**
 * Get material type based on shader.
 *
 * @param {object} Material component data.
 * @returns {string} Material type (as three.js constructor name)
 */
function getMaterialType (data) {
  return data.shader === 'flat' ? MATERIAL_TYPE_BASIC : MATERIAL_TYPE_STANDARD;
}

/**
 * Returns a three.js constant determining which material face sides to render
 * based on the side parameter (passed as a component property).
 *
 * @param {string} [side=front] - `front`, `back`, or `double`.
 * @returns {number} THREE.FrontSide, THREE.BackSide, or THREE.DoubleSide.
 */
function getSide (side) {
  switch (side) {
    case 'back': {
      return THREE.BackSide;
    }
    case 'double': {
      return THREE.DoubleSide;
    }
    default: {
      // Including case `front`.
      return THREE.FrontSide;
    }
  }
}

},{"../../lib/three":1,"../core/component":55,"../utils":90,"../utils/debug":89,"../utils/src-loader":91}],39:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;

module.exports.Component = registerComponent('position', {
  schema: { type: 'vec3' },

  update: function () {
    var object3D = this.el.object3D;
    var data = this.data;
    object3D.position.set(data.x, data.y, data.z);
  }
});

},{"../core/component":55}],40:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;
var requestInterval = _dereq_('request-interval');
var THREE = _dereq_('../../lib/three');

module.exports.Component = registerComponent('raycaster', {
  init: function () {
    this.raycaster = new THREE.Raycaster();
    this.intersectedEl = null;
  },

  play: function () {
    this.pollForHoverIntersections();
  },

  pause: function () {
    var pollInterval = this.pollInterval;
    if (!pollInterval) { return; }
    requestInterval.clear(this.pollInterval);
  },

  remove: function () {
    this.pause();
  },

  pollForHoverIntersections: function () {
    this.pollInterval = requestInterval(100, this.getIntersections.bind(this));
  },

  getIntersections: function () {
    var closest = this.getClosestIntersected();
    if (closest) {
      this.handleIntersection(closest);
      return;
    }
    // If we have no intersections other than the cursor itself,
    // but we still have a previously intersected element, clear it.
    if (this.intersectedEl) {
      this.clearExistingIntersection();
    }
  },

  intersect: function (objects) {
    var el = this.el;
    var raycaster = this.raycaster;
    var cursor = el.object3D;
    var parent = el.parentNode.object3D;
    var originPosition = new THREE.Vector3().setFromMatrixPosition(parent.matrixWorld);
    var cursorPosition = new THREE.Vector3().setFromMatrixPosition(cursor.matrixWorld);
    var direction = cursorPosition.sub(originPosition).normalize();
    raycaster.set(originPosition, direction);
    return raycaster.intersectObjects(objects, true);
  },

  /**
   * Returns the closest intersected object.
   *
   * @returns {Object|null}
   *   The closest intersected element that is not the cursor itself,
   *   an invisible element, or not a a-frame entity element.
   *   If no objects are intersected, `null` is returned.
   */
  getClosestIntersected: function () {
    var scene = this.el.sceneEl.object3D;
    var cursorEl = this.el;
    var intersectedObj;
    var intersectedObjs = this.intersect(scene.children);
    for (var i = 0; i < intersectedObjs.length; ++i) {
      intersectedObj = intersectedObjs[i];
      // If the intersected object is the cursor itself
      // or the object is further than the max distance
      if (intersectedObj.object.el === undefined) { continue; }
      if (intersectedObj.object.el === cursorEl) { continue; }
      if (!intersectedObj.object.visible) { continue; }
      return intersectedObj;
    }
    return null;
  },

  /**
   * Remembers the last intersected element
   */
  setExistingIntersection: function (el, distance) {
    this.intersectedEl = el;
    this.el.emit('intersection', { el: el, distance: distance });
  },

  /**
   * Emits a `mouseleave` event and clears info about the last intersection.
   */
  clearExistingIntersection: function () {
    var intersectedEl = this.intersectedEl;
    this.el.emit('intersectioncleared', { el: intersectedEl });
    this.intersectedEl = null;
  },

  handleIntersection: function (obj) {
    var el = obj.object.el;

    // A new intersection where previously a different element was
    // and now needs a mouseleave event.
    if (this.intersectedEl !== el) {
      this.clearExistingIntersection();
    }
    this.setExistingIntersection(el, obj.distance);
  }
});

},{"../../lib/three":1,"../core/component":55,"request-interval":17}],41:[function(_dereq_,module,exports){
var degToRad = _dereq_('../../lib/three').Math.degToRad;
var registerComponent = _dereq_('../core/component').registerComponent;

module.exports.Component = registerComponent('rotation', {
  schema: { type: 'vec3' },

  /**
   * Updates object3D rotation.
   */
  update: function () {
    var data = this.data;
    var object3D = this.el.object3D;
    object3D.rotation.set(degToRad(data.x), degToRad(data.y), degToRad(data.z));
    object3D.rotation.order = 'YXZ';
  }
});

},{"../../lib/three":1,"../core/component":55}],42:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;

// Avoids triggering a zero-determinant which makes object3D matrix non-invertible.
var zeroScale = 0.00001;

module.exports.Component = registerComponent('scale', {
  schema: {
    type: 'vec3',
    default: { x: 1, y: 1, z: 1 }
  },

  update: function () {
    var data = this.data;
    var object3D = this.el.object3D;
    var x = data.x === 0 ? zeroScale : data.x;
    var y = data.y === 0 ? zeroScale : data.y;
    var z = data.z === 0 ? zeroScale : data.z;
    object3D.scale.set(x, y, z);
  }
});

},{"../core/component":55}],43:[function(_dereq_,module,exports){
var debug = _dereq_('../utils/debug');
var diff = _dereq_('../utils').diff;
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

var warn = debug('components:sound:warn');

/**
 * Sound component.
 *
 * @param {bool} [autoplay=false]
 * @param {string} on
 * @param {bool} [loop=false]
 * @param {number} [volume=1]
 */
module.exports.Component = registerComponent('sound', {
  schema: {
    src: { default: '' },
    on: { default: 'click' },
    autoplay: { default: false },
    loop: { default: false },
    volume: { default: 1 }
  },

  init: function () {
    this.listener = null;
    this.sound = null;
  },

  update: function (oldData) {
    var data = this.data;
    var diffData = diff(oldData || {}, data);
    var el = this.el;
    var sound = this.sound;
    var src = data.src;
    var srcChanged = 'src' in diffData;

    // Create new sound if not yet created or changing `src`.
    if (srcChanged) {
      if (!src) {
        warn('Audio source was not specified with `src`');
        return;
      }
      sound = this.setupSound();
    }

    if (srcChanged || 'autoplay' in diffData) {
      sound.autoplay = data.autoplay;
    }

    if (srcChanged || 'loop' in diffData) {
      sound.setLoop(data.loop);
    }

    if (srcChanged || 'volume' in diffData) {
      sound.setVolume(data.volume);
    }

    if ('on' in diffData) {
      if (oldData && oldData.on) {
        el.removeEventListener(oldData.on);
      }
      el.addEventListener(data.on, this.play.bind(this));
    }

    // All sound values set. Load in `src.
    if (srcChanged) {
      sound.load(src);
    }
  },

  remove: function () {
    this.el.setObject3D('sound');
  },

  /**
   * Removes current sound object, creates new sound object, adds to entity.
   *
   * @returns {object} sound
   */
  setupSound: function () {
    var el = this.el;
    var listener;
    var sound = this.sound;

    if (sound) {
      this.stop();
      el.setObject3D('sound');
    }

    listener = this.listener = new THREE.AudioListener();
    sound = this.sound = new THREE.Audio(listener);
    el.setObject3D('sound', sound);
    return sound;
  },

  play: function () {
    this.sound.play();
  },

  stop: function () {
    this.sound.stop();
  },

  pause: function () {
    this.sound.pause();
  }
});

},{"../../lib/three":1,"../core/component":55,"../utils":90,"../utils/debug":89}],44:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;

/**
 * Visibility component.
 */
module.exports.Component = registerComponent('visible', {
  schema: {
    type: 'boolean',
    default: true
  },

  update: function () {
    this.el.object3D.visible = this.data;
  }
});

},{"../core/component":55}],45:[function(_dereq_,module,exports){
var registerComponent = _dereq_('../core/component').registerComponent;
var THREE = _dereq_('../../lib/three');

var MAX_DELTA = 0.2;

/**
 * WASD component.
 *
 * Control your entities with the WASD keys.
 *
 * @namespace wasd-controls
 * @param {number} [easing=20] - How fast the movement decelerates. If you hold the
 * keys the entity moves and if you release it will stop. Easing simulates friction.
 * @param {number} [acceleration=65] - Determines the acceleration given
 * to the entity when pressing the keys.
 * @param {bool} [enabled=true] - To completely enable or disable the controls
 * @param {bool} [fly=false] - Determines if the direction of the movement sticks
 * to the plane where the entity started off or if there are 6 degrees of
 * freedom as a diver underwater or a plane flying.
 * @param {string} [wsAxis='z'] - The axis that the W and S keys operate on
 * @param {string} [adAxis='x'] - The axis that the A and D keys operate on
 * @param {bool} [wsInverted=false] - WS Axis is inverted
 * @param {bool} [adInverted=false] - AD Axis is inverted
 */
module.exports.Component = registerComponent('wasd-controls', {
  schema: {
    easing: { default: 20 },
    acceleration: { default: 65 },
    enabled: { default: true },
    fly: { default: false },
    wsAxis: { default: 'z', oneOf: [ 'x', 'y', 'z' ] },
    adAxis: { default: 'x', oneOf: [ 'x', 'y', 'z' ] },
    wsInverted: { default: false },
    wsEnabled: { default: true },
    adInverted: { default: false },
    adEnabled: { default: true }
  },

  init: function () {
    this.velocity = new THREE.Vector3();
    // To keep track of the pressed keys
    this.keys = {};
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onKeyUp = this.onKeyUp.bind(this);
  },

  play: function () {
    var scene = this.el.sceneEl;
    this.attachEventListeners();
    scene.addBehavior(this);
  },

  pause: function () {
    var scene = this.el.sceneEl;
    this.removeEventListeners();
    scene.removeBehavior(this);
  },

  remove: function () {
    this.pause();
  },

  update: function (previousData) {
    var data = this.data;
    var acceleration = data.acceleration;
    var easing = data.easing;
    var velocity = this.velocity;
    var prevTime = this.prevTime = this.prevTime || Date.now();
    var time = window.performance.now();
    var delta = (time - prevTime) / 1000;
    var keys = this.keys;
    var movementVector;
    var adAxis = data.adAxis;
    var wsAxis = data.wsAxis;
    var adSign = data.adInverted ? -1 : 1;
    var wsSign = data.wsInverted ? -1 : 1;
    var el = this.el;
    this.prevTime = time;

    // If data has changed or FPS is too low
    // we reset the velocity
    if (previousData || delta > MAX_DELTA) {
      velocity[adAxis] = 0;
      velocity[wsAxis] = 0;
      return;
    }

    velocity[adAxis] -= velocity[adAxis] * easing * delta;
    velocity[wsAxis] -= velocity[wsAxis] * easing * delta;

    var position = el.getComputedAttribute('position');

    if (data.enabled) {
      if (data.adEnabled) {
        if (keys[65]) { velocity[adAxis] -= adSign * acceleration * delta; } // Left
        if (keys[68]) { velocity[adAxis] += adSign * acceleration * delta; } // Right
      }
      if (data.wsEnabled) {
        if (keys[87]) { velocity[wsAxis] -= wsSign * acceleration * delta; } // Up
        if (keys[83]) { velocity[wsAxis] += wsSign * acceleration * delta; } // Down
      }
    }

    movementVector = this.getMovementVector(delta);
    el.object3D.translateX(movementVector.x);
    el.object3D.translateY(movementVector.y);
    el.object3D.translateZ(movementVector.z);

    el.setAttribute('position', {
      x: position.x + movementVector.x,
      y: position.y + movementVector.y,
      z: position.z + movementVector.z
    });
  },

  attachEventListeners: function () {
    // Keyboard events
    window.addEventListener('keydown', this.onKeyDown, false);
    window.addEventListener('keyup', this.onKeyUp, false);
  },

  removeEventListeners: function () {
    // Keyboard events
    window.removeEventListener('keydown', this.onKeyDown);
    window.removeEventListener('keyup', this.onKeyUp);
  },

  onKeyDown: function (event) {
    this.keys[event.keyCode] = true;
  },

  onKeyUp: function (event) {
    this.keys[event.keyCode] = false;
  },

  getMovementVector: (function (delta) {
    var direction = new THREE.Vector3(0, 0, 0);
    var rotation = new THREE.Euler(0, 0, 0, 'YXZ');
    return function (delta) {
      var velocity = this.velocity;
      var elRotation = this.el.getAttribute('rotation');
      direction.copy(velocity);
      direction.multiplyScalar(delta);
      if (!elRotation) { return direction; }
      if (!this.data.fly) { elRotation.x = 0; }
      rotation.set(THREE.Math.degToRad(elRotation.x),
                   THREE.Math.degToRad(elRotation.y), 0);
      direction.applyEuler(rotation);
      return direction;
    };
  })()
});

},{"../../lib/three":1,"../core/component":55}],46:[function(_dereq_,module,exports){
/**
 * Animation configuration options for TWEEN.js animations.
 * Used by `<a-animation>`.
 */
var TWEEN = _dereq_('tween.js');

var DIRECTIONS = {
  alternate: 'alternate',
  alternateReverse: 'alternate-reverse',
  normal: 'normal',
  reverse: 'reverse'
};

var EASING_FUNCTIONS = {
  'linear': TWEEN.Easing.Linear.None,

  'ease': TWEEN.Easing.Cubic.InOut,
  'ease-in': TWEEN.Easing.Cubic.In,
  'ease-out': TWEEN.Easing.Cubic.Out,
  'ease-in-out': TWEEN.Easing.Cubic.InOut,

  'ease-cubic': TWEEN.Easing.Cubic.In,
  'ease-in-cubic': TWEEN.Easing.Cubic.In,
  'ease-out-cubic': TWEEN.Easing.Cubic.Out,
  'ease-in-out-cubic': TWEEN.Easing.Cubic.InOut,

  'ease-quad': TWEEN.Easing.Quadratic.InOut,
  'ease-in-quad': TWEEN.Easing.Quadratic.In,
  'ease-out-quad': TWEEN.Easing.Quadratic.Out,
  'ease-in-out-quad': TWEEN.Easing.Quadratic.InOut,

  'ease-quart': TWEEN.Easing.Quartic.InOut,
  'ease-in-quart': TWEEN.Easing.Quartic.In,
  'ease-out-quart': TWEEN.Easing.Quartic.Out,
  'ease-in-out-quart': TWEEN.Easing.Quartic.InOut,

  'ease-quint': TWEEN.Easing.Quintic.InOut,
  'ease-in-quint': TWEEN.Easing.Quintic.In,
  'ease-out-quint': TWEEN.Easing.Quintic.Out,
  'ease-in-out-quint': TWEEN.Easing.Quintic.InOut,

  'ease-sine': TWEEN.Easing.Sinusoidal.InOut,
  'ease-in-sine': TWEEN.Easing.Sinusoidal.In,
  'ease-out-sine': TWEEN.Easing.Sinusoidal.Out,
  'ease-in-out-sine': TWEEN.Easing.Sinusoidal.InOut,

  'ease-expo': TWEEN.Easing.Exponential.InOut,
  'ease-in-expo': TWEEN.Easing.Exponential.In,
  'ease-out-expo': TWEEN.Easing.Exponential.Out,
  'ease-in-out-expo': TWEEN.Easing.Exponential.InOut,

  'ease-circ': TWEEN.Easing.Circular.InOut,
  'ease-in-circ': TWEEN.Easing.Circular.In,
  'ease-out-circ': TWEEN.Easing.Circular.Out,
  'ease-in-out-circ': TWEEN.Easing.Circular.InOut,

  'ease-elastic': TWEEN.Easing.Elastic.InOut,
  'ease-in-elastic': TWEEN.Easing.Elastic.In,
  'ease-out-elastic': TWEEN.Easing.Elastic.Out,
  'ease-in-out-elastic': TWEEN.Easing.Elastic.InOut,

  'ease-back': TWEEN.Easing.Back.InOut,
  'ease-in-back': TWEEN.Easing.Back.In,
  'ease-out-back': TWEEN.Easing.Back.Out,
  'ease-in-out-back': TWEEN.Easing.Back.InOut,

  'ease-bounce': TWEEN.Easing.Bounce.InOut,
  'ease-in-bounce': TWEEN.Easing.Bounce.In,
  'ease-out-bounce': TWEEN.Easing.Bounce.Out,
  'ease-in-out-bounce': TWEEN.Easing.Bounce.InOut
};

var FILLS = {
  backwards: 'backwards',
  both: 'both',
  forwards: 'forwards',
  none: 'none'
};

var REPEATS = {
  indefinite: 'indefinite'
};

var DEFAULTS = {
  attribute: 'rotation',
  begin: '0',
  dur: 1000,
  easing: 'ease',
  direction: DIRECTIONS.normal,
  fill: FILLS.forwards,
  from: undefined,
  repeat: 0,
  to: undefined
};

module.exports.defaults = DEFAULTS;
module.exports.directions = DIRECTIONS;
module.exports.easingFunctions = EASING_FUNCTIONS;
module.exports.fills = FILLS;
module.exports.repeats = REPEATS;

},{"tween.js":26}],47:[function(_dereq_,module,exports){
var ANode = _dereq_('./a-node');
var constants = _dereq_('../constants/animation');
var coordinates = _dereq_('../utils/').coordinates;
var parseProperty = _dereq_('./schema').parseProperty;
var registerElement = _dereq_('./a-register-element').registerElement;
var TWEEN = _dereq_('tween.js');
var utils = _dereq_('../utils/');

var DEFAULTS = constants.defaults;
var DIRECTIONS = constants.directions;
var EASING_FUNCTIONS = constants.easingFunctions;
var FILLS = constants.fills;
var REPEATS = constants.repeats;
var isCoordinate = coordinates.isCoordinate;

/**
 * Animation element that applies Tween animation to parent element (entity).
 * Takes after the Web Animations spec.
 *
 * @namespace <a-animation>
 * @param {string} attribute -
 *   Entity attribute to animate. Can be a component name (e.g., `position`) if the component
 *   is set via a single value. Or can be a dot-separated componentName.componentProp to
 *   animate a single component property (e.g., `light.intensity`, `material.opacity`).
 * @param {number|string} begin -
 *   Either milliseconds to delay or an event name to wait upon before starting animation.
 * @param {string} direction -
 *   Direction of the animation between from and to.
 *     - alternate: Even iterations played as specified, odd iterations played in reverse
 *                direction from way specified.
 *     - alternate-reverse: Even iterations are played in the reverse direction from way
 *                        specified, odd iterations played as specified.
 *     - normal: All iterations are played as specified.
 *     - reverse: All iterations are played in reverse direction from way specified.
 * @param {number} dur - How long to run the animation in milliseconds.
 * @param {string} easing -
 *   Easing function of animation (e.g., ease, ease-in, ease-in-out, ease-out, linear).
 * @param {string} [fill=forwards] -
 *   Determines effect of animation when not in play.
 *     - backwards: Before animation, set initial value to `from`.
 *     - both: Before animation, backwards fill. After animation, forwards fill.
 *     - forwards: After animation, value will stay at `to`.
 *     - none: Animation has no effect when not in play.
 * @param {number} from - Start value. Defaults to the entity's current value for that attr.
 * @param {number|string} repeat -
 *   How the animation should repeat (e.g., a number or `indefinite`).
 * @param {number} to - End value.
 * @member {number} count -
 *   Decrementing counter for how many cycles of animations left to run.
 * @member {Element} el - Entity which the animation is modifying to.
 * @member initialValue - Value before animation started. Used to restore state.
 * @member {bool} isRunning - Whether animation is currently running.
 * @member {function} partialSetAttribute -
 *   setAttribute function that is agnostic to whether we are setting an attribute value
 *   or a component property value. The el and the attribute names are bundled with
 *   the function.
 * @member {object} tween - tween.js object.
 */
module.exports.AAnimation = registerElement('a-animation', {
  prototype: Object.create(ANode.prototype, {
    createdCallback: {
      value: function () {
        this.bindMethods();
        this.isRunning = false;
        this.partialSetAttribute = function () { /* no-op */ };
        this.tween = null;
      }
    },

    attachedCallback: {
      value: function () {
        var self = this;
        var el = self.el = self.parentNode;

        if (el.isNode) {
          if (el.hasLoaded) {
            init();
          } else {
            el.addEventListener('loaded', init.bind(self));
          }
        } else {
          // To handle elements that are not yet `<a-entity>`s (e.g., templates).
          el.addEventListener('nodeready', init.bind(self));
        }

        function init () {
          self.applyMixin();
          self.update();
          self.load();
        }
      }
    },

    attributeChangedCallback: {
      value: function (attr, oldVal, newVal) {
        if (!this.hasLoaded || !this.isRunning) { return; }
        this.stop();
        this.applyMixin();
        this.update();
      }
    },

    /**
     * Builds a Tween object to handle animations.
     * Uses tween.js's from, to, delay, easing, repeat, onUpdate, and onComplete.
     * Note: tween.js takes objects for its `from` and `to` values.
     *
     * @returns {object}
     */
    getTween: {
      value: function () {
        var self = this;
        var data = self.data;
        var el = self.el;
        var animationValues;
        var attribute = data.attribute;
        var begin = parseInt(data.begin, 10);
        var currentValue = el.getComputedAttribute(attribute);
        var direction = self.getDirection(data.direction);
        var easing = EASING_FUNCTIONS[data.easing];
        var fill = data.fill;
        var from;
        var repeat = data.repeat === REPEATS.indefinite ? Infinity : 0;
        var to;
        var toTemp;
        var yoyo = false;

        animationValues = getAnimationValues(el, attribute, data.from || self.initialValue, data.to, currentValue);
        from = animationValues.from;
        to = animationValues.to;
        self.partialSetAttribute = animationValues.partialSetAttribute;

        if (self.count === undefined) {
          self.count = repeat === Infinity ? 0 : parseInt(data.repeat, 10);
        }

        if (isNaN(begin)) { begin = 0; }

        // Store initial state.
        self.initialValue = self.initialValue || cloneValue(currentValue);

        // Handle indefinite + forwards + alternate yoyo edge-case (#405).
        if (repeat === Infinity && fill === FILLS.forwards &&
            [DIRECTIONS.alternate,
             DIRECTIONS.alternateReverse].indexOf(data.direction) !== -1) {
          yoyo = true;
        }

        // If reversing, swap from and to.
        if (direction === DIRECTIONS.reverse) {
          toTemp = to;
          to = cloneValue(from);
          from = cloneValue(toTemp);
        }

        // If fill is backwards or both, start animation at the specified from.
        if ([FILLS.backwards, FILLS.both].indexOf(fill) !== -1) {
          self.partialSetAttribute(from);
        }

        // Create Tween.
        return new TWEEN.Tween(cloneValue(from))
          .to(to, data.dur)
          .delay(begin)
          .easing(easing)
          .repeat(repeat)
          .yoyo(yoyo)
          .onUpdate(function () {
            self.partialSetAttribute(this);
          })
          .onComplete(self.onCompleted.bind(self));
      }
    },

    /**
     * Animation parameters changed. Stop current animation, get a new one, and start it.
     */
    update: {
      value: function () {
        var data = this.data;
        var begin = data.begin;
        // Cancel previous event listeners
        this.removeEventListeners(this.evt);
        this.addEventListeners(begin);
        // Store new event name.
        this.evt = begin;
        // If `begin` is a number, start the animation right away.
        if (!isNaN(begin)) {
          this.stop();
          this.start();
        }
      },
      writable: window.debug
    },

    /**
     * Callback for when a cycle of an animation is complete. Handles when to completely
     * finish the animation.
     *
     * If `repeat` is set to a value, this method is called after each repeat. Repeats are
     * handled by ending the current animation and creating a new one with `count` updated.
     * Note that this method is *not* called if repeat is set to `indefinite`.
     */
    onCompleted: {
      value: function () {
        var data = this.data;
        this.isRunning = false;
        if ([FILLS.backwards, FILLS.none].indexOf(data.fill) !== -1) {
          this.partialSetAttribute(this.initialValue);
        }
        if (this.count === 0) {
          this.count = undefined;
          this.emit('animationend');
          return;
        }
        this.isRunning = false;
        this.count--;
        this.start();
      }
    },

    start: {
      value: function () {
        if (this.isRunning || this.el.paused) { return; }
        this.tween = this.getTween();
        this.isRunning = true;
        this.tween.start();
        this.emit('animationstart');
      },
      writable: true
    },

    stop: {
      value: function () {
        var tween = this.tween;
        if (!tween) { return; }
        tween.stop();
        this.isRunning = false;
        this.partialSetAttribute(this.initialValue);
        this.emit('animationstop');
      },
      writable: true
    },

    /**
     * Handle alternating directions. Given the current direction, calculate the next one,
     * and store the current one.
     *
     * @param {string} direction
     * @returns {string} Direction that the next individual cycle of the animation will go
     *          towards.
     */
    getDirection: {
      value: function (direction) {
        if (direction === DIRECTIONS.alternate) {
          this.prevDirection =
            this.prevDirection === DIRECTIONS.normal ? DIRECTIONS.reverse : DIRECTIONS.normal;
          return this.prevDirection;
        }
        if (direction === DIRECTIONS.alternateReverse) {
          this.prevDirection =
            this.prevDirection === DIRECTIONS.reverse ? DIRECTIONS.normal : DIRECTIONS.reverse;
          return this.prevDirection;
        }
        return direction;
      }
    },

    /**
     * Preemptive binding to attach/detach event listeners (see `update`).
     */
    bindMethods: {
      value: function () {
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this.onStateAdded = this.onStateAdded.bind(this);
        this.onStateRemoved = this.onStateRemoved.bind(this);
      }
    },

    addEventListeners: {
      value: function (evts) {
        var el = this.el;
        var self = this;
        utils.splitString(evts).forEach(function (evt) {
          el.addEventListener(evt, self.start);
        });
        el.addEventListener('play', this.start);
        el.addEventListener('pause', this.stop);
        el.addEventListener('stateadded', this.onStateAdded);
        el.addEventListener('stateremoved', this.onStateRemoved);
      }
    },

    removeEventListeners: {
      value: function (evts) {
        var el = this.el;
        var start = this.start;
        utils.splitString(evts).forEach(function (evt) {
          el.removeEventListener(evt, start);
        });
        el.removeEventListener('stateadded', this.onStateAdded);
        el.removeEventListener('stateremoved', this.onStateRemoved);
      }
    },

    onStateAdded: {
      value: function (evt) {
        if (evt.detail.state === this.data.begin) { this.start(); }
      },
      writable: true
    },

    onStateRemoved: {
      value: function (evt) {
        if (evt.detail.state === this.data.begin) { this.stop(); }
      },
      writable: true
    },

    /**
     * Applies animation data from a mixin element.
     * Works the same as component mixins but reimplemented because animations
     * aren't components.
     */
    applyMixin: {
      value: function () {
        var data = {};
        var elData;
        var mixinData;
        var mixinEl;

        // Get mixin data.
        mixinEl = document.querySelector('#' + this.getAttribute('mixin'));
        mixinData = mixinEl ? utils.getElData(mixinEl, DEFAULTS) : {};

        elData = utils.getElData(this, DEFAULTS);
        utils.extend(data, DEFAULTS, mixinData, elData);
        this.data = data;
      }
    }
  })
});

function cloneValue (val) {
  return utils.extend({}, val);
}

/**
 * Deduces different animation values based on whether we are:
 *   - animating an inner attribute of a component.
 *   - animating a coordinate component.
 *   - animating a boolean.
 *   - animating a number.
 *
 * @param {Element} el
 * @param {string} attribute - Tells what to animate based on whether it is dot-separated.
 * @param {string} dataFrom - Data `from` value.
 * @param {string} dataTo - Data `to` value.
 * @param currentValue
 * @returns {object}
 *   Object with keys [from, to, partialSetAttribute].
 *     `from` and `to`
 *        Objects where key is attribute being animated and value is value.
 *     `partialSetAttribute`
 *        Closured-function that tells tween how to update the component.
 */
function getAnimationValues (el, attribute, dataFrom, dataTo, currentValue) {
  var attributeSplit = attribute.split('.');
  var schema;
  var component;
  var componentPropName;
  var componentName;
  var from = {};
  var partialSetAttribute;
  var to = {};

  if (attributeSplit.length === 2) {
    getForComponentAttribute();
  } else if (dataTo && isCoordinate(dataTo)) {
    getForCoordinateComponent();
  } else if (['true', 'false'].indexOf(dataTo) !== -1) {
    getForBoolean();
  } else {
    getForNumber();
  }
  return {
    from: from,
    partialSetAttribute: partialSetAttribute,
    to: to
  };

  /**
   * Animating a component that has multiple attributes (e.g., geometry.width).
   */
  function getForComponentAttribute () {
    componentName = attributeSplit[0];
    componentPropName = attributeSplit[1];
    component = el.components[componentName];
    if (!component) {
      el.setAttribute(componentName, '');
      component = el.components[componentName];
    }
    schema = component.schema;
    if (dataFrom === undefined) {  // dataFrom can be 0.
      from[attribute] = el.getComputedAttribute(componentName)[componentPropName];
    } else {
      from[attribute] = dataFrom;
    }
    from[attribute] = parseProperty(from[attribute], schema[componentPropName]);
    to[attribute] = parseProperty(dataTo, schema[componentPropName]);
    partialSetAttribute = function (value) {
      el.setAttribute(componentName, componentPropName, value[attribute]);
    };
  }

  /**
   * Animating a component that is an XYZ coordinate (e.g., position).
   * Will be tweening {x, y, z} all at once.
   */
  function getForCoordinateComponent () {
    from = dataFrom ? coordinates.parse(dataFrom) : currentValue;
    to = coordinates.parse(dataTo);
    partialSetAttribute = function (value) {
      el.setAttribute(attribute, value);
    };
  }

  /**
   * Animation a boolean (e.g., visible).
   * Have to convert from boolean to an integer (0 is false, > 0 is true) for tween.
   */
  function getForBoolean () {
    if (dataFrom === undefined) {
      from[attribute] = false;
    } else {
      from[attribute] = strToBool(dataFrom);
    }
    from[attribute] = boolToNum(from[attribute]);
    to[attribute] = boolToNum(strToBool(dataTo));
    partialSetAttribute = function (value) {
      el.setAttribute(attribute, !!value[attribute]);
    };
  }

  /**
   * Animating a numbered attribute (e.g., opacity).
   */
  function getForNumber () {
    if (dataFrom === undefined) {  // dataFrom can be 0.
      from[attribute] = parseFloat(el.getAttribute(attribute));
    } else {
      from[attribute] = parseFloat(dataFrom);
    }
    to[attribute] = parseFloat(dataTo);
    partialSetAttribute = function (value) {
      el.setAttribute(attribute, value[attribute]);
    };
  }
}
module.exports.getAnimationValues = getAnimationValues;

/**
 * Converts string to bool.
 *
 * @param {string} str - `true` or `false`.
 * @returns {bool}
 */
function strToBool (str) {
  if (str === 'true') { return true; }
  return false;
}

/**
 * Converts boolean to number.
 *
 * @param {bool}
 * @returns {number}
 */
function boolToNum (bool) {
  return bool ? 1 : 0;
}

},{"../constants/animation":46,"../utils/":90,"./a-node":52,"./a-register-element":53,"./schema":57,"tween.js":26}],48:[function(_dereq_,module,exports){
var ANode = _dereq_('./a-node');
var registerElement = _dereq_('./a-register-element').registerElement;

/**
 * TODO: Block on assets before loading.
 */
module.exports = registerElement('a-assets', {
  prototype: Object.create(ANode.prototype, {
    load: {
      value: function () {
        ANode.prototype.load.call(this);
      }
    }
  })
});

},{"./a-node":52,"./a-register-element":53}],49:[function(_dereq_,module,exports){
/* global HTMLElement */
var debug = _dereq_('../utils/debug');
var registerElement = _dereq_('./a-register-element').registerElement;

var warn = debug('core:cubemap:warn');

/**
 * Cubemap element that handles validation and exposes list of URLs.
 * Does not listen to updates.
 */
module.exports = registerElement('a-cubemap', {
  prototype: Object.create(HTMLElement.prototype, {
    /**
     * Calculates this.srcs.
     */
    attachedCallback: {
      value: function () {
        this.srcs = this.validate();
      },
      writable: window.debug
    },

    /**
     * Checks for exactly six elements with [src].
     * Does not check explicitly for <img>s in case user does not want
     * prefetching.
     *
     * @returns {Array|null} - six URLs if valid, else null.
     */
    validate: {
      value: function () {
        var elements = this.querySelectorAll('[src]');
        var i;
        var srcs = [];
        if (elements.length === 6) {
          for (i = 0; i < elements.length; i++) {
            srcs.push(elements[i].getAttribute('src'));
          }
          return srcs;
        }
        // Else if there are not six elements, throw a warning.
        warn(
          '<a-cubemap> did not contain exactly six elements each with a ' +
          '`src` attribute.');
      },
      writable: window.debug
    }
  })
});

},{"../utils/debug":89,"./a-register-element":53}],50:[function(_dereq_,module,exports){
/* global HTMLElement */
var ANode = _dereq_('./a-node');
var components = _dereq_('./component').components;
var debug = _dereq_('../utils/debug');
var re = _dereq_('./a-register-element');
var THREE = _dereq_('../../lib/three');

var isNode = re.isNode;
var log = debug('core:a-entity');
var error = debug('core:a-entity:error');
var registerElement = re.registerElement;

var AEntity;

/**
 * Entity element definition.
 * Entities represent all elements that are part of the scene, and always have
 * a position, rotation, and scale.
 * In the entity-component system, entities are just a container of components.
 *
 * For convenience of inheriting components, the scene element inherits from
 * this prototype. When necessary, it differentiates itself by setting
 * `this.isScene`.
 *
 * @namespace Entity
 * @member {object} components - entity's currently initialized components.
 * @member {object} object3D - three.js object.
 * @member {array} states
 * @member {boolean} paused - true if dynamic behavior of the entity is paused
 */
var proto = Object.create(ANode.prototype, {
  defaults: {
    value: {
      position: '',
      rotation: '',
      scale: '',
      visible: ''
    }
  },

  createdCallback: {
    value: function () {
      this.isEntity = true;
      this.states = [];
      this.components = {};
      this.paused = true;
      this.object3D = new THREE.Group();
      this.object3D.el = this;
      this.objects3D = {};
    }
  },

  attributeChangedCallback: {
    value: function (attr, oldVal, newVal) {
      this.setEntityAttribute(attr, oldVal, newVal);
    }
  },

  attachedCallback: {
    value: function () {
      this.addToParent();
      if (!this.isScene) {
        this.load();
      }
    }
  },

  /**
   * Tell parent to remove this element's object3D from its object3D.
   * Do not call on scene element because that will cause a call to
   * document.body.remove().
   */
  detachedCallback: {
    value: function () {
      if (!this.parentEl || this.isScene) { return; }
      this.removeComponents();
      this.parentEl.remove(this);
    }
  },

  applyMixin: {
    value: function (attr) {
      var attrValue = this.getAttribute(attr);
      if (!attr) {
        this.updateComponents();
        return;
      }
      this.updateComponent(attr, attrValue);
    }
  },

  mapStateMixins: {
    value: function (state, op) {
      var mixins = this.getAttribute('mixin');
      var mixinIds;
      if (!mixins) { return; }
      mixinIds = mixins.split(' ');
      mixinIds.forEach(function (id) {
        var mixinId = id + '-' + state;
        op(mixinId);
      });
      this.updateComponents();
    }
  },

  updateStateMixins: {
    value: function (newMixins, oldMixins) {
      var self = this;
      oldMixins = oldMixins || '';
      var newMixinsIds = newMixins.split(' ');
      var oldMixinsIds = oldMixins ? oldMixins.split(' ') : [];
      // The list of mixins that might have been removed on update
      var diff = oldMixinsIds.filter(function (i) { return newMixinsIds.indexOf(i) < 0; });
      // Remove the mixins that are gone on update
      diff.forEach(function (mixinId) {
        var forEach = Array.prototype.forEach;
        // State Mixins
        var stateMixinsEls = document.querySelectorAll('[id^=' + mixinId + '-]');
        var stateMixinIds = [];
        forEach.call(stateMixinsEls, function (el) { stateMixinIds.push(el.id); });
        stateMixinIds.forEach(self.unregisterMixin.bind(self));
      });
      this.states.forEach(function (state) {
        newMixinsIds.forEach(function (id) {
          var mixinId = id + '-' + state;
          self.registerMixin(mixinId);
        });
      });
    }
  },

  getObject3D: {
    value: function (type) {
      return this.objects3D[type];
    }
  },

  setObject3D: {
    value: function (type, obj) {
      var oldObj = this.objects3D[type];
      if (oldObj) { this.object3D.remove(oldObj); }
      if (obj instanceof THREE.Object3D) {
        this.objects3D[type] = obj;
        obj.el = this;
        this.object3D.add(obj);
      }
    }
  },

  /**
   * Returns an object3D of a given type or creates it if it doesn't exist and
   * a Constructor is passed as an argument
   * @param {string} type - Type of the object3D .
   * @param {string} name - Component name.
   * @type {Object}
   */
  getOrCreateObject3D: {
    value: function (type, Constructor) {
      var object3D = this.getObject3D(type);
      if (!object3D && Constructor) {
        object3D = this.objects3D[type] = new Constructor();
        this.setObject3D(type, object3D);
      }
      return object3D;
    }
  },

  add: {
    value: function (el) {
      if (!el.object3D) {
        error("Trying to add an object3D that doesn't exist");
      }
      this.object3D.add(el.object3D);
    }
  },

  addToParent: {
    value: function () {
      var self = this;
      var parent = this.parentEl = this.parentNode;
      var attachedToParent = this.attachedToParent;
      if (!parent || attachedToParent) { return; }
      if (isNode(parent)) {
        attach();
        return;
      }
      // If the parent isn't an `ANode` but eventually it will be
      // when a templated element is created, we want to attach
      // this element to the parent then.
      parent.addEventListener('nodeready', attach);
      function attach () {
        // To prevent an object to attach itself multiple times to the parent.
        self.attachedToParent = true;
        if (parent.add) {
          parent.add(self);
        }
      }
    }
  },

  load: {
    value: function () {
      if (this.hasLoaded) { return; }

      // Attach to parent object3D.
      this.addToParent();

      if (this.isScene) {
        ANode.prototype.load.call(this, this.updateComponents.bind(this));
      } else {
        ANode.prototype.load.call(this, this.updateComponents.bind(this),
                                  function (el) { return el.isEntity; });
      }
    },
    writable: window.debug
  },

  remove: {
    value: function (el) {
      this.object3D.remove(el.object3D);
    }
  },

  /**
   * @returns {array} Direct children that are entities.
   */
  getChildEntities: {
    value: function () {
      var children = this.children;
      var childEntities = [];

      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child instanceof AEntity) {
          childEntities.push(child);
        }
      }

      return childEntities;
    }
  },

  /**
   * Check if a component is defined for an entity, including defaults and mixins.
   *
   * @param {string} name - Component name.
   */
  isComponentDefined: {
    value: function (name) {
      // If the defaults contain the component
      var inDefaults = this.defaults[name];
      // If the element contains the component
      var inAttribute = this.hasAttribute(name);
      if (inDefaults !== undefined || inAttribute) { return true; }
      return this.isComponentMixedIn(name);
    }
  },

  isComponentMixedIn: {
    value: function (name) {
      var i;
      var inMixin = false;
      var mixinEls = this.mixinEls;
     // If any of the mixins contains the component
      for (i = 0; i < mixinEls.length; ++i) {
        inMixin = mixinEls[i].hasAttribute(name);
        if (inMixin) { break; }
      }
      return inMixin;
    }
  },

  initComponent: {
    value: function (name, isDependency) {
      var isComponentDefined;
      // If it's not a component name or
      // If the component is already initialized
      if (!components[name] || this.components[name]) { return; }
      isComponentDefined = this.isComponentDefined(name);
      // If the component is not defined for the element
      if (!isComponentDefined && !isDependency) { return; }
      this.initComponentDependencies(name);
      // If a component it's a dependency of another but it's not defined
      // on the attribute, mixins or entity defaults
      // we have to add it.
      if (isDependency && !isComponentDefined) {
        this.setAttribute(name, '');
      } else {
        this.components[name] = new components[name].Component(this);
        if (!this.paused) { this.components[name].play(); }
      }
      log('Component initialized: %s', name);
    }
  },

  initComponentDependencies: {
    value: function (name) {
      var self = this;
      var component = components[name];
      var dependencies;
      // If the component doesn't exist
      if (!component) { return; }
      dependencies = components[name].dependencies;
      if (!dependencies) { return; }
      dependencies.forEach(function (component) {
        self.initComponent(component, true);
      });
    }
  },

  removeComponents: {
    value: function () {
      var self = this;
      var entityComponents = Object.keys(this.components);
      entityComponents.forEach(removeComponent);
      function removeComponent (name) {
        self.components[name].remove();
        delete self.components[name];
      }
    }
  },

  updateComponents: {
    value: function () {
      var self = this;
      var entityComponents = Object.keys(components);
      // Updates components
      entityComponents.forEach(updateComponent);
      function updateComponent (name) {
        var elValue = self.getAttribute(name);
        self.updateComponent(name, elValue);
      }
    }
  },

  /**
   * Initialize, update, or remove a single component.
   *
   * When initializing, we set the component on `this.components`.
   *
   * @param {string} name - Component name.
   * @param {object} newData - The new properties assigned to the component
   */
  updateComponent: {
    value: function (name, newData) {
      var component = this.components[name];
      var isDefault = name in this.defaults;
      var isMixedIn = this.isComponentMixedIn(name);
      if (component) {
        // Attribute was removed. Remove component.
        // 1. If the component is not defined in the defaults,
        // mixins or element attribute
        // 2. If the new data is null, it's not a default
        // component and the component it's not defined via
        // mixins
        if (!this.isComponentDefined(name) ||
            newData === null && !isDefault && !isMixedIn) {
          component.remove();
          delete this.components[name];
          return;
        }
        // Component already initialized. Update component.
        component.updateProperties(newData);
        return;
      }
      // Component not yet initialized. Initialize component.
      this.initComponent(name);
    }
  },

  /**
   * If `attr` is a component name and `componentProp` is not defined, removeAttribute removes
   * the entire component from the entity.
   *
   * If `attr` is a component name and `componentProp` is defined, removeAttribute removes a
   * single property from the component.
   *
   * @param {string} attr - Attribute name, which could also be a component name.
   * @param {string} componentProp - Component property name.
   */
  removeAttribute: {
    value: function (attr, componentProp) {
      var component = components[attr];
      if (component) {
        if (componentProp) {
          this.setAttribute(attr, componentProp, undefined);
        } else {
          this.setEntityAttribute(attr, undefined, null);
        }
      }
      HTMLElement.prototype.removeAttribute.call(this, attr);
    }
  },

  /**
   * Starts any dynamic behavior associated to the entity
   * this involves dynamic components and animations
   */
  play: {
    value: function () {
      var components = this.components;
      var componentKeys = Object.keys(components);
      if (!this.paused) { return; }
      this.paused = false;
      componentKeys.forEach(playComponent);
      this.getChildEntities().forEach(play);
      function play (obj) { obj.play(); }
      function playComponent (key) {
        components[key].play();
      }
      this.emit('play');
    },
    writable: true
  },

  /**
   * Stops any dynamic behavior associated to the entity
   * This involves dynamic components and animations
   */
  pause: {
    value: function () {
      var components = this.components;
      var componentKeys = Object.keys(components);
      if (this.paused) { return; }
      this.paused = true;
      componentKeys.forEach(pauseComponent);
      this.getChildEntities().forEach(pause);
      function pause (obj) { obj.pause(); }
      function pauseComponent (key) { components[key].pause(); }
      this.emit('pause');
    },
    writable: true
  },

  /**
   * Deals with updates on entity-specific attributes (i.e., components and mixins).
   *
   * @param {string} attr
   * @param {string} oldVal
   * @param {string|object} newVal
   */
  setEntityAttribute: {
    value: function (attr, oldVal, newVal) {
      var component = components[attr];
      oldVal = oldVal || this.getAttribute(attr);
      // When creating entities programatically and setting attributes, it is not part
      // of the scene until it is inserted into the DOM. This does not apply to scenes as
      // scenes depend on its child entities to load.
      if (!this.hasLoaded && !this.isScene) { return; }
      if (attr === 'mixin') {
        this.updateStateMixins(newVal, oldVal);
        this.updateComponents();
        return;
      }
      if (component) { this.updateComponent(attr, newVal); }
    }
  },

  /**
   * If attribute is a component, setAttribute will apply the value to the
   * existing component data, not replace it. Examples:
   *
   * Examples:
   *
   * setAttribute('id', 'my-element');
   * setAttribute('material', { color: 'crimson' });
   * setAttribute('material', 'color', 'crimson');
   *
   * @param {string} attr - Attribute name. setAttribute will initialize or update
   *        a component if the name corresponds to a registered component.
   * @param {string|object} value - If a string, setAttribute will update the attribute or.
   *        component. If an object, the value will be mixed into the component.
   * @param {string} componentPropValue - If defined, `value` will act as the property
   *        name and setAttribute will only set a single component property.
   */
  setAttribute: {
    value: function (attr, value, componentPropValue) {
      var self = this;
      var component = components[attr];
      var partialComponentData;
      value = value === undefined ? '' : value;
      var valueStr = value;
      var oldValue;

      if (component) {
        if (typeof value === 'string' && componentPropValue !== undefined) {
          // Update currently-defined component data with the new property value.
          partialComponentData = self.getAttribute(attr) || {};
          partialComponentData[value] = componentPropValue;
          value = partialComponentData;
        }
        valueStr = component.stringify(value);
      }

      oldValue = this.getAttribute(attr);
      ANode.prototype.setAttribute.call(self, attr, valueStr);
      self.setEntityAttribute(attr, oldValue, value);
    },
    writable: window.debug
  },

  /**
   * If `attr` is a component, returns JUST the component data specified in the HTML
   * by parsing the style-like string into an object. Like a partial version of
   * `getComputedAttribute` as returned component data does not include applied mixins or
   * defaults.
   *
   * If `attr` is not a component, fall back to HTML getAttribute.
   *
   * @param {string} attr
   * @returns {object|string} Object if component, else string.
   */
  getAttribute: {
    value: function (attr) {
      var component = components[attr];
      var value = HTMLElement.prototype.getAttribute.call(this, attr);
      if (!component || typeof value !== 'string') { return value; }
      return component.parse(value);
    },
    writable: window.debug
  },

  /**
   * If `attr` is a component, returns ALL component data including applied mixins and
   * defaults.
   *
   * If `attr` is not a component, fall back to HTML getAttribute.
   *
   * @param {string} attr
   * @returns {object|string} Object if component, else string.
   */
  getComputedAttribute: {
    value: function (attr) {
      var component = this.components[attr];
      if (component) { return component.getData(); }
      return HTMLElement.prototype.getAttribute.call(this, attr);
    }
  },

  addState: {
    value: function (state) {
      if (this.is(state)) { return; }
      this.states.push(state);
      this.mapStateMixins(state, this.registerMixin.bind(this));
      this.emit('stateadded', {state: state});
    }
  },

  removeState: {
    value: function (state) {
      var stateIndex = this.is(state);
      if (stateIndex === false) { return; }
      this.states.splice(stateIndex, 1);
      this.mapStateMixins(state, this.unregisterMixin.bind(this));
      this.emit('stateremoved', {state: state});
    }
  },

  /**
   * Checks if the element is in a given state. e.g. el.is('alive');
   * @type {string} state - Name of the state we want to check
   */
  is: {
    value: function (state) {
      var is = false;
      this.states.forEach(function (elState, index) {
        if (elState === state) { is = index; }
      });
      return is;
    }
  }
});

AEntity = registerElement('a-entity', {
  prototype: proto
});
module.exports = AEntity;

},{"../../lib/three":1,"../utils/debug":89,"./a-node":52,"./a-register-element":53,"./component":55}],51:[function(_dereq_,module,exports){
/* global HTMLElement */
var AComponents = _dereq_('./component').components;
var ANode = _dereq_('./a-node');
var registerElement = _dereq_('./a-register-element').registerElement;

module.exports = registerElement(
  'a-mixin',
  {
    prototype: Object.create(
      ANode.prototype,
      {
        attachedCallback: {
          value: function () {
            this.load();
          },
          writable: window.debug
        },

        setAttribute: {
          value: function (attr, value) {
            var component = AComponents[attr];
            if (component && typeof value === 'object') {
              value = component.stringify(value);
            }
            HTMLElement.prototype.setAttribute.call(this, attr, value);
          },
          writable: window.debug
        },

        getAttribute: {
          value: function (attr) {
            var component = AComponents[attr];
            var value = HTMLElement.prototype.getAttribute.call(this, attr);
            if (!component || typeof value !== 'string') { return value; }
            return component.parse(value);
          },
          writable: window.debug
        }
      }
    )
  }
);

},{"./a-node":52,"./a-register-element":53,"./component":55}],52:[function(_dereq_,module,exports){
/* global HTMLElement, MutationObserver */
var registerElement = _dereq_('./a-register-element').registerElement;
var utils = _dereq_('../utils/');

/**
 * Base class for A-Frame that manages loading of objects.
 *
 * Nodes can be modified using mixins.
 * Nodes emit a `loaded` event when they and their children have initialized. Which children
 * to wait for can be customized using `loadChildrenFilter`.
 */
module.exports = registerElement('a-node', {
  prototype: Object.create(HTMLElement.prototype, {
    createdCallback: {
      value: function () {
        this.hasLoaded = false;
        this.isNode = true;
        this.mixinEls = [];
        this.mixinObservers = {};
      }
    },

    attachedCallback: {
      value: function () {
        var mixins = this.getAttribute('mixin');

        this.sceneEl = this.closest('a-scene');
        this.emit('nodeready', {}, false);
        if (mixins) { this.updateMixins(mixins); }
      }
    },

    attributeChangedCallback: {
      value: function (attr, oldVal, newVal) {
        if (attr === 'mixin') { this.updateMixins(newVal, oldVal); }
      }
    },

    /**
     * returns the first element that matches a CSS
     * selector by traversing up the DOM tree starting
     * from (and including) the receiver element.
     * @param {string} selector - CSS selector of the matcched element
     */
    closest: {
      value: function closest (selector) {
        var matches = this.matches || this.mozMatchesSelector ||
          this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
        var element = this;
        while (element) {
          if (matches.call(element, selector)) { break; }
          element = element.parentElement;
        }
        return element;
      }
    },

    detachedCallback: {
      value: function () { /* no-op */ }
    },

    /**
     * Wait for children to load, if any.
     * Then emit `loaded` event and set `hasLoaded`.
     */
    load: {
      value: function (cb, childFilter) {
        var children;
        var childrenLoaded;
        var self = this;

        if (self.hasLoaded) { return; }

        // Default to waiting for all nodes.
        childFilter = childFilter || function (el) { return el.isNode; };

        // Wait for children to load (if any), then load.
        children = this.getChildren();
        childrenLoaded = children.filter(childFilter).map(function (child) {
          return new Promise(function waitForLoaded (resolve) {
            child.addEventListener('loaded', resolve);
          });
        });

        Promise.all(childrenLoaded).then(function emitLoaded () {
          if (cb) { cb(); }
          self.hasLoaded = true;
          self.emit('loaded', {}, false);
        });
      },
      writable: true
    },

    getChildren: {
      value: function () {
        var children = [];
        for (var i = 0; i < this.children.length; i++) {
          children.push(this.children[i]);
        }
        return children;
      }
    },

    updateMixins: {
      value: function (newMixins, oldMixins) {
        var newMixinsIds = newMixins.split(' ');
        var oldMixinsIds = oldMixins ? oldMixins.split(' ') : [];
        // To determine what listeners will be removed
        var diff = oldMixinsIds.filter(function (i) { return newMixinsIds.indexOf(i) < 0; });
        this.mixinEls = [];
        diff.forEach(this.unregisterMixin.bind(this));
        newMixinsIds.forEach(this.registerMixin.bind(this));
      }
    },

    addMixin: {
      value: function (mixinId) {
        var mixins = this.getAttribute('mixin');
        var mixinIds = mixins.split(' ');
        var i;
        for (i = 0; i < mixinIds.length; ++i) {
          if (mixinIds[i] === mixinId) { return; }
        }
        mixinIds.push(mixinId);
        this.setAttribute('mixin', mixinIds.join(' '));
      }
    },

    removeMixin: {
      value: function (mixinId) {
        var mixins = this.getAttribute('mixin');
        var mixinIds = mixins.split(' ');
        var i;
        for (i = 0; i < mixinIds.length; ++i) {
          if (mixinIds[i] === mixinId) {
            mixinIds.splice(i, 1);
            this.setAttribute('mixin', mixinIds.join(' '));
            return;
          }
        }
      }
    },

    registerMixin: {
      value: function (mixinId) {
        var mixinEl = document.querySelector('a-mixin#' + mixinId);
        if (!mixinEl) { return; }
        this.attachMixinListener(mixinEl);
        this.mixinEls.push(mixinEl);
      }
    },

    setAttribute: {
      value: function (attr, newValue) {
        if (attr === 'mixin') { this.updateMixins(newValue); }
        HTMLElement.prototype.setAttribute.call(this, attr, newValue);
      }
    },

    unregisterMixin: {
      value: function (mixinId) {
        var mixinEls = this.mixinEls;
        var mixinEl;
        var i;
        for (i = 0; i < mixinEls.length; ++i) {
          mixinEl = mixinEls[i];
          if (mixinId === mixinEl.id) {
            mixinEls.splice(i, 1);
            break;
          }
        }
        this.removeMixinListener(mixinId);
      }
    },

    removeMixinListener: {
      value: function (mixinId) {
        var observer = this.mixinObservers[mixinId];
        if (!observer) { return; }
        observer.disconnect();
        this.mixinObservers[mixinId] = null;
      }
    },

    attachMixinListener: {
      value: function (mixinEl) {
        var self = this;
        var mixinId = mixinEl.id;
        var currentObserver = this.mixinObservers[mixinId];
        if (!mixinEl) { return; }
        if (currentObserver) { return; }
        var observer = new MutationObserver(function (mutations) {
          var attr = mutations[0].attributeName;
          self.applyMixin(attr);
        });
        var config = { attributes: true };
        observer.observe(mixinEl, config);
        this.mixinObservers[mixinId] = observer;
      }
    },

    applyMixin: {
      value: function () { /* no-op */ }
    },

    /**
     * Emits a DOM event.
     *
     * @param {String} name
     *   Name of event (use a space-delimited string for multiple events).
     * @param {Object=} [detail={}]
     *   Custom data to pass as `detail` to the event.
     * @param {Boolean=} [bubbles=true]
     *   Whether the event should bubble.
     */
    emit: {
      value: function (name, detail, bubbles) {
        var self = this;
        detail = detail || {};
        if (bubbles === undefined) { bubbles = true; }
        var data = { bubbles: !!bubbles, detail: detail };
        return name.split(' ').map(function (eventName) {
          return utils.fireEvent(self, eventName, data);
        });
      }
    },

    /**
     * Returns a closure that emits a DOM event.
     *
     * @param {String} name
     *   Name of event (use a space-delimited string for multiple events).
     * @param {Object} detail
     *   Custom data (optional) to pass as `detail` if the event is to
     *   be a `CustomEvent`.
     * @param {Boolean} bubbles
     *   Whether the event should be bubble.
     */
    emitter: {
      value: function (name, detail, bubbles) {
        var self = this;
        return function () {
          self.emit(name, detail, bubbles);
        };
      }
    }
  })
});

},{"../utils/":90,"./a-register-element":53}],53:[function(_dereq_,module,exports){
// Polyfill `document.registerElement`.
_dereq_('document-register-element');

/*
 ------------------------------------------------------------
 ------------- WARNING WARNING WARNING WARNING --------------
 ------------------------------------------------------------

 This module wraps registerElement to deal with
 components that inherit from `ANode` and `AEntity`.
 It's a pass through in any other case.

 It wraps some of the prototype methods
 of the created element to make sure that the corresponding
 functions in the base classes (`AEntity` and `ANode`) are also
 invoked. The method in the base class is always called before the
 one in the derived object.

*/
var registerElement = document.registerElement;

var knownTags = module.exports.knownTags = {};

var addTagName = function (tagName) {
  knownTags[tagName.toLowerCase()] = true;
};

/**
 * Returns whether the element type is one of our known registered ones
 *
 * @param   {string} node The name of the tag to register
 * @returns {boolean} Whether the tag name matches that of our registered
 *                    custom elements
 */
module.exports.isNode = function (node) {
  return node.tagName.toLowerCase() in knownTags || node.isNode;
};

/**
 * @param   {string} tagName The name of the tag to register
 * @param   {object} obj The prototype of the new element
 * @returns {object} The prototype of the new element
 */
module.exports.registerElement = document.registerElement = function (tagName, obj) {
  var proto = Object.getPrototypeOf(obj.prototype);
  var newObj = obj;
  var isANode = ANode && proto === ANode.prototype;
  var isAEntity = AEntity && proto === AEntity.prototype;

  if (isANode || isAEntity) { addTagName(tagName); }

  // Does the element inherit from `ANode`?
  if (isANode) {
    newObj = wrapANodeMethods(obj.prototype);
    newObj = {prototype: Object.create(proto, newObj)};
  }

  // Does the element inherit from `AEntity`?
  if (isAEntity) {
    newObj = wrapAEntityMethods(obj.prototype);
    newObj = {prototype: Object.create(proto, newObj)};
  }

  return registerElement.call(document, tagName, newObj);
};

/**
 * This wraps some of the obj methods to call those on `ANode` base clase.
 * @param  {object} obj The objects that contains the methods that will be wrapped.
 * @return {object} An object with the same properties as the input parameter but
 * with some of methods wrapped.
 */
function wrapANodeMethods (obj) {
  var newObj = {};
  var ANodeMethods = [
    'attachedCallback',
    'attributeChangedCallback',
    'createdCallback'
  ];
  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
  copyProperties(obj, newObj);
  return newObj;
}

/**
 * This wraps some of the obj methods to call those on `AEntity` base class.
 * @param  {object} obj The objects that contains the methods that will be wrapped.
 * @return {object} An object with the same properties as the input parameter but
 * with some of methods wrapped.
 */
function wrapAEntityMethods (obj) {
  var newObj = {};
  var ANodeMethods = [
    'attachedCallback',
    'attributeChangedCallback',
    'createdCallback'
  ];
  var AEntityMethods = [
    'attributeChangedCallback',
    'attachedCallback',
    'createdCallback',
    'detachedCallback'
  ];
  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);
  wrapMethods(newObj, AEntityMethods, obj, AEntity.prototype);
  // Copies the remaining properties into the new object
  copyProperties(obj, newObj);
  return newObj;
}

/**
 * Wraps a list a methods to ensure that those in the base class are called through the derived one.
 * @param  {object} targetObj Object that will contain the wrapped methods
 * @param  {array} methodList List of methods from the derivedObj that will be wrapped
 * @param  {object} derivedObject Object that inherits from the baseObj
 * @param  {object} baseObj Object that derivedObj inherits from
 * @return {undefined}
 */
function wrapMethods (targetObj, methodList, derivedObj, baseObj) {
  methodList.forEach(function (methodName) {
    wrapMethod(targetObj, methodName, derivedObj, baseObj);
  });
}

/**
 * Wraps one method to ensure that the one in the base class is called before the one
 * in the derived one
 * @param  {object} obj Object that will contain the wrapped method
 * @param  {string} methodName The name of the method that will be wrapped
 * @param  {object} derivedObject Object that inherits from the baseObj
 * @param  {object} baseObj Object that derivedObj inherits from
 * @return {undefined}
 */
function wrapMethod (obj, methodName, derivedObj, baseObj) {
  var derivedMethod = derivedObj[methodName];
  var baseMethod = baseObj[methodName];
  if (!derivedMethod || !baseMethod) { return; }
  // The derived class doesn't override the one in the base one
  if (derivedMethod === baseMethod) { return; }
  // Wrapper
  // The base method is called before the one in the derived class
  var wrapperMethod = function () {
    baseMethod.apply(this, arguments);
    return derivedMethod.apply(this, arguments);
  };
  obj[methodName] = {value: wrapperMethod, writable: window.debug};
}

/**
 * It copies the properties from source to destination object
 * if they don't exist already
 * @param  {object} source The object where properties are copied from
 * @param  {type} destination The object where properties are copied to
 * @return {undefined}
 */
function copyProperties (source, destination) {
  var props = Object.getOwnPropertyNames(source);
  props.forEach(function (prop) {
    var desc;
    if (!destination[prop]) {
      desc = Object.getOwnPropertyDescriptor(source, prop);
      destination[prop] = {value: source[prop], writable: desc.writable};
    }
  });
}

var ANode = _dereq_('./a-node');
var AEntity = _dereq_('./a-entity');

},{"./a-entity":50,"./a-node":52,"document-register-element":11}],54:[function(_dereq_,module,exports){
/* global MessageChannel, Promise */
var re = _dereq_('./a-register-element');
var RStats = _dereq_('../../lib/vendor/rStats');
var THREE = _dereq_('../../lib/three');
var TWEEN = _dereq_('tween.js');
var utils = _dereq_('../utils/');
var AEntity = _dereq_('./a-entity');
var ANode = _dereq_('./a-node');
var Wakelock = _dereq_('../../lib/vendor/wakelock/wakelock');

var dummyDolly = new THREE.Object3D();
var controls = new THREE.VRControls(dummyDolly);
var DEFAULT_CAMERA_ATTR = 'data-aframe-default-camera';
var DEFAULT_LIGHT_ATTR = 'data-aframe-default-light';
var HIDDEN_CLASS = 'a-hidden';
var registerElement = re.registerElement;
var ENTER_VR_CLASS = 'a-enter-vr';
var ENTER_VR_NO_HEADSET = 'data-a-enter-vr-no-headset';
var ENTER_VR_NO_WEBVR = 'data-a-enter-vr-no-webvr';
var ENTER_VR_BTN_CLASS = 'a-enter-vr-button';
var ENTER_VR_MODAL_CLASS = 'a-enter-vr-modal';
var ORIENTATION_MODAL_CLASS = 'a-orientation-modal';
var isMobile = utils.isMobile();

/**
 * Scene element, holds all entities.
 *
 * @member {number} animationFrameID
 * @member {array} behaviors - Component instances that have registered themselves to be
           updated on every tick.
 * @member {object} canvas
 * @member {Element} enterVREl
 * @member {bool} insideIframe
 * @member {bool} insideLoader
 * @member {bool} isScene - Differentiates this as a scene entity as opposed
           to other `AEntity`s.
 * @member {bool} isMobile - Whether browser is mobile (via UA detection).
 * @member {object} object3D - The root three.js Scene object.
 * @member {object} monoRenderer
 * @member {object} renderer
 * @member {bool} renderStarted
 * @member {object} stats
 * @member {object} stereoRenderer
 * @member {object} wakelock
 */
var AScene = module.exports = registerElement('a-scene', {
  prototype: Object.create(AEntity.prototype, {
    createdCallback: {
      value: function () {
        this.defaultLightsEnabled = true;
        this.enterVREl = null;
        this.insideIframe = window.top !== window.self;
        this.insideLoader = false;
        this.isScene = true;
        this.object3D = new THREE.Scene();
        this.init();
      }
    },

    init: {
      value: function () {
        this.isMobile = isMobile;
        this.behaviors = [];
        this.materials = {};
        this.paused = true;
        this.hasLoaded = false;
        this.originalHTML = this.innerHTML;
        this.setupCanvas();
        this.setupRenderer();
        this.resizeCanvas();
        this.setupDefaultLights();
        this.setupDefaultCamera();
      },
      writable: true
    },

    attachedCallback: {
      value: function () {
        if (this.isMobile) {
          injectMetaTags();
          this.wakelock = new Wakelock();
        }
        this.attachEventListeners();
        this.play();
      },
      writable: window.debug
    },

    attachEventListeners: {
      value: function () {
        var resizeCanvas = this.resizeCanvas.bind(this);
        this.setupKeyboardShortcuts();
        this.attachFullscreenListeners();
        this.attachOrientationListeners();
        // For Chrome (https://github.com/aframevr/aframe-core/issues/321).
        window.addEventListener('load', resizeCanvas);
      }
    },

    /**
     * Handle stats.
     * TODO: move stats to a component.
     */
    attributeChangedCallback: {
      value: function (attr, oldVal, newVal) {
        if (oldVal === newVal) { return; }
        if (attr === 'stats') { this.setupStats(); }
      }
    },

    /**
     * Shuts down scene on detach.
     */
    detachedCallback: {
      value: function () {
        window.cancelAnimationFrame(this.animationFrameID);
        this.animationFrameID = null;
      }
    },

    /**
     * @param {object} behavior - Generally a component. Must implement a .update() method to
     *        be called on every tick.
     */
    addBehavior: {
      value: function (behavior) {
        this.behaviors.push(behavior);
      }
    },

    attachOrientationListeners: {
      value: function (e) {
        window.addEventListener('orientationchange', this.showOrientationModal.bind(this));
      }
    },

    showOrientationModal: {
      value: function () {
        if (!utils.isIOS()) { return; }
        if (!utils.isLandscape() && this.renderer === this.stereoRenderer) {
          this.orientationModal.classList.remove(HIDDEN_CLASS);
        } else {
          this.orientationModal.classList.add(HIDDEN_CLASS);
        }
      }
    },

    /**
     * Switch back to mono renderer if no longer in fullscreen VR.
     * Lock to landscape orientation on mobile when fullscreen.
     */
    attachFullscreenListeners: {
      value: function () {
        function fullscreenChange (e) {
          var fsElement = document.fullscreenElement ||
                          document.mozFullScreenElement ||
                          document.webkitFullscreenElement;
          if (window.screen.orientation) {
            // Lock to landscape orientation on mobile.
            if (fsElement && this.isMobile) {
              window.screen.orientation.lock('landscape');
            } else {
              window.screen.orientation.unlock();
            }
          }
          if (!fsElement) {
            this.showUI();
            this.setMonoRenderer();
          }
          if (this.wakelock) { this.wakelock.release(); }
        }
        document.addEventListener('mozfullscreenchange',
                                  fullscreenChange.bind(this));
        document.addEventListener('webkitfullscreenchange',
                                  fullscreenChange.bind(this));
      }
    },

    /**
     * Handles VR and fullscreen behavior for when we are inside an iframe.
     */
    attachMessageListeners: {
      value: function () {
        var self = this;
        window.addEventListener('message', function (e) {
          if (e.data) {
            switch (e.data.type) {
              case 'loaderReady': {
                self.insideLoader = true;
                self.removeEnterVRButton();
                break;
              }
              case 'fullscreen': {
                switch (e.data.data) {
                  // Set renderer with fullscreen VR enter and exit.
                  case 'enter':
                    self.setStereoRenderer();
                    break;
                  case 'exit':
                    self.setMonoRenderer();
                    break;
                }
              }
            }
          }
        });
      }
    },

    /**
     * Enters VR when ?mode=vr is specified in the querystring.
     */
    checkUrlParameters: {
      value: function () {
        var mode = utils.getUrlParameter('mode');
        if (mode === 'vr') {
          this.enterVR();
        }

        var ui = utils.getUrlParameter('ui');
        if (ui === 'false') {
          this.hideUI();
        }
      }
    },

    enterVR: {
      value: function () {
        this.hideUI();
        this.setStereoRenderer();
        this.setFullscreen();
        this.showOrientationModal();
      }
    },

    exitVR: {
      value: function () {
        this.showUI();
        this.setMonoRenderer();
        this.orientationModal.classList.add(HIDDEN_CLASS);
      }
    },

    getCanvasSize: {
      value: function () {
        var canvas = this.canvas;
        if (this.isMobile) {
          return {
            height: window.innerHeight,
            width: window.innerWidth
          };
        }
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        return {
          height: canvas.offsetHeight,
          width: canvas.offsetWidth
        };
      }
    },

    hideUI: {
      value: function () {
        if (this.statsEl) {
          this.statsEl.classList.add(HIDDEN_CLASS);
        }
        if (this.enterVREl) {
          this.enterVREl.classList.add(HIDDEN_CLASS);
        }
      }
    },

    /**
     * Sets a camera to be used by the renderer
     * It alse removes the default one if any and disables any other camera
     * in the scene
     *
     * @param {object} el - object holding an entity with a camera component or THREE camera.
     */
    setActiveCamera: {
      value: function (newCamera) {
        var defaultCameraWrapper = document.querySelector('[' + DEFAULT_CAMERA_ATTR + ']');
        var defaultCameraEl = defaultCameraWrapper && defaultCameraWrapper.querySelector('[camera]');
        if (newCamera instanceof AEntity) {
          newCamera.setAttribute('camera', 'active', true);
          if (newCamera !== defaultCameraEl) { this.removeDefaultCamera(); }
          return;
        }
        this.camera = newCamera;
        this.updateCameras();
      }
    },

    /**
     * Enables active camera and disables the rest
     * @type object - activeCamera - The camera used by the renderer
     */
    updateCameras: {
      value: function () {
        var activeCamera = this.camera;
        var activeCameraEl = activeCamera && activeCamera.el;
        var cameraEl;
        var sceneCameras = this.querySelectorAll('[camera]');
        var i;
        if (!activeCamera) {
          activeCameraEl = sceneCameras[sceneCameras.length - 1];
          activeCameraEl.setAttribute('camera', 'active', true);
          return;
        }

        for (i = 0; i < sceneCameras.length; ++i) {
          cameraEl = sceneCameras[i];

          if (activeCameraEl === cameraEl) {
            if (!this.paused) { activeCameraEl.play(); }
            continue;
          }
          cameraEl.setAttribute('camera', 'active', false);
          cameraEl.pause();
        }
      }
    },

    removeDefaultCamera: {
      value: function () {
        var cameraEl = this.camera && this.camera.el;
        if (!cameraEl) { return; }
        // Removes default camera if any
        var defaultCamera = document.querySelector('[' + DEFAULT_CAMERA_ATTR + ']');
        var defaultCameraEl = defaultCamera && defaultCamera.querySelector('[camera]');
        // Remove default camera if any
        if (defaultCameraEl && defaultCameraEl !== cameraEl) {
          this.removeChild(defaultCamera);
        }
      }
    },

    /**
     * Notify scene that light has been added and to remove the default.
     *
     * @param {object} el - element holding the light component.
     */
    registerLight: {
      value: function (el) {
        var defaultLights;
        if (this.defaultLightsEnabled && !el.hasAttribute(DEFAULT_LIGHT_ATTR)) {
          // User added a light, remove default lights through DOM.
          defaultLights = document.querySelectorAll('[' + DEFAULT_LIGHT_ATTR + ']');
          for (var i = 0; i < defaultLights.length; i++) {
            this.removeChild(defaultLights[i]);
          }
          this.defaultLightsEnabled = false;
        }
      }
    },

    /**
     * Keep track of material in case an update trigger is needed (e.g., fog).
     *
     * @param {object} material
     */
    registerMaterial: {
      value: function (material) {
        this.materials[material.uuid] = material;
      }
    },

    /**
     * @param {object} behavior - Generally a component. Has registered itself to behaviors.
     */
    removeBehavior: {
      value: function (behavior) {
        var behaviors = this.behaviors;
        var index = behaviors.indexOf(behavior);
        if (index === -1) { return; }
        behaviors.splice(index, 1);
      }
    },

    removeEnterVR: {
      value: function () {
        if (this.enterVREl) {
          this.enterVREl.parentNode.removeChild(this.enterVREl);
        }
      }
    },

    resizeCanvas: {
      value: function () {
        var camera = this.camera;
        // It's possible that the camera is not injected yet.
        if (!camera) { return; }
        var size = this.getCanvasSize();
        // Updates camera
        camera.aspect = size.width / size.height;
        camera.updateProjectionMatrix();
        // Notify the renderer of the size change
        this.renderer.setSize(size.width, size.height, true);
      },
      writable: window.debug
    },

    /**
     * Manually handles fullscreen for non-VR mobile where the renderer' VR
     * display is not polyfilled. Also sets wakelock for mobile in the process.
     *
     * Desktop just works so use the renderer.setFullScreen in that case.
     */
    setFullscreen: {
      value: function () {
        var canvas = this.canvas;

        if (!this.isMobile) {
          this.stereoRenderer.setFullScreen(true);
          return;
        }

        if (this.wakelock) { this.wakelock.request(); }

        if (canvas.requestFullscreen) {
          canvas.requestFullscreen();
        } else if (canvas.mozRequestFullScreen) {
          canvas.mozRequestFullScreen();
        } else if (canvas.webkitRequestFullscreen) {
          canvas.webkitRequestFullscreen();
        }
      }
    },

    /**
     * Sets renderer to mono (one eye) and resizes canvas.
     */
    setMonoRenderer: {
      value: function () {
        this.renderer = this.monoRenderer;
        this.resizeCanvas();
      }
    },

    /**
     * Sets renderer to stereo (two eyes) and resizes canvas.
     */
    setStereoRenderer: {
      value: function () {
        this.renderer = this.stereoRenderer;
        this.resizeCanvas();
      }
    },

    setupCanvas: {
      value: function () {
        var canvasSelector = this.getAttribute('canvas');
        var canvas;

        if (canvasSelector) {
          canvas = this.canvas = document.querySelector(canvasSelector);
        } else {
          canvas = this.canvas = document.createElement('canvas');
          this.appendChild(canvas);
        }
        canvas.classList.add('a-canvas');
        // Prevents overscroll on mobile devices.
        canvas.addEventListener('touchmove', function (evt) {
          evt.preventDefault();
        });

        window.addEventListener('resize', this.resizeCanvas.bind(this), false);
        return canvas;
      }
    },

    /**
     * Creates a default camera if user has not added one during the initial.
     * scene traversal.
     *
     * Default camera height is at human level (~1.8m) and back such that
     * entities at the origin (0, 0, 0) are well-centered.
     */
    setupDefaultCamera: {
      value: function () {
        var cameraWrapperEl;
        var defaultCamera;
        var sceneCameras = this.querySelectorAll('[camera]');
        if (sceneCameras.length !== 0) { return; }

        // DOM calls to create camera.
        cameraWrapperEl = document.createElement('a-entity');
        cameraWrapperEl.setAttribute('position', {x: 0, y: 1.8, z: 4});
        cameraWrapperEl.setAttribute(DEFAULT_CAMERA_ATTR, '');
        defaultCamera = document.createElement('a-entity');
        defaultCamera.setAttribute('camera', {'active': true});
        defaultCamera.setAttribute('wasd-controls');
        defaultCamera.setAttribute('look-controls');
        cameraWrapperEl.appendChild(defaultCamera);
        this.appendChild(cameraWrapperEl);
      }
    },

    /**
     * Prescibe default lights to the scene.
     * Does so by injecting markup such that this state is not invisible.
     * These lights are removed if the user adds any lights.
     */
    setupDefaultLights: {
      value: function () {
        var ambientLight = document.createElement('a-entity');
        ambientLight.setAttribute('light',
                                  {color: '#fff', type: 'ambient'});
        ambientLight.setAttribute(DEFAULT_LIGHT_ATTR, '');
        this.appendChild(ambientLight);

        var directionalLight = document.createElement('a-entity');
        directionalLight.setAttribute('light', { color: '#fff', intensity: 0.2 });
        directionalLight.setAttribute('position', { x: -1, y: 2, z: 1 });
        directionalLight.setAttribute(DEFAULT_LIGHT_ATTR, '');
        this.appendChild(directionalLight);
      }
    },

    setupEnterVR: {
      value: function () {
        if (this.enterVREl) { return; }
        this.enterVREl = createEnterVR(this.enterVR.bind(this));
        document.body.appendChild(this.enterVREl);
      }
    },

    setupOrientationModal: {
      value: function () {
        var modal = this.orientationModal = document.createElement('div');
        modal.className = ORIENTATION_MODAL_CLASS;
        modal.classList.add(HIDDEN_CLASS);

        var exit = document.createElement('button');
        exit.innerHTML = 'Exit VR';
        exit.addEventListener('click', this.exitVR.bind(this));
        modal.appendChild(exit);

        document.body.appendChild(modal);
      }
    },

    /**
     * Set up keyboard shortcuts to:
     *   - Enter VR when `f` is pressed.
     *   - Reset sensor when `z` is pressed.
     */
    setupKeyboardShortcuts: {
      value: function () {
        var self = this;
        window.addEventListener('keyup', function (event) {
          if (event.keyCode === 70) {  // f.
            self.enterVR();
          }
          if (event.keyCode === 90) {  // z.
            controls.resetSensor();
          }
        }, false);
      }
    },

    /**
     * Checks for VR mode before kicking off render loop.
     */
    setupLoader: {
      value: function () {
        var self = this;

        if (self.insideIframe) {
          self.attachMessageListeners();
          self.vrLoaderMode().then(function (isVr) {
            if (isVr) {
              self.setStereoRenderer();
            } else {
              self.setMonoRenderer();
            }
            window.top.postMessage({type: 'ready'}, '*');
          });
        }
        if (!self.insideLoader) {
          self.setupEnterVR();
          self.setupOrientationModal();
        }
      }
    },

    setupRenderer: {
      value: function () {
        var canvas = this.canvas;
        // Set at startup. To enable/disable antialias
        // at runttime we would have to recreate the whole context
        var antialias = this.getAttribute('antialias') === 'true';
        var renderer = this.renderer = this.monoRenderer =
          new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: antialias,
            alpha: true
          });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.sortObjects = false;
        AScene.renderer = renderer;
        this.stereoRenderer = new THREE.VREffect(renderer);
      },
      writable: window.debug
    },

    /**
     * TODO: move stats to component.
     */
    setupStats: {
      value: function () {
        var statsEnabled = this.getAttribute('stats') === 'true';
        var statsEl = this.statsEl = document.querySelector('.rs-base');
        if (!statsEnabled) {
          if (statsEl) { statsEl.classList.add(HIDDEN_CLASS); }
          return;
        }
        if (statsEl) { statsEl.classList.remove(HIDDEN_CLASS); }
        if (this.stats) { return; }
        this.stats = new RStats({
          CSSPath: '../../style/',
          values: {
            fps: { caption: 'fps', below: 30 }
          },
          groups: [
            { caption: 'Framerate', values: [ 'fps', 'raf' ] }
          ]
        });
        this.statsEl = document.querySelector('.rs-base');
      }
    },

    showUI: {
      value: function () {
        var statsEnabled = this.getAttribute('stats') === 'true';
        if (statsEnabled) {
          this.statsEl.classList.remove(HIDDEN_CLASS);
        }
        if (this.enterVREl) {
          this.enterVREl.classList.remove(HIDDEN_CLASS);
        }
      }
    },

    /**
     * Handler attached to elements to help scene know when to kick off.
     * Scene waits for all entities to load.
     */
    play: {
      value: function () {
        if (this.renderStarted) {
          AEntity.prototype.play.call(this);
          return;
        }

        this.addEventListener('loaded', function () {
          var self = this;
          if (this.renderStarted) { return; }

          this.setupLoader();
          AEntity.prototype.play.call(self);
          self.setupStats();
          self.resizeCanvas();
          // Kick off render loop.
          self.render();
          self.renderStarted = true;
          self.emit('renderstart');
          self.checkUrlParameters();
        });

        AEntity.prototype.load.call(this);
      }
    },

    /**
     * Stops tracking material.
     *
     * @param {object} material
     */
    unregisterMaterial: {
      value: function (material) {
        delete this.materials[material.uuid];
      }
    },

    /**
     * Trigger update to all registered materials.
     */
    updateMaterials: {
      value: function (material) {
        var materials = this.materials;
        Object.keys(materials).forEach(function (uuid) {
          materials[uuid].needsUpdate = true;
        });
      },
      writable: window.debug
    },

    /**
     * @returns {object} Promise that resolves a bool whether loader is in VR
     *          mode.
     */
    vrLoaderMode: {
      value: function () {
        return new Promise(function (resolve) {
          var channel = new MessageChannel();
          window.top.postMessage({type: 'checkVr'}, '*', [channel.port2]);
          channel.port1.onmessage = function (message) {
            resolve(!!message.data.data.isVr);
          };
        });
      }
    },

    /**
     * The render loop.
     *
     * Updates stats.
     * Updates animations.
     * Updates behaviors.
     * Renders with request animation frame.
     */
    render: {
      value: function (t) {
        var camera = this.camera;
        var stats = this.stats;

        if (stats) {
          stats('rAF').tick();
          stats('FPS').frame();
        }
        TWEEN.update(t);
        this.behaviors.forEach(function (behavior) {
          behavior.update();
        });
        this.renderer.render(this.object3D, camera);
        if (stats) { stats().update(); }
        this.animationFrameID = window.requestAnimationFrame(
          this.render.bind(this));
      },
      writable: window.debug
    },

    /**
     * Reloads the scene to the original DOM content
     * @type {bool} - paused - It reloads the scene with all the
     * dynamic behavior paused: dynamic components and animations
     */
    reload: {
      value: function (paused) {
        var self = this;
        if (paused) { this.pause(); }
        this.innerHTML = this.originalHTML;
        this.init();
        ANode.prototype.load.call(this, play);
        function play () {
          if (self.paused) { return; }
          AEntity.prototype.play.call(self);
        }
      }
    }

  })
});

/**
 * Creates Enter VR flow (button and compatibility modal).
 *
 * Creates a button that when clicked will enter into stereo-rendering mode for VR.
 *
 * For compatibility:
 *   - Mobile always has compatibility via polyfill.
 *   - If desktop browser does not have WebVR excluding polyfill, disable button, show modal.
 *   - If desktop browser has WebVR excluding polyfill but not headset connected,
 *     don't disable button, but show modal.
 *   - If desktop browser has WebVR excluding polyfill and has headset connected, then
 *     then no modal.
 *
 * Structure: <div><modal/><button></div>
 *
 * @returns {Element} Wrapper <div>.
 */
function createEnterVR (enterVRHandler) {
  var compatModal;
  var compatModalLink;
  var compatModalText;
  // window.hasNativeVRSupport is set in src/aframe-core.js.
  var hasWebVR = isMobile || window.hasNonPolyfillWebVRSupport;
  var orientation;
  var vrButton;
  var wrapper;

  // Create elements.
  wrapper = document.createElement('div');
  wrapper.classList.add(ENTER_VR_CLASS);
  compatModal = document.createElement('div');
  compatModal.className = ENTER_VR_MODAL_CLASS;
  compatModalText = document.createElement('p');
  compatModalLink = document.createElement('a');
  compatModalLink.setAttribute('href', 'http://mozvr.com/#start');
  compatModalLink.setAttribute('target', '_blank');
  compatModalLink.innerHTML = 'Learn more.';
  vrButton = document.createElement('button');
  vrButton.className = ENTER_VR_BTN_CLASS;

  // Insert elements.
  if (compatModal) {
    compatModal.appendChild(compatModalText);
    compatModal.appendChild(compatModalLink);
    wrapper.appendChild(compatModal);
  }
  wrapper.appendChild(vrButton);

  if (!checkHeadsetConnected() && !isMobile) {
    compatModalText.innerHTML = 'Your browser supports WebVR. To enter VR, connect a headset, or use a mobile phone.';
    wrapper.setAttribute(ENTER_VR_NO_HEADSET, '');
  }

  // Handle enter VR flows.
  if (!hasWebVR) {
    compatModalText.innerHTML = 'Your browser does not support WebVR. To enter VR, use a VR-compatible browser or a mobile phone.';
    wrapper.setAttribute(ENTER_VR_NO_WEBVR, '');
  } else {
    vrButton.addEventListener('click', enterVRHandler);
  }
  return wrapper;

  /**
   * Check for headset connection by looking at orientation {0 0 0}.
   */
  function checkHeadsetConnected () {
    controls.update();
    orientation = dummyDolly.quaternion;
    if (orientation._x !== 0 || orientation._y !== 0 || orientation._z !== 0) {
      return true;
    }
  }
}

/**
 * Injects the necessary metatags in the document for mobile support to:
 * 1. Prevent the user to zoom in the document
 * 2. Ensure that window.innerWidth and window.innerHeight have the correct
 *    values and the canvas is properly scaled
 * 3. To allow fullscreen mode when pinning a web app on the home screen on
 *    iOS.
 * Adapted from: https://www.reddit.com/r/web_design/comments/3la04p/
 *
 * @type {Object}
 */
function injectMetaTags () {
  var headEl;
  var meta = document.querySelector('meta[name="viewport"]');
  if (meta) { return; }  // Already exists.

  headEl = document.getElementsByTagName('head')[0];
  meta = document.createElement('meta');
  meta.name = 'viewport';
  meta.content =
    'width=device-width,initial-scale=1,shrink-to-fit=no,user-scalable=no';
  headEl.appendChild(meta);

  // iOS-specific meta tags for fullscreen when pinning to homescreen.
  meta = document.createElement('meta');
  meta.name = 'apple-mobile-web-app-capable';
  meta.content = 'yes';
  headEl.appendChild(meta);

  meta = document.createElement('meta');
  meta.name = 'apple-mobile-web-app-status-bar-style';
  meta.content = 'black';
  headEl.appendChild(meta);
}

},{"../../lib/three":1,"../../lib/vendor/rStats":4,"../../lib/vendor/wakelock/wakelock":6,"../utils/":90,"./a-entity":50,"./a-node":52,"./a-register-element":53,"tween.js":26}],55:[function(_dereq_,module,exports){
/* global HTMLElement */
var debug = _dereq_('../utils/debug');
var propertyTypes = _dereq_('./propertyTypes').propertyTypes;
var schema = _dereq_('./schema');
var styleParser = _dereq_('style-attr');
var utils = _dereq_('../utils/');

var parseProperties = schema.parseProperties;
var parseProperty = schema.parseProperty;
var isSingleProp = schema.isSingleProperty;
var processSchema = schema.process;
var error = debug('core:register-component:error');

var components = module.exports.components = {};  // Keep track of registered components.

/**
 * Component class definition.
 *
 * Components configure appearance, modify behavior, or add functionality to
 * entities. The behavior and appearance of an entity can be changed at runtime
 * by adding, removing, or updating components. Entities do not share instances
 * of components.
 *
 * @namespace Component
 * @property {object} data - Stores component data, populated by parsing the
 *           attribute name of the component plus applying defaults and mixins.
 * @property {object} el - Reference to the entity element.
 * @property {string} name - Name of the attribute the component is connected
 *           to.
 * @member {Element} el
 * @member {object} data
 * @member {function} getData
 * @member {function} init
 * @member {function} update
 * @member {function} remove
 * @member {function} parse
 * @member {function} stringify
 */
var Component = module.exports.Component = function (el) {
  var rawData = HTMLElement.prototype.getAttribute.call(el, this.name);
  this.el = el;
  this.data = {};
  this.buildData(this.parse(rawData));
  this.init();
  this.update();
};

Component.prototype = {
  /**
   * Contains the type schema and defaults for the data values.
   * Data is coerced into the types of the values of the defaults.
   */
  schema: {},

  /**
   * Init handler. Similar to attachedCallback.
   * Called during component initialization and is only run once.
   * Components can use this to set initial state.
   */
  init: function () { /* no-op */ },

  /**
   * Called to start any dynamic behavior
   * like animations, AI, physics.
   */
  play: function () { /* no-op */ },

  /**
   * Called to stop any dynamic behavior
   * like animations, AI, physics.
   */
  pause: function () { /* no-op */ },

  /**
   * Update handler. Similar to attributeChangedCallback.
   * Called whenever component's data changes.
   * Also called on component initialization when the component receives initial data.
   *
   * @param {object} previousData - Previous attributes of the component.
   */
  update: function (previousData) { /* no-op */ },

  /**
   * Remove handler. Similar to detachedCallback.
   * Called whenever component is removed from the entity (i.e., removeAttribute).
   * Components can use this to reset behavior on the entity.
   */
  remove: function () { /* no-op */ },

  /**
   * Parses each property based on property type.
   * If component is single-property, then parses the single property value.
   *
   * @param {string} value - HTML attribute value.
   * @returns {object} Component data.
   */
  parse: function (value) {
    var typeName;
    var type;

    if (isSingleProp(this.schema)) {
      typeName = this.schema.type;
      type = propertyTypes[typeName];
      if (type) { return type.parse.call(this, value); }
      return error(typeName + ' is not a valid type.');
    }

    return objectParse(value);
  },

  /**
   * Stringifies each property based on property type.
   * If component is single-property, then stringifies the single property value.
   *
   * @param {object} data
   * @returns {string}
   */
  stringify: function (data) {
    var typeName;
    var type;

    if (isSingleProp(this.schema)) {
      typeName = this.schema.type;
      type = propertyTypes[typeName];
      if (type) { return type.stringify.call(this, data); }
      return error(typeName + ' is not a valid type.');
    }

    return objectStringify(data);
  },

  /**
   * Returns a copy of data such that we don't expose the private this.data.
   *
   * @returns {object} data
   */
  getData: function () {
    var data = this.data;
    if (typeof data !== 'object') { return data; }
    return utils.extend({}, data);
  },

  /**
   * Called when new value is coming from the entity (e.g., attributeChangedCb)
   * or from its mixins. Does some parsing and applying before updating the
   * component.
   * Does not update if data has not changed.
   *
   * @param {string} value - HTML attribute value.
   */
  updateProperties: function (value) {
    var isSinglePropSchema = isSingleProp(this.schema);
    var previousData = extendProperties({}, this.data, isSinglePropSchema);
    this.buildData(this.parse(value));

    // Don't update if properties haven't changed
    if (!isSinglePropSchema && utils.deepEqual(previousData, this.data)) { return; }

    this.update(previousData);

    this.el.emit('componentchanged', {
      name: this.name,
      newData: this.getData(),
      oldData: previousData
    });
  },

  /**
   * Builds component data from the current state of the entity, ultimately
   * updating this.data.
   *
   * If the component was detached completely, set data to null.
   *
   * Precedence:
   * 1. Defaults data
   * 2. Mixin data.
   * 3. Attribute data.
   *
   * Finally coerce the data to the types of the defaults.
   */
  buildData: function (newData) {
    var self = this;
    var data = {};
    var schema = self.schema;
    var isSinglePropSchema = isSingleProp(schema);
    var el = self.el;
    var mixinEls = el.mixinEls;
    var name = self.name;

    // 1. Default values (lowest precendence).
    if (isSinglePropSchema) {
      data = schema.default;
    } else {
      Object.keys(schema).forEach(function applyDefault (key) {
        data[key] = schema[key].default;
      });
    }

    // 2. Mixin values.
    mixinEls.forEach(applyMixin);
    function applyMixin (mixinEl) {
      var mixinData = mixinEl.getAttribute(name);
      extendProperties(data, mixinData, isSinglePropSchema);
    }

    // 3. Attribute values (highest precendence).
    data = extendProperties(data, newData, isSinglePropSchema);

    // Parse and coerce using the schema.
    if (isSinglePropSchema) {
      this.data = parseProperty(data, schema);
    } else {
      this.data = parseProperties(data, schema);
    }
  }
};

/**
 * Registers a component to A-Frame.
 *
 * @param {string} name - Component name.
 * @param {object} definition - Component property and methods.
 * @returns {object} Component.
 */
module.exports.registerComponent = function (name, definition) {
  var NewComponent;
  var proto = {};

  // Format definition object to prototype object.
  Object.keys(definition).forEach(function (key) {
    proto[key] = {
      value: definition[key],
      writable: true
    };
  });

  if (components[name]) {
    error('The component "' + name + '" has been already registered');
  }
  NewComponent = function (el) {
    Component.call(this, el);
  };
  NewComponent.prototype = Object.create(Component.prototype, proto);
  NewComponent.prototype.name = name;
  NewComponent.prototype.constructor = NewComponent;
  components[name] = {
    Component: NewComponent,
    dependencies: NewComponent.prototype.dependencies,
    parse: NewComponent.prototype.parse.bind(NewComponent.prototype),
    schema: processSchema(NewComponent.prototype.schema),
    stringify: NewComponent.prototype.stringify.bind(NewComponent.prototype),
    type: NewComponent.prototype.type
  };
  return NewComponent;
};

/**
 * Deserializes style-like string into an object of properties.
 *
 * @param {string} value - HTML attribute value.
 * @returns {object} Property data.k
 */
function objectParse (value) {
  var parsedData;
  if (typeof value !== 'string') { return value; }
  parsedData = styleParser.parse(value);
  return transformKeysToCamelCase(parsedData);
}

/**
 * Serialize an object of properties into a style-like string.
 *
 * @param {object} data - Property data.
 * @returns {string}
 */
function objectStringify (data) {
  if (typeof data === 'string') { return data; }
  return styleParser.stringify(data);
}

/**
* Object extending with checking for single-property schema.
*
* @param dest - Destination object or value.
* @param source - Source object or value
* @param {boolean} isSinglePropSchema - Whether or not schema is only a single property.
* @returns Overridden object or value.
*/
function extendProperties (dest, source, isSinglePropSchema) {
  if (isSinglePropSchema) {
    if (source === undefined) { return dest; }
    return source;
  }
  return utils.extend(dest, source);
}

/**
 * Converts string from hyphen to camelCase.
 *
 * @param {string} str - String to camelCase.
 * @return {string} CamelCased string.
 */
function toCamelCase (str) {
  return str.replace(/-([a-z])/g, camelCase);
  function camelCase (g) { return g[1].toUpperCase(); }
}

/**
 * Converts object's keys from hyphens to camelCase (e.g., `max-value` to
 * `maxValue`).
 *
 * @param {object} obj - The object to camelCase keys.
 * @return {object} The object with keys camelCased.
 */
function transformKeysToCamelCase (obj) {
  var keys = Object.keys(obj);
  var camelCaseObj = {};
  keys.forEach(function (key) {
    var camelCaseKey = toCamelCase(key);
    camelCaseObj[camelCaseKey] = obj[key];
  });
  return camelCaseObj;
}

},{"../utils/":90,"../utils/debug":89,"./propertyTypes":56,"./schema":57,"style-attr":18}],56:[function(_dereq_,module,exports){
var coordinates = _dereq_('../utils/coordinates');
var debug = _dereq_('debug');

var error = debug('core:propertyTypes:warn');

var propertyTypes = module.exports.propertyTypes = {};

// Built-in property types.
registerPropertyType('boolean', false, boolParse);
registerPropertyType('int', 0, intParse);
registerPropertyType('number', 0, numberParse);
registerPropertyType('selector', '', selectorParse, selectorStringify);
registerPropertyType('string', '', defaultParse, defaultStringify);
registerPropertyType('vec3', { x: 0, y: 0, z: 0 }, coordinates.parse, coordinates.stringify);

/**
 * Register a parser for re-use such that when someone uses `type` in the schema,
 * `schema.process` will set the property `parse` and `stringify`.
 *
 * @param {string} type - Type name.
 * @param [defaultValue=null] -
 *   Default value to use if component does not define default value.
 * @param {function} [parse=defaultParse] - Parse string function.
 * @param {function} [stringify=defaultStringify] - Stringify to DOM function.
 */
function registerPropertyType (type, defaultValue, parse, stringify) {
  if ('type' in propertyTypes) {
    error('Property type "' + type + '" is already registered.');
    return;
  }

  propertyTypes[type] = {
    default: defaultValue,
    parse: parse || defaultParse,
    stringify: stringify || defaultStringify
  };
}
module.exports.registerPropertyType = registerPropertyType;

function defaultParse (value) {
  return value;
}

function defaultStringify (value) {
  return value.toString();
}

function boolParse (value) {
  return value !== 'false' && value !== false;
}

function intParse (value) {
  return parseInt(value, 10);
}

function numberParse (value) {
  return parseFloat(value, 10);
}

function selectorParse (value) {
  if (!value) { return null; }
  return document.querySelector(value);
}

function selectorStringify (el) {
  // Currently no way to infer the selector used for this component.
  if (el) { return '#' + el.getAttribute('id'); }
  return '';
}

},{"../utils/coordinates":88,"debug":9}],57:[function(_dereq_,module,exports){
var debug = _dereq_('debug');
var propertyTypes = _dereq_('./propertyTypes').propertyTypes;

var warn = debug('core:schema:warn');

/**
 * A schema is classified as a schema for a single property if:
 * - `type` is defined on the schema as a string.
 * - OR `default` is defined on the schema, as a reserved keyword.
 * - OR schema is empty.
 */
function isSingleProperty (schema) {
  if ('type' in schema) {
    return typeof schema.type === 'string';
  }
  return 'default' in schema || Object.keys(schema).length === 0;
}
module.exports.isSingleProperty = isSingleProperty;

/**
 * Build step to schema to use `type` to inject default value, parser, and stringifier.
 *
 * @param {object} schema
 * @returns {object} Schema.
 */
module.exports.process = function (schema) {
  // For single property schema, run processPropDefinition over the whole schema.
  if (isSingleProperty(schema)) {
    return processPropertyDefinition(schema);
  }

  // For multi-property schema, run processPropDefinition over each property definition.
  Object.keys(schema).forEach(function (propName) {
    schema[propName] = processPropertyDefinition(schema[propName]);
  });
  return schema;
};

/**
 * Inject default value, parser, stringifier for single property.
 */
function processPropertyDefinition (propDefinition) {
  var propType;
  var defaultVal = propDefinition.default;
  var typeName = propDefinition.type;

  if (!propDefinition.type) {
    if (defaultVal !== undefined && ['boolean', 'number'].indexOf(typeof defaultVal) !== -1) {
      // Type inference.
      typeName = typeof defaultVal;
    } else {
      // Fall back to string.
      typeName = 'string';
    }
  } else if (propDefinition.type === 'bool') {
    typeName = 'boolean';
  } else if (propDefinition.type === 'float') {
    typeName = 'number';
  }

  propType = propertyTypes[typeName];

  if (!propType) {
    warn('Unknown property type: ' + typeName);
    return propDefinition;
  }

  propDefinition.parse = propType.parse;
  propDefinition.stringify = propType.stringify;
  propDefinition.type = typeName;
  if (!('default' in propDefinition)) {
    propDefinition.default = propType.default;
  }

  return propDefinition;
}
module.exports.processPropertyDefinition = processPropertyDefinition;

/**
 * If `value` is object, parse values of `val` into types defined by `schema`.
 *
 * @param {object|string} value - value(s) to coerce.
 * @param {object} schema - Object which values will be used to coerce to.
 * @returns Coerced value or object.
 */
module.exports.parseProperties = function (propData, schema) {
  Object.keys(schema).forEach(function (propName) {
    var propDefinition = schema[propName];
    if (!propDefinition) {
      warn('Unknown component property: ' + propName);
      return;
    }

    var propValue = propData[propName];
    propValue = propValue === undefined ? propDefinition.default : propValue;
    propData[propName] = parseProperty(propValue, propDefinition);
  });

  return propData;
};

function parseProperty (value, propDefinition) {
  // Already parsed by component `buildData` setting default value.
  // TODO: Move that logic to the schema.
  if (typeof value !== 'string') { return value; }
  if (typeof value === 'undefined') { return value; }
  return propDefinition.parse(value);
}
module.exports.parseProperty = parseProperty;

},{"./propertyTypes":56,"debug":9}],58:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-click', 'click');

},{"../lib/utils":70}],59:[function(_dereq_,module,exports){
/* global HTMLElement */

var utils = _dereq_('../lib/utils');

var registerElement = _dereq_('../../core/a-register-element').registerElement;
var stateEls = {};
var listeners = {};
var targetData = {};

var attributeBlacklist = {
  // TODO: Consider ignoring unique attributes too
  // (e.g., `class`, `id`, `name`, etc.).
  target: true
};

// State management

function addState (el, state) {
  el.addState(state);
  recordState(el, state);
}

function recordState (el, state) {
  if (state in stateEls) {
    stateEls[state].push(el);
  } else {
    stateEls[state] = [el];
  }
}

function unrecordState (el, state) {
  if (!(state in stateEls)) { return; }
  var elIdx = stateEls[state].indexOf(el);
  if (elIdx === -1) { return; }
  stateEls[state].splice(elIdx, 1);
}

function removeState (el, state) {
  el.removeState(state);
  unrecordState(el, state);
}

function hasState (el, state) {
  if (!(state in stateEls)) { return false; }
  var elIdx = stateEls[state].indexOf(el);
  return elIdx !== -1;
}

// Unique event listeners

function recordListener (el, type) {
  if (type in listeners) {
    listeners[type].push(el);
  } else {
    listeners[type] = [el];
  }
}

function hasListener (el, type) {
  if (!(type in listeners)) { return false; }
  var elIdx = listeners[type].indexOf(el);
  return elIdx !== -1;
}

function addDelegatedListener (el, type, listener, useCapture) {
  if (hasListener(el, type)) { return; }  // Add the event listener only once.
  recordListener(el, type);
  el.addEventListener(type, listener, useCapture);
}

// Target data

function recordTargetData (type, sourceEl, targetSel, attributes) {
  var key = type;
  var obj = {sourceEl: sourceEl, targetSel: targetSel, attributes: attributes};
  if (key in targetData) {
    targetData[key].push(obj);
  } else {
    targetData[key] = [obj];
  }
}

function getTargetData (type) {
  var key = type;
  return targetData[key];
}

function targetListener (e) {
  // Not to be confused with the `target` we are modifying below.
  var eventFiredOnEl = getRealNode(e.target);
  var eventType = e.type;

  var allTargetData = getTargetData(eventType, eventFiredOnEl);
  if (!allTargetData) { return; }

  allTargetData.forEach(updateTargetEl);

  function updateTargetEl (targetData) {
    var sourceEl = targetData.sourceEl;
    if (sourceEl !== eventFiredOnEl) { return; }

    var targetAttributes = targetData.attributes;
    // TODO: Support updating multiple elements later by using `$$` and iterating.
    var targetSel = targetData.targetSel;
    var targetEl = typeof targetSel === 'string' ? utils.$(targetSel) : targetSel;

    if (!targetEl) { return; }

    updateAttrs(targetEl, targetAttributes);
  }
}

function updateAttrs (targetEl, targetAttributes) {
  utils.$$(targetAttributes).forEach(function (attr) {
    if (attr.name in attributeBlacklist) { return; }

    if (attr.name === 'state') {
      var states = utils.splitString(attr.value);
      states.forEach(function (state) {
        // Set the state on this element.
        addState(targetEl, state);
        // Remove the state on the other element(s).
        stateEls[state].forEach(function (el) {
          if (el === targetEl) { return; }  // Don't remove my state!
          removeState(el, state);
        });
      });
    } else {
      targetEl.setAttribute(attr.name, attr.value);
    }
  });
}

// Synthesize events for cursor `mouseenter` and `mouseleave`

window.addEventListener('stateadded', function (e) {
  var detail = e.detail;
  var state = detail.state;
  var el = e.target;

  recordState(el, state);

  if (state === 'hovering') {
    el.emit('mouseenter');
  }
  if (state === 'hovered') {
    if (hasState(el, 'selected')) {
      removeState(el, 'hovered');
    }
  }
});

window.addEventListener('stateremoved', function (e) {
  var detail = e.detail;
  var state = detail.state;
  var el = e.target;

  unrecordState(el, state);

  if (state === 'hovering') {
    el.emit('mouseleave');
  }
});

/**
 * Returns the true node (useful for a wrapped object in a template instance).
 */
function getRealNode (el) {
  if (el.tagName.toLowerCase() === 'a-root') {
    return el.parentNode;
  }
  if (!el.previousElementSibling && !el.nextElementSibling && el.closest('a-root')) {
    return el.closest('a-root').parentNode;
  }
  return el;
}

var AEvent = registerElement(
  'a-event',
  {
    prototype: Object.create(
      HTMLElement.prototype,
      {
        attachedCallback: {
          value: function () {
            var self = this;
            var el = self.parentNode;
            if (el.isNode) {
              attach();
            } else {
              el.addEventListener('nodeready', attach);
            }

            function attach () {
              self.isAEvent = true;
              self.type = self.type || self.getAttribute('type');
              self.target = self.target || self.getAttribute('target');
              self.sceneEl = utils.$('a-scene');
              self.attachEventListener();
            }
          },
          writable: window.debug
        },

        detachedCallback: {
          value: function () {
            // TODO: Remove all event listeners.
          },
          writable: window.debug
        },

        attributeChangedCallback: {
          value: function (attr, oldVal, newVal) {
            if (oldVal === newVal) { return; }
            if (attr === 'type') {
              this.type = newVal;
            } else if (attr === 'target') {
              this.target = newVal;
            }
          },
          writable: window.debug
        },

        attachEventListener: {
          value: function () {
            var self = this;
            var sourceEl;
            var targetEl;
            var listener;

            // TODO: Land `on` PR in `aframe-core`: https://github.com/aframevr/aframe-core/pull/330

            this.sceneEl = this.sceneEl || utils.$('a-scene');

            if (self.type === 'load') {
              sourceEl = getRealNode(self.parentNode);
              targetEl = self.target ? utils.$(self.target) : sourceEl;
              listener = function (e) {
                if (e.target !== sourceEl) { return; }
                updateAttrs(targetEl, self.attributes);
              };
              if (sourceEl && sourceEl.hasLoaded) {
                listener(sourceEl);
                return;
              }
              this.sceneEl.addEventListener('load', listener);
              return;
            }

            listener = targetListener;

            // We must delegate events because the target nodes may not exist yet.
            addDelegatedListener(this.sceneEl, self.type, listener);
            sourceEl = getRealNode(self.parentNode);
            targetEl = self.target || sourceEl;
            recordTargetData(self.type, sourceEl, targetEl, self.attributes);
          },
          writable: window.debug
        }
      }
    )
  }
);

module.exports = AEvent;

},{"../../core/a-register-element":53,"../lib/utils":70}],60:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

/**
 * We `hover` by applying attributes upon `mouseenter` and then
 * rolling back the changes upon `mouseleave` of the element.
 */
module.exports = utils.wrapAEventElement('a-hover', 'mouseenter');

},{"../lib/utils":70}],61:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-load', 'load');

},{"../lib/utils":70}],62:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-mousedown', 'mousedown');

},{"../lib/utils":70}],63:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-mouseenter', 'mouseenter');

},{"../lib/utils":70}],64:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-mouseleave', 'mouseleave');

},{"../lib/utils":70}],65:[function(_dereq_,module,exports){
var utils = _dereq_('../lib/utils');

module.exports = utils.wrapAEventElement('a-mouseup', 'mouseup');

},{"../lib/utils":70}],66:[function(_dereq_,module,exports){
module.exports = {
  'a-click': _dereq_('./a-click'),
  'a-event': _dereq_('./a-event'),
  'a-hover': _dereq_('./a-hover'),
  'a-load': _dereq_('./a-load'),
  'a-mousedown': _dereq_('./a-mousedown'),
  'a-mouseenter': _dereq_('./a-mouseenter'),
  'a-mouseleave': _dereq_('./a-mouseleave'),
  'a-mouseup': _dereq_('./a-mouseup')
};

},{"./a-click":58,"./a-event":59,"./a-hover":60,"./a-load":61,"./a-mousedown":62,"./a-mouseenter":63,"./a-mouseleave":64,"./a-mouseup":65}],67:[function(_dereq_,module,exports){
/* global HTMLTemplateElement, HTMLImports, MutationObserver */

window.addEventListener('HTMLImportsLoaded', injectFromPolyfilledImports);

var registerTemplate = _dereq_('./lib/register-template');
var utils = _dereq_('./lib/utils');

// TODO: Extract to aframe-primitives and require aframe.
var registerElement = _dereq_('../core/a-register-element').registerElement;

function injectFromPolyfilledImports () {
  if (!HTMLImports || HTMLImports.useNative) { return; }

  Object.keys(HTMLImports.importer.documents).forEach(function (key) {
    var doc = HTMLImports.importer.documents[key];
    insertTemplateElements(doc);
  });
}

function insertTemplateElements (doc) {
  var sceneEl = utils.$('a-scene');
  var assetsEl = utils.$('a-assets');
  if (!assetsEl) {
    assetsEl = document.createElement('a-assets');
    sceneEl.parentNode.insertBefore(assetsEl, sceneEl);
  }

  utils.$$('a-mixin', doc).forEach(function (mixinEl) {
    var mixinCloneEl = document.importNode(mixinEl, true);
    assetsEl.appendChild(mixinCloneEl);
  });

  utils.$$('template[is="a-template"]', doc).forEach(function (templateEl) {
    var templateCloneEl = document.importNode(templateEl, true);
    document.body.appendChild(templateCloneEl);
  });
}

module.exports = registerElement(
  'a-template',
  {
    extends: 'template',  // This lets us do `<template is="a-template">`.
    prototype: Object.create(
      HTMLTemplateElement.prototype,
      {
        createdCallback: {
          value: function () {
            var self = this;
            self.placeholders = [];
            // For Chrome: https://github.com/aframevr/aframe-core/issues/321
            window.addEventListener('load', function () {
              appendElement();
              function appendElement () {
                var isInDocument = self.ownerDocument === document;
                // TODO: Handle `<a-mixin>` from imported templates for Chrome.
                if (!isInDocument) { document.body.appendChild(self); }
              }
            });
          },
          writable: window.debug
        },

        attachedCallback: {
          value: function () {
            this.load();
            this.inject();
          },
          writable: window.debug
        },

        detachedCallback: {
          value: function () {
            // XXX: Hack for VS to hide templates from source.
            // var self = this;
            // self.removeTemplateListener();
            // self.placeholders.forEach(function (el) {
            //   self.sceneEl.remove(el);
            // });
          },
          writable: window.debug
        },

        load: {
          value: function () {
            // To prevent emitting the loaded event more than once.
            if (this.hasLoaded) { return; }
            utils.fireEvent(this, 'loaded');
            this.hasLoaded = true;
          },
          writable: window.debug
        },

        register: {
          value: function (tagName) {
            if (this.registered) { return; }
            this.registered = true;
            return registerTemplate(tagName);
          },
          writable: window.debug
        },

        removeTemplateListener: {
          value: function () {
            if (!this.mixinObserver) { return; }
            this.mixinObserver.disconnect();
            this.mixinObserver = null;
          },
          writable: window.debug
        },

        attachTemplateListener: {
          value: function (tagName) {
            var self = this;
            if (self.mixinObserver) { self.mixinObserver.disconnect(); }
            self.mixinObserver = new MutationObserver(function (mutations) {
              self.placeholders.forEach(function (el) {
                el.rerender(true);
              });
            });
            self.mixinObserver.observe(self, {
              attributes: true,
              characterData: true,
              childList: true,
              subtree: true
            });
          },
          writable: window.debug
        },

        inject: {
          value: function () {
            var self = this;

            if (self.injected) { return; }
            self.injected = true;

            var tagName = self.getAttribute('element');
            if (!tagName) { return; }

            self.attachTemplateListener(tagName);
            self.register(tagName);
          },
          writable: window.debug
        }
      }
    )
  }
);

},{"../core/a-register-element":53,"./lib/register-template":69,"./lib/utils":70}],68:[function(_dereq_,module,exports){
var modules = {
  'a-event': _dereq_('./a-event'),
  'a-template': _dereq_('./a-template')
};

// This injects the template definitions into the page.
_dereq_('./templates/index.html');

module.exports = modules;

},{"./a-event":66,"./a-template":67,"./templates/index.html":86}],69:[function(_dereq_,module,exports){
// TODO: Extract to aframe-primitives.
var utils = _dereq_('./utils');

var registerElement = _dereq_('../../core/a-register-element').registerElement;
var AEntity = _dereq_('../../core/a-entity');
var AComponents = _dereq_('../../core/component').components;

var ATTRIBUTE_BLACKLIST = utils.extend({
  id: true,
  name: true,
  class: true,
  target: true
});
var COMPONENT_BLACKLIST = utils.extend({}, AComponents);

registerElement('a-root', {prototype: Object.create(AEntity.prototype)});

// We use counters so we can generate unique `id`s for each template instance.
// Code will be simplified and this can be removed when "primitives" land.
// Fixes https://github.com/aframevr/aframe/issues/308
var counts = {};
function countIncrement (tagName) {
  if (!(tagName in counts)) {
    counts[tagName] = 0;
  }
  return counts[tagName]++;
}

module.exports = function (tagName) {
  var tagNameLower = tagName.toLowerCase();

  return registerElement(
    tagNameLower,
    {
      prototype: Object.create(
        AEntity.prototype, {
          attachedCallback: {
            value: function () {
              // We emit an event so `<a-entity>` knows when we've been
              // registered and adds our children as `object3D`s.
              this.emit('loaded');
              this.emit('nodeready');
              this.rerender(false, true);
            }
          },

          attributeChangedCallback: {
            value: function (attr, oldVal, newVal) {
              if (oldVal === newVal) { return; }
              this.rerender();
            },
            writable: window.debug
          },

          attributeBlacklist: {
            value: ATTRIBUTE_BLACKLIST,
            writable: window.debug
          },

          componentBlacklist: {
            value: COMPONENT_BLACKLIST,
            writable: window.debug
          },

          detachedCallback: {
            value: function () {
              if (!this.sceneEl) {
                this.sceneEl = utils.$('a-scene');
              }
              this.sceneEl.remove(this);
            },
            writable: window.debug
          },

          rerender: {
            value: function (force, firstTime) {
              var self = this;
              if (!force && this.lastOuterHTML === this.outerHTML) { return; }
              var template = utils.$('template[is="a-template"][element="' + tagName + '"]');
              if (!template) { return; }

              // Use the defaults defined on the original `<template is="a-template">`.
              var templateAttrs = utils.mergeAttrs(template, this);
              utils.forEach(template.attributes, function (attr) {
                if (attr.name in self.componentBlacklist) {
                  if (firstTime) {
                    utils.warn('Cannot use attribute name "%s" for template ' +
                      'definition of <%s> because it is a core component',
                      attr.name, tagNameLower);
                  }
                  delete templateAttrs[attr.name];
                }
              });
              Object.keys(templateAttrs).filter(function (key) {
                if (key in this.attributeBlacklist) {
                  // Move these unique identifier attributes over
                  // (i.e., `id`, `name`, `class`, `target`).
                  delete templateAttrs[key];
                }
                var value = templateAttrs[key];
                var component = this.components[key];
                if (component && typeof value === 'object') {
                  templateAttrs[key] = component.stringify(value);
                }
              }, this);

              this.root = utils.$$(this.children).filter(function (el) {
                return el.tagName.toLowerCase() === 'a-root';
              })[0];

              if (!this.root) {
                this.root = document.createElement('a-root');
                this.appendChild(this.root);
              }

              if (firstTime) {
                templateAttrs.__counter__ = countIncrement(tagNameLower).toString();
              }

              var newHTML = utils.format(template.innerHTML, templateAttrs);
              if (newHTML !== this.root.innerHTML) {
                this.root.innerHTML = newHTML;
              }

              this.lastOuterHTML = this.outerHTML;
            },
            writable: window.debug
          }
        }
      )
    });
};

},{"../../core/a-entity":50,"../../core/a-register-element":53,"../../core/component":55,"./utils":70}],70:[function(_dereq_,module,exports){
// TODO: Extract to aframe-primiives.
var AEvent = _dereq_('../a-event/a-event');

var aframeCoreUtils = _dereq_('../../utils');
var registerElement = _dereq_('../../core/a-register-element').registerElement;

/**
 * Wraps `querySelector` à la jQuery's `$`.
 *
 * @param {String|Element} sel CSS selector to match an element.
 * @param {Element=} parent Parent from which to query.
 * @returns {Element} Element matched by selector.
 */
module.exports.$ = function (sel, parent) {
  var el = sel;
  if (sel && typeof sel === 'string') {
    el = (parent || document).querySelector(sel);
  }
  return el;
};

/**
 * Wraps `querySelectorAll` à la jQuery's `$`.
 *
 * @param {String|Element} sel CSS selector to match elements.
 * @param {Element=} parent Parent from which to query.
 * @returns {Array} Array of elements matched by selector.
 */
module.exports.$$ = function (sel, parent) {
  if (Array.isArray(sel)) { return sel; }
  var els = sel;
  if (sel && typeof sel === 'string') {
    els = (parent || document).querySelectorAll(sel);
  }
  return toArray(els);
};

/**
 * Turns an array-like object into an array.
 *
 * @param {String|Element} obj CSS selector to match elements.
 * @param {Array|NamedNodeMap|NodeList|HTMLCollection} arr An array-like object.
 * @returns {Array} Array of elements matched by selector.
 */
var toArray = module.exports.toArray = function (obj) {
  if (Array.isArray(obj)) { return obj; }
  if (typeof obj === 'object' && typeof obj.length === 'number') {
    return Array.prototype.slice.call(obj);
  }
  return [obj];
};

/**
 * Wraps `Array.prototype.forEach`.
 *
 * @param {Object} arr An array-like object.
 * @returns {Array} A real array.
 */
var forEach = module.exports.forEach = function (arr, fn) {
  return Array.prototype.forEach.call(arr, fn);
};

/**
 * Merges attributes à la `Object.assign`.
 *
 * @param {...Object} els
 *   Array-like object (NodeMap, array, etc.) of
 *   parent elements from which to query.
 * @returns {Array} Array of merged attributes.
 */
module.exports.mergeAttrs = function () {
  var mergedAttrs = {};
  forEach(arguments, function (el) {
    forEach(el.attributes, function (attr) {
      // NOTE: We use `getComputedAttribute` instead of `attr.value` so our
      // wrapper for coordinate objects, etc. gets used.
      if (el.getComputedAttribute) {
        mergedAttrs[attr.name] = el.getComputedAttribute(attr.name);
      } else {
        mergedAttrs[attr.name] = el.getAttribute(attr.name);
      }
    });
  });
  return mergedAttrs;
};

/**
 * Does ES6-style (or mustache-style) string formatting.
 *
 * > format('${0}', ['zzz'])
 * "zzz"
 *
 * > format('${0}{1}', 1, 2)
 * "12"
 *
 * > format('${x}', {x: 1})
 * "1"
 *
 * > format('my favourite color is ${color=blue}', {x: 1})
 * "my favourite color is blue"
 *
 * @returns {String} Formatted string with interpolated variables.
 */
module.exports.format = (function () {
  var regexes = [
    /\$?\{\s*([^}= ]+)(\s*=\s*(.+))?\s*\}/g,
    /\$?%7B\s*([^}= ]+)(\s*=\s*(.+))?\s*%7D/g
  ];
  return function (s, args) {
    if (!s) { throw new Error('Format string is empty!'); }
    if (!args) { return; }
    if (!(args instanceof Array || args instanceof Object)) {
      args = Array.prototype.slice.call(arguments, 1);
    }
    Object.keys(args).forEach(function (key) {
      args[String(key).toLowerCase()] = args[key];
    });
    regexes.forEach(function (re) {
      s = s.replace(re, function (_, name, rhs, defaultVal) {
        var val = args[name.toLowerCase()];

        if (typeof val === 'undefined') {
          return (defaultVal || '').trim().replace(/^["']|["']$/g, '');
        }

        return (val || '').trim().replace(/^["']|["']$/g, '');
      });
    });
    return s;
  };
})();

/**
 * Wraps an element as a new one with a different name.
 *
 * @param {String} newTagName - Name of the new custom element.
 * @param {Element} srcElement - Original custom element to wrap.
 * @param {Object=} [data={}] - Data for the new prototype.
 * @returns {Array} Wrapped custom element.
 */
var wrapElement = module.exports.wrapElement = function (newTagName, srcElement, data) {
  data = data || {};
  return registerElement(newTagName, {
    prototype: Object.create(srcElement.prototype, data)
  });
};

/**
 * Wraps `<a-event>` for a particular event `type`.
 *
 * @param {String} newTagName - Name of the new custom element.
 * @param {Element} eventName - Name of event type.
 * @param {Object=} [data={}] - Data for the new prototype.
 * @returns {Array} Wrapped custom element.
 */
module.exports.wrapAEventElement = function (newTagName, eventName, data) {
  data = data || {};
  data.type = {
    value: eventName,
    writable: window.debug
  };
  return wrapElement(newTagName, AEvent, data);
};

// Useful utils from aframe-core.
module.exports.error = aframeCoreUtils.error;
module.exports.extend = aframeCoreUtils.extend;
module.exports.fireEvent = aframeCoreUtils.fireEvent;
module.exports.log = aframeCoreUtils.log;
module.exports.splitString = aframeCoreUtils.splitString;
module.exports.warn = aframeCoreUtils.warn;

},{"../../core/a-register-element":53,"../../utils":90,"../a-event/a-event":59}],71:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-camera\" fov=\"80\" near=\"0.5\" far=\"10000\" look-controls-enabled=\"true\" wasd-controls-enabled=\"true\" cursor-visible=\"true\" cursor-offset=\"1\" cursor-color=\"#FFF\" cursor-maxdistance=\"1000\" cursor-scale=\"1\" cursor-opacity=\"1\">\n  <a-entity camera=\"fov: ${fov}; near: ${near}; far: ${far}\" look-controls=\"enabled: ${look-controls-enabled}\" wasd-controls=\"enabled: ${wasd-controls-enabled}\">\n    <a-entity visible=\"${cursor-visible}\" position=\"0 0 -${cursor-offset}\" geometry=\"primitive: ring; radiusOuter: 0.016; radiusInner: 0.01\" material=\"color: ${cursor-color}; shader: flat; transparent: true; opacity: ${cursor-opacity}\" scale=\"${cursor-scale} ${cursor-scale} ${cursor-scale}\" cursor=\"maxDistance: ${cursor-maxdistance};\">\n    </a-entity>\n  </a-entity>\n</template>");

})
},{}],72:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-cone\" radius-top=\"0.2\" radius-bottom=\"0.75\" height=\"1.5\" segments-radial=\"36\" segments-height=\"1\" theta-start=\"0\" theta-length=\"360\" open-ended=\"false\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" side=\"front\" src=\"\">\n  <a-entity geometry=\"primitive: cone;\n                      radiusTop: ${radius-top};\n                      radiusBottom: ${radius-bottom};\n                      height: ${height};\n                      segmentsRadial: ${segments-radial};\n                      segmentsHeight: ${segments-height};\n                      thetaStart: ${theta-start};\n                      thetaLength: ${theta-length};\n                      openEnded: ${open-ended};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      side: ${side};\n                      transparent: ${transparent};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],73:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-cube\" width=\"1.5\" height=\"1.5\" depth=\"1.5\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" src=\"\">\n  <a-entity geometry=\"primitive: box;\n                      width: ${width};\n                      height: ${height};\n                      depth: ${depth};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      transparent: ${transparent};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],74:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-curvedimage\" radius=\"1\" height=\"1\" segments-radial=\"48\" theta-start=\"0\" theta-length=\"360\" opacity=\"1.0\" transparent=\"true\" src=\"\">\n  <a-entity geometry=\"primitive: cylinder;\n                      radius: ${radius};\n                      height: ${height};\n                      segmentsRadial: ${segments-radial};\n                      segmentsHeight: 1;\n                      thetaStart: ${theta-start};\n                      thetaLength: ${theta-length};\n                      openEnded: true\" scale=\"1 1 -1\" material=\"opacity: ${opacity};\n                      shader: flat;\n                      side: double;\n                      transparent: ${transparent};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],75:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-cylinder\" radius=\"0.75\" radius-top=\"0.75\" radius-bottom=\"0.75\" height=\"1.5\" segments-radial=\"36\" segments-height=\"1\" theta-start=\"0\" theta-length=\"360\" open-ended=\"false\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" side=\"front\" src=\"\">\n  <a-entity geometry=\"primitive: cylinder;\n                      radius: ${radius};\n                      radiusTop: ${radius-top};\n                      radiusBottom: ${radius-bottom};\n                      height: ${height};\n                      segmentsRadial: ${segments-radial};\n                      segmentsHeight: ${segments-height};\n                      thetaStart: ${theta-start};\n                      thetaLength: ${theta-length};\n                      openEnded: ${open-ended};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      side: ${side};\n                      transparent: ${transparent};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],76:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-frame\" size=\"10\" thickness=\"0.1\" color=\"#404040\">\n  <a-cube position=\"5 5 0\" rotation=\"0 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"5 -5 0\" rotation=\"0 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"-5 5 0\" rotation=\"0 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"-5 -5 0\" rotation=\"0 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n\n  <a-cube position=\"0 5 5\" rotation=\"0 90 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"0 5 -5\" rotation=\"0 90 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"0 -5 5\" rotation=\"0 90 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"0 -5 -5\" rotation=\"0 90 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n\n  <a-cube position=\"5 0 5\" rotation=\"90 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"5 0 -5\" rotation=\"90 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"-5 0 5\" rotation=\"90 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n  <a-cube position=\"-5 0 -5\" rotation=\"90 0 0\" width=\"${thickness}\" height=\"${thickness}\" depth=\"${size}\" color=\"${color}\"></a-cube>\n</template>");

})
},{}],77:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-image\" width=\"1.75\" height=\"1.75\" opacity=\"1.0\" src=\"\">\n  <a-entity geometry=\"primitive: plane;\n                      width: ${width};\n                      height: ${height}\" material=\"shader: flat;\n                      src: url(${src});\n                      opacity: ${opacity};\n                      side: double;\n                      transparent: true\">\n  </a-entity>\n</template>");

})
},{}],78:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-light\" angle=\"60\" color=\"#fff\" ground-color=\"#fff\" decay=\"1\" distance=\"0.0\" exponent=\"10.0\" intensity=\"1.0\" type=\"directional\">\n  <a-entity light=\"angle: ${angle};\n                   color: ${color};\n                   groundColor: ${ground-color};\n                   decay: ${decay};\n                   distance: ${distance};\n                   exponent: ${exponent};\n                   intensity: ${intensity};\n                   type: ${type}\">\n  </a-entity>\n</template>");

})
},{}],79:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-model\" opacity=\"1.0\" src=\"\" format=\"collada\">\n  <a-entity material=\"opacity: ${opacity}\" loader=\"src: url(${src}); format: ${format}\">\n  </a-entity>\n</template>");

})
},{}],80:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-plane\" width=\"1.75\" height=\"1.75\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" src=\"\">\n  <a-entity geometry=\"primitive: plane;\n                      height: ${height};\n                      width: ${width};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      transparent: ${transparent};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      side: double;\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],81:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-ring\" radius-inner=\"1\" radius-outer=\"2\" segments-theta=\"20\" segments-phi=\"5\" theta-start=\"0\" theta-length=\"360\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" src=\"\">\n  <a-entity geometry=\"primitive: ring;\n                      radiusInner: ${radius-inner};\n                      radiusOuter: ${radius-outer};\n                      segmentsTheta: ${segments-theta};\n                      segmentsPhi: ${segments-phi};\n                      thetaStart: ${theta-start};\n                      thetaLength: ${theta-length};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      transparent: ${transparent};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],82:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-sky\" src=\"\" color=\"#FFF\" radius=\"5000\" segments-width=\"64\" segments-height=\"64\">\n  <a-entity geometry=\"primitive: sphere;\n                      radius: ${radius};\n                      segmentsWidth: ${segments-width};\n                      segmentsHeight: ${segments-height}\" material=\"shader: flat; \n                      src: url(${src});\n                      color: ${color};\n                      fog: false\" scale=\"-1 1 1\">\n  </a-entity>\n</template>");

})
},{}],83:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-sphere\" radius=\"0.85\" segments-width=\"36\" segments-height=\"18\" translate=\"0 0 0\" color=\"gray\" opacity=\"1.0\" shader=\"standard\" transparent=\"true\" metalness=\"0.0\" roughness=\"0.5\" src=\"\">\n  <a-entity geometry=\"primitive: sphere;\n                      radius: ${radius};\n                      segmentsWidth: ${segments-width};\n                      segmentsHeight: ${segments-height};\n                      translate: ${translate}\" material=\"color: ${color};\n                      opacity: ${opacity};\n                      shader: ${shader};\n                      transparent: ${transparent};\n                      metalness: ${metalness};\n                      roughness: ${roughness};\n                      src: url(${src})\"></a-entity>\n</template>");

})
},{}],84:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-video\" src=\"\" width=\"3\" height=\"1.75\" translate=\"0 0 0\" autoplay=\"true\" loop=\"true\" crossorigin=\"anonymous\">\n  <video id=\"a-video-${__counter__}\" src=\"${src}\" width=\"${width}\" height=\"${height}\" autoplay=\"${autoplay}\" loop=\"${loop}\" crossorigin=\"${crossOrigin}\" style=\"display: none\">\n  </video>\n  <a-entity geometry=\"primitive: plane;\n                      height: ${height};\n                      width: ${width};\n                      translate: ${translate}\" material=\"shader: flat; src: #a-video_${__counter__}\">\n  </a-entity>\n</template>");

})
},{}],85:[function(_dereq_,module,exports){
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<template is=\"a-template\" element=\"a-videosphere\" src=\"\" radius=\"5000\" segments-width=\"64\" segments-height=\"64\" autoplay=\"true\" loop=\"true\" crossorigin=\"anonymous\">\n  <video id=\"a-videosphere-${__counter__}\" src=\"${src}\" width=\"1000\" height=\"500\" autoplay=\"${autoplay}\" loop=\"${loop}\" crossorigin=\"${crossOrigin}\" style=\"display: none\">\n  </video>\n  <a-entity geometry=\"primitive: sphere;\n                      radius: ${radius};\n                      segmentsWidth: ${segments-width};\n                      segmentsHeight: ${segments-height}\" material=\"shader: flat; src: #a-videosphere-${__counter__}\" scale=\"-1 1 1\">\n  </a-entity>\n</template>");

})
},{}],86:[function(_dereq_,module,exports){
_dereq_("./a-camera.html");
_dereq_("./a-cone.html");
_dereq_("./a-cube.html");
_dereq_("./a-curvedimage.html");
_dereq_("./a-cylinder.html");
_dereq_("./a-frame.html");
_dereq_("./a-image.html");
_dereq_("./a-light.html");
_dereq_("./a-model.html");
_dereq_("./a-plane.html");
_dereq_("./a-ring.html");
_dereq_("./a-sky/index.html");
_dereq_("./a-sphere.html");
_dereq_("./a-video.html");
_dereq_("./a-videosphere.html");
document.addEventListener("DOMContentLoaded",function() {
var head = document.getElementsByTagName("head")[0];
head.insertAdjacentHTML("beforeend","<meta charset=\"utf-8\">");

})
},{"./a-camera.html":71,"./a-cone.html":72,"./a-cube.html":73,"./a-curvedimage.html":74,"./a-cylinder.html":75,"./a-frame.html":76,"./a-image.html":77,"./a-light.html":78,"./a-model.html":79,"./a-plane.html":80,"./a-ring.html":81,"./a-sky/index.html":82,"./a-sphere.html":83,"./a-video.html":84,"./a-videosphere.html":85}],87:[function(_dereq_,module,exports){
_dereq_('es6-promise').polyfill();  // Polyfill `Promise`.
_dereq_('present');  // Polyfill `performance.now()`.

// TODO: Extract to aframe-primitives.
// HTML Imports polyfill must come before everything else.
if (!('import' in document.createElement('link'))) {
  _dereq_('../lib/vendor/HTMLImports');
}

_dereq_('../style/aframe-core.css');
_dereq_('../style/rStats.css');

// Required before `AEntity` so that all components are registered.
var AScene = _dereq_('./core/a-scene');
var components = _dereq_('./core/component').components;
var debug = _dereq_('./utils/debug');
var registerComponent = _dereq_('./core/component').registerComponent;
var registerElement = _dereq_('./core/a-register-element');
// Exports THREE to window so three.js can be used without alteration.
var THREE = window.THREE = _dereq_('../lib/three');
var TWEEN = window.TWEEN = _dereq_('tween.js');

var pkg = _dereq_('../package');
var utils = _dereq_('./utils/');

_dereq_('./components/index');  // Register core components.
var ANode = _dereq_('./core/a-node');
var AEntity = _dereq_('./core/a-entity');  // Depends on ANode and core components.

// Webvr polyfill configuration.
window.hasNonPolyfillWebVRSupport = !!navigator.getVRDevices;
window.WebVRConfig = {
  TOUCH_PANNER_DISABLED: true,
  MOUSE_KEYBOARD_CONTROLS_DISABLED: true
};
_dereq_('webvr-polyfill');

_dereq_('./core/a-animation');
_dereq_('./core/a-assets');
_dereq_('./core/a-cubemap');
_dereq_('./core/a-mixin');
_dereq_('./core/a-scene');

// TODO: Extract to aframe-primitives.
var coreElements = _dereq_('./elements/');
var registerTemplate = _dereq_('./elements/lib/register-template');

module.exports = {
  AEntity: AEntity,
  ANode: ANode,
  AScene: AScene,
  components: components,
  debug: debug,
  registerComponent: registerComponent,
  registerElement: registerElement,
  THREE: THREE,
  utils: utils,
  version: pkg.version,

  // TODO: Extract to aframe-primitives.
  elements: {
    core: coreElements
  },
  registerTemplate: registerTemplate
};

},{"../lib/three":1,"../lib/vendor/HTMLImports":2,"../package":28,"../style/aframe-core.css":92,"../style/rStats.css":93,"./components/index":33,"./core/a-animation":47,"./core/a-assets":48,"./core/a-cubemap":49,"./core/a-entity":50,"./core/a-mixin":51,"./core/a-node":52,"./core/a-register-element":53,"./core/a-scene":54,"./core/component":55,"./elements/":68,"./elements/lib/register-template":69,"./utils/":90,"./utils/debug":89,"es6-promise":12,"present":15,"tween.js":26,"webvr-polyfill":27}],88:[function(_dereq_,module,exports){
// Coordinate string regex. Handles negative, positive, and decimals.
var regex = /\s*(-?\d*\.{0,1}\d+)\s*(-?\d*\.{0,1}\d+)\s*(-?\d*\.{0,1}\d+)\s*/;
module.exports.regex = regex;

/**
 * Parses coordinates from an "x y z" string.
 * Example: "3 10 -5" to {x: 3, y: 10, z: -5}.
 *
 * @param {string} val - An "x y z" string.
 * @param {string} defaults - fallback value.
 * @returns {object} An object with keys [x, y, z].
 */
function parse (value, defaultCoordinate) {
  var coordinate;

  if (value && typeof value === 'object') { return value; }

  if (!defaultCoordinate && this.schema) {
    if ('default' in this.schema) {
      defaultCoordinate = this.schema.default;
    } else {
      defaultCoordinate = this.schema;
    }
  }

  if (typeof value !== 'string' || value === null) {
    return defaultCoordinate;
  }

  coordinate = value.trim().replace(/\s+/g, ' ').split(' ');
  return {
    x: parseFloat(coordinate[0] || defaultCoordinate.x),
    y: parseFloat(coordinate[1] || defaultCoordinate.y),
    z: parseFloat(coordinate[2] || defaultCoordinate.z)
  };
}
module.exports.parse = parse;

/**
 * Stringifies coordinates from an object with keys [x y z].
 * Example: {x: 3, y: 10, z: -5} to "3 10 -5".
 *
 * @param {object|string} data - An object with keys [x y z].
 * @returns {string} An "x y z" string.
 */
function stringify (data) {
  if (typeof data !== 'object') { return data; }
  return [data.x, data.y, data.z].join(' ');
}
module.exports.stringify = stringify;

/**
 * @returns {bool}
 */
module.exports.isCoordinate = function (value) {
  return regex.test(value);
};

},{}],89:[function(_dereq_,module,exports){
(function (process){
var debugLib = _dereq_('debug');
var extend = _dereq_('object-assign');

var settings = {
  colors: {
    error: 'red',
    info: 'gray',
    warn: 'orange',
    warning: 'orange'
  }
};

/**
 * Monkeypatches `debug` so we can colorize error/warning messages.
 *
 * (See issue: https://github.com/visionmedia/debug/issues/137)
 */
var debug = function (namespace) {
  var d = debugLib(namespace);

  d.color = getDebugNamespaceColor(namespace);

  return d;
};
extend(debug, debugLib);

/**
 * Returns the type of the namespace (e.g., `error`, `warn`).
 *
 * @param {String} namespace
 *   The debug logger's namespace (e.g., `components:geometry:warn`).
 * @returns {String} The type of the namespace (e.g., `warn`).
 * @api private
 */
function getDebugNamespaceType (namespace) {
  var chunks = namespace.split(':');

  return chunks[chunks.length - 1];  // Return the last one
}

/**
 * Returns the color of the namespace (e.g., `orange`).
 *
 * @param {String} namespace
 *   The debug logger's namespace (e.g., `components:geometry:warn`).
 * @returns {String} The color of the namespace (e.g., `orange`).
 * @api private
 */
function getDebugNamespaceColor (namespace) {
  var type = getDebugNamespaceType(namespace);

  var color = settings.colors && settings.colors[type];

  return color || null;
}

/**
 * Returns `localStorage` if possible.
 *
 * This is necessary because Safari throws when a user disables
 * cookies or `localStorage` and you attempt to access it.
 *
 * @returns {localStorage}
 * @api private
 */
function storage () {
  try {
    return window.localStorage;
  } catch (e) {
  }
}

/**
 * To enable console logging, type this in the Console of your Dev Tools:
 *
 *   localStorage.logs = 1
 *
 * To disable console logging:
 *
 *   localStorage.logs = 0
 *
 */
var ls = storage();
if (ls && (parseInt(ls.logs, 10) || ls.logs === 'true')) {
  debug.enable('*');
} else {
  // We do not call `debug.disable` because it requires two reloads to take.
  // See https://github.com/visionmedia/debug/issues/238
  // Instead, we call `debug.save` to remove the `debug` namespaces persisted
  // in `localStorage`.
  debug.save(null);
  // And then we `noop` the function so nothing happens.
  debug = function () {
    /* noop */
    return function () {};
  };
}

if (process.browser) { window.logs = debug; }

module.exports = debug;

}).call(this,_dereq_('_process'))

},{"_process":16,"debug":9,"object-assign":14}],90:[function(_dereq_,module,exports){
/* global CustomEvent, location */
/* Centralized place to reference utilities since utils is exposed to the user. */
var objectAssign = _dereq_('object-assign');

module.exports.coordinates = _dereq_('./coordinates');

/**
 * Fires a custom DOM event.
 *
 * @param {Element} el Element on which to fire the event.
 * @param {String} name Name of the event.
 * @param {Object=} [data={bubbles: true, {detail: <el>}}]
 *   Data to pass as `customEventInit` to the event.
 */
module.exports.fireEvent = function (el, name, data) {
  data = data || {};
  data.detail = data.detail || {};
  data.detail.target = data.detail.target || el;
  var evt = new CustomEvent(name, data);
  evt.target = el;
  el.dispatchEvent(evt);
};

/**
 * Throws an error given a message.
 *
 * @param {String} msg Error message.
 */
module.exports.error = function (msg) {
  throw new Error(msg);
};

/**
 * Emits a console warning given passed message argument(s).
 */
module.exports.warn = function () {
  console.warn.apply(console, arguments);
};

/**
 * Emits a console log given passed message argument(s).
 */
module.exports.log = function () {
  console.log.apply(console, arguments);
};

/**
 * Mix the properties of source object(s) into a destination object.
 *
 * @param  {object} dest - The object to which properties will be copied.
 * @param  {...object} source - The object(s) from which properties will be copied.
 */
module.exports.extend = objectAssign;

/**
 * Checks if two objects have the same attributes and values, including nested objects.
 *
 * @param {object} a - First object.
 * @param {object} b - Second object.
 * @returns {boolean} Whether two objects are deeply equal.
 */
function deepEqual (a, b) {
  var keysA = Object.keys(a);
  var keysB = Object.keys(b);
  var i;
  if (keysA.length !== keysB.length) { return false; }
  // If there are no keys, compare the objects.
  if (keysA.length === 0) { return a === b; }
  for (i = 0; i < keysA.length; ++i) {
    if (a[keysA[i]] !== b[keysA[i]]) { return false; }
  }
  return true;
}
module.exports.deepEqual = deepEqual;

/**
 * Computes the difference between two objects.
 *
 * @param {object} a - First object to compare (e.g., oldData).
 * @param {object} b - Second object to compare (e.g., newData).
 * @returns {object}
 *   Difference object where set of keys note which values were not equal, and values are
 *   `b`'s values.
 */
module.exports.diff = function (a, b) {
  var diff = {};
  var keys = Object.keys(a);
  Object.keys(b).forEach(function collectKeys (bKey) {
    if (keys.indexOf(bKey) === -1) {
      keys.push(bKey);
    }
  });
  keys.forEach(function doDiff (key) {
    var aVal = a[key];
    var bVal = b[key];
    var isComparingObjects = aVal && bVal &&
                             aVal.constructor === Object && bVal.constructor === Object;
    if ((isComparingObjects && !deepEqual(aVal, bVal)) ||
        (!isComparingObjects && aVal !== bVal)) {
      diff[key] = bVal;
    }
  });
  return diff;
};

/**
 * Checks if browser is mobile.
 * @return {Boolean} True if mobile browser detected.
 */
module.exports.isMobile = function () {
  var check = false;
  (function (a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) {
      check = true;
    }
    if (isIOS()) {
      check = true;
    }
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
};

var isIOS = module.exports.isIOS = function () {
  return /iPad|iPhone|iPod/.test(navigator.platform);
};

/**
 * Checks mobile device orientation
 * @return {Boolean} True if landscape orientation
 */
module.exports.isLandscape = function () {
  return window.orientation === 90 || window.orientation === -90;
};

/**
 * Splits a string into an array based on a delimiter.
 *
 * @param   {string=} [str='']        Source string
 * @param   {string=} [delimiter=' '] Delimiter to use
 * @returns {array}                   Array of delimited strings
 */
module.exports.splitString = function (str, delimiter) {
  if (typeof delimiter === 'undefined') { delimiter = ' '; }
  // First collapse the whitespace (or whatever the delimiter is).
  var regex = new RegExp(delimiter, 'g');
  str = (str || '').replace(regex, delimiter);
  // Then split.
  return str.split(delimiter);
};

/**
 * Extracts data from the element given an object that contains expected keys.
 *
 * @param {Element} Source element.
 * @param {Object} [defaults={}] Object of default key-value pairs.
 * @returns {Object}
 */
module.exports.getElData = function (el, defaults) {
  defaults = defaults || {};
  var data = {};
  Object.keys(defaults).forEach(copyAttribute);
  function copyAttribute (key) {
    if (el.hasAttribute(key)) {
      data[key] = el.getAttribute(key);
    }
  }
  return data;
};

/**
 * Retrieves querystring value.
 * @param  {String} name Name of querystring key.
 * @return {String}      Value
 */
module.exports.getUrlParameter = function (name) {
  name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
  var results = regex.exec(location.search);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
};

// Must be at bottom to avoid circular dependency.
module.exports.srcLoader = _dereq_('./src-loader');

},{"./coordinates":88,"./src-loader":91,"object-assign":14}],91:[function(_dereq_,module,exports){
/* global Image */
var debug = _dereq_('./debug');

var warn = debug('utils:src-loader:warn');

/**
 * Validates a texture, either as a selector or as a URL.
 * Detects whether `src` is pointing to an image or to a video, and invokes the
 * appropriate callback.
 *
 * If `src` is selector, check if it's valid, return the el in the callback.
 * An el is returned so that it can be reused for texture loading.
 *
 * If `src` is a URL, check if it's valid, return the src in the callback.
 *
 * @params {string} src - A selector or a URL. URLs must be wrapped by `url()`.
 * @params {function} isImageCb - callback if texture is an image.
 * @params {function} isVideoCb - callback if texture is a video.
 */
function validateSrc (src, isImageCb, isVideoCb) {
  var textureEl;
  var isImage;
  var isVideo;
  var url = parseUrl(src);

  // src is a url.
  if (url) {
    validateImageUrl(url, function isAnImageUrl (isImage) {
      if (!isImage) { isVideoCb(url); return; }
      isImageCb(url);
    });
    return;
  }

  // src is a query selector.
  textureEl = validateAndGetQuerySelector(src);
  if (!textureEl) { return; }
  isImage = textureEl && textureEl.tagName === 'IMG';
  isVideo = textureEl && textureEl.tagName === 'VIDEO';
  if (isImage) { return isImageCb(textureEl); }
  if (isVideo) { return isVideoCb(textureEl); }

  // src is a valid selector but doesn't match with a <img> or <video> element.
  warn('"%s" does not point to a valid <img> or <video> element', src);
}

/**
 * Validates six images as a cubemap, either as selector or comma-separated
 * URLs.
 *
 * @param {string} src - A selector or comma-separated image URLs. Image URLs
          must be wrapped by `url()`.
 * @param {string} src - A selector or comma-separated image URLs. Image URLs
          must be wrapped by `url()`.
 */
function validateCubemapSrc (src, cb) {
  var aCubemap;
  var cubemapSrcRegex = '';
  var i;
  var urls;
  var validatedUrls = [];

  for (i = 0; i < 6; i++) {
    cubemapSrcRegex += 'url\((.+)\)\s*,\s*';
  }
  urls = src.match(cubemapSrcRegex);

  // `src` is a comma-separated list of URLs.
  // In this case, re-use validateSrc for each side of the cube.
  function isImageCb (url) {
    validatedUrls.push(url);
    if (validatedUrls.length === 6) {
      cb(validatedUrls);
    }
  }
  if (urls) {
    for (i = 1; i < 7; i++) {
      validateSrc(urls[i], isImageCb);
    }
    return;
  }

  // `src` is a query selector to <a-cubemap> containing six $([src])s.
  aCubemap = validateAndGetQuerySelector(src);
  if (!aCubemap) { return; }
  if (aCubemap.tagName === 'A-CUBEMAP' && aCubemap.srcs) {
    return cb(aCubemap.srcs);
  }
  // Else if aCubeMap is not a <a-cubemap>.
  warn('Selector "%s" does not point to <a-cubemap>', src);
}

/**
 * Parses src from `url(src)`.
 * @param  {string} src - String to parse.
 * @return {string} The parsed src, if parseable.
 */
function parseUrl (src) {
  var parsedSrc = src.match(/\url\((.+)\)/);
  if (!parsedSrc) { return; }
  return parsedSrc[1];
}

/**
 * Validate src is a valid image url
 * @param  {string} src - url that will be tested
 * @param  {function} onResult - callback with the test result
 */
function validateImageUrl (src, onResult) {
  var tester = new Image();
  tester.addEventListener('load', onLoad);
  function onLoad () { onResult(true); }
  tester.addEventListener('error', onError);
  function onError () { onResult(false); }
  tester.src = src;
}

/**
 * Query and validate a query selector,
 *
 * @param  {string} selector - DOM selector.
 * @return {object|null|undefined} Selected DOM element if exists.
           null if query yields no results.
           undefined if `selector` is not a valid selector.
 */
function validateAndGetQuerySelector (selector) {
  try {
    var el = document.querySelector(selector);
    if (!el) {
      warn('No element was found matching the selector: "%s"', selector);
    }
    return el;
  } catch (e) {  // Capture exception if it's not a valid selector.
    warn('"%s" is not a valid selector', selector);
    return undefined;
  }
}

module.exports = {
  parseUrl: parseUrl,
  validateSrc: validateSrc,
  validateCubemapSrc: validateCubemapSrc
};

},{"./debug":89}],92:[function(_dereq_,module,exports){
var css = "html{bottom:0;left:0;position:fixed;right:0;top:0}body{height:100%;margin:0;overflow:hidden;padding:0;width:100%}.a-hidden{display:none!important}.a-canvas{height:100%;left:0;position:absolute;top:0;width:100%}a-assets,a-scene img,a-scene video{display:none}.a-enter-vr{align-items:flex-end;-webkit-align-items:flex-end;bottom:5px;display:flex;display:-webkit-flex;font-family:sans-serif,monospace;font-size:13px;font-weight:200;line-height:16px;height:72px;position:fixed;right:5px}.a-enter-vr-button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20viewBox%3D%220%200%20245.82%20141.73%22%3E%3Cdefs%3E%3Cstyle%3E.a%7Bfill%3A%23fff%3Bfill-rule%3Aevenodd%3B%7D%3C%2Fstyle%3E%3C%2Fdefs%3E%3Ctitle%3Emask%3C%2Ftitle%3E%3Cpath%20class%3D%22a%22%20d%3D%22M175.56%2C111.37c-22.52%2C0-40.77-18.84-40.77-42.07S153%2C27.24%2C175.56%2C27.24s40.77%2C18.84%2C40.77%2C42.07S198.08%2C111.37%2C175.56%2C111.37ZM26.84%2C69.31c0-23.23%2C18.25-42.07%2C40.77-42.07s40.77%2C18.84%2C40.77%2C42.07-18.26%2C42.07-40.77%2C42.07S26.84%2C92.54%2C26.84%2C69.31ZM27.27%2C0C11.54%2C0%2C0%2C12.34%2C0%2C28.58V110.9c0%2C16.24%2C11.54%2C30.83%2C27.27%2C30.83H99.57c2.17%2C0%2C4.19-1.83%2C5.4-3.7L116.47%2C118a8%2C8%2C0%2C0%2C1%2C12.52-.18l11.51%2C20.34c1.2%2C1.86%2C3.22%2C3.61%2C5.39%2C3.61h72.29c15.74%2C0%2C27.63-14.6%2C27.63-30.83V28.58C245.82%2C12.34%2C233.93%2C0%2C218.19%2C0H27.27Z%22%2F%3E%3C%2Fsvg%3E) 50% 50%/70% 70% no-repeat rgba(0,0,0,.35);border:0;bottom:0;color:#FFF;cursor:pointer;height:50px;transition:background .05s ease;-webkit-transition:background .05s ease;width:60px;z-index:999999}.a-enter-vr-button:active,.a-enter-vr-button:hover{background-color:#666}[data-a-enter-vr-no-webvr] .a-enter-vr-button{border-color:#666;opacity:.65}[data-a-enter-vr-no-webvr] .a-enter-vr-button:active,[data-a-enter-vr-no-webvr] .a-enter-vr-button:hover{background-color:rgba(0,0,0,.35);cursor:not-allowed}.a-enter-vr-modal{background-color:#666;border-radius:0;color:#FFF;height:32px;opacity:0;margin-right:10px;padding:9px;width:280px;position:relative;transition:opacity .05s ease;-webkit-transition:opacity .05s ease}.a-enter-vr-modal:after{border-bottom:10px solid transparent;border-left:10px solid #666;border-top:10px solid transparent;display:inline-block;content:'';position:absolute;right:-5px;top:5px;width:0;height:0}.a-enter-vr-modal p{margin:0;display:inline}.a-enter-vr-modal p:after{content:' '}.a-enter-vr-modal a{color:#FFF;display:inline}[data-a-enter-vr-no-headset]:hover .a-enter-vr-modal,[data-a-enter-vr-no-webvr]:hover .a-enter-vr-modal{opacity:1}.a-orientation-modal{position:absolute;width:100%;height:100%;top:0;left:0;background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%2090%2090%22%20enable-background%3D%22new%200%200%2090%2090%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpolygon%20points%3D%220%2C0%200%2C0%200%2C0%20%22%3E%3C/polygon%3E%3Cg%3E%3Cpath%20d%3D%22M71.545%2C48.145h-31.98V20.743c0-2.627-2.138-4.765-4.765-4.765H18.456c-2.628%2C0-4.767%2C2.138-4.767%2C4.765v42.789%20%20%20c0%2C2.628%2C2.138%2C4.766%2C4.767%2C4.766h5.535v0.959c0%2C2.628%2C2.138%2C4.765%2C4.766%2C4.765h42.788c2.628%2C0%2C4.766-2.137%2C4.766-4.765V52.914%20%20%20C76.311%2C50.284%2C74.173%2C48.145%2C71.545%2C48.145z%20M18.455%2C16.935h16.344c2.1%2C0%2C3.808%2C1.708%2C3.808%2C3.808v27.401H37.25V22.636%20%20%20c0-0.264-0.215-0.478-0.479-0.478H16.482c-0.264%2C0-0.479%2C0.214-0.479%2C0.478v36.585c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h7.507v7.644%20%20%20h-5.534c-2.101%2C0-3.81-1.709-3.81-3.81V20.743C14.645%2C18.643%2C16.354%2C16.935%2C18.455%2C16.935z%20M16.96%2C23.116h19.331v25.031h-7.535%20%20%20c-2.628%2C0-4.766%2C2.139-4.766%2C4.768v5.828h-7.03V23.116z%20M71.545%2C73.064H28.757c-2.101%2C0-3.81-1.708-3.81-3.808V52.914%20%20%20c0-2.102%2C1.709-3.812%2C3.81-3.812h42.788c2.1%2C0%2C3.809%2C1.71%2C3.809%2C3.812v16.343C75.354%2C71.356%2C73.645%2C73.064%2C71.545%2C73.064z%22%3E%3C/path%3E%3Cpath%20d%3D%22M28.919%2C58.424c-1.466%2C0-2.659%2C1.193-2.659%2C2.66c0%2C1.466%2C1.193%2C2.658%2C2.659%2C2.658c1.468%2C0%2C2.662-1.192%2C2.662-2.658%20%20%20C31.581%2C59.617%2C30.387%2C58.424%2C28.919%2C58.424z%20M28.919%2C62.786c-0.939%2C0-1.703-0.764-1.703-1.702c0-0.939%2C0.764-1.704%2C1.703-1.704%20%20%20c0.94%2C0%2C1.705%2C0.765%2C1.705%2C1.704C30.623%2C62.022%2C29.858%2C62.786%2C28.919%2C62.786z%22%3E%3C/path%3E%3Cpath%20d%3D%22M69.654%2C50.461H33.069c-0.264%2C0-0.479%2C0.215-0.479%2C0.479v20.288c0%2C0.264%2C0.215%2C0.478%2C0.479%2C0.478h36.585%20%20%20c0.263%2C0%2C0.477-0.214%2C0.477-0.478V50.939C70.131%2C50.676%2C69.917%2C50.461%2C69.654%2C50.461z%20M69.174%2C51.417V70.75H33.548V51.417H69.174z%22%3E%3C/path%3E%3Cpath%20d%3D%22M45.201%2C30.296c6.651%2C0%2C12.233%2C5.351%2C12.551%2C11.977l-3.033-2.638c-0.193-0.165-0.507-0.142-0.675%2C0.048%20%20%20c-0.174%2C0.198-0.153%2C0.501%2C0.045%2C0.676l3.883%2C3.375c0.09%2C0.075%2C0.198%2C0.115%2C0.312%2C0.115c0.141%2C0%2C0.273-0.061%2C0.362-0.166%20%20%20l3.371-3.877c0.173-0.2%2C0.151-0.502-0.047-0.675c-0.194-0.166-0.508-0.144-0.676%2C0.048l-2.592%2C2.979%20%20%20c-0.18-3.417-1.629-6.605-4.099-9.001c-2.538-2.461-5.877-3.817-9.404-3.817c-0.264%2C0-0.479%2C0.215-0.479%2C0.479%20%20%20C44.72%2C30.083%2C44.936%2C30.296%2C45.201%2C30.296z%22%3E%3C/path%3E%3C/g%3E%3C/svg%3E) center center/50% 50% no-repeat rgba(244,244,244,1)}.a-orientation-modal:after{content:\"Insert phone into Cardboard holder.\";color:#333;font-family:sans-serif,monospace;font-size:13px;text-align:center;position:absolute;width:100%;top:70%;transform:translateY(-70%)}.a-orientation-modal button{background:url(data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20xmlns%3Axlink%3D%22http%3A//www.w3.org/1999/xlink%22%20version%3D%221.1%22%20x%3D%220px%22%20y%3D%220px%22%20viewBox%3D%220%200%20100%20100%22%20enable-background%3D%22new%200%200%20100%20100%22%20xml%3Aspace%3D%22preserve%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M55.209%2C50l17.803-17.803c1.416-1.416%2C1.416-3.713%2C0-5.129c-1.416-1.417-3.713-1.417-5.129%2C0L50.08%2C44.872%20%20L32.278%2C27.069c-1.416-1.417-3.714-1.417-5.129%2C0c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129L44.951%2C50L27.149%2C67.803%20%20c-1.417%2C1.416-1.417%2C3.713%2C0%2C5.129c0.708%2C0.708%2C1.636%2C1.062%2C2.564%2C1.062c0.928%2C0%2C1.856-0.354%2C2.564-1.062L50.08%2C55.13l17.803%2C17.802%20%20c0.708%2C0.708%2C1.637%2C1.062%2C2.564%2C1.062s1.856-0.354%2C2.564-1.062c1.416-1.416%2C1.416-3.713%2C0-5.129L55.209%2C50z%22%3E%3C/path%3E%3C/svg%3E);width:50px;height:50px;border:none;text-indent:-9999px}@media (min-width:480px){.a-enter-vr{bottom:20px;right:20px}.a-enter-vr-modal{width:400px}}"; (_dereq_("browserify-css").createStyle(css, { "href": "style\\aframe-core.css"})); module.exports = css;
},{"browserify-css":7}],93:[function(_dereq_,module,exports){
var css = ".rs-base{background-color:#EF2D5E;border-radius:0;font-family:'Roboto Condensed',tahoma,sans-serif;font-size:10px;line-height:1.2em;opacity:.75;overflow:hidden;padding:10px;position:fixed;left:5px;top:5px;width:270px;z-index:10000}.rs-base.hidden{display:none}.rs-base h1{color:#fff;cursor:pointer;font-size:1.4em;font-weight:300;margin:0 0 5px;padding:0}.rs-group{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-direction:column-reverse;flex-direction:column-reverse}.rs-counter-base{align-items:center;display:-webkit-box;display:-webkit-flex;display:flex;height:10px;-webkit-justify-content:space-between;justify-content:space-between;margin:2px 0}.rs-counter-id{font-weight:300;-webkit-box-ordinal-group:0;-webkit-order:0;order:0}.rs-counter-value{font-weight:300;-webkit-box-ordinal-group:1;-webkit-order:1;order:1;text-align:right;width:25px}.rs-canvas{-webkit-box-ordinal-group:2;-webkit-order:2;order:2}@media (min-width:480px){.rs-base{left:20px;top:20px}}"; (_dereq_("browserify-css").createStyle(css, { "href": "style\\rStats.css"})); module.exports = css;
},{"browserify-css":7}]},{},[87])(87)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvdGhyZWUuanMiLCJsaWIvdmVuZG9yL0hUTUxJbXBvcnRzLmpzIiwibGliL3ZlbmRvci9SYXljYXN0ZXIuanMiLCJsaWIvdmVuZG9yL3JTdGF0cy5qcyIsImxpYi92ZW5kb3Ivd2FrZWxvY2svdXRpbC5qcyIsImxpYi92ZW5kb3Ivd2FrZWxvY2svd2FrZWxvY2suanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1jc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jb21wb25lbnQtcmFmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlYnVnL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvZG9jdW1lbnQtcmVnaXN0ZXItZWxlbWVudC9idWlsZC9kb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVzZW50L2xpYi9wcmVzZW50LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlcXVlc3QtaW50ZXJ2YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3R5bGUtYXR0ci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1kZXYvYnVpbGQvdGhyZWUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2NvbnRyb2xzL1ZSQ29udHJvbHMuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2VmZmVjdHMvVlJFZmZlY3QuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2xvYWRlcnMvQ29sbGFkYUxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy90aHJlZS1kZXYvZXhhbXBsZXMvanMvbG9hZGVycy9NVExMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2xvYWRlcnMvT0JKTG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RpbWUtbm93L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3R3ZWVuLmpzL3NyYy9Ud2Vlbi5qcyIsIm5vZGVfbW9kdWxlcy93ZWJ2ci1wb2x5ZmlsbC9idWlsZC93ZWJ2ci1wb2x5ZmlsbC5qcyIsInBhY2thZ2UuanNvbiIsInNyYy9jb21wb25lbnRzL2NhbWVyYS5qcyIsInNyYy9jb21wb25lbnRzL2N1cnNvci5qcyIsInNyYy9jb21wb25lbnRzL2ZvZy5qcyIsInNyYy9jb21wb25lbnRzL2dlb21ldHJ5LmpzIiwic3JjL2NvbXBvbmVudHMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9saWdodC5qcyIsInNyYy9jb21wb25lbnRzL2xvYWRlci5qcyIsInNyYy9jb21wb25lbnRzL2xvb2stYXQuanMiLCJzcmMvY29tcG9uZW50cy9sb29rLWNvbnRyb2xzLmpzIiwic3JjL2NvbXBvbmVudHMvbWF0ZXJpYWwuanMiLCJzcmMvY29tcG9uZW50cy9wb3NpdGlvbi5qcyIsInNyYy9jb21wb25lbnRzL3JheWNhc3Rlci5qcyIsInNyYy9jb21wb25lbnRzL3JvdGF0aW9uLmpzIiwic3JjL2NvbXBvbmVudHMvc2NhbGUuanMiLCJzcmMvY29tcG9uZW50cy9zb3VuZC5qcyIsInNyYy9jb21wb25lbnRzL3Zpc2libGUuanMiLCJzcmMvY29tcG9uZW50cy93YXNkLWNvbnRyb2xzLmpzIiwic3JjL2NvbnN0YW50cy9hbmltYXRpb24uanMiLCJzcmMvY29yZS9hLWFuaW1hdGlvbi5qcyIsInNyYy9jb3JlL2EtYXNzZXRzLmpzIiwic3JjL2NvcmUvYS1jdWJlbWFwLmpzIiwic3JjL2NvcmUvYS1lbnRpdHkuanMiLCJzcmMvY29yZS9hLW1peGluLmpzIiwic3JjL2NvcmUvYS1ub2RlLmpzIiwic3JjL2NvcmUvYS1yZWdpc3Rlci1lbGVtZW50LmpzIiwic3JjL2NvcmUvYS1zY2VuZS5qcyIsInNyYy9jb3JlL2NvbXBvbmVudC5qcyIsInNyYy9jb3JlL3Byb3BlcnR5VHlwZXMuanMiLCJzcmMvY29yZS9zY2hlbWEuanMiLCJzcmMvZWxlbWVudHMvYS1ldmVudC9hLWNsaWNrLmpzIiwic3JjL2VsZW1lbnRzL2EtZXZlbnQvYS1ldmVudC5qcyIsInNyYy9lbGVtZW50cy9hLWV2ZW50L2EtaG92ZXIuanMiLCJzcmMvZWxlbWVudHMvYS1ldmVudC9hLWxvYWQuanMiLCJzcmMvZWxlbWVudHMvYS1ldmVudC9hLW1vdXNlZG93bi5qcyIsInNyYy9lbGVtZW50cy9hLWV2ZW50L2EtbW91c2VlbnRlci5qcyIsInNyYy9lbGVtZW50cy9hLWV2ZW50L2EtbW91c2VsZWF2ZS5qcyIsInNyYy9lbGVtZW50cy9hLWV2ZW50L2EtbW91c2V1cC5qcyIsInNyYy9lbGVtZW50cy9hLWV2ZW50L2luZGV4LmpzIiwic3JjL2VsZW1lbnRzL2EtdGVtcGxhdGUuanMiLCJzcmMvZWxlbWVudHMvaW5kZXguanMiLCJzcmMvZWxlbWVudHMvbGliL3JlZ2lzdGVyLXRlbXBsYXRlLmpzIiwic3JjL2VsZW1lbnRzL2xpYi91dGlscy5qcyIsInNyYy9lbGVtZW50cy90ZW1wbGF0ZXMvYS1jYW1lcmEuaHRtbCIsInNyYy9lbGVtZW50cy90ZW1wbGF0ZXMvYS1jb25lLmh0bWwiLCJzcmMvZWxlbWVudHMvdGVtcGxhdGVzL2EtY3ViZS5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLWN1cnZlZGltYWdlLmh0bWwiLCJzcmMvZWxlbWVudHMvdGVtcGxhdGVzL2EtY3lsaW5kZXIuaHRtbCIsInNyYy9lbGVtZW50cy90ZW1wbGF0ZXMvYS1mcmFtZS5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLWltYWdlLmh0bWwiLCJzcmMvZWxlbWVudHMvdGVtcGxhdGVzL2EtbGlnaHQuaHRtbCIsInNyYy9lbGVtZW50cy90ZW1wbGF0ZXMvYS1tb2RlbC5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLXBsYW5lLmh0bWwiLCJzcmMvZWxlbWVudHMvdGVtcGxhdGVzL2EtcmluZy5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLXNreS9pbmRleC5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLXNwaGVyZS5odG1sIiwic3JjL2VsZW1lbnRzL3RlbXBsYXRlcy9hLXZpZGVvLmh0bWwiLCJzcmMvZWxlbWVudHMvdGVtcGxhdGVzL2EtdmlkZW9zcGhlcmUuaHRtbCIsInNyYy9lbGVtZW50cy90ZW1wbGF0ZXMvaW5kZXguaHRtbCIsInNyYy9pbmRleC5qcyIsInNyYy91dGlscy9jb29yZGluYXRlcy5qcyIsInNyYy91dGlscy9kZWJ1Zy5qcyIsInNyYy91dGlscy9pbmRleC5qcyIsInNyYy91dGlscy9zcmMtbG9hZGVyLmpzIiwic3R5bGUvYWZyYW1lLWNvcmUuY3NzIiwic3R5bGUvclN0YXRzLmNzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3Y4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4dnVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3M0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Z4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanJHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBOztBQ0FBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsInZhciBUSFJFRSA9IGdsb2JhbC5USFJFRSA9IHJlcXVpcmUoJ3RocmVlLWRldicpO1xuXG4vLyBBbGxvdyBjcm9zcy1vcmlnaW4gaW1hZ2VzIHRvIGJlIGxvYWRlZC5cbmlmIChUSFJFRS5UZXh0dXJlTG9hZGVyKSB7XG4gIFRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlLmNyb3NzT3JpZ2luID0gJyc7XG59XG5cbi8vIFRPRE86IEV2ZW50dWFsbHkgaW5jbHVkZSB0aGVzZSBvbmx5IGlmIHRoZXkgYXJlIG5lZWRlZCBieSBhIGNvbXBvbmVudC5cblxucmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL3RocmVlLWRldi9leGFtcGxlcy9qcy9sb2FkZXJzL09CSkxvYWRlcicpOyAgLy8gVEhSRUUuT0JKTG9hZGVyXG5yZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2xvYWRlcnMvTVRMTG9hZGVyJyk7ICAvLyBUSFJFRS5NVExMb2FkZXJcbnJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy90aHJlZS1kZXYvZXhhbXBsZXMvanMvbG9hZGVycy9Db2xsYWRhTG9hZGVyJyk7ICAvLyBUSFJFRS5Db2xsYWRhTG9hZGVyXG5yZXF1aXJlKCcuLi9saWIvdmVuZG9yL1JheWNhc3RlcicpOyAgLy8gVEhSRUUuUmF5Y2FzdGVyXG5yZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvdGhyZWUtZGV2L2V4YW1wbGVzL2pzL2NvbnRyb2xzL1ZSQ29udHJvbHMnKTsgIC8vIFRIUkVFLlZSQ29udHJvbHNcbnJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy90aHJlZS1kZXYvZXhhbXBsZXMvanMvZWZmZWN0cy9WUkVmZmVjdCcpOyAgLy8gVEhSRUUuVlJFZmZlY3RcblxubW9kdWxlLmV4cG9ydHMgPSBUSFJFRTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLy8gQHZlcnNpb24gMC43LjE0LWM0NjliMDBcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcbiAgICB9O1xuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkgZW50cnlbMV0gPSB2YWx1ZTsgZWxzZSBkZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5ID0ga2V5W3RoaXMubmFtZV0pICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcbiAgfSkoKTtcbn1cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikgZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgPSBKc011dGF0aW9uT2JzZXJ2ZXI7XG59KShzZWxmKTtcblxud2luZG93LkhUTUxJbXBvcnRzID0gd2luZG93LkhUTUxJbXBvcnRzIHx8IHtcbiAgZmxhZ3M6IHt9XG59O1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIElNUE9SVF9MSU5LX1RZUEUgPSBcImltcG9ydFwiO1xuICB2YXIgdXNlTmF0aXZlID0gQm9vbGVhbihJTVBPUlRfTElOS19UWVBFIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpKTtcbiAgdmFyIGhhc1NoYWRvd0RPTVBvbHlmaWxsID0gQm9vbGVhbih3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwpO1xuICB2YXIgd3JhcCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gaGFzU2hhZG93RE9NUG9seWZpbGwgPyB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwud3JhcElmTmVlZGVkKG5vZGUpIDogbm9kZTtcbiAgfTtcbiAgdmFyIHJvb3REb2N1bWVudCA9IHdyYXAoZG9jdW1lbnQpO1xuICB2YXIgY3VycmVudFNjcmlwdERlc2NyaXB0b3IgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY3JpcHQgPSB3aW5kb3cuSFRNTEltcG9ydHMuY3VycmVudFNjcmlwdCB8fCBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHx8IChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIgPyBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV0gOiBudWxsKTtcbiAgICAgIHJldHVybiB3cmFwKHNjcmlwdCk7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCBcIl9jdXJyZW50U2NyaXB0XCIsIGN1cnJlbnRTY3JpcHREZXNjcmlwdG9yKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3REb2N1bWVudCwgXCJfY3VycmVudFNjcmlwdFwiLCBjdXJyZW50U2NyaXB0RGVzY3JpcHRvcik7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIGZ1bmN0aW9uIHdoZW5SZWFkeShjYWxsYmFjaywgZG9jKSB7XG4gICAgZG9jID0gZG9jIHx8IHJvb3REb2N1bWVudDtcbiAgICB3aGVuRG9jdW1lbnRSZWFkeShmdW5jdGlvbigpIHtcbiAgICAgIHdhdGNoSW1wb3J0c0xvYWQoY2FsbGJhY2ssIGRvYyk7XG4gICAgfSwgZG9jKTtcbiAgfVxuICB2YXIgcmVxdWlyZWRSZWFkeVN0YXRlID0gaXNJRSA/IFwiY29tcGxldGVcIiA6IFwiaW50ZXJhY3RpdmVcIjtcbiAgdmFyIFJFQURZX0VWRU5UID0gXCJyZWFkeXN0YXRlY2hhbmdlXCI7XG4gIGZ1bmN0aW9uIGlzRG9jdW1lbnRSZWFkeShkb2MpIHtcbiAgICByZXR1cm4gZG9jLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBkb2MucmVhZHlTdGF0ZSA9PT0gcmVxdWlyZWRSZWFkeVN0YXRlO1xuICB9XG4gIGZ1bmN0aW9uIHdoZW5Eb2N1bWVudFJlYWR5KGNhbGxiYWNrLCBkb2MpIHtcbiAgICBpZiAoIWlzRG9jdW1lbnRSZWFkeShkb2MpKSB7XG4gICAgICB2YXIgY2hlY2tSZWFkeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZG9jLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBkb2MucmVhZHlTdGF0ZSA9PT0gcmVxdWlyZWRSZWFkeVN0YXRlKSB7XG4gICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoUkVBRFlfRVZFTlQsIGNoZWNrUmVhZHkpO1xuICAgICAgICAgIHdoZW5Eb2N1bWVudFJlYWR5KGNhbGxiYWNrLCBkb2MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoUkVBRFlfRVZFTlQsIGNoZWNrUmVhZHkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1hcmtUYXJnZXRMb2FkZWQoZXZlbnQpIHtcbiAgICBldmVudC50YXJnZXQuX19sb2FkZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHdhdGNoSW1wb3J0c0xvYWQoY2FsbGJhY2ssIGRvYykge1xuICAgIHZhciBpbXBvcnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO1xuICAgIHZhciBwYXJzZWRDb3VudCA9IDAsIGltcG9ydENvdW50ID0gaW1wb3J0cy5sZW5ndGgsIG5ld0ltcG9ydHMgPSBbXSwgZXJyb3JJbXBvcnRzID0gW107XG4gICAgZnVuY3Rpb24gY2hlY2tEb25lKCkge1xuICAgICAgaWYgKHBhcnNlZENvdW50ID09IGltcG9ydENvdW50ICYmIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICBhbGxJbXBvcnRzOiBpbXBvcnRzLFxuICAgICAgICAgIGxvYWRlZEltcG9ydHM6IG5ld0ltcG9ydHMsXG4gICAgICAgICAgZXJyb3JJbXBvcnRzOiBlcnJvckltcG9ydHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWRlZEltcG9ydChlKSB7XG4gICAgICBtYXJrVGFyZ2V0TG9hZGVkKGUpO1xuICAgICAgbmV3SW1wb3J0cy5wdXNoKHRoaXMpO1xuICAgICAgcGFyc2VkQ291bnQrKztcbiAgICAgIGNoZWNrRG9uZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvckxvYWRpbmdJbXBvcnQoZSkge1xuICAgICAgZXJyb3JJbXBvcnRzLnB1c2godGhpcyk7XG4gICAgICBwYXJzZWRDb3VudCsrO1xuICAgICAgY2hlY2tEb25lKCk7XG4gICAgfVxuICAgIGlmIChpbXBvcnRDb3VudCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltcDsgaSA8IGltcG9ydENvdW50ICYmIChpbXAgPSBpbXBvcnRzW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmIChpc0ltcG9ydExvYWRlZChpbXApKSB7XG4gICAgICAgICAgcGFyc2VkQ291bnQrKztcbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXAuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbG9hZGVkSW1wb3J0KTtcbiAgICAgICAgICBpbXAuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9yTG9hZGluZ0ltcG9ydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tEb25lKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGlzSW1wb3J0TG9hZGVkKGxpbmspIHtcbiAgICByZXR1cm4gdXNlTmF0aXZlID8gbGluay5fX2xvYWRlZCB8fCBsaW5rLmltcG9ydCAmJiBsaW5rLmltcG9ydC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiA6IGxpbmsuX19pbXBvcnRQYXJzZWQ7XG4gIH1cbiAgaWYgKHVzZU5hdGl2ZSkge1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKG14bnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbXhucy5sZW5ndGgsIG07IGkgPCBsICYmIChtID0gbXhuc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAobS5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgaGFuZGxlSW1wb3J0cyhtLmFkZGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkub2JzZXJ2ZShkb2N1bWVudC5oZWFkLCB7XG4gICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVJbXBvcnRzKG5vZGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aCwgbjsgaSA8IGwgJiYgKG4gPSBub2Rlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAoaXNJbXBvcnQobikpIHtcbiAgICAgICAgICBoYW5kbGVJbXBvcnQobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNJbXBvcnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQubG9jYWxOYW1lID09PSBcImxpbmtcIiAmJiBlbGVtZW50LnJlbCA9PT0gXCJpbXBvcnRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSW1wb3J0KGVsZW1lbnQpIHtcbiAgICAgIHZhciBsb2FkZWQgPSBlbGVtZW50LmltcG9ydDtcbiAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgbWFya1RhcmdldExvYWRlZCh7XG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBtYXJrVGFyZ2V0TG9hZGVkKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbWFya1RhcmdldExvYWRlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICB2YXIgaW1wb3J0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGltcG9ydHMubGVuZ3RoLCBpbXA7IGkgPCBsICYmIChpbXAgPSBpbXBvcnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgaGFuZGxlSW1wb3J0KGltcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIHdoZW5SZWFkeShmdW5jdGlvbihkZXRhaWwpIHtcbiAgICB3aW5kb3cuSFRNTEltcG9ydHMucmVhZHkgPSB0cnVlO1xuICAgIHdpbmRvdy5IVE1MSW1wb3J0cy5yZWFkeVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgZXZ0ID0gcm9vdERvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChcIkhUTUxJbXBvcnRzTG9hZGVkXCIsIHRydWUsIHRydWUsIGRldGFpbCk7XG4gICAgcm9vdERvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfSk7XG4gIHNjb3BlLklNUE9SVF9MSU5LX1RZUEUgPSBJTVBPUlRfTElOS19UWVBFO1xuICBzY29wZS51c2VOYXRpdmUgPSB1c2VOYXRpdmU7XG4gIHNjb3BlLnJvb3REb2N1bWVudCA9IHJvb3REb2N1bWVudDtcbiAgc2NvcGUud2hlblJlYWR5ID0gd2hlblJlYWR5O1xuICBzY29wZS5pc0lFID0gaXNJRTtcbn0pKHdpbmRvdy5IVE1MSW1wb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICB2YXIgbW9kdWxlcyA9IFtdO1xuICB2YXIgYWRkTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgbW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gIH07XG4gIHZhciBpbml0aWFsaXplTW9kdWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAgIG1vZHVsZShzY29wZSk7XG4gICAgfSk7XG4gIH07XG4gIHNjb3BlLmFkZE1vZHVsZSA9IGFkZE1vZHVsZTtcbiAgc2NvcGUuaW5pdGlhbGl6ZU1vZHVsZXMgPSBpbml0aWFsaXplTW9kdWxlcztcbn0pKHdpbmRvdy5IVE1MSW1wb3J0cyk7XG5cbndpbmRvdy5IVE1MSW1wb3J0cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIENTU19VUkxfUkVHRVhQID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG4gIHZhciBDU1NfSU1QT1JUX1JFR0VYUCA9IC8oQGltcG9ydFtcXHNdKyg/IXVybFxcKCkpKFteO10qKSg7KS9nO1xuICB2YXIgcGF0aCA9IHtcbiAgICByZXNvbHZlVXJsc0luU3R5bGU6IGZ1bmN0aW9uKHN0eWxlLCBsaW5rVXJsKSB7XG4gICAgICB2YXIgZG9jID0gc3R5bGUub3duZXJEb2N1bWVudDtcbiAgICAgIHZhciByZXNvbHZlciA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGhpcy5yZXNvbHZlVXJsc0luQ3NzVGV4dChzdHlsZS50ZXh0Q29udGVudCwgbGlua1VybCwgcmVzb2x2ZXIpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH0sXG4gICAgcmVzb2x2ZVVybHNJbkNzc1RleHQ6IGZ1bmN0aW9uKGNzc1RleHQsIGxpbmtVcmwsIHVybE9iaikge1xuICAgICAgdmFyIHIgPSB0aGlzLnJlcGxhY2VVcmxzKGNzc1RleHQsIHVybE9iaiwgbGlua1VybCwgQ1NTX1VSTF9SRUdFWFApO1xuICAgICAgciA9IHRoaXMucmVwbGFjZVVybHMociwgdXJsT2JqLCBsaW5rVXJsLCBDU1NfSU1QT1JUX1JFR0VYUCk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHJlcGxhY2VVcmxzOiBmdW5jdGlvbih0ZXh0LCB1cmxPYmosIGxpbmtVcmwsIHJlZ2V4cCkge1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgICAgIHZhciB1cmxQYXRoID0gdXJsLnJlcGxhY2UoL1tcIiddL2csIFwiXCIpO1xuICAgICAgICBpZiAobGlua1VybCkge1xuICAgICAgICAgIHVybFBhdGggPSBuZXcgVVJMKHVybFBhdGgsIGxpbmtVcmwpLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgdXJsT2JqLmhyZWYgPSB1cmxQYXRoO1xuICAgICAgICB1cmxQYXRoID0gdXJsT2JqLmhyZWY7XG4gICAgICAgIHJldHVybiBwcmUgKyBcIidcIiArIHVybFBhdGggKyBcIidcIiArIHBvc3Q7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHNjb3BlLnBhdGggPSBwYXRoO1xufSk7XG5cbndpbmRvdy5IVE1MSW1wb3J0cy5hZGRNb2R1bGUoZnVuY3Rpb24oc2NvcGUpIHtcbiAgdmFyIHhociA9IHtcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBvazogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc3RhdHVzID49IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDMwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMzA0IHx8IHJlcXVlc3Quc3RhdHVzID09PSAwO1xuICAgIH0sXG4gICAgbG9hZDogZnVuY3Rpb24odXJsLCBuZXh0LCBuZXh0Q29udGV4dCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIGlmIChzY29wZS5mbGFncy5kZWJ1ZyB8fCBzY29wZS5mbGFncy5idXN0KSB7XG4gICAgICAgIHVybCArPSBcIj9cIiArIE1hdGgucmFuZG9tKCk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Lm9wZW4oXCJHRVRcIiwgdXJsLCB4aHIuYXN5bmMpO1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICB2YXIgbG9jYXRpb25IZWFkZXIgPSByZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKFwiTG9jYXRpb25cIik7XG4gICAgICAgICAgdmFyIHJlZGlyZWN0ZWRVcmwgPSBudWxsO1xuICAgICAgICAgIGlmIChsb2NhdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgdmFyIHJlZGlyZWN0ZWRVcmwgPSBsb2NhdGlvbkhlYWRlci5zdWJzdHIoMCwgMSkgPT09IFwiL1wiID8gbG9jYXRpb24ub3JpZ2luICsgbG9jYXRpb25IZWFkZXIgOiBsb2NhdGlvbkhlYWRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dC5jYWxsKG5leHRDb250ZXh0LCAheGhyLm9rKHJlcXVlc3QpICYmIHJlcXVlc3QsIHJlcXVlc3QucmVzcG9uc2UgfHwgcmVxdWVzdC5yZXNwb25zZVRleHQsIHJlZGlyZWN0ZWRVcmwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSxcbiAgICBsb2FkRG9jdW1lbnQ6IGZ1bmN0aW9uKHVybCwgbmV4dCwgbmV4dENvbnRleHQpIHtcbiAgICAgIHRoaXMubG9hZCh1cmwsIG5leHQsIG5leHRDb250ZXh0KS5yZXNwb25zZVR5cGUgPSBcImRvY3VtZW50XCI7XG4gICAgfVxuICB9O1xuICBzY29wZS54aHIgPSB4aHI7XG59KTtcblxud2luZG93LkhUTUxJbXBvcnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgeGhyID0gc2NvcGUueGhyO1xuICB2YXIgZmxhZ3MgPSBzY29wZS5mbGFncztcbiAgdmFyIExvYWRlciA9IGZ1bmN0aW9uKG9uTG9hZCwgb25Db21wbGV0ZSkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB0aGlzLm9ubG9hZCA9IG9uTG9hZDtcbiAgICB0aGlzLm9uY29tcGxldGUgPSBvbkNvbXBsZXRlO1xuICAgIHRoaXMuaW5mbGlnaHQgPSAwO1xuICAgIHRoaXMucGVuZGluZyA9IHt9O1xuICB9O1xuICBMb2FkZXIucHJvdG90eXBlID0ge1xuICAgIGFkZE5vZGVzOiBmdW5jdGlvbihub2Rlcykge1xuICAgICAgdGhpcy5pbmZsaWdodCArPSBub2Rlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aCwgbjsgaSA8IGwgJiYgKG4gPSBub2Rlc1tpXSk7IGkrKykge1xuICAgICAgICB0aGlzLnJlcXVpcmUobik7XG4gICAgICB9XG4gICAgICB0aGlzLmNoZWNrRG9uZSgpO1xuICAgIH0sXG4gICAgYWRkTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdGhpcy5pbmZsaWdodCsrO1xuICAgICAgdGhpcy5yZXF1aXJlKG5vZGUpO1xuICAgICAgdGhpcy5jaGVja0RvbmUoKTtcbiAgICB9LFxuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgdmFyIHVybCA9IGVsdC5zcmMgfHwgZWx0LmhyZWY7XG4gICAgICBlbHQuX19ub2RlVXJsID0gdXJsO1xuICAgICAgaWYgKCF0aGlzLmRlZHVwZSh1cmwsIGVsdCkpIHtcbiAgICAgICAgdGhpcy5mZXRjaCh1cmwsIGVsdCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWR1cGU6IGZ1bmN0aW9uKHVybCwgZWx0KSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nW3VybF0pIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nW3VybF0ucHVzaChlbHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXNvdXJjZTtcbiAgICAgIGlmICh0aGlzLmNhY2hlW3VybF0pIHtcbiAgICAgICAgdGhpcy5vbmxvYWQodXJsLCBlbHQsIHRoaXMuY2FjaGVbdXJsXSk7XG4gICAgICAgIHRoaXMudGFpbCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1t1cmxdID0gWyBlbHQgXTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGZldGNoOiBmdW5jdGlvbih1cmwsIGVsdCkge1xuICAgICAgZmxhZ3MubG9hZCAmJiBjb25zb2xlLmxvZyhcImZldGNoXCIsIHVybCwgZWx0KTtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlKHVybCwgZWx0LCB7XG4gICAgICAgICAgICBlcnJvcjogXCJocmVmIG11c3QgYmUgc3BlY2lmaWVkXCJcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAodXJsLm1hdGNoKC9eZGF0YTovKSkge1xuICAgICAgICB2YXIgcGllY2VzID0gdXJsLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgdmFyIGhlYWRlciA9IHBpZWNlc1swXTtcbiAgICAgICAgdmFyIGJvZHkgPSBwaWVjZXNbMV07XG4gICAgICAgIGlmIChoZWFkZXIuaW5kZXhPZihcIjtiYXNlNjRcIikgPiAtMSkge1xuICAgICAgICAgIGJvZHkgPSBhdG9iKGJvZHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvZHkgPSBkZWNvZGVVUklDb21wb25lbnQoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnJlY2VpdmUodXJsLCBlbHQsIG51bGwsIGJvZHkpO1xuICAgICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlY2VpdmVYaHIgPSBmdW5jdGlvbihlcnIsIHJlc291cmNlLCByZWRpcmVjdGVkVXJsKSB7XG4gICAgICAgICAgdGhpcy5yZWNlaXZlKHVybCwgZWx0LCBlcnIsIHJlc291cmNlLCByZWRpcmVjdGVkVXJsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB4aHIubG9hZCh1cmwsIHJlY2VpdmVYaHIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZTogZnVuY3Rpb24odXJsLCBlbHQsIGVyciwgcmVzb3VyY2UsIHJlZGlyZWN0ZWRVcmwpIHtcbiAgICAgIHRoaXMuY2FjaGVbdXJsXSA9IHJlc291cmNlO1xuICAgICAgdmFyICRwID0gdGhpcy5wZW5kaW5nW3VybF07XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9ICRwLmxlbmd0aCwgcDsgaSA8IGwgJiYgKHAgPSAkcFtpXSk7IGkrKykge1xuICAgICAgICB0aGlzLm9ubG9hZCh1cmwsIHAsIHJlc291cmNlLCBlcnIsIHJlZGlyZWN0ZWRVcmwpO1xuICAgICAgICB0aGlzLnRhaWwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ1t1cmxdID0gbnVsbDtcbiAgICB9LFxuICAgIHRhaWw6IGZ1bmN0aW9uKCkge1xuICAgICAgLS10aGlzLmluZmxpZ2h0O1xuICAgICAgdGhpcy5jaGVja0RvbmUoKTtcbiAgICB9LFxuICAgIGNoZWNrRG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaW5mbGlnaHQpIHtcbiAgICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzY29wZS5Mb2FkZXIgPSBMb2FkZXI7XG59KTtcblxud2luZG93LkhUTUxJbXBvcnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbihhZGRDYWxsYmFjaykge1xuICAgIHRoaXMuYWRkQ2FsbGJhY2sgPSBhZGRDYWxsYmFjaztcbiAgICB0aGlzLm1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5oYW5kbGVyLmJpbmQodGhpcykpO1xuICB9O1xuICBPYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24obXV0YXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG11dGF0aW9ucy5sZW5ndGgsIG07IGkgPCBsICYmIChtID0gbXV0YXRpb25zW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmIChtLnR5cGUgPT09IFwiY2hpbGRMaXN0XCIgJiYgbS5hZGRlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYWRkZWROb2RlcyhtLmFkZGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRlZE5vZGVzOiBmdW5jdGlvbihub2Rlcykge1xuICAgICAgaWYgKHRoaXMuYWRkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hZGRDYWxsYmFjayhub2Rlcyk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aCwgbiwgbG9hZGluZzsgaSA8IGwgJiYgKG4gPSBub2Rlc1tpXSk7IGkrKykge1xuICAgICAgICBpZiAobi5jaGlsZHJlbiAmJiBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYWRkZWROb2RlcyhuLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb2JzZXJ2ZTogZnVuY3Rpb24ocm9vdCkge1xuICAgICAgdGhpcy5tby5vYnNlcnZlKHJvb3QsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHNjb3BlLk9ic2VydmVyID0gT2JzZXJ2ZXI7XG59KTtcblxud2luZG93LkhUTUxJbXBvcnRzLmFkZE1vZHVsZShmdW5jdGlvbihzY29wZSkge1xuICB2YXIgcGF0aCA9IHNjb3BlLnBhdGg7XG4gIHZhciByb290RG9jdW1lbnQgPSBzY29wZS5yb290RG9jdW1lbnQ7XG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuICB2YXIgaXNJRSA9IHNjb3BlLmlzSUU7XG4gIHZhciBJTVBPUlRfTElOS19UWVBFID0gc2NvcGUuSU1QT1JUX0xJTktfVFlQRTtcbiAgdmFyIElNUE9SVF9TRUxFQ1RPUiA9IFwibGlua1tyZWw9XCIgKyBJTVBPUlRfTElOS19UWVBFICsgXCJdXCI7XG4gIHZhciBpbXBvcnRQYXJzZXIgPSB7XG4gICAgZG9jdW1lbnRTZWxlY3RvcnM6IElNUE9SVF9TRUxFQ1RPUixcbiAgICBpbXBvcnRzU2VsZWN0b3JzOiBbIElNUE9SVF9TRUxFQ1RPUiwgXCJsaW5rW3JlbD1zdHlsZXNoZWV0XTpub3QoW3R5cGVdKVwiLCBcInN0eWxlOm5vdChbdHlwZV0pXCIsIFwic2NyaXB0Om5vdChbdHlwZV0pXCIsICdzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIl0nLCAnc2NyaXB0W3R5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIl0nIF0uam9pbihcIixcIiksXG4gICAgbWFwOiB7XG4gICAgICBsaW5rOiBcInBhcnNlTGlua1wiLFxuICAgICAgc2NyaXB0OiBcInBhcnNlU2NyaXB0XCIsXG4gICAgICBzdHlsZTogXCJwYXJzZVN0eWxlXCJcbiAgICB9LFxuICAgIGR5bmFtaWNFbGVtZW50czogW10sXG4gICAgcGFyc2VOZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5uZXh0VG9QYXJzZSgpO1xuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgdGhpcy5wYXJzZShuZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihlbHQpIHtcbiAgICAgIGlmICh0aGlzLmlzUGFyc2VkKGVsdCkpIHtcbiAgICAgICAgZmxhZ3MucGFyc2UgJiYgY29uc29sZS5sb2coXCJbJXNdIGlzIGFscmVhZHkgcGFyc2VkXCIsIGVsdC5sb2NhbE5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZm4gPSB0aGlzW3RoaXMubWFwW2VsdC5sb2NhbE5hbWVdXTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICB0aGlzLm1hcmtQYXJzaW5nKGVsdCk7XG4gICAgICAgIGZuLmNhbGwodGhpcywgZWx0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlRHluYW1pYzogZnVuY3Rpb24oZWx0LCBxdWlldCkge1xuICAgICAgdGhpcy5keW5hbWljRWxlbWVudHMucHVzaChlbHQpO1xuICAgICAgaWYgKCFxdWlldCkge1xuICAgICAgICB0aGlzLnBhcnNlTmV4dCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWFya1BhcnNpbmc6IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgZmxhZ3MucGFyc2UgJiYgY29uc29sZS5sb2coXCJwYXJzaW5nXCIsIGVsdCk7XG4gICAgICB0aGlzLnBhcnNpbmdFbGVtZW50ID0gZWx0O1xuICAgIH0sXG4gICAgbWFya1BhcnNpbmdDb21wbGV0ZTogZnVuY3Rpb24oZWx0KSB7XG4gICAgICBlbHQuX19pbXBvcnRQYXJzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5tYXJrRHluYW1pY1BhcnNpbmdDb21wbGV0ZShlbHQpO1xuICAgICAgaWYgKGVsdC5fX2ltcG9ydEVsZW1lbnQpIHtcbiAgICAgICAgZWx0Ll9faW1wb3J0RWxlbWVudC5fX2ltcG9ydFBhcnNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya0R5bmFtaWNQYXJzaW5nQ29tcGxldGUoZWx0Ll9faW1wb3J0RWxlbWVudCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnNpbmdFbGVtZW50ID0gbnVsbDtcbiAgICAgIGZsYWdzLnBhcnNlICYmIGNvbnNvbGUubG9nKFwiY29tcGxldGVkXCIsIGVsdCk7XG4gICAgfSxcbiAgICBtYXJrRHluYW1pY1BhcnNpbmdDb21wbGV0ZTogZnVuY3Rpb24oZWx0KSB7XG4gICAgICB2YXIgaSA9IHRoaXMuZHluYW1pY0VsZW1lbnRzLmluZGV4T2YoZWx0KTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgdGhpcy5keW5hbWljRWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VJbXBvcnQ6IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgZWx0LmltcG9ydCA9IGVsdC5fX2RvYztcbiAgICAgIGlmICh3aW5kb3cuSFRNTEltcG9ydHMuX19pbXBvcnRzUGFyc2luZ0hvb2spIHtcbiAgICAgICAgd2luZG93LkhUTUxJbXBvcnRzLl9faW1wb3J0c1BhcnNpbmdIb29rKGVsdCk7XG4gICAgICB9XG4gICAgICBpZiAoZWx0LmltcG9ydCkge1xuICAgICAgICBlbHQuaW1wb3J0Ll9faW1wb3J0UGFyc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya1BhcnNpbmdDb21wbGV0ZShlbHQpO1xuICAgICAgaWYgKGVsdC5fX3Jlc291cmNlICYmICFlbHQuX19lcnJvcikge1xuICAgICAgICBlbHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJsb2FkXCIsIHtcbiAgICAgICAgICBidWJibGVzOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgYnViYmxlczogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKGVsdC5fX3BlbmRpbmcpIHtcbiAgICAgICAgdmFyIGZuO1xuICAgICAgICB3aGlsZSAoZWx0Ll9fcGVuZGluZy5sZW5ndGgpIHtcbiAgICAgICAgICBmbiA9IGVsdC5fX3BlbmRpbmcuc2hpZnQoKTtcbiAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgIGZuKHtcbiAgICAgICAgICAgICAgdGFyZ2V0OiBlbHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZU5leHQoKTtcbiAgICB9LFxuICAgIHBhcnNlTGluazogZnVuY3Rpb24obGlua0VsdCkge1xuICAgICAgaWYgKG5vZGVJc0ltcG9ydChsaW5rRWx0KSkge1xuICAgICAgICB0aGlzLnBhcnNlSW1wb3J0KGxpbmtFbHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlua0VsdC5ocmVmID0gbGlua0VsdC5ocmVmO1xuICAgICAgICB0aGlzLnBhcnNlR2VuZXJpYyhsaW5rRWx0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlU3R5bGU6IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgdmFyIHNyYyA9IGVsdDtcbiAgICAgIGVsdCA9IGNsb25lU3R5bGUoZWx0KTtcbiAgICAgIHNyYy5fX2FwcGxpZWRFbGVtZW50ID0gZWx0O1xuICAgICAgZWx0Ll9faW1wb3J0RWxlbWVudCA9IHNyYztcbiAgICAgIHRoaXMucGFyc2VHZW5lcmljKGVsdCk7XG4gICAgfSxcbiAgICBwYXJzZUdlbmVyaWM6IGZ1bmN0aW9uKGVsdCkge1xuICAgICAgdGhpcy50cmFja0VsZW1lbnQoZWx0KTtcbiAgICAgIHRoaXMuYWRkRWxlbWVudFRvRG9jdW1lbnQoZWx0KTtcbiAgICB9LFxuICAgIHJvb3RJbXBvcnRGb3JFbGVtZW50OiBmdW5jdGlvbihlbHQpIHtcbiAgICAgIHZhciBuID0gZWx0O1xuICAgICAgd2hpbGUgKG4ub3duZXJEb2N1bWVudC5fX2ltcG9ydExpbmspIHtcbiAgICAgICAgbiA9IG4ub3duZXJEb2N1bWVudC5fX2ltcG9ydExpbms7XG4gICAgICB9XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuICAgIGFkZEVsZW1lbnRUb0RvY3VtZW50OiBmdW5jdGlvbihlbHQpIHtcbiAgICAgIHZhciBwb3J0ID0gdGhpcy5yb290SW1wb3J0Rm9yRWxlbWVudChlbHQuX19pbXBvcnRFbGVtZW50IHx8IGVsdCk7XG4gICAgICBwb3J0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsdCwgcG9ydCk7XG4gICAgfSxcbiAgICB0cmFja0VsZW1lbnQ6IGZ1bmN0aW9uKGVsdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlbHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZG9uZSk7XG4gICAgICAgIGVsdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZG9uZSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubWFya1BhcnNpbmdDb21wbGV0ZShlbHQpO1xuICAgICAgICBzZWxmLnBhcnNlTmV4dCgpO1xuICAgICAgfTtcbiAgICAgIGVsdC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBkb25lKTtcbiAgICAgIGVsdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZG9uZSk7XG4gICAgICBpZiAoaXNJRSAmJiBlbHQubG9jYWxOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgdmFyIGZha2VMb2FkID0gZmFsc2U7XG4gICAgICAgIGlmIChlbHQudGV4dENvbnRlbnQuaW5kZXhPZihcIkBpbXBvcnRcIikgPT0gLTEpIHtcbiAgICAgICAgICBmYWtlTG9hZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZWx0LnNoZWV0KSB7XG4gICAgICAgICAgZmFrZUxvYWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBjc3IgPSBlbHQuc2hlZXQuY3NzUnVsZXM7XG4gICAgICAgICAgdmFyIGxlbiA9IGNzciA/IGNzci5sZW5ndGggOiAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgbGVuICYmIChyID0gY3NyW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoci50eXBlID09PSBDU1NSdWxlLklNUE9SVF9SVUxFKSB7XG4gICAgICAgICAgICAgIGZha2VMb2FkID0gZmFrZUxvYWQgJiYgQm9vbGVhbihyLnN0eWxlU2hlZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFrZUxvYWQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZWx0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwibG9hZFwiLCB7XG4gICAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlU2NyaXB0OiBmdW5jdGlvbihzY3JpcHRFbHQpIHtcbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgc2NyaXB0Ll9faW1wb3J0RWxlbWVudCA9IHNjcmlwdEVsdDtcbiAgICAgIHNjcmlwdC5zcmMgPSBzY3JpcHRFbHQuc3JjID8gc2NyaXB0RWx0LnNyYyA6IGdlbmVyYXRlU2NyaXB0RGF0YVVybChzY3JpcHRFbHQpO1xuICAgICAgc2NvcGUuY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsdDtcbiAgICAgIHRoaXMudHJhY2tFbGVtZW50KHNjcmlwdCwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlLmN1cnJlbnRTY3JpcHQgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZEVsZW1lbnRUb0RvY3VtZW50KHNjcmlwdCk7XG4gICAgfSxcbiAgICBuZXh0VG9QYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9tYXlQYXJzZSA9IFtdO1xuICAgICAgcmV0dXJuICF0aGlzLnBhcnNpbmdFbGVtZW50ICYmICh0aGlzLm5leHRUb1BhcnNlSW5Eb2Mocm9vdERvY3VtZW50KSB8fCB0aGlzLm5leHRUb1BhcnNlRHluYW1pYygpKTtcbiAgICB9LFxuICAgIG5leHRUb1BhcnNlSW5Eb2M6IGZ1bmN0aW9uKGRvYywgbGluaykge1xuICAgICAgaWYgKGRvYyAmJiB0aGlzLl9tYXlQYXJzZS5pbmRleE9mKGRvYykgPCAwKSB7XG4gICAgICAgIHRoaXMuX21heVBhcnNlLnB1c2goZG9jKTtcbiAgICAgICAgdmFyIG5vZGVzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5wYXJzZVNlbGVjdG9yc0Zvck5vZGUoZG9jKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoLCBwID0gMCwgbjsgaSA8IGwgJiYgKG4gPSBub2Rlc1tpXSk7IGkrKykge1xuICAgICAgICAgIGlmICghdGhpcy5pc1BhcnNlZChuKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzUmVzb3VyY2UobikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGVJc0ltcG9ydChuKSA/IHRoaXMubmV4dFRvUGFyc2VJbkRvYyhuLl9fZG9jLCBuKSA6IG47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluaztcbiAgICB9LFxuICAgIG5leHRUb1BhcnNlRHluYW1pYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5keW5hbWljRWxlbWVudHNbMF07XG4gICAgfSxcbiAgICBwYXJzZVNlbGVjdG9yc0Zvck5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZTtcbiAgICAgIHJldHVybiBkb2MgPT09IHJvb3REb2N1bWVudCA/IHRoaXMuZG9jdW1lbnRTZWxlY3RvcnMgOiB0aGlzLmltcG9ydHNTZWxlY3RvcnM7XG4gICAgfSxcbiAgICBpc1BhcnNlZDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuX19pbXBvcnRQYXJzZWQ7XG4gICAgfSxcbiAgICBuZWVkc0R5bmFtaWNQYXJzaW5nOiBmdW5jdGlvbihlbHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNFbGVtZW50cy5pbmRleE9mKGVsdCkgPj0gMDtcbiAgICB9LFxuICAgIGhhc1Jlc291cmNlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZUlzSW1wb3J0KG5vZGUpICYmIG5vZGUuX19kb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIG5vZGVJc0ltcG9ydChlbHQpIHtcbiAgICByZXR1cm4gZWx0LmxvY2FsTmFtZSA9PT0gXCJsaW5rXCIgJiYgZWx0LnJlbCA9PT0gSU1QT1JUX0xJTktfVFlQRTtcbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZVNjcmlwdERhdGFVcmwoc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdENvbnRlbnQgPSBnZW5lcmF0ZVNjcmlwdENvbnRlbnQoc2NyaXB0KTtcbiAgICByZXR1cm4gXCJkYXRhOnRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04LFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNjcmlwdENvbnRlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2NyaXB0Q29udGVudChzY3JpcHQpIHtcbiAgICByZXR1cm4gc2NyaXB0LnRleHRDb250ZW50ICsgZ2VuZXJhdGVTb3VyY2VNYXBIaW50KHNjcmlwdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVTb3VyY2VNYXBIaW50KHNjcmlwdCkge1xuICAgIHZhciBvd25lciA9IHNjcmlwdC5vd25lckRvY3VtZW50O1xuICAgIG93bmVyLl9faW1wb3J0ZWRTY3JpcHRzID0gb3duZXIuX19pbXBvcnRlZFNjcmlwdHMgfHwgMDtcbiAgICB2YXIgbW9uaWtlciA9IHNjcmlwdC5vd25lckRvY3VtZW50LmJhc2VVUkk7XG4gICAgdmFyIG51bSA9IG93bmVyLl9faW1wb3J0ZWRTY3JpcHRzID8gXCItXCIgKyBvd25lci5fX2ltcG9ydGVkU2NyaXB0cyA6IFwiXCI7XG4gICAgb3duZXIuX19pbXBvcnRlZFNjcmlwdHMrKztcbiAgICByZXR1cm4gXCJcXG4vLyMgc291cmNlVVJMPVwiICsgbW9uaWtlciArIG51bSArIFwiLmpzXFxuXCI7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICAgIHZhciBjbG9uZSA9IHN0eWxlLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGNsb25lLnRleHRDb250ZW50ID0gc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgcGF0aC5yZXNvbHZlVXJsc0luU3R5bGUoY2xvbmUpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzY29wZS5wYXJzZXIgPSBpbXBvcnRQYXJzZXI7XG4gIHNjb3BlLklNUE9SVF9TRUxFQ1RPUiA9IElNUE9SVF9TRUxFQ1RPUjtcbn0pO1xuXG53aW5kb3cuSFRNTEltcG9ydHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBmbGFncyA9IHNjb3BlLmZsYWdzO1xuICB2YXIgSU1QT1JUX0xJTktfVFlQRSA9IHNjb3BlLklNUE9SVF9MSU5LX1RZUEU7XG4gIHZhciBJTVBPUlRfU0VMRUNUT1IgPSBzY29wZS5JTVBPUlRfU0VMRUNUT1I7XG4gIHZhciByb290RG9jdW1lbnQgPSBzY29wZS5yb290RG9jdW1lbnQ7XG4gIHZhciBMb2FkZXIgPSBzY29wZS5Mb2FkZXI7XG4gIHZhciBPYnNlcnZlciA9IHNjb3BlLk9ic2VydmVyO1xuICB2YXIgcGFyc2VyID0gc2NvcGUucGFyc2VyO1xuICB2YXIgaW1wb3J0ZXIgPSB7XG4gICAgZG9jdW1lbnRzOiB7fSxcbiAgICBkb2N1bWVudFByZWxvYWRTZWxlY3RvcnM6IElNUE9SVF9TRUxFQ1RPUixcbiAgICBpbXBvcnRzUHJlbG9hZFNlbGVjdG9yczogWyBJTVBPUlRfU0VMRUNUT1IgXS5qb2luKFwiLFwiKSxcbiAgICBsb2FkTm9kZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaW1wb3J0TG9hZGVyLmFkZE5vZGUobm9kZSk7XG4gICAgfSxcbiAgICBsb2FkU3VidHJlZTogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm1hcnNoYWxOb2RlcyhwYXJlbnQpO1xuICAgICAgaW1wb3J0TG9hZGVyLmFkZE5vZGVzKG5vZGVzKTtcbiAgICB9LFxuICAgIG1hcnNoYWxOb2RlczogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICByZXR1cm4gcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5sb2FkU2VsZWN0b3JzRm9yTm9kZShwYXJlbnQpKTtcbiAgICB9LFxuICAgIGxvYWRTZWxlY3RvcnNGb3JOb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGU7XG4gICAgICByZXR1cm4gZG9jID09PSByb290RG9jdW1lbnQgPyB0aGlzLmRvY3VtZW50UHJlbG9hZFNlbGVjdG9ycyA6IHRoaXMuaW1wb3J0c1ByZWxvYWRTZWxlY3RvcnM7XG4gICAgfSxcbiAgICBsb2FkZWQ6IGZ1bmN0aW9uKHVybCwgZWx0LCByZXNvdXJjZSwgZXJyLCByZWRpcmVjdGVkVXJsKSB7XG4gICAgICBmbGFncy5sb2FkICYmIGNvbnNvbGUubG9nKFwibG9hZGVkXCIsIHVybCwgZWx0KTtcbiAgICAgIGVsdC5fX3Jlc291cmNlID0gcmVzb3VyY2U7XG4gICAgICBlbHQuX19lcnJvciA9IGVycjtcbiAgICAgIGlmIChpc0ltcG9ydExpbmsoZWx0KSkge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudHNbdXJsXTtcbiAgICAgICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZG9jID0gZXJyID8gbnVsbCA6IG1ha2VEb2N1bWVudChyZXNvdXJjZSwgcmVkaXJlY3RlZFVybCB8fCB1cmwpO1xuICAgICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIGRvYy5fX2ltcG9ydExpbmsgPSBlbHQ7XG4gICAgICAgICAgICB0aGlzLmJvb3REb2N1bWVudChkb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmRvY3VtZW50c1t1cmxdID0gZG9jO1xuICAgICAgICB9XG4gICAgICAgIGVsdC5fX2RvYyA9IGRvYztcbiAgICAgIH1cbiAgICAgIHBhcnNlci5wYXJzZU5leHQoKTtcbiAgICB9LFxuICAgIGJvb3REb2N1bWVudDogZnVuY3Rpb24oZG9jKSB7XG4gICAgICB0aGlzLmxvYWRTdWJ0cmVlKGRvYyk7XG4gICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUoZG9jKTtcbiAgICAgIHBhcnNlci5wYXJzZU5leHQoKTtcbiAgICB9LFxuICAgIGxvYWRlZEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICBwYXJzZXIucGFyc2VOZXh0KCk7XG4gICAgfVxuICB9O1xuICB2YXIgaW1wb3J0TG9hZGVyID0gbmV3IExvYWRlcihpbXBvcnRlci5sb2FkZWQuYmluZChpbXBvcnRlciksIGltcG9ydGVyLmxvYWRlZEFsbC5iaW5kKGltcG9ydGVyKSk7XG4gIGltcG9ydGVyLm9ic2VydmVyID0gbmV3IE9ic2VydmVyKCk7XG4gIGZ1bmN0aW9uIGlzSW1wb3J0TGluayhlbHQpIHtcbiAgICByZXR1cm4gaXNMaW5rUmVsKGVsdCwgSU1QT1JUX0xJTktfVFlQRSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNMaW5rUmVsKGVsdCwgcmVsKSB7XG4gICAgcmV0dXJuIGVsdC5sb2NhbE5hbWUgPT09IFwibGlua1wiICYmIGVsdC5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IHJlbDtcbiAgfVxuICBmdW5jdGlvbiBoYXNCYXNlVVJJQWNjZXNzb3IoZG9jKSB7XG4gICAgcmV0dXJuICEhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkb2MsIFwiYmFzZVVSSVwiKTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlRG9jdW1lbnQocmVzb3VyY2UsIHVybCkge1xuICAgIHZhciBkb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoSU1QT1JUX0xJTktfVFlQRSk7XG4gICAgZG9jLl9VUkwgPSB1cmw7XG4gICAgdmFyIGJhc2UgPSBkb2MuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XG4gICAgYmFzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHVybCk7XG4gICAgaWYgKCFkb2MuYmFzZVVSSSAmJiAhaGFzQmFzZVVSSUFjY2Vzc29yKGRvYykpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2MsIFwiYmFzZVVSSVwiLCB7XG4gICAgICAgIHZhbHVlOiB1cmxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWV0YSA9IGRvYy5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcbiAgICBtZXRhLnNldEF0dHJpYnV0ZShcImNoYXJzZXRcIiwgXCJ1dGYtOFwiKTtcbiAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChtZXRhKTtcbiAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChiYXNlKTtcbiAgICBkb2MuYm9keS5pbm5lckhUTUwgPSByZXNvdXJjZTtcbiAgICBpZiAod2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5ib290c3RyYXApIHtcbiAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuYm9vdHN0cmFwKGRvYyk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgaWYgKCFkb2N1bWVudC5iYXNlVVJJKSB7XG4gICAgdmFyIGJhc2VVUklEZXNjcmlwdG9yID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKTtcbiAgICAgICAgcmV0dXJuIGJhc2UgPyBiYXNlLmhyZWYgOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgXCJiYXNlVVJJXCIsIGJhc2VVUklEZXNjcmlwdG9yKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocm9vdERvY3VtZW50LCBcImJhc2VVUklcIiwgYmFzZVVSSURlc2NyaXB0b3IpO1xuICB9XG4gIHNjb3BlLmltcG9ydGVyID0gaW1wb3J0ZXI7XG4gIHNjb3BlLmltcG9ydExvYWRlciA9IGltcG9ydExvYWRlcjtcbn0pO1xuXG53aW5kb3cuSFRNTEltcG9ydHMuYWRkTW9kdWxlKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBwYXJzZXIgPSBzY29wZS5wYXJzZXI7XG4gIHZhciBpbXBvcnRlciA9IHNjb3BlLmltcG9ydGVyO1xuICB2YXIgZHluYW1pYyA9IHtcbiAgICBhZGRlZDogZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIHZhciBvd25lciwgcGFyc2VkLCBsb2FkaW5nO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGgsIG47IGkgPCBsICYmIChuID0gbm9kZXNbaV0pOyBpKyspIHtcbiAgICAgICAgaWYgKCFvd25lcikge1xuICAgICAgICAgIG93bmVyID0gbi5vd25lckRvY3VtZW50O1xuICAgICAgICAgIHBhcnNlZCA9IHBhcnNlci5pc1BhcnNlZChvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGluZyA9IHRoaXMuc2hvdWxkTG9hZE5vZGUobik7XG4gICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgaW1wb3J0ZXIubG9hZE5vZGUobik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VOb2RlKG4pICYmIHBhcnNlZCkge1xuICAgICAgICAgIHBhcnNlci5wYXJzZUR5bmFtaWMobiwgbG9hZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZExvYWROb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBtYXRjaGVzLmNhbGwobm9kZSwgaW1wb3J0ZXIubG9hZFNlbGVjdG9yc0Zvck5vZGUobm9kZSkpO1xuICAgIH0sXG4gICAgc2hvdWxkUGFyc2VOb2RlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBtYXRjaGVzLmNhbGwobm9kZSwgcGFyc2VyLnBhcnNlU2VsZWN0b3JzRm9yTm9kZShub2RlKSk7XG4gICAgfVxuICB9O1xuICBpbXBvcnRlci5vYnNlcnZlci5hZGRDYWxsYmFjayA9IGR5bmFtaWMuYWRkZWQuYmluZChkeW5hbWljKTtcbiAgdmFyIG1hdGNoZXMgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBIVE1MRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8IEhUTUxFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgSFRNTEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBIVE1MRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG59KTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gIHZhciBpbml0aWFsaXplTW9kdWxlcyA9IHNjb3BlLmluaXRpYWxpemVNb2R1bGVzO1xuICB2YXIgaXNJRSA9IHNjb3BlLmlzSUU7XG4gIGlmIChzY29wZS51c2VOYXRpdmUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF3aW5kb3cuQ3VzdG9tRXZlbnQgfHwgaXNJRSAmJiB0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihpblR5cGUsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuICAgICAgZS5pbml0Q3VzdG9tRXZlbnQoaW5UeXBlLCBCb29sZWFuKHBhcmFtcy5idWJibGVzKSwgQm9vbGVhbihwYXJhbXMuY2FuY2VsYWJsZSksIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0UHJldmVudGVkXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZTtcbiAgICB9O1xuICAgIHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICB9XG4gIGluaXRpYWxpemVNb2R1bGVzKCk7XG4gIHZhciByb290RG9jdW1lbnQgPSBzY29wZS5yb290RG9jdW1lbnQ7XG4gIGZ1bmN0aW9uIGJvb3RzdHJhcCgpIHtcbiAgICB3aW5kb3cuSFRNTEltcG9ydHMuaW1wb3J0ZXIuYm9vdERvY3VtZW50KHJvb3REb2N1bWVudCk7XG4gIH1cbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImludGVyYWN0aXZlXCIgJiYgIXdpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgIGJvb3RzdHJhcCgpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGJvb3RzdHJhcCk7XG4gIH1cbn0pKHdpbmRvdy5IVE1MSW1wb3J0cyk7IiwiLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xuICovXG5cbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcblxuXHRUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cblx0XHR0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcblx0XHR0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcblxuXHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0TWVzaDoge30sXG5cdFx0XHRMaW5lOiB7fSxcblx0XHRcdExPRDoge30sXG5cdFx0XHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRTcHJpdGU6IHt9XG5cdFx0fTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xuXHRcdFx0UG9pbnRDbG91ZDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYXNjU29ydCggYSwgYiApIHtcblxuXHRcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHR9XG5cblx0fTtcblxufSggVEhSRUUgKSApO1xuIiwiLy8gcGVyZm9ybWFuY2Uubm93KCkgcG9seWZpbGwgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvNTQzODY1MFxuXG4oZnVuY3Rpb24oKXtcblxuICAvLyBwcmVwYXJlIGJhc2UgcGVyZiBvYmplY3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7fTtcbiAgfVxuXG4gIGlmICghd2luZG93LnBlcmZvcm1hbmNlLm5vdyl7XG5cbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChwZXJmb3JtYW5jZS50aW1pbmcgJiYgcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydCl7XG4gICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0XG4gICAgfVxuXG5cbiAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gbm93KCl7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9XG5cbiAgfVxuXG59KSgpO1xuXG52YXIgclN0YXRzID0gZnVuY3Rpb24gclN0YXRzKCBzZXR0aW5ncyApIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGltcG9ydENTUyggdXJsICl7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIGVsZW1lbnQuaHJlZiA9IHVybDtcbiAgICAgICAgZWxlbWVudC5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoZWxlbWVudClcblxuICAgIH1cblxuICAgIHZhciBfc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fSxcbiAgICAgICAgX2NvbG91cnMgPSBbICcjODUwNzAwJywgJyNjNzQ5MDAnLCAnI2ZjYjMwMCcsICcjMjg0MjgwJywgJyM0YzdjMGMnIF07XG5cbiAgICBpbXBvcnRDU1MoICdodHRwOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG8rQ29uZGVuc2VkOjQwMCw3MDAsMzAwJyApO1xuICAgIGltcG9ydENTUyggKCBfc2V0dGluZ3MuQ1NTUGF0aD9fc2V0dGluZ3MuQ1NTUGF0aDonJyApICsgJ3JTdGF0cy5jc3MnICk7XG5cbiAgICBpZiggIV9zZXR0aW5ncy52YWx1ZXMgKSBfc2V0dGluZ3MudmFsdWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBHcmFwaCggX2RvbSwgX2lkLCBfZGVmICkge1xuXG4gICAgICAgIHZhciBfZGVmID0gX2RlZiB8fCB7fTtcbiAgICAgICAgdmFyIF9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuICAgICAgICAgICAgX2N0eCA9IF9jYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLFxuICAgICAgICAgICAgX21heCA9IDAsXG4gICAgICAgICAgICBfY3VycmVudCA9IDA7XG5cbiAgICAgICAgdmFyIGMgPSBfZGVmLmNvbG9yP19kZWYuY29sb3I6JyM2NjY2NjYnO1xuICAgICAgICB2YXIgd2MgPSBfZGVmLndhcm5pbmdDb2xvcj9fZGVmLndhcm5pbmdDb2xvcjonI2I3MDAwMCc7XG5cbiAgICAgICAgdmFyIF9kb3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxuICAgICAgICAgICAgX2RvdEN0eCA9IF9kb3RDYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICBfZG90Q2FudmFzLndpZHRoID0gMTtcbiAgICAgICAgX2RvdENhbnZhcy5oZWlnaHQgPSAyICogX2VsSGVpZ2h0O1xuICAgICAgICBfZG90Q3R4LmZpbGxTdHlsZSA9ICcjNDQ0NDQ0JztcbiAgICAgICAgX2RvdEN0eC5maWxsUmVjdCggMCwgMCwgMSwgMiAqIF9lbEhlaWdodCApO1xuICAgICAgICBfZG90Q3R4LmZpbGxTdHlsZSA9IGM7XG4gICAgICAgIF9kb3RDdHguZmlsbFJlY3QoIDAsIF9lbEhlaWdodCwgMSwgX2VsSGVpZ2h0ICk7XG4gICAgICAgIF9kb3RDdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuICAgICAgICBfZG90Q3R4Lmdsb2JhbEFscGhhID0gLjU7XG4gICAgICAgIF9kb3RDdHguZmlsbFJlY3QoIDAsIF9lbEhlaWdodCwgMSwgMSApO1xuICAgICAgICBfZG90Q3R4Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICB2YXIgX2FsYXJtQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgICAgICAgICAgIF9hbGFybUN0eCA9IF9hbGFybUNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICAgIF9hbGFybUNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgIF9hbGFybUNhbnZhcy5oZWlnaHQgPSAyICogX2VsSGVpZ2h0O1xuICAgICAgICBfYWxhcm1DdHguZmlsbFN0eWxlID0gJyM0NDQ0NDQnO1xuICAgICAgICBfYWxhcm1DdHguZmlsbFJlY3QoIDAsIDAsIDEsIDIgKiBfZWxIZWlnaHQgKTtcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxTdHlsZSA9ICcjYjcwMDAwJztcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxSZWN0KCAwLCBfZWxIZWlnaHQsIDEsIF9lbEhlaWdodCApO1xuICAgICAgICBfYWxhcm1DdHguZ2xvYmFsQWxwaGEgPSAuNTtcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcbiAgICAgICAgX2FsYXJtQ3R4LmZpbGxSZWN0KCAwLCBfZWxIZWlnaHQsIDEsIDEgKTtcbiAgICAgICAgX2FsYXJtQ3R4Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICBmdW5jdGlvbiBfaW5pdCgpIHtcblxuICAgICAgICAgICAgX2NhbnZhcy53aWR0aCA9IF9lbFdpZHRoO1xuICAgICAgICAgICAgX2NhbnZhcy5oZWlnaHQgPSBfZWxIZWlnaHQ7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gX2NhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IF9jYW52YXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIF9jYW52YXMuY2xhc3NOYW1lID0gJ3JzLWNhbnZhcyc7XG4gICAgICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfY2FudmFzICk7XG5cbiAgICAgICAgICAgIF9jdHguZmlsbFN0eWxlID0gJyM0NDQ0NDQnO1xuICAgICAgICAgICAgX2N0eC5maWxsUmVjdCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2RyYXcoIHYsIGFsYXJtICkge1xuICAgICAgICAgICAgX2N1cnJlbnQgKz0gKCB2IC0gX2N1cnJlbnQgKSAqIC4xO1xuICAgICAgICAgICAgX21heCAqPSAuOTk7XG4gICAgICAgICAgICBpZiggX2N1cnJlbnQgPiBfbWF4ICkgX21heCA9IF9jdXJyZW50O1xuICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoIF9jYW52YXMsIDEsIDAsIF9jYW52YXMud2lkdGggLSAxLCBfY2FudmFzLmhlaWdodCwgMCwgMCwgX2NhbnZhcy53aWR0aCAtIDEsIF9jYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgICBpZiggYWxhcm0gKSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoIF9hbGFybUNhbnZhcywgX2NhbnZhcy53aWR0aCAtIDEsIF9jYW52YXMuaGVpZ2h0IC0gX2N1cnJlbnQgKiBfY2FudmFzLmhlaWdodCAvIF9tYXggLSBfZWxIZWlnaHQgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoIF9kb3RDYW52YXMsIF9jYW52YXMud2lkdGggLSAxLCBfY2FudmFzLmhlaWdodCAtIF9jdXJyZW50ICogX2NhbnZhcy5oZWlnaHQgLyBfbWF4IC0gX2VsSGVpZ2h0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkcmF3OiBfZHJhd1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBTdGFja0dyYXBoKCBfZG9tLCBfbnVtICkge1xuXG4gICAgICAgIHZhciBfY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgICAgICAgICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoICcyZCcgKSxcbiAgICAgICAgICAgIF9tYXggPSAwLFxuICAgICAgICAgICAgX2N1cnJlbnQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9pbml0KCkge1xuXG4gICAgICAgICAgICBfY2FudmFzLndpZHRoID0gX2VsV2lkdGg7XG4gICAgICAgICAgICBfY2FudmFzLmhlaWdodCA9IF9lbEhlaWdodCAqIF9udW07XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLndpZHRoID0gX2NhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgICAgICBfY2FudmFzLnN0eWxlLmhlaWdodCA9IF9jYW52YXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIF9jYW52YXMuY2xhc3NOYW1lID0gJ3JzLWNhbnZhcyc7XG4gICAgICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfY2FudmFzICk7XG5cbiAgICAgICAgICAgIF9jdHguZmlsbFN0eWxlID0gJyM0NDQ0NDQnO1xuICAgICAgICAgICAgX2N0eC5maWxsUmVjdCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2RyYXcoIHYgKSB7XG4gICAgICAgICAgICBfY3R4LmRyYXdJbWFnZSggX2NhbnZhcywgMSwgMCwgX2NhbnZhcy53aWR0aCAtIDEsIF9jYW52YXMuaGVpZ2h0LCAwLCAwLCBfY2FudmFzLndpZHRoIC0gMSwgX2NhbnZhcy5oZWlnaHQgKTtcbiAgICAgICAgICAgIHZhciB0aCA9IDA7XG4gICAgICAgICAgICBmb3IoIHZhciBqIGluIHYgKSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSB2WyBqIF0gKiBfY2FudmFzLmhlaWdodDtcbiAgICAgICAgICAgICAgICBfY3R4LmZpbGxTdHlsZSA9IF9jb2xvdXJzWyBqIF07XG4gICAgICAgICAgICAgICAgX2N0eC5maWxsUmVjdCggX2NhbnZhcy53aWR0aCAtIDEsIHRoLCAxLCBoICk7XG4gICAgICAgICAgICAgICAgdGggKz0gaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9pbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRyYXc6IF9kcmF3XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBlcmZDb3VudGVyKCBpZCwgZ3JvdXAgKSB7XG5cbiAgICAgICAgdmFyIF9pZCA9IGlkLFxuICAgICAgICAgICAgX3RpbWUsXG4gICAgICAgICAgICBfdmFsdWUgPSAwLFxuICAgICAgICAgICAgX3RvdGFsID0gMCxcbiAgICAgICAgICAgIF9hdmVyYWdlVmFsdWUgPSAwLFxuICAgICAgICAgICAgX2FjY3VtVmFsdWUgPSAwLFxuICAgICAgICAgICAgX2FjY3VtU3RhcnQgPSBEYXRlLm5vdygpLFxuICAgICAgICAgICAgX2FjY3VtU2FtcGxlcyA9IDAsXG4gICAgICAgICAgICBfZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSxcbiAgICAgICAgICAgIF9zcGFuSWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3BhbicgKSxcbiAgICAgICAgICAgIF9zcGFuVmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApLFxuICAgICAgICAgICAgX3NwYW5WYWx1ZVRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggJycgKSxcbiAgICAgICAgICAgIF9kZWYgPSBfc2V0dGluZ3M/X3NldHRpbmdzLnZhbHVlc1sgX2lkLnRvTG93ZXJDYXNlKCkgXTpudWxsLFxuICAgICAgICAgICAgX2dyYXBoID0gbmV3IEdyYXBoKCBfZG9tLCBfaWQsIF9kZWYgKTtcblxuICAgICAgICBfZG9tLmNsYXNzTmFtZSA9ICdycy1jb3VudGVyLWJhc2UnO1xuXG4gICAgICAgIF9zcGFuSWQuY2xhc3NOYW1lID0gJ3JzLWNvdW50ZXItaWQnXG4gICAgICAgIF9zcGFuSWQudGV4dENvbnRlbnQgPSAoIF9kZWYgJiYgX2RlZi5jYXB0aW9uICk/X2RlZi5jYXB0aW9uOl9pZDtcblxuICAgICAgICBfc3BhblZhbHVlLmNsYXNzTmFtZSA9ICdycy1jb3VudGVyLXZhbHVlJztcbiAgICAgICAgX3NwYW5WYWx1ZS5hcHBlbmRDaGlsZCggX3NwYW5WYWx1ZVRleHQgKTtcblxuICAgICAgICBfZG9tLmFwcGVuZENoaWxkKCBfc3BhbklkICk7XG4gICAgICAgIF9kb20uYXBwZW5kQ2hpbGQoIF9zcGFuVmFsdWUgKTtcbiAgICAgICAgaWYoIGdyb3VwICkgZ3JvdXAuZGl2LmFwcGVuZENoaWxkKCBfZG9tICk7XG4gICAgICAgIGVsc2UgX2Rpdi5hcHBlbmRDaGlsZCggX2RvbSApO1xuXG4gICAgICAgIF90aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgICAgZnVuY3Rpb24gX2F2ZXJhZ2UoIHYgKSB7XG4gICAgICAgICAgICBpZiggX2RlZiAmJiBfZGVmLmF2ZXJhZ2UgKSB7XG4gICAgICAgICAgICAgICAgX2FjY3VtVmFsdWUgKz0gdjtcbiAgICAgICAgICAgICAgICBfYWNjdW1TYW1wbGVzKys7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGlmKCB0IC0gX2FjY3VtU3RhcnQgPj0gKCBfZGVmLmF2Z01zIHx8IDEwMDAgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgX2F2ZXJhZ2VWYWx1ZSA9IF9hY2N1bVZhbHVlIC8gX2FjY3VtU2FtcGxlcztcbiAgICAgICAgICAgICAgICAgICAgX2FjY3VtVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBfYWNjdW1TdGFydCA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIF9hY2N1bVNhbXBsZXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9zdGFydCgpe1xuICAgICAgICAgICAgX3RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9lbmQoKSB7XG4gICAgICAgICAgICBfdmFsdWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIF90aW1lO1xuICAgICAgICAgICAgX2F2ZXJhZ2UoIF92YWx1ZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX3RpY2soKSB7XG4gICAgICAgICAgICBfZW5kKCk7XG4gICAgICAgICAgICBfc3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9kcmF3KCkge1xuICAgICAgICAgICAgdmFyIHYgPSAoIF9kZWYgJiYgX2RlZi5hdmVyYWdlICk/X2F2ZXJhZ2VWYWx1ZTpfdmFsdWVcbiAgICAgICAgICAgIF9zcGFuVmFsdWVUZXh0Lm5vZGVWYWx1ZSA9IE1hdGgucm91bmQoIHYgKiAxMDAgKSAvIDEwMDtcbiAgICAgICAgICAgIHZhciBhID0gKCBfZGVmICYmICggKCBfZGVmLmJlbG93ICYmIF92YWx1ZSA8IF9kZWYuYmVsb3cgKSB8fCAoIF9kZWYub3ZlciAmJiBfdmFsdWUgPiBfZGVmLm92ZXIgKSApICk7XG4gICAgICAgICAgICBfZ3JhcGguZHJhdyggX3ZhbHVlLCBhICk7XG4gICAgICAgICAgICBfZG9tLnN0eWxlLmNvbG9yID0gYT8nI2I3MDAwMCc6JyNmZmZmZmYnO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2ZyYW1lKCkge1xuICAgICAgICAgICAgdmFyIHQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIHZhciBlID0gdCAtIF90aW1lO1xuICAgICAgICAgICAgX3RvdGFsKys7XG4gICAgICAgICAgICBpZiggZSA+IDEwMDAgKSB7XG4gICAgICAgICAgICAgICAgX3ZhbHVlID0gX3RvdGFsICogMTAwMCAvIGU7XG4gICAgICAgICAgICAgICAgX3RvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBfdGltZSA9IHQ7XG4gICAgICAgICAgICAgICAgX2F2ZXJhZ2UoIF92YWx1ZSApO1xuICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfc2V0KCB2ICkge1xuICAgICAgICAgICAgX3ZhbHVlID0gdjtcbiAgICAgICAgICAgIF9hdmVyYWdlKCBfdmFsdWUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXQ6IF9zZXQsXG4gICAgICAgICAgICBzdGFydDogX3N0YXJ0LFxuICAgICAgICAgICAgdGljazogX3RpY2ssXG4gICAgICAgICAgICBlbmQ6IF9lbmQsXG4gICAgICAgICAgICBmcmFtZTogX2ZyYW1lLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCl7IHJldHVybiBfdmFsdWU7IH0sXG4gICAgICAgICAgICBkcmF3OiBfZHJhd1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYW1wbGUoKSB7XG5cbiAgICAgICAgdmFyIF92YWx1ZSA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gX3NldCggdiApIHtcbiAgICAgICAgICAgIF92YWx1ZSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0OiBfc2V0LFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCl7IHJldHVybiBfdmFsdWU7IH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIF9iYXNlLFxuICAgICAgICBfZGl2LFxuICAgICAgICBfaGVpZ2h0ID0gbnVsbCxcbiAgICAgICAgX2VsSGVpZ2h0ID0gMTAsXG4gICAgICAgIF9lbFdpZHRoID0gMjAwO1xuXG4gICAgdmFyIF9wZXJmQ291bnRlcnMgPSB7fSxcbiAgICAgICAgX3NhbXBsZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIF9wZXJmKCBpZCApIHtcblxuICAgICAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKCBpZCA9PT0gdW5kZWZpbmVkICkgaWQgPSAnZGVmYXVsdCc7XG4gICAgICAgIGlmKCBfcGVyZkNvdW50ZXJzWyBpZCBdICkgcmV0dXJuIF9wZXJmQ291bnRlcnNbIGlkIF07XG5cbiAgICAgICAgdmFyIGdyb3VwID0gbnVsbDtcbiAgICAgICAgaWYoIF9zZXR0aW5ncyAmJiBfc2V0dGluZ3MuZ3JvdXBzICkge1xuICAgICAgICAgICAgZm9yKCB2YXIgaiBpbiBfc2V0dGluZ3MuZ3JvdXBzICkge1xuICAgICAgICAgICAgICAgIHZhciBnID0gX3NldHRpbmdzLmdyb3Vwc1sgcGFyc2VJbnQoIGosIDEwICkgXTtcbiAgICAgICAgICAgICAgICBpZiggZy52YWx1ZXMuaW5kZXhPZiggaWQudG9Mb3dlckNhc2UoKSApICE9IC0xICkge1xuICAgICAgICAgICAgICAgICAgICBncm91cCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwID0gbmV3IFBlcmZDb3VudGVyKCBpZCwgZ3JvdXAgKTtcbiAgICAgICAgX3BlcmZDb3VudGVyc1sgaWQgXSA9IHA7XG4gICAgICAgIHJldHVybiBwO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaXQoKSB7XG5cbiAgICAgICAgaWYoIF9zZXR0aW5ncy5wbHVnaW5zICkge1xuICAgICAgICAgICAgaWYoICFfc2V0dGluZ3MudmFsdWVzICkgX3NldHRpbmdzLnZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgaWYoICFfc2V0dGluZ3MuZ3JvdXBzICkgX3NldHRpbmdzLmdyb3VwcyA9IFtdO1xuICAgICAgICAgICAgaWYoICFfc2V0dGluZ3MuZnJhY3Rpb25zICkgX3NldHRpbmdzLmZyYWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBfc2V0dGluZ3MucGx1Z2lucy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgICAgICAgICBfc2V0dGluZ3MucGx1Z2luc1sgaiBdLmF0dGFjaCggX3BlcmYgKTtcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBrIGluIF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0udmFsdWVzICkge1xuICAgICAgICAgICAgICAgICAgICBfc2V0dGluZ3MudmFsdWVzWyBrIF0gPSBfc2V0dGluZ3MucGx1Z2luc1sgaiBdLnZhbHVlcyBbIGsgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3NldHRpbmdzLmdyb3VwcyA9IF9zZXR0aW5ncy5ncm91cHMuY29uY2F0KCBfc2V0dGluZ3MucGx1Z2luc1sgaiBdLmdyb3VwcyApO1xuICAgICAgICAgICAgICAgIF9zZXR0aW5ncy5mcmFjdGlvbnMgPSBfc2V0dGluZ3MuZnJhY3Rpb25zLmNvbmNhdCggX3NldHRpbmdzLnBsdWdpbnNbIGogXS5mcmFjdGlvbnMgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9zZXR0aW5ncy5wbHVnaW5zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBfYmFzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgIF9iYXNlLmNsYXNzTmFtZSA9ICdycy1iYXNlJztcbiAgICAgICAgX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgIF9kaXYuY2xhc3NOYW1lID0gJ3JzLWNvbnRhaW5lcic7XG4gICAgICAgIF9kaXYuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICBfYmFzZS5hcHBlbmRDaGlsZCggX2RpdiApO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBfYmFzZSApO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBfYmFzZSwgbnVsbCApLmdldFByb3BlcnR5VmFsdWUoICdmb250LXNpemUnICk7XG4gICAgICAgIC8vX2VsSGVpZ2h0ID0gcGFyc2VGbG9hdCggc3R5bGUgKTtcblxuICAgICAgICBpZiggIV9zZXR0aW5ncyApIHJldHVybjtcblxuICAgICAgICBpZiggX3NldHRpbmdzLmdyb3VwcyApIHtcbiAgICAgICAgICAgIGZvciggdmFyIGogaW4gX3NldHRpbmdzLmdyb3VwcyApIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IF9zZXR0aW5ncy5ncm91cHNbIHBhcnNlSW50KCBqLCAxMCApIF07XG4gICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9ICdycy1ncm91cCc7XG4gICAgICAgICAgICAgICAgZy5kaXYgPSBkaXY7XG4gICAgICAgICAgICAgICAgdmFyIGgxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2gxJyApO1xuICAgICAgICAgICAgICAgIGgxLnRleHRDb250ZW50ID0gZy5jYXB0aW9uO1xuICAgICAgICAgICAgICAgIGgxLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC50b2dnbGUoICdoaWRkZW4nICk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQoIGRpdiApICk7XG4gICAgICAgICAgICAgICAgX2Rpdi5hcHBlbmRDaGlsZCggaDEgKTtcbiAgICAgICAgICAgICAgICBfZGl2LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBfc2V0dGluZ3MuZnJhY3Rpb25zICkge1xuICAgICAgICAgICAgZm9yKCB2YXIgaiBpbiBfc2V0dGluZ3MuZnJhY3Rpb25zICkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgcGFyc2VJbnQoIGosIDEwICkgXTtcbiAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gJ3JzLWZyYWN0aW9uJztcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQuY2xhc3NOYW1lID0gJ3JzLWxlZ2VuZCc7XG5cbiAgICAgICAgICAgICAgICB2YXIgaCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgayBpbiBfc2V0dGluZ3MuZnJhY3Rpb25zWyBqIF0uc3RlcHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3AnICk7XG4gICAgICAgICAgICAgICAgICAgIHAudGV4dENvbnRlbnQgPSBfc2V0dGluZ3MuZnJhY3Rpb25zWyBqIF0uc3RlcHNbIGsgXTtcbiAgICAgICAgICAgICAgICAgICAgcC5zdHlsZS5jb2xvciA9IF9jb2xvdXJzWyBoIF07XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmRDaGlsZCggcCApO1xuICAgICAgICAgICAgICAgICAgICBoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZCggbGVnZW5kICk7XG4gICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGggKiBfZWxIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIGYuZGl2ID0gZGl2O1xuICAgICAgICAgICAgICAgIHZhciBncmFwaCA9IG5ldyBTdGFja0dyYXBoKCBkaXYsIGggKTtcbiAgICAgICAgICAgICAgICBmLmdyYXBoID0gZ3JhcGg7XG4gICAgICAgICAgICAgICAgX2Rpdi5hcHBlbmRDaGlsZCggZGl2ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF91cGRhdGUoKSB7XG5cbiAgICAgICAgZm9yKCB2YXIgaiBpbiBfc2V0dGluZ3MucGx1Z2lucyApIHtcbiAgICAgICAgICAgIF9zZXR0aW5ncy5wbHVnaW5zWyBqIF0udXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBqIGluIF9wZXJmQ291bnRlcnMgKSB7XG4gICAgICAgICAgICBfcGVyZkNvdW50ZXJzWyBqIF0uZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIF9zZXR0aW5ncyAmJiBfc2V0dGluZ3MuZnJhY3Rpb25zICkge1xuICAgICAgICAgICAgZm9yKCB2YXIgaiBpbiBfc2V0dGluZ3MuZnJhY3Rpb25zICkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gX3NldHRpbmdzLmZyYWN0aW9uc1sgcGFyc2VJbnQoIGosIDEwICkgXTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBiYXNlID0gX3BlcmZDb3VudGVyc1sgZi5iYXNlLnRvTG93ZXJDYXNlKCkgXTtcbiAgICAgICAgICAgICAgICBpZiggYmFzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UudmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgayBpbiBfc2V0dGluZ3MuZnJhY3Rpb25zWyBqIF0uc3RlcHMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9zZXR0aW5ncy5mcmFjdGlvbnNbIGogXS5zdGVwc1sgcGFyc2VJbnQoIGssIDEwICkgXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9wZXJmQ291bnRlcnNbIHMgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5wdXNoKCB2YWwudmFsdWUoKSAvIGJhc2UgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmLmdyYXBoLmRyYXcoIHYgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qaWYoIF9oZWlnaHQgIT0gX2Rpdi5jbGllbnRIZWlnaHQgKSB7XG4gICAgICAgICAgICBfaGVpZ2h0ID0gX2Rpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBfYmFzZS5zdHlsZS5oZWlnaHQgPSBfaGVpZ2h0ICsgMiAqIF9lbEhlaWdodCArICdweCc7XG4gICAgICAgIGNvbnNvbGUubG9nKCBfYmFzZS5jbGllbnRIZWlnaHQgKTtcbiAgICAgICAgfSovXG5cbiAgICB9XG5cbiAgICBfaW5pdCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBpZCApIHtcbiAgICAgICAgaWYoIGlkICkgcmV0dXJuIF9wZXJmKCBpZCApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlOiBfdXBkYXRlXG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7IG1vZHVsZS5leHBvcnRzID0gclN0YXRzOyB9IiwiLypcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxudmFyIFV0aWwgPSB7fTtcblxuVXRpbC5iYXNlNjQgPSBmdW5jdGlvbihtaW1lVHlwZSwgYmFzZTY0KSB7XG4gIHJldHVybiAnZGF0YTonICsgbWltZVR5cGUgKyAnO2Jhc2U2NCwnICsgYmFzZTY0O1xufTtcblxuVXRpbC5pc01vYmlsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgKGZ1bmN0aW9uKGEpe2lmKC8oYW5kcm9pZHxiYlxcZCt8bWVlZ28pLittb2JpbGV8YXZhbnRnb3xiYWRhXFwvfGJsYWNrYmVycnl8YmxhemVyfGNvbXBhbHxlbGFpbmV8ZmVubmVjfGhpcHRvcHxpZW1vYmlsZXxpcChob25lfG9kKXxpcmlzfGtpbmRsZXxsZ2UgfG1hZW1vfG1pZHB8bW1wfG1vYmlsZS4rZmlyZWZveHxuZXRmcm9udHxvcGVyYSBtKG9ifGluKWl8cGFsbSggb3MpP3xwaG9uZXxwKGl4aXxyZSlcXC98cGx1Y2tlcnxwb2NrZXR8cHNwfHNlcmllcyg0fDYpMHxzeW1iaWFufHRyZW98dXBcXC4oYnJvd3NlcnxsaW5rKXx2b2RhZm9uZXx3YXB8d2luZG93cyBjZXx4ZGF8eGlpbm8vaS50ZXN0KGEpfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsNCkpKWNoZWNrID0gdHJ1ZX0pKG5hdmlnYXRvci51c2VyQWdlbnR8fG5hdmlnYXRvci52ZW5kb3J8fHdpbmRvdy5vcGVyYSk7XG4gIHJldHVybiBjaGVjaztcbn07XG5cblV0aWwuaXNJT1MgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIC8oaVBhZHxpUGhvbmV8aVBvZCkvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufTtcblxuVXRpbC5pc0lGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5VdGlsLmFwcGVuZFF1ZXJ5UGFyYW1ldGVyID0gZnVuY3Rpb24odXJsLCBrZXksIHZhbHVlKSB7XG4gIC8vIERldGVybWluZSBkZWxpbWl0ZXIgYmFzZWQgb24gaWYgdGhlIFVSTCBhbHJlYWR5IEdFVCBwYXJhbWV0ZXJzIGluIGl0LlxuICB2YXIgZGVsaW1pdGVyID0gKHVybC5pbmRleE9mKCc/JykgPCAwID8gJz8nIDogJyYnKTtcbiAgdXJsICs9IGRlbGltaXRlciArIGtleSArICc9JyArIHZhbHVlO1xuICByZXR1cm4gdXJsO1xufTtcblxuLy8gRnJvbSBodHRwOi8vZ29vLmdsLzRXWDN0Z1xuVXRpbC5nZXRRdWVyeVBhcmFtZXRlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcW10vLCBcIlxcXFxbXCIpLnJlcGxhY2UoL1tcXF1dLywgXCJcXFxcXVwiKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIltcXFxcPyZdXCIgKyBuYW1lICsgXCI9KFteJiNdKilcIiksXG4gICAgICByZXN1bHRzID0gcmVnZXguZXhlYyhsb2NhdGlvbi5zZWFyY2gpO1xuICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbCA/IFwiXCIgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgXCIgXCIpKTtcbn07XG5cblV0aWwuaXNMYW5kc2NhcGVNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAod2luZG93Lm9yaWVudGF0aW9uID09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAtOTApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgVXRpbCA9IHJlcXVpcmUoJy4vdXRpbC5qcycpO1xuXG4vKipcbiAqIEFuZHJvaWQgYW5kIGlPUyBjb21wYXRpYmxlIHdha2Vsb2NrIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIFJlZmFjdG9yZWQgdGhhbmtzIHRvIGRrb3ZhbGV2QC5cbiAqL1xuZnVuY3Rpb24gQW5kcm9pZFdha2VMb2NrKCkge1xuICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuXG4gIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgdmlkZW8ucGxheSgpO1xuICB9KTtcblxuICB0aGlzLnJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodmlkZW8ucGF1c2VkKSB7XG4gICAgICAvLyBCYXNlNjQgdmVyc2lvbiBvZiB2aWRlb3Nfc3JjL25vLXNsZWVwLTYwcy53ZWJtLlxuICAgICAgdmlkZW8uc3JjID0gVXRpbC5iYXNlNjQoJ3ZpZGVvL3dlYm0nLCAnR2tYZm93RUFBQUFBQUFBZlFvYUJBVUwzZ1FGQzhvRUVRdk9CQ0VLQ2hIZGxZbTFDaDRFQ1FvV0JBaGhUZ0djQkFBQUFBQUFINHhGTm0zUkFMRTI3aTFPcmhCVkpxV1pUcklIZlRidU1VNnVFRmxTdWExT3NnZ0V3VGJ1TVU2dUVIRk83YTFPc2dnZkc3QUVBQUFBQUFBQ2tBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFWU2FsbUFRQUFBQUFBQUVVcTE3R0REMEpBVFlDTlRHRjJaalUyTGpRd0xqRXdNVmRCalV4aGRtWTFOaTQwTUM0eE1ERnpwSkFHU0pUTWJzTHBEdC95U2tpcGdYMWZSSW1JUU8xTUFBQUFBQUFXVks1ckFRQUFBQUFBQUR1dUFRQUFBQUFBQURMWGdRRnp4WUVCbklFQUlyV2NnM1Z1WklhRlZsOVdVRG1EZ1FFajQ0T0VPNXJLQU9BQkFBQUFBQUFBQnJDQnNMcUJrQjlEdG5VQkFBQUFBQUFBbytlQkFLT21nUUFBZ0tKSmcwSUFBVjRCSHNBSEJJT0RDb0FBQ21IMk1BQUFaeGd6NGRQU1RGaTVKQUNqbG9FRDZBQ21BRUNTbkFCTVFBQURZQUFBV2kwcXVvQ2psb0VIMEFDbUFFQ1NuQUJOd0FBRFlBQUFXaTBxdW9DamxvRUx1QUNtQUVDU25BQk5nQUFEWUFBQVdpMHF1b0NqbG9FUG9BQ21BRUNTbkFCTllBQURZQUFBV2kwcXVvQ2psb0VUaUFDbUFFQ1NuQUJOSUFBRFlBQUFXaTBxdW9BZlE3WjFBUUFBQUFBQUFKVG5naGR3bzVhQkFBQUFwZ0JBa3B3QVRPQUFBMkFBQUZvdEtycUFvNWFCQStnQXBnQkFrcHdBVE1BQUEyQUFBRm90S3JxQW81YUJCOUFBcGdCQWtwd0FUSUFBQTJBQUFGb3RLcnFBbzVhQkM3Z0FwZ0JBa3B3QVRFQUFBMkFBQUZvdEtycUFvNWFCRDZBQXBnREFrcHdBUTJBQUEyQUFBRm90S3JxQW81YUJFNGdBcGdCQWtwd0FUQ0FBQTJBQUFGb3RLcnFBSDBPMmRRRUFBQUFBQUFDVTU0SXU0S09XZ1FBQUFLWUFRSktjQUV2QUFBTmdBQUJhTFNxNmdLT1dnUVBvQUtZQVFKS2NBRXRnQUFOZ0FBQmFMU3E2Z0tPV2dRZlFBS1lBUUpLY0FFc0FBQU5nQUFCYUxTcTZnS09XZ1F1NEFLWUFRSktjQUVxQUFBTmdBQUJhTFNxNmdLT1dnUStnQUtZQVFKS2NBRW9nQUFOZ0FBQmFMU3E2Z0tPV2dST0lBS1lBUUpLY0FFbkFBQU5nQUFCYUxTcTZnQjlEdG5VQkFBQUFBQUFBbE9lQ1JsQ2psb0VBQUFDbUFFQ1NuQUJKZ0FBRFlBQUFXaTBxdW9DamxvRUQ2QUNtQUVDU25BQkpJQUFEWUFBQVdpMHF1b0NqbG9FSDBBQ21BTUNTbkFCRFlBQURZQUFBV2kwcXVvQ2psb0VMdUFDbUFFQ1NuQUJJNEFBRFlBQUFXaTBxdW9DamxvRVBvQUNtQUVDU25BQklvQUFEWUFBQVdpMHF1b0NqbG9FVGlBQ21BRUNTbkFCSVlBQURZQUFBV2kwcXVvQWZRN1oxQVFBQUFBQUFBSlRuZ2wzQW81YUJBQUFBcGdCQWtwd0FTQ0FBQTJBQUFGb3RLcnFBbzVhQkErZ0FwZ0JBa3B3QVNBQUFBMkFBQUZvdEtycUFvNWFCQjlBQXBnQkFrcHdBUjhBQUEyQUFBRm90S3JxQW81YUJDN2dBcGdCQWtwd0FSNEFBQTJBQUFGb3RLcnFBbzVhQkQ2QUFwZ0JBa3B3QVIyQUFBMkFBQUZvdEtycUFvNWFCRTRnQXBnQkFrcHdBUnlBQUEyQUFBRm90S3JxQUgwTzJkUUVBQUFBQUFBQ1U1NEoxTUtPV2dRQUFBS1lBd0pLY0FFTmdBQU5nQUFCYUxTcTZnS09XZ1FQb0FLWUFRSktjQUViZ0FBTmdBQUJhTFNxNmdLT1dnUWZRQUtZQVFKS2NBRWFnQUFOZ0FBQmFMU3E2Z0tPV2dRdTRBS1lBUUpLY0FFYUFBQU5nQUFCYUxTcTZnS09XZ1ErZ0FLWUFRSktjQUVaQUFBTmdBQUJhTFNxNmdLT1dnUk9JQUtZQVFKS2NBRVlBQUFOZ0FBQmFMU3E2Z0I5RHRuVUJBQUFBQUFBQWxPZUNqS0NqbG9FQUFBQ21BRUNTbkFCRjRBQURZQUFBV2kwcXVvQ2psb0VENkFDbUFFQ1NuQUJGd0FBRFlBQUFXaTBxdW9DamxvRUgwQUNtQUVDU25BQkZvQUFEWUFBQVdpMHF1b0NqbG9FTHVBQ21BRUNTbkFCRmdBQURZQUFBV2kwcXVvQ2psb0VQb0FDbUFNQ1NuQUJEWUFBRFlBQUFXaTBxdW9DamxvRVRpQUNtQUVDU25BQkZZQUFEWUFBQVdpMHF1b0FmUTdaMUFRQUFBQUFBQUpUbmdxUVFvNWFCQUFBQXBnQkFrcHdBUlVBQUEyQUFBRm90S3JxQW81YUJBK2dBcGdCQWtwd0FSU0FBQTJBQUFGb3RLcnFBbzVhQkI5QUFwZ0JBa3B3QVJRQUFBMkFBQUZvdEtycUFvNWFCQzdnQXBnQkFrcHdBUlFBQUEyQUFBRm90S3JxQW81YUJENkFBcGdCQWtwd0FST0FBQTJBQUFGb3RLcnFBbzVhQkU0Z0FwZ0JBa3B3QVJNQUFBMkFBQUZvdEtycUFIME8yZFFFQUFBQUFBQUNVNTRLN2dLT1dnUUFBQUtZQVFKS2NBRVNnQUFOZ0FBQmFMU3E2Z0tPV2dRUG9BS1lBUUpLY0FFU0FBQU5nQUFCYUxTcTZnS09XZ1FmUUFLWUF3SktjQUVOZ0FBTmdBQUJhTFNxNmdLT1dnUXU0QUtZQVFKS2NBRVJnQUFOZ0FBQmFMU3E2Z0tPV2dRK2dBS1lBUUpLY0FFUkFBQU5nQUFCYUxTcTZnS09XZ1JPSUFLWUFRSktjQUVRZ0FBTmdBQUJhTFNxNmdCOUR0blVCQUFBQUFBQUFsT2VDMHZDamxvRUFBQUNtQUVDU25BQkVJQUFEWUFBQVdpMHF1b0NqbG9FRDZBQ21BRUNTbkFCRUFBQURZQUFBV2kwcXVvQ2psb0VIMEFDbUFFQ1NuQUJENEFBRFlBQUFXaTBxdW9DamxvRUx1QUNtQUVDU25BQkR3QUFEWUFBQVdpMHF1b0NqbG9FUG9BQ21BRUNTbkFCRG9BQURZQUFBV2kwcXVvQ2psb0VUaUFDbUFFQ1NuQUJEZ0FBRFlBQUFXaTBxdW9BY1U3dHJBUUFBQUFBQUFCRzdqN09CQUxlSzk0RUI4WUlCZC9DQkF3PT0nKTtcbiAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5yZWxlYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmlkZW8ucGF1c2UoKTtcbiAgICB2aWRlby5zcmMgPSAnJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaU9TV2FrZUxvY2soKSB7XG4gIHZhciB0aW1lciA9IG51bGw7XG5cbiAgdGhpcy5yZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICBzZXRUaW1lb3V0KHdpbmRvdy5zdG9wLCAwKTtcbiAgICAgIH0sIDMwMDAwKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnJlbGVhc2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGdldFdha2VMb2NrKCkge1xuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcbiAgaWYgKHVzZXJBZ2VudC5tYXRjaCgvaVBob25lL2kpIHx8IHVzZXJBZ2VudC5tYXRjaCgvaVBvZC9pKSkge1xuICAgIHJldHVybiBpT1NXYWtlTG9jaztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQW5kcm9pZFdha2VMb2NrO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0V2FrZUxvY2soKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IGJyb3dzZXIgZmllbGQsIGNoZWNrIG91dCB0aGUgYnJvd3NlciBmaWVsZCBhdCBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svYnJvd3NlcmlmeS1oYW5kYm9vayNicm93c2VyLWZpZWxkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBDcmVhdGUgYSA8bGluaz4gdGFnIHdpdGggb3B0aW9uYWwgZGF0YSBhdHRyaWJ1dGVzXG4gICAgY3JlYXRlTGluazogZnVuY3Rpb24oaHJlZiwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG5cbiAgICAgICAgbGluay5ocmVmID0gaHJlZjtcbiAgICAgICAgbGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICggISBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgfSxcbiAgICAvLyBDcmVhdGUgYSA8c3R5bGU+IHRhZyB3aXRoIG9wdGlvbmFsIGRhdGEgYXR0cmlidXRlc1xuICAgIGNyZWF0ZVN0eWxlOiBmdW5jdGlvbihjc3NUZXh0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLFxuICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXG4gICAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoICEgYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtJyArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc3R5bGUuc2hlZXQpIHsgLy8gZm9yIGpzZG9tIGFuZCBJRTkrXG4gICAgICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBjc3NUZXh0O1xuICAgICAgICAgICAgc3R5bGUuc2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7IC8vIGZvciBJRTggYW5kIGJlbG93XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgICAgIH0gZWxzZSB7IC8vIGZvciBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQpKTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIi8qKlxuICogRXhwb3NlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgZmFsbGJhY2s7XG5cbi8qKlxuICogRmFsbGJhY2sgaW1wbGVtZW50YXRpb24uXG4gKi9cblxudmFyIHByZXYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbmZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7XG4gIHZhciBjdXJyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciBtcyA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnIgLSBwcmV2KSk7XG4gIHZhciByZXEgPSBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gIHByZXYgPSBjdXJyO1xuICByZXR1cm4gcmVxO1xufVxuXG4vKipcbiAqIENhbmNlbC5cbiAqL1xuXG52YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LmNsZWFyVGltZW91dDtcblxuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbihpZCl7XG4gIGNhbmNlbC5jYWxsKHdpbmRvdywgaWQpO1xufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyohIChDKSBXZWJSZWZsZWN0aW9uIE1pdCBTdHlsZSBMaWNlbnNlICovXG4oZnVuY3Rpb24oZSx0LG4scil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcnQoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspdnQoZVtuXSx0KX1mdW5jdGlvbiBpdChlKXtmb3IodmFyIHQ9MCxuPWUubGVuZ3RoLHI7dDxuO3QrKylyPWVbdF0sbnQocixiW290KHIpXSl9ZnVuY3Rpb24gc3QoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe2oodCkmJih2dCh0LGUpLHJ0KHQucXVlcnlTZWxlY3RvckFsbCh3KSxlKSl9fWZ1bmN0aW9uIG90KGUpe3ZhciB0PWUuZ2V0QXR0cmlidXRlKFwiaXNcIiksbj1lLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkscj1TLmNhbGwoeSx0P3YrdC50b1VwcGVyQ2FzZSgpOmQrbik7cmV0dXJuIHQmJi0xPHImJiF1dChuLHQpPy0xOnJ9ZnVuY3Rpb24gdXQoZSx0KXtyZXR1cm4tMTx3LmluZGV4T2YoZSsnW2lzPVwiJyt0KydcIl0nKX1mdW5jdGlvbiBhdChlKXt2YXIgdD1lLmN1cnJlbnRUYXJnZXQsbj1lLmF0dHJDaGFuZ2Uscj1lLmF0dHJOYW1lLGk9ZS50YXJnZXQ7USYmKCFpfHxpPT09dCkmJnQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiZyIT09XCJzdHlsZVwiJmUucHJldlZhbHVlIT09ZS5uZXdWYWx1ZSYmdC5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2socixuPT09ZVthXT9udWxsOmUucHJldlZhbHVlLG49PT1lW2xdP251bGw6ZS5uZXdWYWx1ZSl9ZnVuY3Rpb24gZnQoZSl7dmFyIHQ9c3QoZSk7cmV0dXJuIGZ1bmN0aW9uKGUpe1gucHVzaCh0LGUudGFyZ2V0KX19ZnVuY3Rpb24gbHQoZSl7SyYmKEs9ITEsZS5jdXJyZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoaCxsdCkpLHJ0KChlLnRhcmdldHx8dCkucXVlcnlTZWxlY3RvckFsbCh3KSxlLmRldGFpbD09PW8/bzpzKSxCJiZwdCgpfWZ1bmN0aW9uIGN0KGUsdCl7dmFyIG49dGhpcztxLmNhbGwobixlLHQpLEcuY2FsbChuLHt0YXJnZXQ6bn0pfWZ1bmN0aW9uIGh0KGUsdCl7RChlLHQpLGV0P2V0Lm9ic2VydmUoZSx6KTooSiYmKGUuc2V0QXR0cmlidXRlPWN0LGVbaV09WihlKSxlLmFkZEV2ZW50TGlzdGVuZXIocCxHKSksZS5hZGRFdmVudExpc3RlbmVyKGMsYXQpKSxlLmNyZWF0ZWRDYWxsYmFjayYmUSYmKGUuY3JlYXRlZD0hMCxlLmNyZWF0ZWRDYWxsYmFjaygpLGUuY3JlYXRlZD0hMSl9ZnVuY3Rpb24gcHQoKXtmb3IodmFyIGUsdD0wLG49Ri5sZW5ndGg7dDxuO3QrKyllPUZbdF0sRS5jb250YWlucyhlKXx8KG4tLSxGLnNwbGljZSh0LS0sMSksdnQoZSxvKSl9ZnVuY3Rpb24gZHQoZSl7dGhyb3cgbmV3IEVycm9yKFwiQSBcIitlK1wiIHR5cGUgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpfWZ1bmN0aW9uIHZ0KGUsdCl7dmFyIG4scj1vdChlKTstMTxyJiYodHQoZSxiW3JdKSxyPTAsdD09PXMmJiFlW3NdPyhlW29dPSExLGVbc109ITAscj0xLEImJlMuY2FsbChGLGUpPDAmJkYucHVzaChlKSk6dD09PW8mJiFlW29dJiYoZVtzXT0hMSxlW29dPSEwLHI9MSksciYmKG49ZVt0K1wiQ2FsbGJhY2tcIl0pJiZuLmNhbGwoZSkpfWlmKHIgaW4gdClyZXR1cm47dmFyIGk9XCJfX1wiK3IrKE1hdGgucmFuZG9tKCkqMWU1Pj4wKSxzPVwiYXR0YWNoZWRcIixvPVwiZGV0YWNoZWRcIix1PVwiZXh0ZW5kc1wiLGE9XCJBRERJVElPTlwiLGY9XCJNT0RJRklDQVRJT05cIixsPVwiUkVNT1ZBTFwiLGM9XCJET01BdHRyTW9kaWZpZWRcIixoPVwiRE9NQ29udGVudExvYWRlZFwiLHA9XCJET01TdWJ0cmVlTW9kaWZpZWRcIixkPVwiPFwiLHY9XCI9XCIsbT0vXltBLVpdW0EtWjAtOV0qKD86LVtBLVowLTldKykrJC8sZz1bXCJBTk5PVEFUSU9OLVhNTFwiLFwiQ09MT1ItUFJPRklMRVwiLFwiRk9OVC1GQUNFXCIsXCJGT05ULUZBQ0UtU1JDXCIsXCJGT05ULUZBQ0UtVVJJXCIsXCJGT05ULUZBQ0UtRk9STUFUXCIsXCJGT05ULUZBQ0UtTkFNRVwiLFwiTUlTU0lORy1HTFlQSFwiXSx5PVtdLGI9W10sdz1cIlwiLEU9dC5kb2N1bWVudEVsZW1lbnQsUz15LmluZGV4T2Z8fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLmxlbmd0aDt0LS0mJnRoaXNbdF0hPT1lOyk7cmV0dXJuIHR9LHg9bi5wcm90b3R5cGUsVD14Lmhhc093blByb3BlcnR5LE49eC5pc1Byb3RvdHlwZU9mLEM9bi5kZWZpbmVQcm9wZXJ0eSxrPW4uZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLEw9bi5nZXRPd25Qcm9wZXJ0eU5hbWVzLEE9bi5nZXRQcm90b3R5cGVPZixPPW4uc2V0UHJvdG90eXBlT2YsTT0hIW4uX19wcm90b19fLF89bi5jcmVhdGV8fGZ1bmN0aW9uIG10KGUpe3JldHVybiBlPyhtdC5wcm90b3R5cGU9ZSxuZXcgbXQpOnRoaXN9LEQ9T3x8KE0/ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfTpMJiZrP2Z1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2Zvcih2YXIgbixyPUwodCksaT0wLHM9ci5sZW5ndGg7aTxzO2krKyluPXJbaV0sVC5jYWxsKGUsbil8fEMoZSxuLGsodCxuKSl9cmV0dXJuIGZ1bmN0aW9uKHQsbil7ZG8gZSh0LG4pO3doaWxlKChuPUEobikpJiYhTi5jYWxsKG4sdCkpO3JldHVybiB0fX0oKTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbiBpbiB0KWVbbl09dFtuXTtyZXR1cm4gZX0pLFA9ZS5NdXRhdGlvbk9ic2VydmVyfHxlLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsSD0oZS5IVE1MRWxlbWVudHx8ZS5FbGVtZW50fHxlLk5vZGUpLnByb3RvdHlwZSxCPSFOLmNhbGwoSCxFKSxqPUI/ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT0xfTpmdW5jdGlvbihlKXtyZXR1cm4gTi5jYWxsKEgsZSl9LEY9QiYmW10sST1ILmNsb25lTm9kZSxxPUguc2V0QXR0cmlidXRlLFI9SC5yZW1vdmVBdHRyaWJ1dGUsVT10LmNyZWF0ZUVsZW1lbnQsej1QJiZ7YXR0cmlidXRlczohMCxjaGFyYWN0ZXJEYXRhOiEwLGF0dHJpYnV0ZU9sZFZhbHVlOiEwfSxXPVB8fGZ1bmN0aW9uKGUpe0o9ITEsRS5yZW1vdmVFdmVudExpc3RlbmVyKGMsVyl9LFgsVj1lLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fGUubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxlLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxmdW5jdGlvbihlKXtzZXRUaW1lb3V0KGUsMTApfSwkPSExLEo9ITAsSz0hMCxRPSEwLEcsWSxaLGV0LHR0LG50O098fE0/KHR0PWZ1bmN0aW9uKGUsdCl7Ti5jYWxsKHQsZSl8fGh0KGUsdCl9LG50PWh0KToodHQ9ZnVuY3Rpb24oZSx0KXtlW2ldfHwoZVtpXT1uKCEwKSxodChlLHQpKX0sbnQ9dHQpLEI/KEo9ITEsZnVuY3Rpb24oKXt2YXIgZT1rKEgsXCJhZGRFdmVudExpc3RlbmVyXCIpLHQ9ZS52YWx1ZSxuPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBDdXN0b21FdmVudChjLHtidWJibGVzOiEwfSk7dC5hdHRyTmFtZT1lLHQucHJldlZhbHVlPXRoaXMuZ2V0QXR0cmlidXRlKGUpLHQubmV3VmFsdWU9bnVsbCx0W2xdPXQuYXR0ckNoYW5nZT0yLFIuY2FsbCh0aGlzLGUpLHRoaXMuZGlzcGF0Y2hFdmVudCh0KX0scj1mdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuaGFzQXR0cmlidXRlKGUpLHI9biYmdGhpcy5nZXRBdHRyaWJ1dGUoZSksaT1uZXcgQ3VzdG9tRXZlbnQoYyx7YnViYmxlczohMH0pO3EuY2FsbCh0aGlzLGUsdCksaS5hdHRyTmFtZT1lLGkucHJldlZhbHVlPW4/cjpudWxsLGkubmV3VmFsdWU9dCxuP2lbZl09aS5hdHRyQ2hhbmdlPTE6aVthXT1pLmF0dHJDaGFuZ2U9MCx0aGlzLmRpc3BhdGNoRXZlbnQoaSl9LHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jdXJyZW50VGFyZ2V0LG49dFtpXSxyPWUucHJvcGVydHlOYW1lLHM7bi5oYXNPd25Qcm9wZXJ0eShyKSYmKG49bltyXSxzPW5ldyBDdXN0b21FdmVudChjLHtidWJibGVzOiEwfSkscy5hdHRyTmFtZT1uLm5hbWUscy5wcmV2VmFsdWU9bi52YWx1ZXx8bnVsbCxzLm5ld1ZhbHVlPW4udmFsdWU9dFtyXXx8bnVsbCxzLnByZXZWYWx1ZT09bnVsbD9zW2FdPXMuYXR0ckNoYW5nZT0wOnNbZl09cy5hdHRyQ2hhbmdlPTEsdC5kaXNwYXRjaEV2ZW50KHMpKX07ZS52YWx1ZT1mdW5jdGlvbihlLG8sdSl7ZT09PWMmJnRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiZ0aGlzLnNldEF0dHJpYnV0ZSE9PXImJih0aGlzW2ldPXtjbGFzc05hbWU6e25hbWU6XCJjbGFzc1wiLHZhbHVlOnRoaXMuY2xhc3NOYW1lfX0sdGhpcy5zZXRBdHRyaWJ1dGU9cix0aGlzLnJlbW92ZUF0dHJpYnV0ZT1uLHQuY2FsbCh0aGlzLFwicHJvcGVydHljaGFuZ2VcIixzKSksdC5jYWxsKHRoaXMsZSxvLHUpfSxDKEgsXCJhZGRFdmVudExpc3RlbmVyXCIsZSl9KCkpOlB8fChFLmFkZEV2ZW50TGlzdGVuZXIoYyxXKSxFLnNldEF0dHJpYnV0ZShpLDEpLEUucmVtb3ZlQXR0cmlidXRlKGkpLEomJihHPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbixyLHM7aWYodD09PWUudGFyZ2V0KXtuPXRbaV0sdFtpXT1yPVoodCk7Zm9yKHMgaW4gcil7aWYoIShzIGluIG4pKXJldHVybiBZKDAsdCxzLG5bc10scltzXSxhKTtpZihyW3NdIT09bltzXSlyZXR1cm4gWSgxLHQscyxuW3NdLHJbc10sZil9Zm9yKHMgaW4gbilpZighKHMgaW4gcikpcmV0dXJuIFkoMix0LHMsbltzXSxyW3NdLGwpfX0sWT1mdW5jdGlvbihlLHQsbixyLGkscyl7dmFyIG89e2F0dHJDaGFuZ2U6ZSxjdXJyZW50VGFyZ2V0OnQsYXR0ck5hbWU6bixwcmV2VmFsdWU6cixuZXdWYWx1ZTppfTtvW3NdPWUsYXQobyl9LFo9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LG4scj17fSxpPWUuYXR0cmlidXRlcyxzPTAsbz1pLmxlbmd0aDtzPG87cysrKXQ9aVtzXSxuPXQubmFtZSxuIT09XCJzZXRBdHRyaWJ1dGVcIiYmKHJbbl09dC52YWx1ZSk7cmV0dXJuIHJ9KSksdFtyXT1mdW5jdGlvbihuLHIpe2M9bi50b1VwcGVyQ2FzZSgpLCR8fCgkPSEwLFA/KGV0PWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgbj0wLHI9ZS5sZW5ndGg7bjxyO3QoZVtuKytdKSk7fXJldHVybiBuZXcgUChmdW5jdGlvbihyKXtmb3IodmFyIGkscyxvLHU9MCxhPXIubGVuZ3RoO3U8YTt1KyspaT1yW3VdLGkudHlwZT09PVwiY2hpbGRMaXN0XCI/KG4oaS5hZGRlZE5vZGVzLGUpLG4oaS5yZW1vdmVkTm9kZXMsdCkpOihzPWkudGFyZ2V0LFEmJnMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiZpLmF0dHJpYnV0ZU5hbWUhPT1cInN0eWxlXCImJihvPXMuZ2V0QXR0cmlidXRlKGkuYXR0cmlidXRlTmFtZSksbyE9PWkub2xkVmFsdWUmJnMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGkuYXR0cmlidXRlTmFtZSxpLm9sZFZhbHVlLG8pKSl9KX0oc3Qocyksc3QobykpLGV0Lm9ic2VydmUodCx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KSk6KFg9W10sVihmdW5jdGlvbiBFKCl7d2hpbGUoWC5sZW5ndGgpWC5zaGlmdCgpLmNhbGwobnVsbCxYLnNoaWZ0KCkpO1YoRSl9KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIixmdChzKSksdC5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIixmdChvKSkpLHQuYWRkRXZlbnRMaXN0ZW5lcihoLGx0KSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsbHQpLHQuY3JlYXRlRWxlbWVudD1mdW5jdGlvbihlLG4pe3ZhciByPVUuYXBwbHkodCxhcmd1bWVudHMpLGk9XCJcIitlLHM9Uy5jYWxsKHksKG4/djpkKSsobnx8aSkudG9VcHBlckNhc2UoKSksbz0tMTxzO3JldHVybiBuJiYoci5zZXRBdHRyaWJ1dGUoXCJpc1wiLG49bi50b0xvd2VyQ2FzZSgpKSxvJiYobz11dChpLnRvVXBwZXJDYXNlKCksbikpKSxRPSF0LmNyZWF0ZUVsZW1lbnQuaW5uZXJIVE1MSGVscGVyLG8mJm50KHIsYltzXSkscn0sSC5jbG9uZU5vZGU9ZnVuY3Rpb24oZSl7dmFyIHQ9SS5jYWxsKHRoaXMsISFlKSxuPW90KHQpO3JldHVybi0xPG4mJm50KHQsYltuXSksZSYmaXQodC5xdWVyeVNlbGVjdG9yQWxsKHcpKSx0fSksLTI8Uy5jYWxsKHksditjKStTLmNhbGwoeSxkK2MpJiZkdChuKTtpZighbS50ZXN0KGMpfHwtMTxTLmNhbGwoZyxjKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHlwZSBcIituK1wiIGlzIGludmFsaWRcIik7dmFyIGk9ZnVuY3Rpb24oKXtyZXR1cm4gZj90LmNyZWF0ZUVsZW1lbnQobCxjKTp0LmNyZWF0ZUVsZW1lbnQobCl9LGE9cnx8eCxmPVQuY2FsbChhLHUpLGw9Zj9yW3VdLnRvVXBwZXJDYXNlKCk6YyxjLHA7cmV0dXJuIGYmJi0xPFMuY2FsbCh5LGQrbCkmJmR0KGwpLHA9eS5wdXNoKChmP3Y6ZCkrYyktMSx3PXcuY29uY2F0KHcubGVuZ3RoP1wiLFwiOlwiXCIsZj9sKydbaXM9XCInK24udG9Mb3dlckNhc2UoKSsnXCJdJzpsKSxpLnByb3RvdHlwZT1iW3BdPVQuY2FsbChhLFwicHJvdG90eXBlXCIpP2EucHJvdG90eXBlOl8oSCkscnQodC5xdWVyeVNlbGVjdG9yQWxsKHcpLHMpLGl9fSkod2luZG93LGRvY3VtZW50LE9iamVjdCxcInJlZ2lzdGVyRWxlbWVudFwiKTsiLCIvKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAzLjAuMlxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZSh4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuICAgIC8vIHRlc3QgZm9yIHdlYiB3b3JrZXIgYnV0IG5vdCBpbiBJRTEwXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBpbXBvcnRTY3JpcHRzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuICAgIC8vIG5vZGVcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3Vqb2pzL3doZW4vaXNzdWVzLzQxMCBmb3IgZGV0YWlsc1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHZlcnR4XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IChpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlYiB3b3JrZXJcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlU2V0VGltZW91dCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gsIDEpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbjsgaSs9Mikge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV07XG4gICAgICAgIHZhciBhcmcgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhdHRlbXB0VmVydHgoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgciA9IHJlcXVpcmU7XG4gICAgICAgIHZhciB2ZXJ0eCA9IHIoJ3ZlcnR4Jyk7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQgPSB2ZXJ0eC5ydW5Pbkxvb3AgfHwgdmVydHgucnVuT25Db250ZXh0O1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVZlcnR4VGltZXIoKTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2g7XG4gICAgLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbiAgICBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzTm9kZSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTmV4dFRpY2soKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGlzV29ya2VyKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0aGVuID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZ2V0VGhlbihtYXliZVRoZW5hYmxlKTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0Z1bmN0aW9uKHRoZW4pKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlRm9yZWlnblRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAobGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGVudW1lcmF0b3IuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIGVudW1lcmF0b3IucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKGVudW1lcmF0b3IuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICBlbnVtZXJhdG9yLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICBlbnVtZXJhdG9yLl9pbml0KCk7XG5cbiAgICAgICAgaWYgKGVudW1lcmF0b3IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChlbnVtZXJhdG9yLnByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5sZW5ndGggPSBlbnVtZXJhdG9yLmxlbmd0aCB8fCAwO1xuICAgICAgICAgIGVudW1lcmF0b3IuX2VudW1lcmF0ZSgpO1xuICAgICAgICAgIGlmIChlbnVtZXJhdG9yLl9yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwoZW51bWVyYXRvci5wcm9taXNlLCBlbnVtZXJhdG9yLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KGVudW1lcmF0b3IucHJvbWlzZSwgZW51bWVyYXRvci5fdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5KGlucHV0KTtcbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3Jlc3VsdCA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgfTtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcblxuICAgICAgdmFyIGxlbmd0aCAgPSBlbnVtZXJhdG9yLmxlbmd0aDtcbiAgICAgIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuICAgICAgdmFyIGlucHV0ICAgPSBlbnVtZXJhdG9yLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBlbnVtZXJhdG9yLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG4gICAgICB2YXIgYyA9IGVudW1lcmF0b3IuX2luc3RhbmNlQ29uc3RydWN0b3I7XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzTWF5YmVUaGVuYWJsZShlbnRyeSkpIHtcbiAgICAgICAgaWYgKGVudHJ5LmNvbnN0cnVjdG9yID09PSBjICYmIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIGVudHJ5Ll9vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnVtZXJhdG9yLl93aWxsU2V0dGxlQXQoYy5yZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3JlbWFpbmluZy0tO1xuICAgICAgICBlbnVtZXJhdG9yLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9zZXR0bGVkQXQgPSBmdW5jdGlvbihzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICAgIHZhciBlbnVtZXJhdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gZW51bWVyYXRvci5wcm9taXNlO1xuXG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgZW51bWVyYXRvci5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW51bWVyYXRvci5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVudW1lcmF0b3IuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIGVudW1lcmF0b3IuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24ocHJvbWlzZSwgaSkge1xuICAgICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRlVMRklMTEVELCBpLCB2YWx1ZSk7XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgZW51bWVyYXRvci5fc2V0dGxlZEF0KGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVELCBpLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcblxuICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbG1lbnQodmFsdWUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0aW9uKHJlYXNvbikge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUoQ29uc3RydWN0b3IucmVzb2x2ZShlbnRyaWVzW2ldKSwgdW5kZWZpbmVkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJHJhY2U7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZShvYmplY3QpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIG9iamVjdCk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRyZXNvbHZlO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkcmVqZWN0KHJlYXNvbikge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcihsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKTtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNSZXNvbHZlcigpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlO1xuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICAgICAgd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG5cbiAgICAgIFRlcm1pbm9sb2d5XG4gICAgICAtLS0tLS0tLS0tLVxuXG4gICAgICAtIGBwcm9taXNlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gd2l0aCBhIGB0aGVuYCBtZXRob2Qgd2hvc2UgYmVoYXZpb3IgY29uZm9ybXMgdG8gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgLSBgdGhlbmFibGVgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYSBgdGhlbmAgbWV0aG9kLlxuICAgICAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAgICAgLSBgZXhjZXB0aW9uYCBpcyBhIHZhbHVlIHRoYXQgaXMgdGhyb3duIHVzaW5nIHRoZSB0aHJvdyBzdGF0ZW1lbnQuXG4gICAgICAtIGByZWFzb25gIGlzIGEgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2h5IGEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQuXG4gICAgICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICAgICAgQSBwcm9taXNlIGNhbiBiZSBpbiBvbmUgb2YgdGhyZWUgc3RhdGVzOiBwZW5kaW5nLCBmdWxmaWxsZWQsIG9yIHJlamVjdGVkLlxuXG4gICAgICBQcm9taXNlcyB0aGF0IGFyZSBmdWxmaWxsZWQgaGF2ZSBhIGZ1bGZpbGxtZW50IHZhbHVlIGFuZCBhcmUgaW4gdGhlIGZ1bGZpbGxlZFxuICAgICAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICAgICAgcmVqZWN0ZWQgc3RhdGUuICBBIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5ldmVyIGEgdGhlbmFibGUuXG5cbiAgICAgIFByb21pc2VzIGNhbiBhbHNvIGJlIHNhaWQgdG8gKnJlc29sdmUqIGEgdmFsdWUuICBJZiB0aGlzIHZhbHVlIGlzIGFsc28gYVxuICAgICAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICAgICAgc2V0dGxlZCBzdGF0ZS4gIFNvIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aWxsXG4gICAgICBpdHNlbGYgcmVqZWN0LCBhbmQgYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aWxsXG4gICAgICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gICAgICBCYXNpYyBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLVxuXG4gICAgICBgYGBqc1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gb24gc3VjY2Vzc1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgICAgICAvLyBvbiBmYWlsdXJlXG4gICAgICAgIHJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvLyBvbiBmdWxmaWxsbWVudFxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIC8vIG9uIHJlamVjdGlvblxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQWR2YW5jZWQgVXNhZ2U6XG4gICAgICAtLS0tLS0tLS0tLS0tLS1cblxuICAgICAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICAgICAgYFhNTEh0dHBSZXF1ZXN0YHMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gaGFuZGxlcjtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgIHhoci5zZW5kKCk7XG5cbiAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdnZXRKU09OOiBgJyArIHVybCArICdgIGZhaWxlZCB3aXRoIHN0YXR1czogWycgKyB0aGlzLnN0YXR1cyArICddJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04oJy9wb3N0cy5qc29uJykudGhlbihmdW5jdGlvbihqc29uKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBVbmxpa2UgY2FsbGJhY2tzLCBwcm9taXNlcyBhcmUgZ3JlYXQgY29tcG9zYWJsZSBwcmltaXRpdmVzLlxuXG4gICAgICBgYGBqc1xuICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZXRKU09OKCcvcG9zdHMnKSxcbiAgICAgICAgZ2V0SlNPTignL2NvbW1lbnRzJylcbiAgICAgIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICAgICAgdmFsdWVzWzBdIC8vID0+IHBvc3RzSlNPTlxuICAgICAgICB2YWx1ZXNbMV0gLy8gPT4gY29tbWVudHNKU09OXG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBjbGFzcyBQcm9taXNlXG4gICAgICBAcGFyYW0ge2Z1bmN0aW9ufSByZXNvbHZlclxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpcy5faWQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlcisrO1xuICAgICAgdGhpcy5fc3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuXG4gICAgICBpZiAobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgICAgaWYgKCFsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSkpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5hbGwgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmFjZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJhY2UkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQ7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVqZWN0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRTY2hlZHVsZXIgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2V0U2NoZWR1bGVyO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9zZXRBc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldEFzYXA7XG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuX2FzYXAgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcDtcblxuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZSxcblxuICAgIC8qKlxuICAgICAgVGhlIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsXG4gICAgICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICAgICAgcmVhc29uIHdoeSB0aGUgcHJvbWlzZSBjYW5ub3QgYmUgZnVsZmlsbGVkLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uKHVzZXIpe1xuICAgICAgICAvLyB1c2VyIGlzIGF2YWlsYWJsZVxuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gdXNlciBpcyB1bmF2YWlsYWJsZSwgYW5kIHlvdSBhcmUgZ2l2ZW4gdGhlIHJlYXNvbiB3aHlcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIENoYWluaW5nXG4gICAgICAtLS0tLS0tLVxuXG4gICAgICBUaGUgcmV0dXJuIHZhbHVlIG9mIGB0aGVuYCBpcyBpdHNlbGYgYSBwcm9taXNlLiAgVGhpcyBzZWNvbmQsICdkb3duc3RyZWFtJ1xuICAgICAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICAgICAgb3IgcmVqZWN0aW9uIGhhbmRsZXIsIG9yIHJlamVjdGVkIGlmIHRoZSBoYW5kbGVyIHRocm93cyBhbiBleGNlcHRpb24uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHVzZXIubmFtZTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuICdkZWZhdWx0IG5hbWUnO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodXNlck5hbWUpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgICAgICAvLyB3aWxsIGJlIGAnZGVmYXVsdCBuYW1lJ2BcbiAgICAgIH0pO1xuXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gaWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGByZWFzb25gIHdpbGwgYmUgJ0ZvdW5kIHVzZXIsIGJ1dCBzdGlsbCB1bmhhcHB5Jy5cbiAgICAgICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gICAgICB9KTtcbiAgICAgIGBgYFxuICAgICAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBlZGFnb2dpY2FsRXhjZXB0aW9uKCdVcHN0cmVhbSBlcnJvcicpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbmV2ZXIgcmVhY2hlZFxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUaGUgYFBlZGdhZ29jaWFsRXhjZXB0aW9uYCBpcyBwcm9wYWdhdGVkIGFsbCB0aGUgd2F5IGRvd24gdG8gaGVyZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQXNzaW1pbGF0aW9uXG4gICAgICAtLS0tLS0tLS0tLS1cblxuICAgICAgU29tZXRpbWVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBwcm9wYWdhdGUgdG8gYSBkb3duc3RyZWFtIHByb21pc2UgY2FuIG9ubHkgYmVcbiAgICAgIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgICAgIGZ1bGZpbGxtZW50IG9yIHJlamVjdGlvbiBoYW5kbGVyLiBUaGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgdGhlbiBiZSBwZW5kaW5nXG4gICAgICB1bnRpbCB0aGUgcmV0dXJuZWQgcHJvbWlzZSBpcyBzZXR0bGVkLiBUaGlzIGlzIGNhbGxlZCAqYXNzaW1pbGF0aW9uKi5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBUaGUgdXNlcidzIGNvbW1lbnRzIGFyZSBub3cgYXZhaWxhYmxlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgICAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChjb21tZW50cykge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIElmIGBmaW5kQ29tbWVudHNCeUF1dGhvcmAgcmVqZWN0cywgd2UnbGwgaGF2ZSB0aGUgcmVhc29uIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFNpbXBsZSBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFJlc3VsdChmdW5jdGlvbihyZXN1bHQsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFkdmFuY2VkIEV4YW1wbGVcbiAgICAgIC0tLS0tLS0tLS0tLS0tXG5cbiAgICAgIFN5bmNocm9ub3VzIEV4YW1wbGVcblxuICAgICAgYGBgamF2YXNjcmlwdFxuICAgICAgdmFyIGF1dGhvciwgYm9va3M7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF1dGhvciA9IGZpbmRBdXRob3IoKTtcbiAgICAgICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgfVxuICAgICAgYGBgXG5cbiAgICAgIEVycmJhY2sgRXhhbXBsZVxuXG4gICAgICBgYGBqc1xuXG4gICAgICBmdW5jdGlvbiBmb3VuZEJvb2tzKGJvb2tzKSB7XG5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcblxuICAgICAgfVxuXG4gICAgICBmaW5kQXV0aG9yKGZ1bmN0aW9uKGF1dGhvciwgZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAvLyBmYWlsdXJlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmRCb29va3NCeUF1dGhvcihhdXRob3IsIGZ1bmN0aW9uKGJvb2tzLCBlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgIGZhaWx1cmUocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gc3VjY2Vzc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBQcm9taXNlIEV4YW1wbGU7XG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIGZpbmRBdXRob3IoKS5cbiAgICAgICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgICAgIHRoZW4oZnVuY3Rpb24oYm9va3Mpe1xuICAgICAgICAgIC8vIGZvdW5kIGJvb2tzXG4gICAgICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCB0aGVuXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3RlZFxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgdGhlbjogZnVuY3Rpb24ob25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQgJiYgIW9uRnVsZmlsbG1lbnQgfHwgc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJlbnQuX3Jlc3VsdDtcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbc3RhdGUgLSAxXTtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSxcblxuICAgIC8qKlxuICAgICAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICAgICAgYXMgdGhlIGNhdGNoIGJsb2NrIG9mIGEgdHJ5L2NhdGNoIHN0YXRlbWVudC5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGZpbmRBdXRob3IoKXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG4ndCBmaW5kIHRoYXQgYXV0aG9yJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmNocm9ub3VzXG4gICAgICB0cnkge1xuICAgICAgICBmaW5kQXV0aG9yKCk7XG4gICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfVxuXG4gICAgICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gICAgICBmaW5kQXV0aG9yKCkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgY2F0Y2hcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0aW9uXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAcmV0dXJuIHtQcm9taXNlfVxuICAgICovXG4gICAgICAnY2F0Y2gnOiBmdW5jdGlvbihvblJlamVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbid1c2Ugc3RyaWN0JztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsInZhciBwZXJmb3JtYW5jZSA9IGdsb2JhbC5wZXJmb3JtYW5jZSB8fCB7fTtcblxudmFyIHByZXNlbnQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgbmFtZXMgPSBbJ25vdycsICd3ZWJraXROb3cnLCAnbXNOb3cnLCAnbW96Tm93JywgJ29Ob3cnXTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCkge1xuICAgIHZhciBuYW1lID0gbmFtZXMuc2hpZnQoKTtcbiAgICBpZiAobmFtZSBpbiBwZXJmb3JtYW5jZSkge1xuICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlW25hbWVdLmJpbmQocGVyZm9ybWFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRlTm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG4gIHZhciBuYXZpZ2F0aW9uU3RhcnQgPSAocGVyZm9ybWFuY2UudGltaW5nIHx8IHt9KS5uYXZpZ2F0aW9uU3RhcnQgfHwgZGF0ZU5vdygpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkYXRlTm93KCkgLSBuYXZpZ2F0aW9uU3RhcnQ7XG4gIH07XG59KCkpO1xuXG5wcmVzZW50LnBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93O1xucHJlc2VudC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICBwZXJmb3JtYW5jZS5ub3cgPSBwcmVzZW50LnBlcmZvcm1hbmNlTm93O1xufTtcbnByZXNlbnQuY29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHBlcmZvcm1hbmNlLm5vdyA9IHByZXNlbnQ7XG59O1xucHJlc2VudC5jb25mbGljdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZXNlbnQ7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJhZiA9IHJlcXVpcmUoJ3JhZicpO1xudmFyIG5vdyA9IHJlcXVpcmUoJ3RpbWUtbm93Jyk7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVydmFsO1xuZnVuY3Rpb24gaW50ZXJ2YWwoZGVsYXksIGZuLCBjdHgpIHtcbiAgdmFyIHN0YXJ0ID0gbm93KCk7XG4gIHZhciBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZGF0YS5pZCA9IHJhZihsb29wKTtcblxuICByZXR1cm4gZGF0YTtcblxuICBmdW5jdGlvbiBsb29wKCkge1xuICAgIGRhdGEuaWQgPSByYWYobG9vcCk7XG5cbiAgICBpZiAoKG5vdygpIC0gc3RhcnQpID49IGRlbGF5KSB7XG4gICAgICBmbi5jYWxsKGN0eCk7XG4gICAgICBzdGFydCA9IG5vdygpO1xuICAgIH1cbiAgfVxufVxuXG5cbmV4cG9ydHMuY2xlYXIgPSBjbGVhckludGVydmFsO1xuZnVuY3Rpb24gY2xlYXJJbnRlcnZhbChkYXRhKSB7XG4gIHJhZi5jYW5jZWwoZGF0YS5pZCk7XG59XG4iLCIvKlxuXG5zdHlsZS1hdHRyXG49PT09XG5cblZlcnkgc2ltcGxlIHBhcnNpbmcgYW5kIHN0cmluZ2lmeWluZyBvZiBzdHlsZSBhdHRyaWJ1dGVzLlxuXG5gcGFyc2VgXG4tLS0tXG5cbkNvbnZlcnQgYSBzdHlsZSBhdHRyaWJ1dGUgc3RyaW5nIHRvIGFuIG9iamVjdC5cblxuLSBpbnB1dDogc3RyaW5nIChlZy4gYW55dGhpbmcgeW91IG1pZ2h0IHNlZSBpbiBhIHN0eWxlIGF0dHJpYnV0ZSlcbi0gcmV0dXJuOiBvYmplY3RcblxuKi9cbmZ1bmN0aW9uIHBhcnNlIChyYXcpIHtcbiAgdmFyIHRyaW0gPSBmdW5jdGlvbiAocykgeyByZXR1cm4gcy50cmltKCk7IH07XG4gIHZhciBvYmogPSB7fTtcbiAgcmF3XG4gICAgLnNwbGl0KCc7JylcbiAgICAubWFwKHRyaW0pXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAvLyBzcGxpdCB3aXRoIGAuaW5kZXhPZmAgcmF0aGVyIHRoYW4gYC5zcGxpdGAgYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGFsc28gY29udGFpbiBjb2xvbnMuXG4gICAgICB2YXIgcG9zID0gaXRlbS5pbmRleE9mKCc6Jyk7XG4gICAgICB2YXIga2V5ID0gaXRlbS5zdWJzdHIoMCwgcG9zKS50cmltKCk7XG4gICAgICB2YXIgdmFsID0gaXRlbS5zdWJzdHIocG9zICsgMSkudHJpbSgpO1xuXG4gICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vKlxuXG5gc3RyaW5naWZ5YFxuLS0tLVxuXG5Db252ZXJ0IGFuIG9iamVjdCBpbnRvIGFuIGF0dHJpYnV0ZSBzdHJpbmdcblxuLSBpbnB1dDogb2JqZWN0XG4tIHJldHVybjogc3RyaW5nXG5cbiovXG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleSArICc6JyArIG9ialtrZXldO1xuICAgIH0pXG4gICAgLmpvaW4oJzsnKTtcbn1cblxuLypcblxuYG5vcm1hbGl6ZWBcbi0tLS1cblxuTm9ybWFsaXplIGFuIGF0dHJpYnV0ZSBzdHJpbmcgKGVnLiBjb2xsYXBzZSBkdXBsaWNhdGVzKVxuXG4tIGlucHV0OiBzdHJpbmdcbi0gcmV0dXJuOiBzdHJpbmdcblxuKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAoc3RyKSB7XG4gIHJldHVybiBzdHJpbmdpZnkocGFyc2Uoc3RyKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5tb2R1bGUuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4iLCIvLyBGaWxlOnNyYy9UaHJlZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxudmFyIFRIUkVFID0geyBSRVZJU0lPTjogJzc0ZGV2JyB9O1xuXG4vL1xuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRkZWZpbmUoICd0aHJlZScsIFRIUkVFICk7XG5cbn0gZWxzZSBpZiAoICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZXhwb3J0cyAmJiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSApIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IFRIUkVFO1xuXG59XG5cblxuLy8gcG9seWZpbGxzXG5cbmlmICggc2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHVuZGVmaW5lZCB8fCBzZWxmLmNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgKSB7XG5cblx0Ly8gTWlzc2luZyBpbiBBbmRyb2lkIHN0b2NrIGJyb3dzZXIuXG5cblx0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbGFzdFRpbWUgPSAwO1xuXHRcdHZhciB2ZW5kb3JzID0gWyAnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJyBdO1xuXG5cdFx0Zm9yICggdmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgISBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKysgeCApIHtcblxuXHRcdFx0c2VsZi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXHRcdFx0c2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHNlbGZbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCBzZWxmWyB2ZW5kb3JzWyB4IF0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuc2V0VGltZW91dCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRzZWxmLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRcdFx0dmFyIGN1cnJUaW1lID0gRGF0ZS5ub3coKSwgdGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG5cdFx0XHRcdHZhciBpZCA9IHNlbGYuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0Y2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXG5cdFx0XHRcdH0sIHRpbWVUb0NhbGwgKTtcblx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdHJldHVybiBpZDtcblxuXHRcdFx0fTtcblxuXHRcdH1cblxuXHRcdGlmICggc2VsZi5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gdW5kZWZpbmVkICYmIHNlbGYuY2xlYXJUaW1lb3V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNlbGYuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoIGlkICkge1xuXG5cdFx0XHRcdHNlbGYuY2xlYXJUaW1lb3V0KCBpZCApO1xuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdH0gKSgpO1xuXG59XG5cbi8vXG5cbmlmICggc2VsZi5wZXJmb3JtYW5jZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdHNlbGYucGVyZm9ybWFuY2UgPSB7fTtcblxufVxuXG5pZiAoIHNlbGYucGVyZm9ybWFuY2Uubm93ID09PSB1bmRlZmluZWQgKSB7XG5cblx0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG5cdFx0c2VsZi5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnQ7XG5cblx0XHR9XG5cblx0fSApKCk7XG5cbn1cblxuLy9cblxuaWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcblxufVxuXG4vL1xuXG5pZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxuXG5cdE1hdGguc2lnbiA9IGZ1bmN0aW9uICggeCApIHtcblxuXHRcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xuXG5cdH07XG5cbn1cblxuaWYgKCBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdC8vIE1pc3NpbmcgaW4gSUU5LTExLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBGdW5jdGlvbi5wcm90b3R5cGUsICduYW1lJywge1xuXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxzKmZ1bmN0aW9uXFxzKihcXFMqKVxccypcXCgvIClbIDEgXTtcblxuXHRcdH1cblxuXHR9ICk7XG5cbn1cblxuaWYgKCBPYmplY3QuYXNzaWduID09PSB1bmRlZmluZWQgKSB7XG5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggT2JqZWN0LCAnYXNzaWduJywge1xuXG5cdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG5cdFx0XHQndXNlIHN0cmljdCc7XG5cblx0XHRcdGlmICggdGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0XCIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG8gPSBPYmplY3QoIHRhcmdldCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdG5leHRTb3VyY2UgPSBPYmplY3QoIG5leHRTb3VyY2UgKTtcblxuXHRcdFx0XHR2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoIG5leHRTb3VyY2UgKTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4ICE9PSBsZW47ICsrIG5leHRJbmRleCApIHtcblxuXHRcdFx0XHRcdHZhciBuZXh0S2V5ID0ga2V5c0FycmF5WyBuZXh0SW5kZXggXTtcblx0XHRcdFx0XHR2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIG5leHRTb3VyY2UsIG5leHRLZXkgKTtcblxuXHRcdFx0XHRcdGlmICggZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSApIHtcblxuXHRcdFx0XHRcdFx0dG9bIG5leHRLZXkgXSA9IG5leHRTb3VyY2VbIG5leHRLZXkgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRvO1xuXG5cdFx0fVxuXG5cdH0gKTtcblxufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC5idXR0b25cblxuVEhSRUUuTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcblxuLy8gR0wgU1RBVEUgQ09OU1RBTlRTXG5cblRIUkVFLkN1bGxGYWNlTm9uZSA9IDA7XG5USFJFRS5DdWxsRmFjZUJhY2sgPSAxO1xuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XG5USFJFRS5DdWxsRmFjZUZyb250QmFjayA9IDM7XG5cblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG5cbi8vIFNIQURPV0lORyBUWVBFU1xuXG5USFJFRS5CYXNpY1NoYWRvd01hcCA9IDA7XG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xuVEhSRUUuUENGU29mdFNoYWRvd01hcCA9IDI7XG5cbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xuXG4vLyBzaWRlXG5cblRIUkVFLkZyb250U2lkZSA9IDA7XG5USFJFRS5CYWNrU2lkZSA9IDE7XG5USFJFRS5Eb3VibGVTaWRlID0gMjtcblxuLy8gc2hhZGluZ1xuXG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcblxuLy8gY29sb3JzXG5cblRIUkVFLk5vQ29sb3JzID0gMDtcblRIUkVFLkZhY2VDb2xvcnMgPSAxO1xuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcblxuLy8gYmxlbmRpbmcgbW9kZXNcblxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDE7XG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXG4vLyBtYXBwaW5ncyB0byBPcGVuR0wgY29uc3RhbnRzIGRlZmluZWQgaW4gVGV4dHVyZS5qcylcblxuVEhSRUUuQWRkRXF1YXRpb24gPSAxMDA7XG5USFJFRS5TdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XG5USFJFRS5NaW5FcXVhdGlvbiA9IDEwMztcblRIUkVFLk1heEVxdWF0aW9uID0gMTA0O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xuXG5USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xuVEhSRUUuU3JjQ29sb3JGYWN0b3IgPSAyMDI7XG5USFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XG5USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xuXG4vLyBjdXN0b20gYmxlbmRpbmcgc291cmNlIGZhY3RvcnNcblxuLy9USFJFRS5aZXJvRmFjdG9yID0gMjAwO1xuLy9USFJFRS5PbmVGYWN0b3IgPSAyMDE7XG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xuLy9USFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xuLy9USFJFRS5Ec3RBbHBoYUZhY3RvciA9IDIwNjtcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblRIUkVFLkRzdENvbG9yRmFjdG9yID0gMjA4O1xuVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciA9IDIwOTtcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XG5cbi8vIGRlcHRoIG1vZGVzXG5cblRIUkVFLk5ldmVyRGVwdGggPSAwO1xuVEhSRUUuQWx3YXlzRGVwdGggPSAxO1xuVEhSRUUuTGVzc0RlcHRoID0gMjtcblRIUkVFLkxlc3NFcXVhbERlcHRoID0gMztcblRIUkVFLkVxdWFsRGVwdGggPSA0O1xuVEhSRUUuR3JlYXRlckVxdWFsRGVwdGggPSA1O1xuVEhSRUUuR3JlYXRlckRlcHRoID0gNjtcblRIUkVFLk5vdEVxdWFsRGVwdGggPSA3O1xuXG5cbi8vIFRFWFRVUkUgQ09OU1RBTlRTXG5cblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcblRIUkVFLk1peE9wZXJhdGlvbiA9IDE7XG5USFJFRS5BZGRPcGVyYXRpb24gPSAyO1xuXG4vLyBNYXBwaW5nIG1vZGVzXG5cblRIUkVFLlVWTWFwcGluZyA9IDMwMDtcblxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gMzAyO1xuXG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IDMwMztcblRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xuXG5USFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcblxuLy8gV3JhcHBpbmcgbW9kZXNcblxuVEhSRUUuUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IDEwMDE7XG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcblxuLy8gRmlsdGVyc1xuXG5USFJFRS5OZWFyZXN0RmlsdGVyID0gMTAwMztcblRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xuVEhSRUUuTGluZWFyRmlsdGVyID0gMTAwNjtcblRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcblxuLy8gRGF0YSB0eXBlc1xuXG5USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcblRIUkVFLkJ5dGVUeXBlID0gMTAxMDtcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XG5USFJFRS5VbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XG5USFJFRS5JbnRUeXBlID0gMTAxMztcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG5USFJFRS5GbG9hdFR5cGUgPSAxMDE1O1xuVEhSRUUuSGFsZkZsb2F0VHlwZSA9IDEwMjU7XG5cbi8vIFBpeGVsIHR5cGVzXG5cbi8vVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE2O1xuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxODtcblxuLy8gUGl4ZWwgZm9ybWF0c1xuXG5USFJFRS5BbHBoYUZvcm1hdCA9IDEwMTk7XG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xuVEhSRUUuUkdCQUZvcm1hdCA9IDEwMjE7XG5USFJFRS5MdW1pbmFuY2VGb3JtYXQgPSAxMDIyO1xuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xuLy8gVEhSRUUuUkdCRUZvcm1hdCBoYW5kbGVkIGFzIFRIUkVFLlJHQkFGb3JtYXQgaW4gc2hhZGVyc1xuVEhSRUUuUkdCRUZvcm1hdCA9IFRIUkVFLlJHQkFGb3JtYXQ7IC8vMTAyNDtcblxuLy8gRERTIC8gU1QzQyBDb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0c1xuXG5USFJFRS5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XG5USFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcblRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XG5cblxuLy8gUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xuVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xuVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XG5cbi8vIExvb3Agc3R5bGVzIGZvciBBbmltYXRpb25BY3Rpb25cblxuVEhSRUUuTG9vcE9uY2UgPSAyMjAwO1xuVEhSRUUuTG9vcFJlcGVhdCA9IDIyMDE7XG5USFJFRS5Mb29wUGluZ1BvbmcgPSAyMjAyO1xuXG4vLyBJbnRlcnBvbGF0aW9uXG5cblRIUkVFLkludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xuVEhSRUUuSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xuVEhSRUUuSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuXG4vLyBJbnRlcnBvbGFudCBlbmRpbmcgbW9kZXNcblxuVEhSRUUuWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XG5USFJFRS5aZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xuVEhSRUUuV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG5cbi8vIFRyaWFuZ2xlIERyYXcgbW9kZXNcblxuVEhSRUUuVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xuVEhSRUUuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcblRIUkVFLlRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xuXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBhcmd1bWVudHMgKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXMuc2V0KCBjb2xvciApO1xuXG59O1xuXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkNvbG9yLFxuXG5cdHI6IDEsIGc6IDEsIGI6IDEsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHZhbHVlICk7XG5cblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXG5cdFx0XHR0aGlzLnNldEhleCggdmFsdWUgKTtcblxuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnIgPSBzY2FsYXI7XG5cdFx0dGhpcy5nID0gc2NhbGFyO1xuXHRcdHRoaXMuYiA9IHNjYWxhcjtcblxuXHR9LFxuXG5cdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XG5cblx0XHRoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuXHRcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG5cdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xuXG5cdFx0dGhpcy5yID0gcjtcblx0XHR0aGlzLmcgPSBnO1xuXHRcdHRoaXMuYiA9IGI7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEhTTDogZnVuY3Rpb24gKCkge1xuXG5cdFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcblxuXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcblx0XHRcdGlmICggdCA+IDEgKSB0IC09IDE7XG5cdFx0XHRpZiAoIHQgPCAxIC8gNiApIHJldHVybiBwICsgKCBxIC0gcCApICogNiAqIHQ7XG5cdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuXHRcdFx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuXHRcdFx0cmV0dXJuIHA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBoLCBzLCBsICkge1xuXG5cdFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxuXHRcdFx0aCA9IFRIUkVFLk1hdGguZXVjbGlkZWFuTW9kdWxvKCBoLCAxICk7XG5cdFx0XHRzID0gVEhSRUUuTWF0aC5jbGFtcCggcywgMCwgMSApO1xuXHRcdFx0bCA9IFRIUkVFLk1hdGguY2xhbXAoIGwsIDAsIDEgKTtcblxuXHRcdFx0aWYgKCBzID09PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcblx0XHRcdFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xuXG5cdFx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xuXHRcdFx0XHR0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XG5cdFx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xuXG5cdFx0XHRpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHBhcnNlRmxvYXQoIHN0cmluZyApIDwgMSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogQWxwaGEgY29tcG9uZW50IG9mICcgKyBzdHlsZSArICcgd2lsbCBiZSBpZ25vcmVkLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHR2YXIgbTtcblxuXHRcdGlmICggbSA9IC9eKCg/OnJnYnxoc2wpYT8pXFwoXFxzKihbXlxcKV0qKVxcKS8uZXhlYyggc3R5bGUgKSApIHtcblxuXHRcdFx0Ly8gcmdiIC8gaHNsXG5cblx0XHRcdHZhciBjb2xvcjtcblx0XHRcdHZhciBuYW1lID0gbVsgMSBdO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XG5cblx0XHRcdHN3aXRjaCAoIG5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAncmdiJzpcblx0XHRcdFx0Y2FzZSAncmdiYSc6XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oXFxkKylcXHMqLFxccyooXFxkKylcXHMqLFxccyooXFxkKylcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcblx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcblxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG5cdFx0XHRcdFx0XHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcblx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XG5cdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuXHRcdFx0XHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcblxuXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdoc2wnOlxuXHRcdFx0XHRjYXNlICdoc2xhJzpcblxuXHRcdFx0XHRcdGlmICggY29sb3IgPSAvXihbMC05XSpcXC4/WzAtOV0rKVxccyosXFxzKihcXGQrKVxcJVxccyosXFxzKihcXGQrKVxcJVxccyooLFxccyooWzAtOV0qXFwuP1swLTldKylcXHMqKT8kLy5leGVjKCBjb21wb25lbnRzICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIGhzbCgxMjAsNTAlLDUwJSkgaHNsYSgxMjAsNTAlLDUwJSwwLjUpXG5cdFx0XHRcdFx0XHR2YXIgaCA9IHBhcnNlRmxvYXQoIGNvbG9yWyAxIF0gKSAvIDM2MDtcblx0XHRcdFx0XHRcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XG5cdFx0XHRcdFx0XHR2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xuXG5cdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRIU0woIGgsIHMsIGwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBtID0gL15cXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoIHN0eWxlICkgKSB7XG5cblx0XHRcdC8vIGhleCBjb2xvclxuXG5cdFx0XHR2YXIgaGV4ID0gbVsgMSBdO1xuXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHNpemUgPT09IDMgKSB7XG5cblx0XHRcdFx0Ly8gI2ZmMFxuXHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xuXHRcdFx0XHR0aGlzLmcgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMSApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xuXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xuXG5cdFx0XHRcdC8vICNmZjAwMDBcblx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcblx0XHRcdFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHQvLyBjb2xvciBrZXl3b3Jkc1xuXHRcdFx0dmFyIGhleCA9IFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF07XG5cblx0XHRcdGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gcmVkXG5cdFx0XHRcdHRoaXMuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuciwgdGhpcy5nLCB0aGlzLmIgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvci5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yLmc7XG5cdFx0dGhpcy5iID0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG5cdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cblx0XHR0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcblx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcblx0XHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG5cdFx0aWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cblx0XHR2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xuXG5cdFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG5cdFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIHNhZmVJbnZlcnNlICk7XG5cdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdHRoaXMuciA9IHIgKiByO1xuXHRcdHRoaXMuZyA9IGcgKiBnO1xuXHRcdHRoaXMuYiA9IGIgKiBiO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5yID0gTWF0aC5zcXJ0KCB0aGlzLnIgKTtcblx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xuXHRcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEhleDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XG5cblx0fSxcblxuXHRnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcblxuXHR9LFxuXG5cdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cblx0XHR2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwgeyBoOiAwLCBzOiAwLCBsOiAwIH07XG5cblx0XHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xuXG5cdFx0dmFyIGh1ZSwgc2F0dXJhdGlvbjtcblx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuXHRcdGlmICggbWluID09PSBtYXggKSB7XG5cblx0XHRcdGh1ZSA9IDA7XG5cdFx0XHRzYXR1cmF0aW9uID0gMDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuXHRcdFx0c2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xuXG5cdFx0XHRzd2l0Y2ggKCBtYXggKSB7XG5cblx0XHRcdFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcblx0XHRcdFx0Y2FzZSBnOiBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7IGJyZWFrO1xuXHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0aHVlIC89IDY7XG5cblx0XHR9XG5cblx0XHRoc2wuaCA9IGh1ZTtcblx0XHRoc2wucyA9IHNhdHVyYXRpb247XG5cdFx0aHNsLmwgPSBsaWdodG5lc3M7XG5cblx0XHRyZXR1cm4gaHNsO1xuXG5cdH0sXG5cblx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cblx0fSxcblxuXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcblxuXHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG5cdFx0aHNsLmggKz0gaDsgaHNsLnMgKz0gczsgaHNsLmwgKz0gbDtcblxuXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHRcdHRoaXMuciArPSBjb2xvci5yO1xuXHRcdHRoaXMuZyArPSBjb2xvci5nO1xuXHRcdHRoaXMuYiArPSBjb2xvci5iO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRDb2xvcnM6IGZ1bmN0aW9uICggY29sb3IxLCBjb2xvcjIgKSB7XG5cblx0XHR0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuXHRcdHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnIgKz0gcztcblx0XHR0aGlzLmcgKz0gcztcblx0XHR0aGlzLmIgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cblx0XHR0aGlzLnIgKj0gY29sb3Iucjtcblx0XHR0aGlzLmcgKj0gY29sb3IuZztcblx0XHR0aGlzLmIgKj0gY29sb3IuYjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMuciAqPSBzO1xuXHRcdHRoaXMuZyAqPSBzO1xuXHRcdHRoaXMuYiAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuXHRcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuXHRcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xuXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcblxuXHRcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLnIgPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLmIgPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkNvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcbidiZWlnZSc6IDB4RjVGNURDLCAnYmlzcXVlJzogMHhGRkU0QzQsICdibGFjayc6IDB4MDAwMDAwLCAnYmxhbmNoZWRhbG1vbmQnOiAweEZGRUJDRCwgJ2JsdWUnOiAweDAwMDBGRiwgJ2JsdWV2aW9sZXQnOiAweDhBMkJFMixcbidicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcbidjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxuJ2Rhcmtnb2xkZW5yb2QnOiAweEI4ODYwQiwgJ2RhcmtncmF5JzogMHhBOUE5QTksICdkYXJrZ3JlZW4nOiAweDAwNjQwMCwgJ2RhcmtncmV5JzogMHhBOUE5QTksICdkYXJra2hha2knOiAweEJEQjc2QiwgJ2RhcmttYWdlbnRhJzogMHg4QjAwOEIsXG4nZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuJ2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcbidkZWVwcGluayc6IDB4RkYxNDkzLCAnZGVlcHNreWJsdWUnOiAweDAwQkZGRiwgJ2RpbWdyYXknOiAweDY5Njk2OSwgJ2RpbWdyZXknOiAweDY5Njk2OSwgJ2RvZGdlcmJsdWUnOiAweDFFOTBGRiwgJ2ZpcmVicmljayc6IDB4QjIyMjIyLFxuJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG4nZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXG4naW5kaWFucmVkJzogMHhDRDVDNUMsICdpbmRpZ28nOiAweDRCMDA4MiwgJ2l2b3J5JzogMHhGRkZGRjAsICdraGFraSc6IDB4RjBFNjhDLCAnbGF2ZW5kZXInOiAweEU2RTZGQSwgJ2xhdmVuZGVyYmx1c2gnOiAweEZGRjBGNSwgJ2xhd25ncmVlbic6IDB4N0NGQzAwLFxuJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcbidsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxuJ2xpZ2h0c2xhdGVncmF5JzogMHg3Nzg4OTksICdsaWdodHNsYXRlZ3JleSc6IDB4Nzc4ODk5LCAnbGlnaHRzdGVlbGJsdWUnOiAweEIwQzRERSwgJ2xpZ2h0eWVsbG93JzogMHhGRkZGRTAsICdsaW1lJzogMHgwMEZGMDAsICdsaW1lZ3JlZW4nOiAweDMyQ0QzMixcbidsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbidtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcbidtZWRpdW12aW9sZXRyZWQnOiAweEM3MTU4NSwgJ21pZG5pZ2h0Ymx1ZSc6IDB4MTkxOTcwLCAnbWludGNyZWFtJzogMHhGNUZGRkEsICdtaXN0eXJvc2UnOiAweEZGRTRFMSwgJ21vY2Nhc2luJzogMHhGRkU0QjUsICduYXZham93aGl0ZSc6IDB4RkZERUFELFxuJ25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcbidwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxuJ3BlcnUnOiAweENEODUzRiwgJ3BpbmsnOiAweEZGQzBDQiwgJ3BsdW0nOiAweEREQTBERCwgJ3Bvd2RlcmJsdWUnOiAweEIwRTBFNiwgJ3B1cnBsZSc6IDB4ODAwMDgwLCAncmVkJzogMHhGRjAwMDAsICdyb3N5YnJvd24nOiAweEJDOEY4Rixcbidyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuJ3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXG4nc3ByaW5nZ3JlZW4nOiAweDAwRkY3RiwgJ3N0ZWVsYmx1ZSc6IDB4NDY4MkI0LCAndGFuJzogMHhEMkI0OEMsICd0ZWFsJzogMHgwMDgwODAsICd0aGlzdGxlJzogMHhEOEJGRDgsICd0b21hdG8nOiAweEZGNjM0NywgJ3R1cnF1b2lzZSc6IDB4NDBFMEQwLFxuJ3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuLy8gRmlsZTpzcmMvbWF0aC9RdWF0ZXJuaW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5USFJFRS5RdWF0ZXJuaW9uID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdHRoaXMuX3ggPSB4IHx8IDA7XG5cdHRoaXMuX3kgPSB5IHx8IDA7XG5cdHRoaXMuX3ogPSB6IHx8IDA7XG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxuXG5cdGdldCB4ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH0sXG5cblx0c2V0IHggKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB5ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH0sXG5cblx0c2V0IHkgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB6ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH0sXG5cblx0c2V0IHogKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB3ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl93O1xuXG5cdH0sXG5cblx0c2V0IHcgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3cgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5feiA9IHo7XG5cdFx0dGhpcy5fdyA9IHc7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcblx0XHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuXHRcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuXHRcdGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xuXHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG5cdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG5cdFx0dmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xuXHRcdHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcblx0XHR2YXIgYzMgPSBNYXRoLmNvcyggZXVsZXIuX3ogLyAyICk7XG5cdFx0dmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xuXHRcdHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcblx0XHR2YXIgczMgPSBNYXRoLnNpbiggZXVsZXIuX3ogLyAyICk7XG5cblx0XHR2YXIgb3JkZXIgPSBldWxlci5vcmRlcjtcblxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxuXG5cdFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuXHRcdHRoaXMuX3ggPSBheGlzLnggKiBzO1xuXHRcdHRoaXMuX3kgPSBheGlzLnkgKiBzO1xuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuXHRcdHRoaXMuX3cgPSBNYXRoLmNvcyggaGFsZkFuZ2xlICk7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXG5cblx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuXHRcdFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF0sXG5cblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuXHRcdFx0cztcblxuXHRcdGlmICggdHJhY2UgPiAwICkge1xuXG5cdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG5cdFx0XHR0aGlzLl93ID0gMC4yNSAvIHM7XG5cdFx0XHR0aGlzLl94ID0gKCBtMzIgLSBtMjMgKSAqIHM7XG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG5cdFx0XHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XG5cblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xuXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xuXG5cdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuXHRcdFx0dGhpcy5fdyA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuXHRcdFx0dGhpcy5feiA9ICggbTIzICsgbTMyICkgLyBzO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cblx0XHRcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcblx0XHRcdHRoaXMuX3ggPSAoIG0xMyArIG0zMSApIC8gcztcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcblx0XHRcdHRoaXMuX3ogPSAwLjI1ICogcztcblxuXHRcdH1cblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIGh0dHA6Ly9sb2xlbmdpbmUubmV0L2Jsb2cvMjAxNC8wMi8yNC9xdWF0ZXJuaW9uLWZyb20tdHdvLXZlY3RvcnMtZmluYWxcblxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIHYxLCByO1xuXG5cdFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XG5cblx0XHRcdGlmICggciA8IEVQUyApIHtcblxuXHRcdFx0XHRyID0gMDtcblxuXHRcdFx0XHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0djEuc2V0KCAwLCAtIHZGcm9tLnosIHZGcm9tLnkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5feCA9IHYxLng7XG5cdFx0XHR0aGlzLl95ID0gdjEueTtcblx0XHRcdHRoaXMuX3ogPSB2MS56O1xuXHRcdFx0dGhpcy5fdyA9IHI7XG5cblx0XHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0aW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLl94ICo9IC0gMTtcblx0XHR0aGlzLl95ICo9IC0gMTtcblx0XHR0aGlzLl96ICo9IC0gMTtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuXHR9LFxuXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuXHRcdGlmICggbCA9PT0gMCApIHtcblxuXHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHR0aGlzLl95ID0gMDtcblx0XHRcdHRoaXMuX3ogPSAwO1xuXHRcdFx0dGhpcy5fdyA9IDE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRsID0gMSAvIGw7XG5cblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcblx0XHRcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcblx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuXHRcdH1cblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xuXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG5cdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG5cdFx0dmFyIHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuXHRcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG5cdFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG5cdFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuXHRcdHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG5cdFx0XHR0aGlzLl93ID0gLSBxYi5fdztcblx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XG5cdFx0XHR0aGlzLl96ID0gLSBxYi5fejtcblxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cblx0XHRcdHRoaXMuX3cgPSB3O1xuXHRcdFx0dGhpcy5feCA9IHg7XG5cdFx0XHR0aGlzLl95ID0geTtcblx0XHRcdHRoaXMuX3ogPSB6O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcblxuXHRcdFx0dGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcblx0XHRcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XG5cdFx0XHR0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xuXHRcdFx0dGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcblx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuXHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuXHRcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XG5cdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG5cdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59O1xuXG5PYmplY3QuYXNzaWduKCBUSFJFRS5RdWF0ZXJuaW9uLCB7XG5cblx0c2xlcnA6IGZ1bmN0aW9uKCBxYSwgcWIsIHFtLCB0ICkge1xuXG5cdFx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XG5cblx0fSxcblxuXHRzbGVycEZsYXQ6IGZ1bmN0aW9uKFxuXHRcdFx0ZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XG5cblx0XHQvLyBmdXp6LWZyZWUsIGFycmF5LWJhc2VkIFF1YXRlcm5pb24gU0xFUlAgb3BlcmF0aW9uXG5cblx0XHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuXHRcdFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxuXHRcdFx0ejAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMiBdLFxuXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxuXG5cdFx0XHR4MSA9IHNyYzFbIHNyY09mZnNldDEgKyAwIF0sXG5cdFx0XHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXG5cdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG5cdFx0XHR3MSA9IHNyYzFbIHNyY09mZnNldDEgKyAzIF07XG5cblx0XHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcblxuXHRcdFx0dmFyIHMgPSAxIC0gdCxcblxuXHRcdFx0XHRjb3MgPSB4MCAqIHgxICsgeTAgKiB5MSArIHowICogejEgKyB3MCAqIHcxLFxuXG5cdFx0XHRcdGRpciA9ICggY29zID49IDAgPyAxIDogLSAxICksXG5cdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cblx0XHRcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XG5cdFx0XHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuXHRcdFx0XHRcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XG5cblx0XHRcdFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XG5cdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0RGlyID0gdCAqIGRpcjtcblxuXHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG5cdFx0XHR5MCA9IHkwICogcyArIHkxICogdERpcjtcblx0XHRcdHowID0gejAgKiBzICsgejEgKiB0RGlyO1xuXHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSBpbiBjYXNlIHdlIGp1c3QgZGlkIGEgbGVycDpcblx0XHRcdGlmICggcyA9PT0gMSAtIHQgKSB7XG5cblx0XHRcdFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cblx0XHRcdFx0eDAgKj0gZjtcblx0XHRcdFx0eTAgKj0gZjtcblx0XHRcdFx0ejAgKj0gZjtcblx0XHRcdFx0dzAgKj0gZjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xuXHRcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XG5cdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcblx0XHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xuXG5cdH1cblxufSApO1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuXHR0aGlzLnggPSB4IHx8IDA7XG5cdHRoaXMueSA9IHkgfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXG5cblx0Z2V0IHdpZHRoKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueDtcblxuXHR9LFxuXG5cdHNldCB3aWR0aCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnggPSB2YWx1ZTtcblxuXHR9LFxuXG5cdGdldCBoZWlnaHQoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy55O1xuXG5cdH0sXG5cblx0c2V0IGhlaWdodCggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuXHR9LFxuXG5cdC8vXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gdi54O1xuXHRcdHRoaXMueSA9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHRoaXMueCAqPSB2Lng7XG5cdFx0dGhpcy55ICo9IHYueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XG5cblx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnkgKj0gc2NhbGFyO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy54ID0gMDtcblx0XHRcdHRoaXMueSA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXHRcdFx0XHRtYXggPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcblx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblxuXHRcdHJldHVybiBhcnJheTtcblxuXHR9LFxuXG5cdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG5cdFx0dGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKSwgcyA9IE1hdGguc2luKCBhbmdsZSApO1xuXG5cdFx0dmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcblx0XHR2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG5cdFx0dGhpcy54ID0geCAqIGMgLSB5ICogcyArIGNlbnRlci54O1xuXHRcdHRoaXMueSA9IHggKiBzICsgeSAqIGMgKyBjZW50ZXIueTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXHR0aGlzLnogPSB6IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMueiA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHR0aGlzLnggPSBzY2FsYXI7XG5cdFx0dGhpcy55ID0gc2NhbGFyO1xuXHRcdHRoaXMueiA9IHNjYWxhcjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG5cdFx0dGhpcy54ID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG5cdFx0dGhpcy55ID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG5cdFx0dGhpcy56ID0gejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcblx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCArPSB2Lng7XG5cdFx0dGhpcy55ICs9IHYueTtcblx0XHR0aGlzLnogKz0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCArPSBzO1xuXHRcdHRoaXMueSArPSBzO1xuXHRcdHRoaXMueiArPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggKyBiLng7XG5cdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXHRcdHRoaXMueiA9IGEueiArIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gdi54ICogcztcblx0XHR0aGlzLnkgKz0gdi55ICogcztcblx0XHR0aGlzLnogKz0gdi56ICogcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMueCAtPSB2Lng7XG5cdFx0dGhpcy55IC09IHYueTtcblx0XHR0aGlzLnogLT0gdi56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuXHRcdHRoaXMueCAtPSBzO1xuXHRcdHRoaXMueSAtPSBzO1xuXHRcdHRoaXMueiAtPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR0aGlzLnggPSBhLnggLSBiLng7XG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICo9IHYueDtcblx0XHR0aGlzLnkgKj0gdi55O1xuXHRcdHRoaXMueiAqPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdGlmICggaXNGaW5pdGUoIHNjYWxhciApICkge1xuXG5cdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueiAqPSBzY2FsYXI7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnggPSAwO1xuXHRcdFx0dGhpcy55ID0gMDtcblx0XHRcdHRoaXMueiA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcblx0XHR0aGlzLnogPSBhLnogKiBiLno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5RXVsZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBxdWF0ZXJuaW9uO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG5cdFx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cblx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgNyBdICogejtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXTtcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cdFx0dmFyIGQgPSAxIC8gKCBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSApOyAvLyBwZXJzcGVjdGl2ZSBkaXZpZGVcblxuXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG5cdFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXSApICogZDtcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuXHRcdHZhciB4ID0gdGhpcy54O1xuXHRcdHZhciB5ID0gdGhpcy55O1xuXHRcdHZhciB6ID0gdGhpcy56O1xuXG5cdFx0dmFyIHF4ID0gcS54O1xuXHRcdHZhciBxeSA9IHEueTtcblx0XHR2YXIgcXogPSBxLno7XG5cdFx0dmFyIHF3ID0gcS53O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG5cdFx0dmFyIGl5ID0gIHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcblx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuXHRcdHZhciBpdyA9IC0gcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG5cdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xuXHRcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdCggY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXHRcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XG5cdFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuXHRcdHRoaXMubm9ybWFsaXplKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54IC89IHYueDtcblx0XHR0aGlzLnkgLz0gdi55O1xuXHRcdHRoaXMueiAvPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG5cdH0sXG5cblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1pbiggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgbWluIDwgbWF4LCBpZiB0aGlzIGFzc3VtcHRpb24gaXNuJ3QgdHJ1ZSBpdCB3aWxsIG5vdCBvcGVyYXRlIGNvcnJlY3RseVxuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWluLCBtYXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xuXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNsYW1wTGVuZ3RoOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApIC8gbGVuZ3RoICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VpbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuXHRcdHRoaXMueSA9IC0gdGhpcy55O1xuXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cblx0fSxcblxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuXHR9LFxuXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cblx0fSxcblxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XG5cblx0fSxcblxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcblx0XHR0aGlzLnkgPSB6ICogdi54IC0geCAqIHYuejtcblx0XHR0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cblx0XHR2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcblx0XHR2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcblxuXHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuXHRcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSwgZG90O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblZlY3RvciggdmVjdG9yICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHYxLmNvcHkoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRkb3QgPSB0aGlzLmRvdCggdjEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCBwbGFuZU5vcm1hbCApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByZWZsZWN0KCBub3JtYWwgKSB7XG5cblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XG5cblx0XHR9XG5cblx0fSgpLFxuXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcblxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXG5cblx0XHRyZXR1cm4gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciBkeCA9IHRoaXMueCAtIHYueDtcblx0XHR2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XG5cdFx0dmFyIGR6ID0gdGhpcy56IC0gdi56O1xuXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dGhpcy54ID0gbS5lbGVtZW50c1sgMTIgXTtcblx0XHR0aGlzLnkgPSBtLmVsZW1lbnRzWyAxMyBdO1xuXHRcdHRoaXMueiA9IG0uZWxlbWVudHNbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhTY2FsZTogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDAgXSwgbS5lbGVtZW50c1sgMSBdLCBtLmVsZW1lbnRzWyAyIF0gKS5sZW5ndGgoKTtcblx0XHR2YXIgc3kgPSB0aGlzLnNldCggbS5lbGVtZW50c1sgNCBdLCBtLmVsZW1lbnRzWyA1IF0sIG0uZWxlbWVudHNbIDYgXSApLmxlbmd0aCgpO1xuXHRcdHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0dGhpcy54ID0gc3g7XG5cdFx0dGhpcy55ID0gc3k7XG5cdFx0dGhpcy56ID0gc3o7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcblxuXHRcdHZhciBvZmZzZXQgPSBpbmRleCAqIDQ7XG5cblx0XHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBtZVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gbWVbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBtZVsgb2Zmc2V0ICsgMiBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XG5cblx0fSxcblxuXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG5cdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvVmVjdG9yNC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3I0ID0gZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdHRoaXMueCA9IHggfHwgMDtcblx0dGhpcy55ID0geSB8fCAwO1xuXHR0aGlzLnogPSB6IHx8IDA7XG5cdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxufTtcblxuVEhSRUUuVmVjdG9yNC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjQsXG5cblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy56ID0gejtcblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy54ID0gc2NhbGFyO1xuXHRcdHRoaXMueSA9IHNjYWxhcjtcblx0XHR0aGlzLnogPSBzY2FsYXI7XG5cdFx0dGhpcy53ID0gc2NhbGFyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XG5cblx0XHR0aGlzLnggPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XG5cblx0XHR0aGlzLnkgPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cblx0XHR0aGlzLnogPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XG5cblx0XHR0aGlzLncgPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XG5cblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcblx0XHRcdGNhc2UgMzogdGhpcy53ID0gdmFsdWU7IGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG5cdFx0XHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR0aGlzLnggPSB2Lng7XG5cdFx0dGhpcy55ID0gdi55O1xuXHRcdHRoaXMueiA9IHYuejtcblx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54ICs9IHYueDtcblx0XHR0aGlzLnkgKz0gdi55O1xuXHRcdHRoaXMueiArPSB2Lno7XG5cdFx0dGhpcy53ICs9IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggKz0gcztcblx0XHR0aGlzLnkgKz0gcztcblx0XHR0aGlzLnogKz0gcztcblx0XHR0aGlzLncgKz0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54ICsgYi54O1xuXHRcdHRoaXMueSA9IGEueSArIGIueTtcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XG5cdFx0dGhpcy53ID0gYS53ICsgYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuXHRcdHRoaXMueCArPSB2LnggKiBzO1xuXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXHRcdHRoaXMudyArPSB2LncgKiBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy54IC09IHYueDtcblx0XHR0aGlzLnkgLT0gdi55O1xuXHRcdHRoaXMueiAtPSB2Lno7XG5cdFx0dGhpcy53IC09IHYudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cblx0XHR0aGlzLnggLT0gcztcblx0XHR0aGlzLnkgLT0gcztcblx0XHR0aGlzLnogLT0gcztcblx0XHR0aGlzLncgLT0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xuXHRcdHRoaXMueSA9IGEueSAtIGIueTtcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XG5cdFx0dGhpcy53ID0gYS53IC0gYi53O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cblx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuXHRcdFx0dGhpcy54ICo9IHNjYWxhcjtcblx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG5cdFx0XHR0aGlzLnogKj0gc2NhbGFyO1xuXHRcdFx0dGhpcy53ICo9IHNjYWxhcjtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMueCA9IDA7XG5cdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0dGhpcy56ID0gMDtcblx0XHRcdHRoaXMudyA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHggPSB0aGlzLng7XG5cdFx0dmFyIHkgPSB0aGlzLnk7XG5cdFx0dmFyIHogPSB0aGlzLno7XG5cdFx0dmFyIHcgPSB0aGlzLnc7XG5cblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XG5cdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cblx0XHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xuXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xuXG5cdFx0XHQgdGhpcy54ID0gMTtcblx0XHRcdCB0aGlzLnkgPSAwO1xuXHRcdFx0IHRoaXMueiA9IDA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQgdGhpcy54ID0gcS54IC8gcztcblx0XHRcdCB0aGlzLnkgPSBxLnkgLyBzO1xuXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxuXHRcdFx0ZXBzaWxvbiA9IDAuMDEsXHRcdC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG5cdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuXHRcdFx0dGUgPSBtLmVsZW1lbnRzLFxuXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcblx0XHRcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKVxuXHRcdCAgICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApXG5cdFx0ICAgJiYgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XG5cblx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXG5cdFx0XHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXG5cblx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApXG5cdFx0XHQgICAmJiAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yIClcblx0XHRcdCAgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxuXHRcdFx0ICAgJiYgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuXHRcdFx0XHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcblxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXG5cblx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblxuXHRcdFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuXHRcdFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XG5cdFx0XHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG5cdFx0XHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xuXG5cdFx0XHRcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMDtcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XG5cdFx0XHRcdFx0eiA9IHh6IC8geDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XG5cblx0XHRcdFx0Ly8gbTIyIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcblxuXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcblx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcblx0XHRcdFx0XHR6ID0geXogLyB5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XG5cblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuXHRcdFx0XHRcdHogPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xuXHRcdFx0XHRcdHggPSB4eiAvIHo7XG5cdFx0XHRcdFx0eSA9IHl6IC8gejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XG5cblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG5cdFx0fVxuXG5cdFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxuXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXG5cdFx0XHRcdFx0XHQgICsgKCBtMTMgLSBtMzEgKSAqICggbTEzIC0gbTMxIClcblx0XHRcdFx0XHRcdCAgKyAoIG0yMSAtIG0xMiApICogKCBtMjEgLSBtMTIgKSApOyAvLyB1c2VkIHRvIG5vcm1hbGl6ZVxuXG5cdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuXHRcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcblxuXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xuXHRcdHRoaXMueiA9ICggbTIxIC0gbTEyICkgLyBzO1xuXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5tYXgoIHRoaXMudywgdi53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuXHRcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xuXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuXHRcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuXHRcdFx0aWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXHRcdFx0XHRtYXggPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cblx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXHRcdHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG5cdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG5cdFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcblx0XHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcblx0XHR0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnggPSAtIHRoaXMueDtcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcblx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xuXG5cdH0sXG5cblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLnc7XG5cblx0fSxcblxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xuXG5cdH0sXG5cblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuXHR9LFxuXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggbGVuZ3RoIC8gdGhpcy5sZW5ndGgoKSApO1xuXG5cdH0sXG5cblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXHRcdHRoaXMudyArPSAoIHYudyAtIHRoaXMudyApICogYWxwaGE7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XG5cblx0XHR0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcblxuXHR9LFxuXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcblx0XHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xuXHRcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcblx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuXHRcdHRoaXMueiA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAyIF07XG5cdFx0dGhpcy53ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDMgXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9FdWxlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0dGhpcy5feCA9IHggfHwgMDtcblx0dGhpcy5feSA9IHkgfHwgMDtcblx0dGhpcy5feiA9IHogfHwgMDtcblx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXI7XG5cbn07XG5cblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XG5cblRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXG5USFJFRS5FdWxlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxuXG5cdGdldCB4ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl94O1xuXG5cdH0sXG5cblx0c2V0IHggKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ggPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB5ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl95O1xuXG5cdH0sXG5cblx0c2V0IHkgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCB6ICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl96O1xuXG5cdH0sXG5cblx0c2V0IHogKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHR9LFxuXG5cdGdldCBvcmRlciAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fb3JkZXI7XG5cblx0fSxcblxuXHRzZXQgb3JkZXIgKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuX29yZGVyID0gdmFsdWU7XG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl96ID0gejtcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0dGhpcy5feCA9IGV1bGVyLl94O1xuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcblx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG5cdFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0sIG9yZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xuXG5cdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XG5cdFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XG5cdFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG5cdFx0dmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xuXG5cdFx0b3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcblxuXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcblx0XHRcdFx0dGhpcy5feiA9IDA7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuXHRcdFx0dGhpcy5feCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzLCAtIDEsIDEgKSApO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XG5cblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG5cdFx0XHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dGhpcy5feiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5feCA9IDA7XG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcblxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xuXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuXHRcdFx0XHR0aGlzLl95ID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyIClcblxuXHRcdH1cblxuXHRcdHRoaXMuX29yZGVyID0gb3JkZXI7XG5cblx0XHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdG1hdHJpeC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcSApO1xuXHRcdFx0dGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KCB2LngsIHYueSwgdi56LCBvcmRlciB8fCB0aGlzLl9vcmRlciApO1xuXG5cdH0sXG5cblx0cmVvcmRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxuXG5cdFx0dmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbmV3T3JkZXIgKSB7XG5cblx0XHRcdHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cdFx0XHR0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG5cdFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5feCA9IGFycmF5WyAwIF07XG5cdFx0dGhpcy5feSA9IGFycmF5WyAxIF07XG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XG5cdFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XG5cblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG5cdFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0xpbmUzLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICovXG5cblRIUkVFLkxpbmUzID0gZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG5cdHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5MaW5lMy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkxpbmUzLFxuXG5cdHNldDogZnVuY3Rpb24gKCBzdGFydCwgZW5kICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xuXHRcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cdFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cblx0XHRcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuXHRcdFx0c3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcblx0XHRcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG5cdFx0XHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuXHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuXHRcdFx0XHR0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0O1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cblx0XHRyZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0JveDIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKi9cblxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cblx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMiggSW5maW5pdHksIEluZmluaXR5ICk7XG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94Mi5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDIsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG5cdH0sXG5cblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuXHR9LFxuXG5cdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XG5cdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcblx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0aWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG5cdFx0ICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdHJldHVybiByZXN1bHQuc2V0KFxuXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG5cdFx0KTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxuXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcblxuXHR9LFxuXG5cdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0JveDMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5Cb3gzID0gZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcblxufTtcblxuVEhSRUUuQm94My5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkJveDMsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XG5cdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFx0dGhpcy5tYWtlRW1wdHkoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cblx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cblx0XHRcdHRoaXMubWluLmNvcHkoIGNlbnRlciApLnN1YiggaGFsZlNpemUgKTtcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxuXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXG5cdFx0dmFyIGJveDtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0aWYgKCBib3ggPT09IHVuZGVmaW5lZCApIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cblx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cblx0XHRcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG5cdFx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ym94LmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICk7XG5cdFx0XHRcdFx0Ym94LmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdHNjb3BlLnVuaW9uKCBib3ggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9IEluZmluaXR5O1xuXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XG5cblx0fSxcblxuXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuXHR9LFxuXG5cdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG5cdH0sXG5cblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG5cdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuXHRcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRcdCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuXHRcdFx0XHQgcG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogKSB7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG5cdFx0XHQgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSAmJlxuXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG5cdFx0XHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXG5cdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcblx0XHQpO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuXHRcdGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG5cdFx0XHRcdCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcblx0XHRcdFx0IGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBjbG9zZXN0UG9pbnQ7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0XHRpZiAoIGNsb3Nlc3RQb2ludCA9PT0gdW5kZWZpbmVkICkgY2xvc2VzdFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0Ly8gRmluZCB0aGUgcG9pbnQgb24gdGhlIEFBQkIgY2xvc2VzdCB0byB0aGUgc3BoZXJlIGNlbnRlci5cblx0XHRcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7XG5cblx0XHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuXHRcdFx0cmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcblxuXHRcdH07XG5cblx0fSApKCksXG5cblx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0Ly8gV2UgY29tcHV0ZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBkb3QgcHJvZHVjdCB2YWx1ZXMuIElmIHRob3NlIHZhbHVlc1xuXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG5cdFx0dmFyIG1pbiwgbWF4O1xuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcblx0XHRcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcblxuXHRcdH1cblxuXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG5cdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXHRcdFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XG5cblx0XHRcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcblx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gKCBtaW4gPD0gcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IHBsYW5lLmNvbnN0YW50ICk7XG5cblx0fSxcblxuXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdFx0XHRyZXN1bHQuY2VudGVyID0gdGhpcy5jZW50ZXIoKTtcblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XG5cdFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuXHRcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjMoKVxuXHRcdF07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHRcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG5cdFx0XHRwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcblx0XHRcdHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxuXHRcdFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG5cdFx0XHRwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcblx0XHRcdHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxuXHRcdFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG5cdFx0XHRwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcblx0XHRcdHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHQvLyAxMTFcblxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcblx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5USFJFRS5NYXRyaXgzID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cblx0XHQxLCAwLCAwLFxuXHRcdDAsIDEsIDAsXG5cdFx0MCwgMCwgMVxuXG5cdF0gKTtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTWF0cml4My5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNyBdID0gbjIzO1xuXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA1IF0gPSBuMzI7IHRlWyA4IF0gPSBuMzM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgMCxcblx0XHRcdDAsIDEsIDAsXG5cdFx0XHQwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sXG5cdFx0XHRtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLFxuXHRcdFx0bWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cblx0XHRcdFx0djEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRcdHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcblx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cblx0XHRcdFx0YnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuXHRcdFx0ZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcblx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG5cdH0sXG5cblx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xuXG5cdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcblx0XHQvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcblxuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDAgXSA9ICAgbWVbIDEwIF0gKiBtZVsgNSBdIC0gbWVbIDYgXSAqIG1lWyA5IF07XG5cdFx0dGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XG5cdFx0dGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcblx0XHR0ZVsgMyBdID0gLSBtZVsgMTAgXSAqIG1lWyA0IF0gKyBtZVsgNiBdICogbWVbIDggXTtcblx0XHR0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcblx0XHR0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xuXHRcdHRlWyA2IF0gPSAgIG1lWyA5IF0gKiBtZVsgNCBdIC0gbWVbIDUgXSAqIG1lWyA4IF07XG5cdFx0dGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcblx0XHR0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xuXG5cdFx0dmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcblxuXHRcdC8vIG5vIGludmVyc2VcblxuXHRcdGlmICggZGV0ID09PSAwICkge1xuXG5cdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG5cdFx0XHRpZiAoIHRocm93T25EZWdlbmVyYXRlIHx8IGZhbHNlICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xuXHRcdHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XG5cdFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0XG5cblx0XHR0aGlzLmdldEludmVyc2UoIG0gKS50cmFuc3Bvc2UoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyWyAwIF0gPSBtWyAwIF07XG5cdFx0clsgMSBdID0gbVsgMyBdO1xuXHRcdHJbIDIgXSA9IG1bIDYgXTtcblx0XHRyWyAzIF0gPSBtWyAxIF07XG5cdFx0clsgNCBdID0gbVsgNCBdO1xuXHRcdHJbIDUgXSA9IG1bIDcgXTtcblx0XHRyWyA2IF0gPSBtWyAyIF07XG5cdFx0clsgNyBdID0gbVsgNSBdO1xuXHRcdHJbIDggXSA9IG1bIDggXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSxcblx0XHRcdHRlWyAzIF0sIHRlWyA0IF0sIHRlWyA1IF0sXG5cdFx0XHR0ZVsgNiBdLCB0ZVsgNyBdLCB0ZVsgOCBdXG5cdFx0XTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTWF0cml4NC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuTWF0cml4NCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG5cdFx0MSwgMCwgMCwgMCxcblx0XHQwLCAxLCAwLCAwLFxuXHRcdDAsIDAsIDEsIDAsXG5cdFx0MCwgMCwgMCwgMVxuXG5cdF0gKTtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTWF0cml4NC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXG5cblx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcblx0XHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcblx0XHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XG5cdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIDAsXG5cdFx0XHQwLCAxLCAwLCAwLFxuXHRcdFx0MCwgMCwgMSwgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLk1hdHJpeDQoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuXHRcdHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSBtZVsgMTIgXTtcblx0XHR0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHhBeGlzLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xuXHRcdHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xuXHRcdHpBeGlzLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZUJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cblx0XHR0aGlzLnNldChcblx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG5cdFx0XHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuXHRcdFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcblx0XHRcdDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHRcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0KCBtZVsgMCBdLCBtZVsgMSBdLCBtZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xuXHRcdFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cblx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuXHRcdFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG5cdFx0XHR0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG5cdFx0XHR0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcblx0XHRcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG5cdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcblx0XHRcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuXHRcdFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcblx0XHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG5cdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gYyAqIGY7XG5cdFx0XHR0ZVsgOCBdID0gZDtcblxuXHRcdFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuXHRcdFx0dGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cblx0XHRcdHRlWyAyIF0gPSBiZiAtIGFlICogZDtcblx0XHRcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG5cdFx0XHR0ZVsgOCBdID0gYSAqIGQ7XG5cblx0XHRcdHRlWyAxIF0gPSBhICogZjtcblx0XHRcdHRlWyA1IF0gPSBhICogZTtcblx0XHRcdHRlWyA5IF0gPSAtIGI7XG5cblx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcblx0XHRcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcblx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG5cdFx0XHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG5cdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcblx0XHRcdHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuXHRcdFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBhICogZDtcblx0XHRcdHRlWyA2IF0gPSBiO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcblx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuXHRcdFx0dGVbIDEgXSA9IGMgKiBmO1xuXHRcdFx0dGVbIDUgXSA9IGJmICogZCArIGFlO1xuXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG5cdFx0XHR0ZVsgMiBdID0gLSBkO1xuXHRcdFx0dGVbIDYgXSA9IGIgKiBjO1xuXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cblx0XHRcdHRlWyAwIF0gPSBjICogZTtcblx0XHRcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcblx0XHRcdHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuXHRcdFx0dGVbIDEgXSA9IGY7XG5cdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG5cdFx0XHR0ZVsgOSBdID0gLSBiICogZTtcblxuXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG5cdFx0XHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG5cdFx0XHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG5cdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuXHRcdFx0dGVbIDAgXSA9IGMgKiBlO1xuXHRcdFx0dGVbIDQgXSA9IC0gZjtcblx0XHRcdHRlWyA4IF0gPSBkICogZTtcblxuXHRcdFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xuXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuXHRcdFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG5cdFx0XHR0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG5cdFx0XHR0ZVsgNiBdID0gYiAqIGU7XG5cdFx0XHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbGFzdCBjb2x1bW5cblx0XHR0ZVsgMyBdID0gMDtcblx0XHR0ZVsgNyBdID0gMDtcblx0XHR0ZVsgMTEgXSA9IDA7XG5cblx0XHQvLyBib3R0b20gcm93XG5cdFx0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMTQgXSA9IDA7XG5cdFx0dGVbIDE1IF0gPSAxO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xuXHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xuXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuXHRcdHZhciB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyO1xuXHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xuXG5cdFx0dGVbIDAgXSA9IDEgLSAoIHl5ICsgenogKTtcblx0XHR0ZVsgNCBdID0geHkgLSB3ejtcblx0XHR0ZVsgOCBdID0geHogKyB3eTtcblxuXHRcdHRlWyAxIF0gPSB4eSArIHd6O1xuXHRcdHRlWyA1IF0gPSAxIC0gKCB4eCArIHp6ICk7XG5cdFx0dGVbIDkgXSA9IHl6IC0gd3g7XG5cblx0XHR0ZVsgMiBdID0geHogLSB3eTtcblx0XHR0ZVsgNiBdID0geXogKyB3eDtcblx0XHR0ZVsgMTAgXSA9IDEgLSAoIHh4ICsgeXkgKTtcblxuXHRcdC8vIGxhc3QgY29sdW1uXG5cdFx0dGVbIDMgXSA9IDA7XG5cdFx0dGVbIDcgXSA9IDA7XG5cdFx0dGVbIDExIF0gPSAwO1xuXG5cdFx0Ly8gYm90dG9tIHJvd1xuXHRcdHRlWyAxMiBdID0gMDtcblx0XHR0ZVsgMTMgXSA9IDA7XG5cdFx0dGVbIDE0IF0gPSAwO1xuXHRcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgeCwgeSwgejtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcblxuXHRcdFx0aWYgKCB4ID09PSB1bmRlZmluZWQgKSB4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdGlmICggeSA9PT0gdW5kZWZpbmVkICkgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRpZiAoIHogPT09IHVuZGVmaW5lZCApIHogPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGlmICggei5sZW5ndGhTcSgpID09PSAwICkge1xuXG5cdFx0XHRcdHoueiA9IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xuXG5cdFx0XHRcdHoueCArPSAwLjAwMDE7XG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHkuY3Jvc3NWZWN0b3JzKCB6LCB4ICk7XG5cblxuXHRcdFx0dGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcblx0XHRcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XG5cdFx0XHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xuXG5cdFx0aWYgKCBuICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcblxuXHR9LFxuXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuXHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuXHRcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNSBdLCBhMjMgPSBhZVsgOSBdLCBhMjQgPSBhZVsgMTMgXTtcblx0XHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDYgXSwgYTMzID0gYWVbIDEwIF0sIGEzNCA9IGFlWyAxNCBdO1xuXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cblx0XHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XG5cdFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xuXHRcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG5cdFx0dmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcblxuXHRcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XG5cdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0Mjtcblx0XHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xuXHRcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xuXG5cdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcblx0XHR0ZVsgNSBdID0gYTIxICogYjEyICsgYTIyICogYjIyICsgYTIzICogYjMyICsgYTI0ICogYjQyO1xuXHRcdHRlWyA5IF0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XG5cdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cblx0XHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xuXHRcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XG5cdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG5cdFx0dGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XG5cblx0XHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xuXHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG5cdFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XG5cdFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCBhLCBiLCByICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRoaXMubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApO1xuXG5cdFx0clsgMCBdID0gdGVbIDAgXTsgclsgMSBdID0gdGVbIDEgXTsgclsgMiBdID0gdGVbIDIgXTsgclsgMyBdID0gdGVbIDMgXTtcblx0XHRyWyA0IF0gPSB0ZVsgNCBdOyByWyA1IF0gPSB0ZVsgNSBdOyByWyA2IF0gPSB0ZVsgNiBdOyByWyA3IF0gPSB0ZVsgNyBdO1xuXHRcdHJbIDggXSAgPSB0ZVsgOCBdOyByWyA5IF0gID0gdGVbIDkgXTsgclsgMTAgXSA9IHRlWyAxMCBdOyByWyAxMSBdID0gdGVbIDExIF07XG5cdFx0clsgMTIgXSA9IHRlWyAxMiBdOyByWyAxMyBdID0gdGVbIDEzIF07IHJbIDE0IF0gPSB0ZVsgMTQgXTsgclsgMTUgXSA9IHRlWyAxNSBdO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XG5cdFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcblx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcblx0XHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cblx0XHRcdFx0djEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblx0XHRcdFx0djEudG9BcnJheSggYXJyYXksIGogKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdjE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG5cdFx0XHRcdHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcblx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cblx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cblx0XHRcdFx0YnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidWZmZXI7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuXHRcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcblx0XHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XG5cdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcblx0XHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xuXG5cdFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcblx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuXHRcdHJldHVybiAoXG5cdFx0XHRuNDEgKiAoXG5cdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG5cdFx0XHRcdCAtIG4xMyAqIG4yNCAqIG4zMlxuXHRcdFx0XHQgLSBuMTQgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG5cdFx0XHRcdCArIG4xMyAqIG4yMiAqIG4zNFxuXHRcdFx0XHQgLSBuMTIgKiBuMjMgKiBuMzRcblx0XHRcdCkgK1xuXHRcdFx0bjQyICogKFxuXHRcdFx0XHQrIG4xMSAqIG4yMyAqIG4zNFxuXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcblx0XHRcdFx0ICsgbjE0ICogbjIxICogbjMzXG5cdFx0XHRcdCAtIG4xMyAqIG4yMSAqIG4zNFxuXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcblx0XHRcdFx0IC0gbjE0ICogbjIzICogbjMxXG5cdFx0XHQpICtcblx0XHRcdG40MyAqIChcblx0XHRcdFx0KyBuMTEgKiBuMjQgKiBuMzJcblx0XHRcdFx0IC0gbjExICogbjIyICogbjM0XG5cdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuXHRcdFx0XHQgKyBuMTIgKiBuMjEgKiBuMzRcblx0XHRcdFx0ICsgbjE0ICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuXHRcdFx0KSArXG5cdFx0XHRuNDQgKiAoXG5cdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG5cdFx0XHRcdCAtIG4xMSAqIG4yMyAqIG4zMlxuXHRcdFx0XHQgKyBuMTEgKiBuMjIgKiBuMzNcblx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG5cdFx0XHRcdCAtIG4xMiAqIG4yMSAqIG4zM1xuXHRcdFx0XHQgKyBuMTIgKiBuMjMgKiBuMzFcblx0XHRcdClcblxuXHRcdCk7XG5cblx0fSxcblxuXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHRtcDtcblxuXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xuXG5cdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcblx0XHR0bXAgPSB0ZVsgNyBdOyB0ZVsgNyBdID0gdGVbIDEzIF07IHRlWyAxMyBdID0gdG1wO1xuXHRcdHRtcCA9IHRlWyAxMSBdOyB0ZVsgMTEgXSA9IHRlWyAxNCBdOyB0ZVsgMTQgXSA9IHRtcDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG5cdFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cblx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDkgXSAgPSB0ZVsgOSBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuXHRcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG5cdFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcblx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuXHRcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cblx0XHRyZXR1cm4gYXJyYXk7XG5cblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblx0XHRcdHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dGVbIDEyIF0gPSB2Lng7XG5cdFx0dGVbIDEzIF0gPSB2Lnk7XG5cdFx0dGVbIDE0IF0gPSB2Lno7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cblx0XHR2YXIgbjExID0gbWVbIDAgXSwgbjEyID0gbWVbIDQgXSwgbjEzID0gbWVbIDggXSwgbjE0ID0gbWVbIDEyIF07XG5cdFx0dmFyIG4yMSA9IG1lWyAxIF0sIG4yMiA9IG1lWyA1IF0sIG4yMyA9IG1lWyA5IF0sIG4yNCA9IG1lWyAxMyBdO1xuXHRcdHZhciBuMzEgPSBtZVsgMiBdLCBuMzIgPSBtZVsgNiBdLCBuMzMgPSBtZVsgMTAgXSwgbjM0ID0gbWVbIDE0IF07XG5cdFx0dmFyIG40MSA9IG1lWyAzIF0sIG40MiA9IG1lWyA3IF0sIG40MyA9IG1lWyAxMSBdLCBuNDQgPSBtZVsgMTUgXTtcblxuXHRcdHRlWyAwIF0gPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQ7XG5cdFx0dGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcblx0XHR0ZVsgOCBdID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0O1xuXHRcdHRlWyAxMiBdID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuXHRcdHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XG5cdFx0dGVbIDUgXSA9IG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NDtcblx0XHR0ZVsgOSBdID0gbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0O1xuXHRcdHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xuXHRcdHRlWyAyIF0gPSBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQ7XG5cdFx0dGVbIDYgXSA9IG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NDtcblx0XHR0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcblx0XHR0ZVsgMTQgXSA9IG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNDtcblx0XHR0ZVsgMyBdID0gbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzO1xuXHRcdHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XG5cdFx0dGVbIDExIF0gPSBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDM7XG5cdFx0dGVbIDE1IF0gPSBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzM7XG5cblx0XHR2YXIgZGV0ID0gbjExICogdGVbIDAgXSArIG4yMSAqIHRlWyA0IF0gKyBuMzEgKiB0ZVsgOCBdICsgbjQxICogdGVbIDEyIF07XG5cblx0XHRpZiAoIGRldCA9PT0gMCApIHtcblxuXHRcdFx0dmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuXHRcdFx0aWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5pZGVudGl0eSgpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH1cblxuXHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBkZXQgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XG5cblx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xuXHRcdHRlWyAxIF0gKj0geDsgdGVbIDUgXSAqPSB5OyB0ZVsgOSBdICo9IHo7XG5cdFx0dGVbIDIgXSAqPSB4OyB0ZVsgNiBdICo9IHk7IHRlWyAxMCBdICo9IHo7XG5cdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0dmFyIHNjYWxlWFNxID0gdGVbIDAgXSAqIHRlWyAwIF0gKyB0ZVsgMSBdICogdGVbIDEgXSArIHRlWyAyIF0gKiB0ZVsgMiBdO1xuXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcblx0XHR2YXIgc2NhbGVaU3EgPSB0ZVsgOCBdICogdGVbIDggXSArIHRlWyA5IF0gKiB0ZVsgOSBdICsgdGVbIDEwIF0gKiB0ZVsgMTAgXTtcblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcblxuXHR9LFxuXG5cdG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdDEsIDAsIDAsIHgsXG5cdFx0XHQwLCAxLCAwLCB5LFxuXHRcdFx0MCwgMCwgMSwgeixcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cblx0XHR0aGlzLnNldChcblxuXHRcdFx0MSwgMCwgIDAsIDAsXG5cdFx0XHQwLCBjLCAtIHMsIDAsXG5cdFx0XHQwLCBzLCAgYywgMCxcblx0XHRcdDAsIDAsICAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdCBjLCAwLCBzLCAwLFxuXHRcdFx0IDAsIDEsIDAsIDAsXG5cdFx0XHQtIHMsIDAsIGMsIDAsXG5cdFx0XHQgMCwgMCwgMCwgMVxuXG5cdFx0KTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHRjLCAtIHMsIDAsIDAsXG5cdFx0XHRzLCAgYywgMCwgMCxcblx0XHRcdDAsICAwLCAxLCAwLFxuXHRcdFx0MCwgIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cblx0XHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcblxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblx0XHR2YXIgdCA9IDEgLSBjO1xuXHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuXHRcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xuXG5cdFx0dGhpcy5zZXQoXG5cblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcblx0XHRcdHR4ICogeSArIHMgKiB6LCB0eSAqIHkgKyBjLCB0eSAqIHogLSBzICogeCwgMCxcblx0XHRcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcblx0XHRcdDAsIDAsIDAsIDFcblxuXHRcdCk7XG5cblx0XHQgcmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuXHRcdHRoaXMuc2V0KFxuXG5cdFx0XHR4LCAwLCAwLCAwLFxuXHRcdFx0MCwgeSwgMCwgMCxcblx0XHRcdDAsIDAsIHosIDAsXG5cdFx0XHQwLCAwLCAwLCAxXG5cblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuXHRcdHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblx0XHR0aGlzLnNjYWxlKCBzY2FsZSApO1xuXHRcdHRoaXMuc2V0UG9zaXRpb24oIHBvc2l0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHZlY3RvciwgbWF0cml4O1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG5cdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG5cdFx0XHR2YXIgc3ggPSB2ZWN0b3Iuc2V0KCB0ZVsgMCBdLCB0ZVsgMSBdLCB0ZVsgMiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XG5cdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG5cdFx0XHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxuXHRcdFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcblx0XHRcdGlmICggZGV0IDwgMCApIHtcblxuXHRcdFx0XHRzeCA9IC0gc3g7XG5cblx0XHRcdH1cblxuXHRcdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuXHRcdFx0cG9zaXRpb24ueSA9IHRlWyAxMyBdO1xuXHRcdFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xuXG5cdFx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG5cdFx0XHRtYXRyaXguZWxlbWVudHMuc2V0KCB0aGlzLmVsZW1lbnRzICk7IC8vIGF0IHRoaXMgcG9pbnQgbWF0cml4IGlzIGluY29tcGxldGUgc28gd2UgY2FuJ3QgdXNlIC5jb3B5KClcblxuXHRcdFx0dmFyIGludlNYID0gMSAvIHN4O1xuXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xuXHRcdFx0dmFyIGludlNaID0gMSAvIHN6O1xuXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyAyIF0gKj0gaW52U1g7XG5cblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcblxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA4IF0gKj0gaW52U1o7XG5cdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcblx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcblxuXHRcdFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRzY2FsZS54ID0gc3g7XG5cdFx0XHRzY2FsZS55ID0gc3k7XG5cdFx0XHRzY2FsZS56ID0gc3o7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XG5cblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXHRcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xuXHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG5cdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcblx0XHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xuXHRcdHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuXHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xuXG5cdFx0dGVbIDAgXSA9IHg7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSBhO1x0dGVbIDEyIF0gPSAwO1xuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjtcdHRlWyAxMyBdID0gMDtcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSBjO1x0dGVbIDE0IF0gPSBkO1xuXHRcdHRlWyAzIF0gPSAwO1x0dGVbIDcgXSA9IDA7XHR0ZVsgMTEgXSA9IC0gMTtcdHRlWyAxNSBdID0gMDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cblx0XHR2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcblx0XHR2YXIgeW1pbiA9IC0geW1heDtcblx0XHR2YXIgeG1pbiA9IHltaW4gKiBhc3BlY3Q7XG5cdFx0dmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xuXG5cdFx0cmV0dXJuIHRoaXMubWFrZUZydXN0dW0oIHhtaW4sIHhtYXgsIHltaW4sIHltYXgsIG5lYXIsIGZhciApO1xuXG5cdH0sXG5cblx0bWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIHcgPSByaWdodCAtIGxlZnQ7XG5cdFx0dmFyIGggPSB0b3AgLSBib3R0b207XG5cdFx0dmFyIHAgPSBmYXIgLSBuZWFyO1xuXG5cdFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApIC8gdztcblx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgLyBoO1xuXHRcdHZhciB6ID0gKCBmYXIgKyBuZWFyICkgLyBwO1xuXG5cdFx0dGVbIDAgXSA9IDIgLyB3O1x0dGVbIDQgXSA9IDA7XHR0ZVsgOCBdID0gMDtcdHRlWyAxMiBdID0gLSB4O1xuXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IDIgLyBoO1x0dGVbIDkgXSA9IDA7XHR0ZVsgMTMgXSA9IC0geTtcblx0XHR0ZVsgMiBdID0gMDtcdHRlWyA2IF0gPSAwO1x0dGVbIDEwIF0gPSAtIDIgLyBwO1x0dGVbIDE0IF0gPSAtIHo7XG5cdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gMDtcdHRlWyAxNSBdID0gMTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0dGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSwgdGVbIDMgXSxcblx0XHRcdHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0sIHRlWyA3IF0sXG5cdFx0XHR0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXG5cdFx0XHR0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdLCB0ZVsgMTUgXVxuXHRcdF07XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1JheS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdHRoaXMub3JpZ2luID0gKCBvcmlnaW4gIT09IHVuZGVmaW5lZCApID8gb3JpZ2luIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5SYXkucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5SYXksXG5cblx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcblxuXHRcdHRoaXMub3JpZ2luLmNvcHkoIHJheS5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0fSxcblxuXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXN1bHQuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICk7XG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMub3JpZ2luICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VTcVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gdjEuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMub3JpZ2luICkuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG5cdFx0XHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxuXG5cdFx0XHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXG5cdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuXHRcdFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcblx0XHRcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG5cdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcblx0XHRcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuXHRcdFx0c2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblx0XHRcdHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcblx0XHRcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG5cdFx0XHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcblx0XHRcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XG5cdFx0XHR2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblx0XHRcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuXHRcdFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XG5cdFx0XHR2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcblx0XHRcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuXHRcdFx0aWYgKCBkZXQgPiAwICkge1xuXG5cdFx0XHRcdC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuXHRcdFx0XHRzMCA9IGEwMSAqIGIxIC0gYjA7XG5cdFx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcblx0XHRcdFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG5cdFx0XHRcdGlmICggczAgPj0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggczEgPj0gLSBleHREZXQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggczEgPD0gZXh0RGV0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAwXG5cdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuXHRcdFx0XHRcdFx0XHR2YXIgaW52RGV0ID0gMSAvIGRldDtcblx0XHRcdFx0XHRcdFx0czAgKj0gaW52RGV0O1xuXHRcdFx0XHRcdFx0XHRzMSAqPSBpbnZEZXQ7XG5cdFx0XHRcdFx0XHRcdHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcblxuXHRcdFx0XHRcdFx0XHRzMSA9IHNlZ0V4dGVudDtcblx0XHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyByZWdpb24gNVxuXG5cdFx0XHRcdFx0XHRzMSA9IC0gc2VnRXh0ZW50O1xuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBzMSA8PSAtIGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDRcblxuXHRcdFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcblxuXHRcdFx0XHRcdFx0czAgPSAwO1xuXHRcdFx0XHRcdFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHJlZ2lvbiAyXG5cblx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG5cdFx0XHRcdFx0XHRzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuXHRcdFx0XHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG5cdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcblx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG5cdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3FyRGlzdDtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRcdHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XG5cblx0XHRcdHZhciB0Y2EgPSB2MS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cblx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcblxuXHRcdFx0dmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcblxuXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0dmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XG5cblx0XHRcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXG5cdFx0XHR2YXIgdDAgPSB0Y2EgLSB0aGM7XG5cblx0XHRcdC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcblx0XHRcdHZhciB0MSA9IHRjYSArIHRoYztcblxuXHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG5cdFx0XHRpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XG5cdFx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG5cdFx0XHQvLyBpbiBvcmRlciB0byBhbHdheXMgcmV0dXJuIGFuIGludGVyc2VjdCBwb2ludCB0aGF0IGlzIGluIGZyb250IG9mIHRoZSByYXkuXG5cdFx0XHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcblx0XHRcdHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH1cblxuXHR9KCksXG5cblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cblx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybiAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR9XG5cblx0XHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG5cdFx0Ly8gUmV0dXJuIGlmIHRoZSByYXkgbmV2ZXIgaW50ZXJzZWN0cyB0aGUgcGxhbmVcblxuXHRcdHJldHVybiB0ID49IDAgPyB0IDogIG51bGw7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xuXG5cdFx0aWYgKCB0ID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblxuXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuXHRcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcblxuXHRcdGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHRcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XG5cblx0XHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxuXHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxuXHRcdFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xuXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG5cdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cblx0XHRcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXHRcdFx0dG1heCA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0bWluID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblx0XHRcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbnZkaXJ5ID49IDAgKSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHR5bWluID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuXHRcdH1cblxuXHRcdGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cblx0XHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG5cdFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG5cdFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cblx0XHRpZiAoIGludmRpcnogPj0gMCApIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cblx0XHRpZiAoIHR6bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR6bWF4O1xuXG5cdFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxuXG5cdFx0aWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXMuYXQoIHRtaW4gPj0gMCA/IHRtaW4gOiB0bWF4LCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XG5cblx0XHR9O1xuXG5cdH0gKSgpLFxuXG5cdGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cblx0XHR2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cblx0XHRcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcblx0XHRcdGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG5cdFx0XHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcblx0XHRcdC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcblx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuXHRcdFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG5cdFx0XHQvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuXHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG5cdFx0XHR2YXIgc2lnbjtcblxuXHRcdFx0aWYgKCBEZE4gPiAwICkge1xuXG5cdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG5cdFx0XHRcdHNpZ24gPSAxO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG5cdFx0XHRcdHNpZ24gPSAtIDE7XG5cdFx0XHRcdERkTiA9IC0gRGROO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcblx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuXHRcdFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cblx0XHRcdGlmICggRGRReEUyIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xuXG5cdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBEZEUxeFEgPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG5cdFx0XHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuXHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuXHRcdFx0Ly8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuXHRcdFx0aWYgKCBRZE4gPCAwICkge1xuXG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG5cdFx0dGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuXHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcblx0XHR0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcblxuXHRcdHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BoZXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG5cdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuXG5cdFx0XHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ym94LnNldEZyb21Qb2ludHMoIHBvaW50cyApLmNlbnRlciggY2VudGVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuXHRcdHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuXHR9LFxuXG5cdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuXHRcdC8vIFdlIHVzZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHRvIGNvbXB1dGUgdGhlIHNpZ25lZCBkaXN0YW5jZSBmcm9tXG5cdFx0Ly8gdGhlIGNlbnRlciBvZiB0aGUgc3BoZXJlIHRvIHRoZSBwbGFuZS5cblx0XHQvL1xuXHRcdC8vIGRpc3RhbmNlID0gcSAqIG4gLSBkXG5cdFx0Ly9cblx0XHQvLyBJZiB0aGlzIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUsXG5cdFx0Ly8gdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMuY2VudGVyLmRvdCggcGxhbmUubm9ybWFsICkgLSBwbGFuZS5jb25zdGFudCApIDw9IHRoaXMucmFkaXVzO1xuXG5cdH0sXG5cblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXN1bHQuY29weSggcG9pbnQgKTtcblxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xuXG5cdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XG5cdFx0Ym94LmV4cGFuZEJ5U2NhbGFyKCB0aGlzLnJhZGl1cyApO1xuXG5cdFx0cmV0dXJuIGJveDtcblxuXHR9LFxuXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXHRcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9GcnVzdHVtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKi9cblxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuXHR0aGlzLnBsYW5lcyA9IFtcblxuXHRcdCggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuXHRcdCggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSxcblx0XHQoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXG5cdFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXG5cblx0XTtcblxufTtcblxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cblx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuXHRcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG5cdFx0cGxhbmVzWyAyIF0uY29weSggcDIgKTtcblx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuXHRcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG5cdFx0cGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggZnJ1c3R1bSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cdFx0dmFyIG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XG5cdFx0dmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XG5cdFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xuXHRcdHZhciBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XG5cblx0XHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcblx0XHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XG5cdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcblx0XHR2YXIgbmVnUmFkaXVzID0gLSBzcGhlcmUucmFkaXVzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHAxID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcblxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2IDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcblxuXHRcdFx0XHRwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xuXHRcdFx0XHRwMi54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1heC54IDogYm94Lm1pbi54O1xuXHRcdFx0XHRwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xuXHRcdFx0XHRwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuXHRcdFx0XHRwMS56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1pbi56IDogYm94Lm1heC56O1xuXHRcdFx0XHRwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xuXG5cdFx0XHRcdHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcblx0XHRcdFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xuXG5cdFx0XHRcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXG5cblx0XHRcdFx0aWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9QbGFuZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqL1xuXG5USFJFRS5QbGFuZSA9IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcblxufTtcblxuVEhSRUUuUGxhbmUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5QbGFuZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggbm9ybWFsLCBjb25zdGFudCApIHtcblxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuXHRcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XHQvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cblx0XHRcdC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cblx0XHRcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG5cdFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XG5cdFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXG5cdFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcblx0XHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xuXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmNvbnN0YW50ICo9IC0gMTtcblx0XHR0aGlzLm5vcm1hbC5uZWdhdGUoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cblx0fSxcblxuXHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcblxuXHR9LFxuXG5cdHByb2plY3RQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XG5cblx0fSxcblxuXHRvcnRob1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcblxuXHR9LFxuXG5cdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG5cdFx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG5cdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cblx0XHRcdFx0aWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cblx0XHRcdGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRpbnRlcnNlY3RzTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG5cdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cblx0XHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcblx0XHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xuXG5cdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cblx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH0sXG5cblx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcblxuXHRcdFx0Ly8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxuXHRcdFx0Ly8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblx0XHRcdHZhciBuZXdOb3JtYWwgPSB2MS5jb3B5KCB0aGlzLm5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICk7XG5cblx0XHRcdHZhciBuZXdDb3BsYW5hclBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MiApO1xuXHRcdFx0bmV3Q29wbGFuYXJQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBuZXdOb3JtYWwsIG5ld0NvcGxhbmFyUG9pbnQgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cblx0XHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRoID0ge1xuXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuXHRcdHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XG5cdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG5cdFx0dmFyIHJuZCA9IDAsIHI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XG5cblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnLSc7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XG5cblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnNCc7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG5cdFx0XHRcdFx0ciA9IHJuZCAmIDB4Zjtcblx0XHRcdFx0XHRybmQgPSBybmQgPj4gNDtcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xuXG5cdH0sXG5cblx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG5cdC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vZHVsb19vcGVyYXRpb25cblxuXHRldWNsaWRlYW5Nb2R1bG86IGZ1bmN0aW9uICggbiwgbSApIHtcblxuXHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cblx0fSxcblxuXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5cblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG5cdFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cblx0fSxcblxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG5cdH0sXG5cblx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cblx0XHRyZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG5cdH0sXG5cblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGgucmFuZG9tMTYoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgTWF0aC5yYW5kb20oKSBpbnN0ZWFkLicgKTtcblx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKTtcblxuXHR9LFxuXG5cdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcblxuXHRcdHJldHVybiBsb3cgKyBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICsgMSApICk7XG5cblx0fSxcblxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG5cdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XG5cblx0XHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xuXG5cdH0sXG5cblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxuXG5cdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcblxuXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG5cdH0sXG5cblx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBkZWdyZWVUb1JhZGlhbnNGYWN0b3IgPSBNYXRoLlBJIC8gMTgwO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcblxuXHRcdFx0cmV0dXJuIGRlZ3JlZXMgKiBkZWdyZWVUb1JhZGlhbnNGYWN0b3I7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyYWRUb0RlZzogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHJhZGlhblRvRGVncmVlc0ZhY3RvciA9IDE4MCAvIE1hdGguUEk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xuXG5cdFx0XHRyZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG5cdH0sXG5cblx0bmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG5cdH0sXG5cblx0bmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR2YWx1ZSAtLTtcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiAxO1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDI7XG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gNDtcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA4O1xuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE2O1xuXHRcdHZhbHVlICsrO1xuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9TcGxpbmUuanNcblxuLyoqXG4gKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcbiAqIGh0dHA6Ly9zb2xlLmdpdGh1Yi5jb20vdHdlZW4uanMvZXhhbXBsZXMvMDVfc3BsaW5lLmh0bWxcbiAqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcGxpbmUgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHR0aGlzLnBvaW50cyA9IHBvaW50cztcblxuXHR2YXIgYyA9IFtdLCB2MyA9IHsgeDogMCwgeTogMCwgejogMCB9LFxuXHRwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxuXHRwYSwgcGIsIHBjLCBwZDtcblxuXHR0aGlzLmluaXRGcm9tQXJyYXkgPSBmdW5jdGlvbiAoIGEgKSB7XG5cblx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMucG9pbnRzWyBpIF0gPSB7IHg6IGFbIGkgXVsgMCBdLCB5OiBhWyBpIF1bIDEgXSwgejogYVsgaSBdWyAyIF0gfTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcblx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuXHRcdGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMiA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDE7XG5cdFx0Y1sgMyBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMyA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XG5cblx0XHRwYSA9IHRoaXMucG9pbnRzWyBjWyAwIF0gXTtcblx0XHRwYiA9IHRoaXMucG9pbnRzWyBjWyAxIF0gXTtcblx0XHRwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcblx0XHRwZCA9IHRoaXMucG9pbnRzWyBjWyAzIF0gXTtcblxuXHRcdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xuXHRcdHczID0gd2VpZ2h0ICogdzI7XG5cblx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XG5cdFx0djMueSA9IGludGVycG9sYXRlKCBwYS55LCBwYi55LCBwYy55LCBwZC55LCB3ZWlnaHQsIHcyLCB3MyApO1xuXHRcdHYzLnogPSBpbnRlcnBvbGF0ZSggcGEueiwgcGIueiwgcGMueiwgcGQueiwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuXHRcdHJldHVybiB2MztcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGksIHAsIGwgPSB0aGlzLnBvaW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBbXTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XG5cdFx0XHRjb29yZHNbIGkgXSA9IFsgcC54LCBwLnksIHAueiBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvb3JkcztcblxuXHR9O1xuXG5cdC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xuXG5cdHRoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBuU3ViRGl2aXNpb25zICkge1xuXG5cdFx0dmFyIGksIGluZGV4LCBuU2FtcGxlcywgcG9zaXRpb24sXG5cdFx0XHRwb2ludCA9IDAsIGludFBvaW50ID0gMCwgb2xkSW50UG9pbnQgPSAwLFxuXHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0dG1wVmVjID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdGNodW5rTGVuZ3RocyA9IFtdLFxuXHRcdFx0dG90YWxMZW5ndGggPSAwO1xuXG5cdFx0Ly8gZmlyc3QgcG9pbnQgaGFzIDAgbGVuZ3RoXG5cblx0XHRjaHVua0xlbmd0aHNbIDAgXSA9IDA7XG5cblx0XHRpZiAoICEgblN1YkRpdmlzaW9ucyApIG5TdWJEaXZpc2lvbnMgPSAxMDA7XG5cblx0XHRuU2FtcGxlcyA9IHRoaXMucG9pbnRzLmxlbmd0aCAqIG5TdWJEaXZpc2lvbnM7XG5cblx0XHRvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IG5TYW1wbGVzOyBpICsrICkge1xuXG5cdFx0XHRpbmRleCA9IGkgLyBuU2FtcGxlcztcblxuXHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuXHRcdFx0dG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XG5cblx0XHRcdHRvdGFsTGVuZ3RoICs9IHRtcFZlYy5kaXN0YW5jZVRvKCBvbGRQb3NpdGlvbiApO1xuXG5cdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xuXG5cdFx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XG5cdFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cblx0XHRcdGlmICggaW50UG9pbnQgIT09IG9sZEludFBvaW50ICkge1xuXG5cdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xuXHRcdFx0XHRvbGRJbnRQb2ludCA9IGludFBvaW50O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBsYXN0IHBvaW50IGVuZHMgd2l0aCB0b3RhbCBsZW5ndGhcblxuXHRcdGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XG5cblx0XHRyZXR1cm4geyBjaHVua3M6IGNodW5rTGVuZ3RocywgdG90YWw6IHRvdGFsTGVuZ3RoIH07XG5cblx0fTtcblxuXHR0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xuXG5cdFx0dmFyIGksIGosXG5cdFx0XHRpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXG5cdFx0XHRyZWFsRGlzdGFuY2UsXG5cdFx0XHRzYW1wbGluZywgcG9zaXRpb24sXG5cdFx0XHRuZXdwb2ludHMgPSBbXSxcblx0XHRcdHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRzbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cblx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKS5jbG9uZSgpICk7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0Ly90bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgLSAxIF0gKTtcblx0XHRcdC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xuXG5cdFx0XHRyZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcblxuXHRcdFx0c2FtcGxpbmcgPSBNYXRoLmNlaWwoIHNhbXBsaW5nQ29lZiAqIHJlYWxEaXN0YW5jZSAvIHNsLnRvdGFsICk7XG5cblx0XHRcdGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXHRcdFx0aW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHRpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcblxuXHRcdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG5cdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5wb2ludHMgPSBuZXdwb2ludHM7XG5cblx0fTtcblxuXHQvLyBDYXRtdWxsLVJvbVxuXG5cdGZ1bmN0aW9uIGludGVycG9sYXRlKCBwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzICkge1xuXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG5cdFx0XHR2MSA9ICggcDMgLSBwMSApICogMC41O1xuXG5cdFx0cmV0dXJuICggMiAqICggcDEgLSBwMiApICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqICggcDEgLSBwMiApIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1RyaWFuZ2xlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHR0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcblx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XG5cdFx0cmVzdWx0LmNyb3NzKCB2MCApO1xuXG5cdFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG5cdFx0aWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XG5cblx0XHRcdHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XG5cblx0fTtcblxufSgpO1xuXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcblRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcblx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XG5cdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcblx0XHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XG5cdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcblx0XHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XG5cblx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuXHRcdGlmICggZGVub20gPT09IDAgKSB7XG5cblx0XHRcdC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xuXHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcblxuXHRcdH1cblxuXHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcblx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuXHRcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XG5cblx0XHQvLyBiYXJ5Y2VudHJpYyBjb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuXHR9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcblxuXHRcdHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG5cdFx0cmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xuXG5cdH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcblxuXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XG5cdFx0dGhpcy5iLmNvcHkoIGIgKTtcblx0XHR0aGlzLmMuY29weSggYyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cblx0XHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG5cdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuXHRcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xuXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG5cdFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0YXJlYTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcblx0XHRcdHYxLnN1YlZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICk7XG5cblx0XHRcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdG1pZHBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XG5cblx0fSxcblxuXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHRyZXR1cm4gVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlBsYW5lKCk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xuXG5cdH0sXG5cblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xuXG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9JbnRlcnBvbGFudC5qc1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3Mgb2YgaW50ZXJwb2xhbnRzIG92ZXIgcGFyYW1ldHJpYyBzYW1wbGVzLlxuICpcbiAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxuICogYWxvbmcgYSBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBkYXRhLlxuICpcbiAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxuICogYXBwbHkgc3BlY2lhbCBpbnRlcnByZXRhdGlvbnMgdG8gdGhlIGRhdGEuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXG4gKiB0aGUgYWN0dWFsIGludGVycG9sYXRpb24gdG8gZGVyaXZlZCBjbGFzc2VzLlxuICpcbiAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xuICogYW5kIE8obG9nIE4pIGZvciByYW5kb20gYWNjZXNzLCB3aGVyZSBOIGlzIHRoZSBudW1iZXIgb2YgcG9zaXRpb25zLlxuICpcbiAqIFJlZmVyZW5jZXM6XG4gKlxuICogXHRcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcbiAqXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuSW50ZXJwb2xhbnQgPSBmdW5jdGlvbihcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdHRoaXMucGFyYW1ldGVyUG9zaXRpb25zID0gcGFyYW1ldGVyUG9zaXRpb25zO1xuXHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cblx0dGhpcy5yZXN1bHRCdWZmZXIgPSByZXN1bHRCdWZmZXIgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRyZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKCBzYW1wbGVTaXplICk7XG5cdHRoaXMuc2FtcGxlVmFsdWVzID0gc2FtcGxlVmFsdWVzO1xuXHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XG5cbn07XG5cblRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXBvbGFudCxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24oIHQgKSB7XG5cblx0XHR2YXIgcHAgPSB0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyxcblx0XHRcdGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXG5cblx0XHRcdHQxID0gcHBbICAgaTEgICBdLFxuXHRcdFx0dDAgPSBwcFsgaTEgLSAxIF07XG5cblx0XHR2YWxpZGF0ZV9pbnRlcnZhbDoge1xuXG5cdFx0XHRzZWVrOiB7XG5cblx0XHRcdFx0dmFyIHJpZ2h0O1xuXG5cdFx0XHRcdGxpbmVhcl9zY2FuOiB7XG4vLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcbi8vLSBzbG93ZXIgY29kZTpcbi8vLVxuLy8tIFx0XHRcdFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Zm9yd2FyZF9zY2FuOiBpZiAoICEgKCB0IDwgdDEgKSApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgKyAyOyA7KSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDAgKSBicmVhayBmb3J3YXJkX3NjYW47XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciBlbmRcblxuXHRcdFx0XHRcdFx0XHRcdGkxID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxuXG5cdFx0XHRcdFx0XHRcdHQwID0gdDE7XG5cdFx0XHRcdFx0XHRcdHQxID0gcHBbICsrIGkxIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0IDwgdDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgaW5kZXhcblx0XHRcdFx0XHRcdHJpZ2h0ID0gcHAubGVuZ3RoO1xuXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cblx0XHRcdFx0XHR9XG5cbi8vLSBzbG93ZXIgY29kZTpcbi8vLVx0XHRcdFx0XHRpZiAoIHQgPCB0MCB8fCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGlmICggISAoIHQgPj0gdDAgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gbG9vcGluZz9cblxuXHRcdFx0XHRcdFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0IDwgdDFnbG9iYWwgKSB7XG5cblx0XHRcdFx0XHRcdFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xuXHRcdFx0XHRcdFx0XHR0MCA9IHQxZ2xvYmFsO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cblxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgLSAyOyA7KSB7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYmVmb3JlIHN0YXJ0XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuXHRcdFx0XHRcdFx0XHR0MSA9IHQwO1xuXHRcdFx0XHRcdFx0XHR0MCA9IHBwWyAtLSBpMSAtIDEgXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHQgPj0gdDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrIHNlZWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmRleFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBpMTtcblx0XHRcdFx0XHRcdGkxID0gMDtcblx0XHRcdFx0XHRcdGJyZWFrIGxpbmVhcl9zY2FuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdGhlIGludGVydmFsIGlzIHZhbGlkXG5cblx0XHRcdFx0XHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcblxuXHRcdFx0XHR9IC8vIGxpbmVhciBzY2FuXG5cblx0XHRcdFx0Ly8gYmluYXJ5IHNlYXJjaFxuXG5cdFx0XHRcdHdoaWxlICggaTEgPCByaWdodCApIHtcblxuXHRcdFx0XHRcdHZhciBtaWQgPSAoIGkxICsgcmlnaHQgKSA+Pj4gMTtcblxuXHRcdFx0XHRcdGlmICggdCA8IHBwWyBtaWQgXSApIHtcblxuXHRcdFx0XHRcdFx0cmlnaHQgPSBtaWQ7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpMSA9IG1pZCArIDE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHQxID0gcHBbICAgaTEgICBdO1xuXHRcdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuXHRcdFx0XHQvLyBjaGVjayBib3VuZGFyeSBjYXNlcywgYWdhaW5cblxuXHRcdFx0XHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHQxID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcblx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRW5kXyggaTEgLSAxLCB0MCwgdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSAvLyBzZWVrXG5cblx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XG5cblx0XHRcdHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApO1xuXG5cdFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxuXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJwb2xhdGVfKCBpMSwgdDAsIHQsIHQxICk7XG5cblx0fSxcblxuXHRzZXR0aW5nczogbnVsbCwgLy8gb3B0aW9uYWwsIHN1YmNsYXNzLXNwZWNpZmljIHNldHRpbmdzIHN0cnVjdHVyZVxuXHQvLyBOb3RlOiBUaGUgaW5kaXJlY3Rpb24gYWxsb3dzIGNlbnRyYWwgY29udHJvbCBvZiBtYW55IGludGVycG9sYW50cy5cblxuXHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxuXG5cdERlZmF1bHRTZXR0aW5nc186IHt9LFxuXG5cdGdldFNldHRpbmdzXzogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XG5cblx0fSxcblxuXHRjb3B5U2FtcGxlVmFsdWVfOiBmdW5jdGlvbiggaW5kZXggKSB7XG5cblx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG5cdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9LFxuXG5cdC8vIFRlbXBsYXRlIG1ldGhvZHMgZm9yIGRlcml2ZWQgY2xhc3NlczpcblxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbGwgdG8gYWJzdHJhY3QgbWV0aG9kXCIgKTtcblx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgc2hhbGwgcmV0dXJuIHRoaXMucmVzdWx0QnVmZmVyXG5cblx0fSxcblxuXHRpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiggaTEsIHQwLCB0MSApIHtcblxuXHRcdC8vIGVtcHR5XG5cblx0fVxuXG59O1xuXG5PYmplY3QuYXNzaWduKCBUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUsIHtcblxuXHRiZWZvcmVTdGFydF86IC8vKCAwLCB0LCB0MCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXG5cdFx0VEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXG5cblx0YWZ0ZXJFbmRfOiAvLyggTi0xLCB0Ti0xLCB0ICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcblx0XHRUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlX1xuXG59ICk7XG5cbi8vIEZpbGU6c3JjL21hdGgvaW50ZXJwb2xhbnRzL0N1YmljSW50ZXJwb2xhbnQuanNcblxuLyoqXG4gKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuICpcbiAqIEl0IHdhcyBkZXJpdmVkIGZyb20gYSBIZXJtaXRpYW4gY29uc3RydWN0aW9uIHNldHRpbmcgdGhlIGZpcnN0IGRlcml2YXRpdmVcbiAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcbiAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxuICpcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5USFJFRS5DdWJpY0ludGVycG9sYW50ID0gZnVuY3Rpb24oXG5cdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuXHRUSFJFRS5JbnRlcnBvbGFudC5jYWxsKFxuXHRcdFx0dGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG5cdHRoaXMuX3dlaWdodFByZXYgPSAtMDtcblx0dGhpcy5fb2Zmc2V0UHJldiA9IC0wO1xuXHR0aGlzLl93ZWlnaHROZXh0ID0gLTA7XG5cdHRoaXMuX29mZnNldE5leHQgPSAtMDtcblxufTtcblxuVEhSRUUuQ3ViaWNJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkN1YmljSW50ZXJwb2xhbnQsXG5cblx0RGVmYXVsdFNldHRpbmdzXzoge1xuXG5cdFx0ZW5kaW5nU3RhcnQ6IFx0VEhSRUUuWmVyb0N1cnZhdHVyZUVuZGluZyxcblx0XHRlbmRpbmdFbmQ6XHRcdFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmdcblxuXHR9LFxuXG5cdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xuXG5cdFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHRpUHJldiA9IGkxIC0gMixcblx0XHRcdGlOZXh0ID0gaTEgKyAxLFxuXG5cdFx0XHR0UHJldiA9IHBwWyBpUHJldiBdLFxuXHRcdFx0dE5leHQgPSBwcFsgaU5leHQgXTtcblxuXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLlplcm9TbG9wZUVuZGluZzpcblxuXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcblx0XHRcdFx0XHRpUHJldiA9IGkxO1xuXHRcdFx0XHRcdHRQcmV2ID0gMiAqIHQwIC0gdDE7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFRIUkVFLldyYXBBcm91bmRFbmRpbmc6XG5cblx0XHRcdFx0XHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcblx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XG5cdFx0XHRcdFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG5cdFx0XHRcdFx0Ly8gZicnKHQwKSA9IDAgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aVByZXYgPSBpMTtcblx0XHRcdFx0XHR0UHJldiA9IHQxO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nRW5kICkge1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuWmVyb1Nsb3BlRW5kaW5nOlxuXG5cdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuXHRcdFx0XHRcdGlOZXh0ID0gaTE7XG5cdFx0XHRcdFx0dE5leHQgPSAyICogdDEgLSB0MDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuV3JhcEFyb3VuZEVuZGluZzpcblxuXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuXHRcdFx0XHRcdGlOZXh0ID0gMTtcblx0XHRcdFx0XHR0TmV4dCA9IHQxICsgcHBbIDEgXSAtIHBwWyAwIF07XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cblx0XHRcdFx0XHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXG5cdFx0XHRcdFx0aU5leHQgPSBpMSAtIDE7XG5cdFx0XHRcdFx0dE5leHQgPSB0MDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG5cblx0XHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XG5cdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICggdE5leHQgLSB0MSApO1xuXHRcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcblx0XHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XG5cblx0fSxcblxuXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG5cdFx0XHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcblxuXHRcdFx0bzEgPSBpMSAqIHN0cmlkZSxcdFx0bzAgPSBvMSAtIHN0cmlkZSxcblx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldiwgXHRvTiA9IHRoaXMuX29mZnNldE5leHQsXG5cdFx0XHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXG5cblx0XHRcdHAgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXG5cdFx0XHRwcCA9IHAgKiBwLFxuXHRcdFx0cHBwID0gcHAgKiBwO1xuXG5cdFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcblxuXHRcdHZhciBzUCA9ICAgICAtIHdQICAgKiBwcHAgICArICAgICAgICAgMiAqIHdQICAgICogcHAgICAgLSAgICAgICAgICB3UCAgICogcDtcblx0XHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICAgKyAoLTEuNSAtIDIgKiB3UCApICAqIHBwICAgICsgKCAtMC41ICsgd1AgKSAqIHAgICAgICsgMTtcblx0XHR2YXIgczEgPSAoLTEgLSB3TiApICogcHBwICAgKyAoIDEuNSArICAgd04gICApICAqIHBwICAgICsgICAgMC41ICAgICAgICAqIHA7XG5cdFx0dmFyIHNOID0gICAgICAgd04gICAqIHBwcCAgIC0gICAgICAgICAgIHdOICAgICAgKiBwcDtcblxuXHRcdC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID1cblx0XHRcdFx0XHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xuXHRcdFx0XHRcdHMwICogdmFsdWVzWyBvMCArIGkgXSArXG5cdFx0XHRcdFx0czEgKiB2YWx1ZXNbIG8xICsgaSBdICtcblx0XHRcdFx0XHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxufSApO1xuXG4vLyBGaWxlOnNyYy9tYXRoL2ludGVycG9sYW50cy9EaXNjcmV0ZUludGVycG9sYW50LmpzXG5cbi8qKlxuICpcbiAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZWRpbmdcbiAqIHRoZSBwYXJhbWV0ZXIuXG4gKlxuICogQGF1dGhvciB0c2Nod1xuICovXG5cblRIUkVFLkRpc2NyZXRlSW50ZXJwb2xhbnQgPSBmdW5jdGlvbihcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFRIUkVFLkludGVycG9sYW50LmNhbGwoXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbn07XG5cblRIUkVFLkRpc2NyZXRlSW50ZXJwb2xhbnQucHJvdG90eXBlID1cblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5JbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5EaXNjcmV0ZUludGVycG9sYW50LFxuXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5jb3B5U2FtcGxlVmFsdWVfKCBpMSAtIDEgKTtcblxuXHR9XG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvbWF0aC9pbnRlcnBvbGFudHMvTGluZWFySW50ZXJwb2xhbnQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuTGluZWFySW50ZXJwb2xhbnQgPSBmdW5jdGlvbihcblx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG5cdFRIUkVFLkludGVycG9sYW50LmNhbGwoXG5cdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbn07XG5cblRIUkVFLkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTGluZWFySW50ZXJwb2xhbnQsXG5cblx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcblxuXHRcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcblx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cblx0XHRcdG9mZnNldDEgPSBpMSAqIHN0cmlkZSxcblx0XHRcdG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlLFxuXG5cdFx0XHR3ZWlnaHQxID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApLFxuXHRcdFx0d2VpZ2h0MCA9IDEgLSB3ZWlnaHQxO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHJlc3VsdFsgaSBdID1cblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcblx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB3ZWlnaHQxO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvbWF0aC9pbnRlcnBvbGFudHMvUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LmpzXG5cbi8qKlxuICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXG4gKlxuICogQGF1dGhvciB0c2Nod1xuICovXG5cblRIUkVFLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCA9IGZ1bmN0aW9uKFxuXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cblx0VEhSRUUuSW50ZXJwb2xhbnQuY2FsbChcblx0XHRcdHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XG5cdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxuXG5cdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvZmZzZXQgPSBpMSAqIHN0cmlkZSxcblxuXHRcdFx0YWxwaGEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICk7XG5cblx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XG5cblx0XHRcdFRIUkVFLlF1YXRlcm5pb24uc2xlcnBGbGF0KCByZXN1bHQsIDAsXG5cdFx0XHRcdFx0dmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvY29yZS9DbG9jay5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ2xvY2sgPSBmdW5jdGlvbiAoIGF1dG9TdGFydCApIHtcblxuXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XG5cblx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHR0aGlzLm9sZFRpbWUgPSAwO1xuXHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcblxuXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ2xvY2sucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DbG9jayxcblxuXHRzdGFydDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG5cdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZ2V0RWxhcHNlZFRpbWUoKTtcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuXHR9LFxuXG5cdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmdldERlbHRhKCk7XG5cdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRpZmYgPSAwO1xuXG5cdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcblxuXHRcdFx0dGhpcy5zdGFydCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cblx0XHRcdHZhciBuZXdUaW1lID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0ZGlmZiA9IDAuMDAxICogKCBuZXdUaW1lIC0gdGhpcy5vbGRUaW1lICk7XG5cdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xuXG5cdFx0XHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGlmZjtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRXZlbnREaXNwYXRjaGVyLmpzXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXG4gKi9cblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge307XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkV2ZW50RGlzcGF0Y2hlcixcblxuXHRhcHBseTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRvYmplY3QuYWRkRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRvYmplY3QuaGFzRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuaGFzRXZlbnRMaXN0ZW5lcjtcblx0XHRvYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCA9IFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudDtcblxuXHR9LFxuXG5cdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG5cblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRoYXNFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cblx0XHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9LFxuXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cblx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG5cdFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZiggbGlzdGVuZXIgKTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG5cdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcblxuXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRldmVudC50YXJnZXQgPSB0aGlzO1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHRcdHZhciBsZW5ndGggPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0gPSBsaXN0ZW5lckFycmF5WyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9MYXllcnMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxheWVycyA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLm1hc2sgPSAxO1xuXG59O1xuXG5USFJFRS5MYXllcnMucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MYXllcnMsXG5cblx0c2V0OiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgPSAxIDw8IGNoYW5uZWw7XG5cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWw7XG5cblx0fSxcblxuXHR0b2dnbGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcblxuXHRcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWw7XG5cblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cblx0XHR0aGlzLm1hc2sgJj0gfiAoIDEgPDwgY2hhbm5lbCApO1xuXG5cdH0sXG5cblx0dGVzdDogZnVuY3Rpb24gKCBsYXllcnMgKSB7XG5cblx0XHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9SYXljYXN0ZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xuICovXG5cbiggZnVuY3Rpb24gKCBUSFJFRSApIHtcblxuXHRUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cblx0XHR0aGlzLnJheSA9IG5ldyBUSFJFRS5SYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG5cdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuXHRcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcblx0XHR0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcblxuXHRcdHRoaXMucGFyYW1zID0ge1xuXHRcdFx0TWVzaDoge30sXG5cdFx0XHRMaW5lOiB7fSxcblx0XHRcdExPRDoge30sXG5cdFx0XHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXG5cdFx0XHRTcHJpdGU6IHt9XG5cdFx0fTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xuXHRcdFx0UG9pbnRDbG91ZDoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuUG9pbnRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gYXNjU29ydCggYSwgYiApIHtcblxuXHRcdHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gaW50ZXJzZWN0T2JqZWN0KCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0Ly9cblxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG5cdFx0Y29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuXHRcdGxpbmVQcmVjaXNpb246IDEsXG5cblx0XHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cblx0XHRcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cblx0XHRcdHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuXHRcdH0sXG5cblx0XHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG5cdFx0XHRpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG5cdFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblx0XHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdHZhciBpbnRlcnNlY3RzID0gW107XG5cblx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XG5cblx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG5cdFx0fSxcblxuXHRcdGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xuXG5cdFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyLmludGVyc2VjdE9iamVjdHM6IG9iamVjdHMgaXMgbm90IGFuIEFycmF5LicgKTtcblx0XHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0c1sgaSBdLCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcblxuXHRcdFx0cmV0dXJuIGludGVyc2VjdHM7XG5cblx0XHR9XG5cblx0fTtcblxufSggVEhSRUUgKSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL09iamVjdDNELmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG4gKi9cblxuVEhSRUUuT2JqZWN0M0QgPSBmdW5jdGlvbiAoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5PYmplY3QzRElkQ291bnQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XG5cblx0dGhpcy5wYXJlbnQgPSBudWxsO1xuXHR0aGlzLmNoaWxkcmVuID0gW107XG5cblx0dGhpcy51cCA9IFRIUkVFLk9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigpO1xuXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XG5cblx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuXHRcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG5cdFx0cm90YXRpb24uc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHVuZGVmaW5lZCwgZmFsc2UgKTtcblxuXHR9XG5cblx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcblx0cXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRwb3NpdGlvbjoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdHZhbHVlOiBwb3NpdGlvblxuXHRcdH0sXG5cdFx0cm90YXRpb246IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogcm90YXRpb25cblx0XHR9LFxuXHRcdHF1YXRlcm5pb246IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogcXVhdGVybmlvblxuXHRcdH0sXG5cdFx0c2NhbGU6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogc2NhbGVcblx0XHR9LFxuXHRcdG1vZGVsVmlld01hdHJpeDoge1xuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXg0KClcblx0XHR9LFxuXHRcdG5vcm1hbE1hdHJpeDoge1xuXHRcdFx0dmFsdWU6IG5ldyBUSFJFRS5NYXRyaXgzKClcblx0XHR9XG5cdH0gKTtcblxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cblx0dGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcblx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5sYXllcnMgPSBuZXcgVEhSRUUuTGF5ZXJzKCk7XG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cblx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG5cdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xuXG5cdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG5cdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xuXG5cdHRoaXMudXNlckRhdGEgPSB7fTtcblxufTtcblxuVEhSRUUuT2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblRIUkVFLk9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcblxuVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XG5cblx0XHR0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cblx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG5cdH0sXG5cblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG5cdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cblx0fSxcblxuXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2Vcblx0XHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0dmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG5cdFx0XHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgb2JqZWN0IGJ5IGRpc3RhbmNlIGFsb25nIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG5cdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBheGlzLCBkaXN0YW5jZSApIHtcblxuXHRcdFx0djEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cblx0XHRcdHRoaXMucG9zaXRpb24uYWRkKCB2MS5tdWx0aXBseVNjYWxhciggZGlzdGFuY2UgKSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuXHRcdFx0bTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cIiwgb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG5cdFx0XHRvYmplY3QucGFyZW50ID0gbnVsbDtcblxuXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuXHRcdFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuXHR9LFxuXG5cdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cblx0fSxcblxuXHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXG5cdFx0aWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcblx0XHRcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBvYmplY3Q7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fSxcblxuXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG5cdH0sXG5cblx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5FdWxlcigpO1xuXG5cdFx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Z2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcblxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRyYXZlcnNlVmlzaWJsZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdGNhbGxiYWNrKCB0aGlzICk7XG5cblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZVZpc2libGUoIGNhbGxiYWNrICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRjYWxsYmFjayggcGFyZW50ICk7XG5cblx0XHRcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH0sXG5cblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0XHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXBkYXRlIGNoaWxkcmVuXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkICk7XG5cblx0XHR2YXIgb3V0cHV0ID0ge307XG5cblx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuXHRcdC8vIG5vdCBwcm92aWRpbmcgaXQgaW1wbGllcyB0aGF0IHRoaXMgaXMgdGhlIHJvb3Qgb2JqZWN0XG5cdFx0Ly8gYmVpbmcgc2VyaWFsaXplZC5cblx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuXHRcdFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0Z2VvbWV0cmllczoge30sXG5cdFx0XHRcdG1hdGVyaWFsczoge30sXG5cdFx0XHRcdHRleHR1cmVzOiB7fSxcblx0XHRcdFx0aW1hZ2VzOiB7fVxuXHRcdFx0fTtcblxuXHRcdFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdPYmplY3QnLFxuXHRcdFx0XHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG5cdFx0dmFyIG9iamVjdCA9IHt9O1xuXG5cdFx0b2JqZWN0LnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0b2JqZWN0LnR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcblx0XHRpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBvYmplY3QudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xuXHRcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cblx0XHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggdGhpcy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdG9iamVjdC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWwudXVpZDtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290T2JqZWN0ICkge1xuXG5cdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuXHRcdFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuXHRcdFx0aWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG5cdFx0XHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcblx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cblx0XHR9XG5cblx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHRcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXG5cdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuXHRcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG5cdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG5cdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMudXAuY29weSggc291cmNlLnVwICk7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuXHRcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xuXHRcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XG5cblx0XHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHNvdXJjZS5yb3RhdGlvbkF1dG9VcGRhdGU7XG5cblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG5cdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG5cblx0XHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcblx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblxuXHRcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xuXHRcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XG5cblx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc291cmNlLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcblx0XHRcdFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblxuVEhSRUUuT2JqZWN0M0RJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY29yZS9GYWNlMy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZhY2UzID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdHRoaXMuYSA9IGE7XG5cdHRoaXMuYiA9IGI7XG5cdHRoaXMuYyA9IGM7XG5cblx0dGhpcy5ub3JtYWwgPSBub3JtYWwgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzID8gbm9ybWFsIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcblxuXHR0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XG5cdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XG5cblx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0dGhpcy5hID0gc291cmNlLmE7XG5cdFx0dGhpcy5iID0gc291cmNlLmI7XG5cdFx0dGhpcy5jID0gc291cmNlLmM7XG5cblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XG5cdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnZlcnRleE5vcm1hbHNbIGkgXSA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRmFjZTQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xuXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMuYXJyYXkgPSBhcnJheTtcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xuXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblxuXHR0aGlzLnZlcnNpb24gPSAwO1xuXG59O1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUsXG5cblx0Z2V0IGNvdW50KCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZTtcblxuXHR9LFxuXG5cdHNldCBuZWVkc1VwZGF0ZSggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xuXG5cdH0sXG5cblx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcblx0XHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xuXG5cdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG5cdFx0aW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG5cdFx0aW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG5cdFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XG5cblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XG5cdFx0XHRcdGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3Iucjtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoIGluZGljZXMgKSB7XG5cblx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XG5cblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmE7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG5cdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cblx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG5cdFx0XHRcdHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG5cdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcblx0XHRcdFx0dmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcblx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuXHR9LFxuXG5cdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuXHR9LFxuXG5cdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuXHR9LFxuXG5cdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cblx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblx0XHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufTtcblxuLy9cblxuVEhSRUUuSW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50OEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDhDbGFtcGVkQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuSW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQxNkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG5cdHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MzJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5GbG9hdDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuXG4vLyBEZXByZWNhdGVkXG5cblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xuXHRyZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcblxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlciA9IGZ1bmN0aW9uICggYXJyYXksIHN0cmlkZSApIHtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMuYXJyYXkgPSBhcnJheTtcblx0dGhpcy5zdHJpZGUgPSBzdHJpZGU7XG5cblx0dGhpcy5keW5hbWljID0gZmFsc2U7XG5cdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xuXG5cdHRoaXMudmVyc2lvbiA9IDA7XG5cbn07XG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIsXG5cblx0Z2V0IGxlbmd0aCAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cblx0fSxcblxuXHRnZXQgY291bnQgKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5zdHJpZGU7XG5cblx0fSxcblxuXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcblxuXHR9LFxuXG5cdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmFycmF5ID0gbmV3IHNvdXJjZS5hcnJheS5jb25zdHJ1Y3Rvciggc291cmNlLmFycmF5ICk7XG5cdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuXHRcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuXHRcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcblx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cblx0XHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdFRIUkVFLkludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcblxuXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XG5cblRIUkVFLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0VEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQgKSB7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLmRhdGEgPSBpbnRlcmxlYXZlZEJ1ZmZlcjtcblx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuXHR0aGlzLm9mZnNldCA9IG9mZnNldDtcblxufTtcblxuXG5USFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuXG5cdGdldCBsZW5ndGgoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAuY291bnQuJyApO1xuXHRcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcblxuXHR9LFxuXG5cdGdldCBjb3VudCgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XG5cblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF0gPSB5O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xuXG5cdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXSA9IHo7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF07XG5cblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XG5cblx0fSxcblxuXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XG5cblx0fSxcblxuXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF07XG5cblx0fSxcblxuXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcblx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG5cdFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICovXG5cblRIUkVFLkdlb21ldHJ5ID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuR2VvbWV0cnlJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG5cdHRoaXMudmVydGljZXMgPSBbXTtcblx0dGhpcy5jb2xvcnMgPSBbXTtcblx0dGhpcy5mYWNlcyA9IFtdO1xuXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG5cblx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XG5cdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0Ly8gdXBkYXRlIGZsYWdzXG5cblx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG5cdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuXHRcdFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHR9LFxuXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBzY2FsZSBnZW9tZXRyeVxuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG9iajtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuXHRcdFx0aWYgKCBvYmogPT09IHVuZGVmaW5lZCApIG9iaiA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdFx0XHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcblxuXHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRmcm9tQnVmZmVyR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdHZhciBjb2xvcnMgPSBhdHRyaWJ1dGVzLmNvbG9yICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLmNvbG9yLmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdHZhciB1dnMgPSBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2LmFycmF5IDogdW5kZWZpbmVkO1xuXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IFtdO1xuXG5cdFx0dmFyIHRlbXBOb3JtYWxzID0gW107XG5cdFx0dmFyIHRlbXBVVnMgPSBbXTtcblx0XHR2YXIgdGVtcFVWczIgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiApIHtcblxuXHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApICk7XG5cblx0XHRcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRlbXBOb3JtYWxzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRlbXBVVnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRlbXBVVnMyLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjICkge1xuXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzICk7XG5cblx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB0ZW1wVVZzWyBhIF0uY2xvbmUoKSwgdGVtcFVWc1sgYiBdLmNsb25lKCksIHRlbXBVVnNbIGMgXS5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAxIF0ucHVzaCggWyB0ZW1wVVZzMlsgYSBdLmNsb25lKCksIHRlbXBVVnMyWyBiIF0uY2xvbmUoKSwgdGVtcFVWczJbIGMgXS5jbG9uZSgpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cblx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG5cdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG5cdFx0dmFyIHMgPSByYWRpdXMgPT09IDAgPyAxIDogMS4wIC8gcmFkaXVzO1xuXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0bWF0cml4LnNldChcblx0XHRcdHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxuXHRcdFx0MCwgcywgMCwgLSBzICogY2VudGVyLnksXG5cdFx0XHQwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcblx0XHRcdDAsIDAsIDAsIDFcblx0XHQpO1xuXG5cdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHR2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcblx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cblx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG5cdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0Y2Iubm9ybWFsaXplKCk7XG5cblx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cblx0XHR2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcblxuXHRcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuXHRcdFx0dmVydGljZXNbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcblxuXHRcdFx0Ly8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcblx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuXHRcdFx0dmFyIHZBLCB2QiwgdkM7XG5cdFx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuXHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuXHRcdFx0XHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuXHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcblx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcblx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cblx0XHQvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcblx0XHQvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3Ncblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cblx0XHR2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cblx0XHRcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xuXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG5cdFx0XHR0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG5cdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHRcdFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuXHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuXHRcdFx0XHRmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG5cdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcblx0XHRcdFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG5cdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcblx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cblx0XHR9XG5cblx0fSxcblxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cblx0fSxcblxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGQgPSAwO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdGlmICggaSA+IDAgKSB7XG5cblx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBub3JtYWxNYXRyaXgsXG5cdFx0dmVydGV4T2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0dmVydGljZXMxID0gdGhpcy52ZXJ0aWNlcyxcblx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcblx0XHRmYWNlczEgPSB0aGlzLmZhY2VzLFxuXHRcdGZhY2VzMiA9IGdlb21ldHJ5LmZhY2VzLFxuXHRcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcblx0XHR1dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcblxuXHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuXHRcdH1cblxuXHRcdC8vIHZlcnRpY2VzXG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cblx0XHRcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XG5cblx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cblx0XHRcdHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyBmYWNlc1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcblx0XHRcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuXHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG5cdFx0XHRmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuXHRcdFx0ZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cblx0XHRcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuXHRcdFx0XHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cblx0XHRcdH1cblxuXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcblxuXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XG5cblx0XHR9XG5cblx0XHQvLyB1dnNcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XG5cblx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHV2czEucHVzaCggdXZDb3B5ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcblxuXHRcdGlmICggbWVzaCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guJywgbWVzaCApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0bWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XG5cblx0XHR0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xuXG5cdH0sXG5cblx0Lypcblx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxuXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXG5cdCAqIGFuZCBmYWNlcycgdmVydGljZXMgYXJlIHVwZGF0ZWQuXG5cdCAqL1xuXG5cdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZXJ0aWNlc01hcCA9IHt9OyAvLyBIYXNobWFwIGZvciBsb29raW5nIHVwIHZlcnRpY2VzIGJ5IHBvc2l0aW9uIGNvb3JkaW5hdGVzIChhbmQgbWFraW5nIHN1cmUgdGhleSBhcmUgdW5pcXVlKVxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xuXG5cdFx0dmFyIHYsIGtleTtcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG5cdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG5cdFx0dmFyIGksIGlsLCBmYWNlO1xuXHRcdHZhciBpbmRpY2VzLCBqLCBqbDtcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XG5cblx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcblx0XHRcdFx0dW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xuXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cblx0XHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXG5cdFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cblx0XHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuXHRcdFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XG5cdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcblx0XHRcdGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XG5cblx0XHRcdHZhciBkdXBJbmRleCA9IC0gMTtcblxuXHRcdFx0Ly8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xuXHRcdFx0Ly8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcblx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG5cblx0XHRcdFx0aWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcblxuXHRcdFx0XHRcdGR1cEluZGV4ID0gbjtcblx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcblxuXHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcblxuXHRcdFx0dGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuXHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xuXHRcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XG5cdFx0cmV0dXJuIGRpZmY7XG5cblx0fSxcblxuXHRzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG5cdFx0dmFyIGxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuXHRcdC8vIHRhZyBmYWNlc1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRmYWNlc1sgaSBdLl9pZCA9IGk7XG5cblx0XHR9XG5cblx0XHQvLyBzb3J0IGZhY2VzXG5cblx0XHRmdW5jdGlvbiBtYXRlcmlhbEluZGV4U29ydCggYSwgYiApIHtcblxuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcblxuXHRcdH1cblxuXHRcdGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XG5cblx0XHQvLyBzb3J0IHV2c1xuXG5cdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblx0XHR2YXIgdXZzMiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdO1xuXG5cdFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XG5cblx0XHRpZiAoIHV2czEgJiYgdXZzMS5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czEgPSBbXTtcblx0XHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGlkID0gZmFjZXNbIGkgXS5faWQ7XG5cblx0XHRcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xuXHRcdFx0aWYgKCBuZXdVdnMyICkgbmV3VXZzMi5wdXNoKCB1dnMyWyBpZCBdICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XG5cdFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xuXG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgZGF0YSA9IHtcblx0XHRcdG1ldGFkYXRhOiB7XG5cdFx0XHRcdHZlcnNpb246IDQuNCxcblx0XHRcdFx0dHlwZTogJ0dlb21ldHJ5Jyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cblx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG5cdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XG5cdFx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0XHR2YXIgZmFjZXMgPSBbXTtcblx0XHR2YXIgbm9ybWFscyA9IFtdO1xuXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xuXHRcdHZhciBjb2xvcnMgPSBbXTtcblx0XHR2YXIgY29sb3JzSGFzaCA9IHt9O1xuXHRcdHZhciB1dnMgPSBbXTtcblx0XHR2YXIgdXZzSGFzaCA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5mYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG5cdFx0XHR2YXIgaGFzTWF0ZXJpYWwgPSB0cnVlO1xuXHRcdFx0dmFyIGhhc0ZhY2VVdiA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XG5cdFx0XHR2YXIgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwO1xuXHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xuXHRcdFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XG5cblx0XHRcdHZhciBmYWNlVHlwZSA9IDA7XG5cblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApOyAvLyBpc1F1YWRcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcblx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG5cdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xuXG5cdFx0XHRmYWNlcy5wdXNoKCBmYWNlVHlwZSApO1xuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5tYXRlcmlhbEluZGV4ICk7XG5cblx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG5cdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKFxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDAgXSApLFxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxuXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDIgXSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goIGdldE5vcm1hbEluZGV4KCBmYWNlLm5vcm1hbCApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG5cdFx0XHRcdGZhY2VzLnB1c2goXG5cdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxuXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcblx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdFx0ZmFjZXMucHVzaChcblx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxuXHRcdFx0XHRcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXG5cdFx0XHRcdFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcblxuXHRcdFx0cmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uICkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XG5cblx0XHRcdHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xuXG5cdFx0XHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xuXHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cblx0XHRcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XG5cblx0XHRcdHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xuXG5cdFx0XHRpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0Y29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcblx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xuXG5cdFx0XHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XG5cblx0XHRcdHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xuXG5cdFx0XHRpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cblx0XHRcdH1cblxuXHRcdFx0dXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XG5cdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG5cdFx0XHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG5cdFx0fVxuXG5cdFx0ZGF0YS5kYXRhID0ge307XG5cblx0XHRkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcblx0XHRkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XG5cdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG5cdFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdFx0ZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvKlxuXHRcdC8vIEhhbmRsZSBwcmltaXRpdmVzXG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBPYmplY3QuY3JlYXRlKCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xuXHRcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXHRcdCovXG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLkdlb21ldHJ5KCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzID0gW107XG5cdFx0dGhpcy5mYWNlcyA9IFtdO1xuXHRcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFsgW10gXTtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IHNvdXJjZS52ZXJ0aWNlcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBzb3VyY2UuZmFjZVZlcnRleFV2c1sgaSBdO1xuXG5cdFx0XHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPSBbXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdXZzID0gZmFjZVZlcnRleFV2c1sgaiBdLCB1dnNDb3B5ID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcblxuXHRcdFx0XHRcdHZhciB1diA9IHV2c1sgayBdO1xuXG5cdFx0XHRcdFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0RpcmVjdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5EaXJlY3RHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLm5hbWUgPSAnJztcblx0dGhpcy50eXBlID0gJ0RpcmVjdEdlb21ldHJ5JztcblxuXHR0aGlzLmluZGljZXMgPSBbXTtcblx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xuXHR0aGlzLm5vcm1hbHMgPSBbXTtcblx0dGhpcy5jb2xvcnMgPSBbXTtcblx0dGhpcy51dnMgPSBbXTtcblx0dGhpcy51dnMyID0gW107XG5cblx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG5cdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xuXG5cdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuXHQvLyB1cGRhdGUgZmxhZ3NcblxuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXG5cblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cblx0fSxcblxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cblx0fSxcblxuXHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG5cdFx0dmFyIGdyb3VwO1xuXHRcdHZhciBncm91cHMgPSBbXTtcblx0XHR2YXIgbWF0ZXJpYWxJbmRleDtcblxuXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdC8vIG1hdGVyaWFsc1xuXG5cdFx0XHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XG5cdFx0XHRcdFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdyb3VwID0ge1xuXHRcdFx0XHRcdHN0YXJ0OiBpICogMyxcblx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcblx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ncm91cHMgPSBncm91cHM7XG5cblx0fSxcblxuXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XG5cblx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xuXHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xuXG5cdFx0Ly8gbW9ycGhzXG5cblx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuXHRcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG5cdFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xuXG5cdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGkgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XG5cblx0XHR9XG5cblx0XHR2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuXHRcdHZhciBtb3JwaE5vcm1hbHNMZW5ndGggPSBtb3JwaE5vcm1hbHMubGVuZ3RoO1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcblxuXHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcblxuXHRcdH1cblxuXHRcdC8vIHNraW5zXG5cblx0XHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcblx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuXHRcdHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXHRcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0Ly9cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cblx0XHRcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cblx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cblx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuXHRcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xuXG5cdFx0XHRcdFx0dGhpcy51dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG5cdFx0XHRcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XG5cblx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaHNcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaiBdLnZlcnRpY2VzO1xuXG5cdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cblx0XHRcdFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHNraW5zXG5cblx0XHRcdGlmICggaGFzU2tpbkluZGljZXMgKSB7XG5cblx0XHRcdFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcblxuXHRcdFx0XHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jb21wdXRlR3JvdXBzKCBnZW9tZXRyeSApO1xuXG5cdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG5cdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuXHRcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG5cdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcblx0XHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cblx0dGhpcy5pbmRleCA9IG51bGw7XG5cdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG5cdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XG5cblx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cblx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cblx0fSxcblxuXHRzZXRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblxuXHR9LFxuXG5cdGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgJiYgYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPT09IGZhbHNlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICkgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBuYW1lID09PSAnaW5kZXgnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuXHR9LFxuXG5cdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdH0sXG5cblx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XG5cblx0fSxcblxuXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGNvdW50OiBjb3VudCxcblx0XHRcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwXG5cblx0XHR9ICk7XG5cblx0fSxcblxuXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5ncm91cHMgPSBbXTtcblxuXHR9LFxuXG5cdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHN0YXJ0O1xuXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cblx0fSxcblxuXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBwb3NpdGlvbi5hcnJheSApO1xuXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XG5cblx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG5cdFx0XHRub3JtYWxNYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggbm9ybWFsLmFycmF5ICk7XG5cdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xuXG5cdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG5cdFx0dmFyIG0xO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG5cdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcblxuXHRcdHZhciBtMTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIHNjYWxlIGdlb21ldHJ5XG5cblx0XHR2YXIgbTE7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XG5cblx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgb2JqO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG5cdFx0XHRpZiAoIG9iaiA9PT0gdW5kZWZpbmVkICkgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xuXG5cdFx0XHRvYmoudXBkYXRlTWF0cml4KCk7XG5cblx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG9iai5tYXRyaXggKTtcblxuXHRcdH07XG5cblx0fSgpLFxuXG5cdGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG5cdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuXHRcdHJldHVybiBvZmZzZXQ7XG5cblx0fSxcblxuXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcblxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XG5cblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG5cdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0dGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0dXBkYXRlRnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xuXG5cdFx0XHRpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuXHRcdFx0ZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG5cdFx0XHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG5cdFx0XHRkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG5cdFx0XHRkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XG5cblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdFx0Z2VvbWV0cnkgPSBkaXJlY3Q7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG5cdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSApIHtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy51djtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xuXHRcdFx0XHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGF0dHJpYnV0ZS5jb3B5QXJyYXkoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgKTtcblx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xuXG5cdFx0XHRnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcblx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0XHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGZyb21HZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgVEhSRUUuRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cblx0XHRyZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcblxuXHR9LFxuXG5cdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKiAzICk7XG5cdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG5cblx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCAqIDMgKTtcblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdHZhciB1dnMyID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzMi5sZW5ndGggKiAyICk7XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0dmFyIFR5cGVBcnJheSA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcblx0XHRcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG5cdFx0XHR0aGlzLnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XG5cblx0XHR9XG5cblx0XHQvLyBncm91cHNcblxuXHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG5cdFx0Ly8gbW9ycGhzXG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcblxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbmV3IFRIUkVFLkZsb2F0MzJBdHRyaWJ1dGUoIG1vcnBoVGFyZ2V0Lmxlbmd0aCAqIDMsIDMgKTtcblxuXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XG5cblx0XHR9XG5cblx0XHQvLyBza2lubmluZ1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR2YXIgc2tpbldlaWdodHMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luV2VpZ2h0Jywgc2tpbldlaWdodHMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5XZWlnaHRzICkgKTtcblxuXHRcdH1cblxuXHRcdC8vXG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cblx0XHRcdGlmICggcG9zaXRpb25zICkge1xuXG5cdFx0XHRcdHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3g7XG5cdFx0XHRcdGJiLm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuXHRcdFx0XHRcdGJiLmV4cGFuZEJ5UG9pbnQoIHZlY3RvciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHBvc2l0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHBvc2l0aW9ucy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0dGhpcy5ib3VuZGluZ0JveC5taW4uc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWF4LnNldCggMCwgMCwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH0oKSxcblxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBib3ggPSBuZXcgVEhSRUUuQm94MygpO1xuXHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBwb3NpdGlvbnMgKSB7XG5cblx0XHRcdFx0Ym94Lm1ha2VFbXB0eSgpO1xuXG5cdFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHR2ZWN0b3IuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKTtcblx0XHRcdFx0XHRib3guZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJveC5jZW50ZXIoIGNlbnRlciApO1xuXG5cdFx0XHRcdC8vIGhvcGluZyB0byBmaW5kIGEgYm91bmRpbmdTcGhlcmUgd2l0aCBhIHJhZGl1cyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuXHRcdFx0XHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuXHRcdFx0XHRcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG5cdFx0XHRcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHR9KCksXG5cblx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG5cdH0sXG5cblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cdFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cblxuXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRhcnJheVsgaSBdID0gMDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsXG5cblx0XHRcdHBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdHBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0YWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0XHR0aGlzLmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG5cdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XG5cblx0XHRcdFx0XHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcblx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHZBID0gaW5kaWNlc1sgaSArIDAgXSAqIDM7XG5cdFx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xuXHRcdFx0XHRcdFx0dkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcblxuXHRcdFx0XHRcdFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XG5cdFx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcblx0XHRcdFx0XHRcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xuXG5cdFx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XG5cblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBIF0gKz0gY2IueDtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xuXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiBdICs9IGNiLng7XG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKyAyIF0gKz0gY2IuejtcblxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuXHRcdFx0XHRcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG5cdFx0XHRcdFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG5cdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cblx0XHRcdFx0XHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcblx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSA9IGNiLng7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNCBdID0gY2IueTtcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA2IF0gPSBjYi54O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuXHRcdFx0YXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXHRcdFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF07XG5cdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblxuXHRcdFx0dmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSArKywgaiArKyApIHtcblxuXHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG5vcm1hbGl6ZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuXHRcdHZhciB4LCB5LCB6LCBuO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcblx0XHRcdHkgPSBub3JtYWxzWyBpICsgMSBdO1xuXHRcdFx0eiA9IG5vcm1hbHNbIGkgKyAyIF07XG5cblx0XHRcdG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG5cdFx0XHRub3JtYWxzWyBpIF0gKj0gbjtcblx0XHRcdG5vcm1hbHNbIGkgKyAxIF0gKj0gbjtcblx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG5cdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cblx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG5cdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XG5cblx0XHRcdGRhdGEuZGF0YS5pbmRleCA9IHtcblx0XHRcdFx0dHlwZTogaW5kZXguYXJyYXkuY29uc3RydWN0b3IubmFtZSxcblx0XHRcdFx0YXJyYXk6IGFycmF5XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcblxuXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG5cdFx0XHRkYXRhLmRhdGEuYXR0cmlidXRlc1sga2V5IF0gPSB7XG5cdFx0XHRcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXG5cdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuXHRcdFx0XHRhcnJheTogYXJyYXlcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cblx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRkYXRhLmRhdGEuZ3JvdXBzID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIGdyb3VwcyApICk7XG5cblx0XHR9XG5cblx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG5cdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xuXHRcdFx0XHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXG5cdFx0XHRcdHJhZGl1czogYm91bmRpbmdTcGhlcmUucmFkaXVzXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Lypcblx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xuXG5cdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cblx0XHRcdFx0dmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcblx0XHRcdHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcblx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblx0XHQqL1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcblxuXHR9LFxuXG5cdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFx0dmFyIGluZGV4ID0gc291cmNlLmluZGV4O1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzb3VyY2UuYXR0cmlidXRlcztcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggbmFtZSwgYXR0cmlidXRlLmNsb25lKCkgKTtcblxuXHRcdH1cblxuXHRcdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5Lk1heEluZGV4ID0gNjU1MzU7XG5cbi8vIEZpbGU6c3JjL2NvcmUvSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5Jztcblx0dGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZEdyb3VwID0gZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluc3RhbmNlcyApIHtcblxuXHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cblx0XHRzdGFydDogc3RhcnQsXG5cdFx0Y291bnQ6IGNvdW50LFxuXHRcdGluc3RhbmNlczogaW5zdGFuY2VzXG5cblx0fSApO1xuXG59O1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG5cdH1cblxuXHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG5cdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuXHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG5cdH1cblxuXHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAuaW5zdGFuY2VzICk7XG5cblx0fVxuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvY29yZS9Vbmlmb3JtLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Vbmlmb3JtID0gZnVuY3Rpb24gKCB0eXBlLCB2YWx1ZSApIHtcblxuXHR0aGlzLnR5cGUgPSB0eXBlO1xuXHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cblx0dGhpcy5keW5hbWljID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLlVuaWZvcm0ucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5Vbmlmb3JtLFxuXG5cdG9uVXBkYXRlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0dGhpcy5keW5hbWljID0gdHJ1ZTtcblx0XHR0aGlzLm9uVXBkYXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkNsaXAuanNcblxuLyoqXG4gKlxuICogUmV1c2FibGUgc2V0IG9mIFRyYWNrcyB0aGF0IHJlcHJlc2VudCBhbiBhbmltYXRpb24uXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICovXG5cblRIUkVFLkFuaW1hdGlvbkNsaXAgPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKSB7XG5cblx0dGhpcy5uYW1lID0gbmFtZSB8fCBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcblx0dGhpcy5kdXJhdGlvbiA9ICggZHVyYXRpb24gIT09IHVuZGVmaW5lZCApID8gZHVyYXRpb24gOiAtMTtcblxuXHQvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXG5cdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XG5cblx0XHR0aGlzLnJlc2V0RHVyYXRpb24oKTtcblxuXHR9XG5cblx0Ly8gbWF5YmUgb25seSBkbyB0aGVzZSBvbiBkZW1hbmQsIGFzIGRvaW5nIHRoZW0gaGVyZSBjb3VsZCBwb3RlbnRpYWxseSBzbG93IGRvd24gbG9hZGluZ1xuXHQvLyBidXQgbGVhdmluZyB0aGVzZSBoZXJlIGR1cmluZyBkZXZlbG9wbWVudCBhcyB0aGlzIGVuc3VyZXMgYSBsb3Qgb2YgdGVzdGluZyBvZiB0aGVzZSBmdW5jdGlvbnNcblx0dGhpcy50cmltKCk7XG5cdHRoaXMub3B0aW1pemUoKTtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkFuaW1hdGlvbkNsaXAsXG5cblx0cmVzZXREdXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsXG5cdFx0XHRkdXJhdGlvbiA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB0cmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG5cdFx0XHRkdXJhdGlvbiA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdGR1cmF0aW9uLCB0cmFjay50aW1lc1sgdHJhY2sudGltZXMubGVuZ3RoIC0gMSBdICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cblx0fSxcblxuXHR0cmltOiBmdW5jdGlvbigpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50cmFja3NbIGkgXS50cmltKCAwLCB0aGlzLmR1cmF0aW9uICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdG9wdGltaXplOiBmdW5jdGlvbigpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudHJhY2tzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59O1xuXG4vLyBTdGF0aWMgbWV0aG9kczpcblxuT2JqZWN0LmFzc2lnbiggVEhSRUUuQW5pbWF0aW9uQ2xpcCwge1xuXG5cdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuXHRcdHZhciB0cmFja3MgPSBbXSxcblx0XHRcdGpzb25UcmFja3MgPSBqc29uLnRyYWNrcyxcblx0XHRcdGZyYW1lVGltZSA9IDEuMCAvICgganNvbi5mcHMgfHwgMS4wICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBqc29uVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sucGFyc2UoIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBqc29uLm5hbWUsIGpzb24uZHVyYXRpb24sIHRyYWNrcyApO1xuXG5cdH0sXG5cblxuXHR0b0pTT046IGZ1bmN0aW9uKCBjbGlwICkge1xuXG5cdFx0dmFyIHRyYWNrcyA9IFtdLFxuXHRcdFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xuXG5cdFx0dmFyIGpzb24gPSB7XG5cblx0XHRcdCduYW1lJzogY2xpcC5uYW1lLFxuXHRcdFx0J2R1cmF0aW9uJzogY2xpcC5kdXJhdGlvbixcblx0XHRcdCd0cmFja3MnOiB0cmFja3NcblxuXHRcdH07XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dHJhY2tzLnB1c2goIFRIUkVFLktleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpzb247XG5cblx0fSxcblxuXG5cdENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlOiBmdW5jdGlvbiggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzICkge1xuXG5cdFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xuXHRcdHZhciB0cmFja3MgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRpbWVzID0gW107XG5cdFx0XHR2YXIgdmFsdWVzID0gW107XG5cblx0XHRcdHRpbWVzLnB1c2goXG5cdFx0XHRcdFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0KCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzICk7XG5cblx0XHRcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XG5cblx0XHRcdHZhciBvcmRlciA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmdldEtleWZyYW1lT3JkZXIoIHRpbWVzICk7XG5cdFx0XHR0aW1lcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcblx0XHRcdHZhbHVlcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxuXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG5cdFx0XHRpZiAoIHRpbWVzWyAwIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0dGltZXMucHVzaCggbnVtTW9ycGhUYXJnZXRzICk7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyYWNrcy5wdXNoKFxuXHRcdFx0XHRcdG5ldyBUSFJFRS5OdW1iZXJLZXlmcmFtZVRyYWNrKFxuXHRcdFx0XHRcdFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoVGFyZ2V0U2VxdWVuY2VbIGkgXS5uYW1lICsgJ10nLFxuXHRcdFx0XHRcdFx0dGltZXMsIHZhbHVlc1xuXHRcdFx0XHRcdCkuc2NhbGUoIDEuMCAvIGZwcyApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5BbmltYXRpb25DbGlwKCBuYW1lLCAtMSwgdHJhY2tzICk7XG5cblx0fSxcblxuXHRmaW5kQnlOYW1lOiBmdW5jdGlvbiggY2xpcEFycmF5LCBuYW1lICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xuXG5cdFx0XHRcdHJldHVybiBjbGlwQXJyYXlbIGkgXTtcblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH0sXG5cblx0Q3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXM6IGZ1bmN0aW9uKCBtb3JwaFRhcmdldHMsIGZwcyApIHtcblxuXHRcdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG5cdFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xuXHRcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxuXHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcblxuXHRcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxuXHRcdC8vIHBhdHRlcm5zIGxpa2UgV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cdFx0XHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XG5cblx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0XHR2YXIgbmFtZSA9IHBhcnRzWyAxIF07XG5cblx0XHRcdFx0dmFyIGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF07XG5cdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdID0gYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gW107XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY2xpcHMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRjbGlwcy5wdXNoKCBUSFJFRS5BbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsaXBzO1xuXG5cdH0sXG5cblx0Ly8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XG5cdHBhcnNlQW5pbWF0aW9uOiBmdW5jdGlvbiggYW5pbWF0aW9uLCBib25lcywgbm9kZU5hbWUgKSB7XG5cblx0XHRpZiAoICEgYW5pbWF0aW9uICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgbm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YVwiICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHZhciBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24oXG5cdFx0XHRcdHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XG5cblx0XHRcdC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxuXHRcdFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHR2YXIgdGltZXMgPSBbXTtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdFRIUkVFLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgdGltZXMsIHZhbHVlcywgcHJvcGVydHlOYW1lICk7XG5cblx0XHRcdFx0Ly8gZW1wdHkga2V5cyBhcmUgZmlsdGVyZWQgb3V0LCBzbyBjaGVjayBhZ2FpblxuXHRcdFx0XHRpZiAoIHRpbWVzLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdGRlc3RUcmFja3MucHVzaCggbmV3IHRyYWNrVHlwZSggdHJhY2tOYW1lLCB0aW1lcywgdmFsdWVzICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHR2YXIgdHJhY2tzID0gW107XG5cblx0XHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XG5cdFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXG5cdFx0dmFyIGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtMTtcblx0XHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcblxuXHRcdHZhciBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xuXG5cdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcblxuXHRcdFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xuXG5cdFx0XHQvLyBza2lwIGVtcHR5IHRyYWNrc1xuXHRcdFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT0gMCApIGNvbnRpbnVlO1xuXG5cdFx0XHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHMgaW4gYSB3YXkgZXhhY3RseSBjb21wYXRpYmxlXG5cdFx0XHQvLyB3aXRoIEFuaW1hdGlvbkhhbmRsZXIuaW5pdCggYW5pbWF0aW9uIClcblx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1swXS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcblx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0TmFtZXMgPSB7fTtcblx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHNbbV0gXSA9IC0xO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xuXHRcdFx0XHQvLyBtb3JwaFRhcmdldEluZmx1ZW5jZXMgZXhjZXB0IGZvciB0aGUga2V5cyBpbiB3aGljaFxuXHRcdFx0XHQvLyB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXG5cdFx0XHRcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcblxuXHRcdFx0XHRcdHZhciB0aW1lcyA9IFtdO1xuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDtcblx0XHRcdFx0XHRcdFx0bSAhPT0gYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcblxuXHRcdFx0XHRcdFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCAoIGFuaW1hdGlvbktleS5tb3JwaFRhcmdldCA9PT0gbW9ycGhUYXJnZXROYW1lICkgPyAxIDogMCApXG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0cmFja3MucHVzaCggbmV3IFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2soXG5cdFx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VbJyArIG1vcnBoVGFyZ2V0TmFtZSArICddJywgdGltZXMsIHZhbHVlcyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGR1cmF0aW9uID0gbW9ycGhUYXJnZXROYW1lcy5sZW5ndGggKiAoIGZwcyB8fCAxLjAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gLi4uYXNzdW1lIHNrZWxldGFsIGFuaW1hdGlvblxuXG5cdFx0XHRcdHZhciBib25lTmFtZSA9ICcuYm9uZXNbJyArIGJvbmVzWyBoIF0ubmFtZSArICddJztcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnBvc2l0aW9uJyxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdwb3MnLCB0cmFja3MgKTtcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFx0VEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJyxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcblxuXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuXHRcdFx0XHRcdFx0VEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnNjYWxlJyxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsICdzY2wnLCB0cmFja3MgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCB0cmFja3MubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHRcdHZhciBjbGlwID0gbmV3IFRIUkVFLkFuaW1hdGlvbkNsaXAoIGNsaXBOYW1lLCBkdXJhdGlvbiwgdHJhY2tzICk7XG5cblx0XHRyZXR1cm4gY2xpcDtcblxuXHR9XG5cbn0gKTtcblxuXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vQW5pbWF0aW9uTWl4ZXIuanNcblxuLyoqXG4gKlxuICogUGxheWVyIGZvciBBbmltYXRpb25DbGlwcy5cbiAqXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cblRIUkVFLkFuaW1hdGlvbk1peGVyID0gZnVuY3Rpb24oIHJvb3QgKSB7XG5cblx0dGhpcy5fcm9vdCA9IHJvb3Q7XG5cdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XG5cdHRoaXMuX2FjY3VJbmRleCA9IDA7XG5cblx0dGhpcy50aW1lID0gMDtcblxuXHR0aGlzLnRpbWVTY2FsZSA9IDEuMDtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25NaXhlcixcblxuXHQvLyByZXR1cm4gYW4gYWN0aW9uIGZvciBhIGNsaXAgb3B0aW9uYWxseSB1c2luZyBhIGN1c3RvbSByb290IHRhcmdldFxuXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcblx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG5cdGNsaXBBY3Rpb246IGZ1bmN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cdFx0XHRjbGlwTmFtZSA9ICggdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnICkgPyBjbGlwIDogY2xpcC5uYW1lLFxuXHRcdFx0Y2xpcE9iamVjdCA9ICggY2xpcCAhPT0gY2xpcE5hbWUgKSA/IGNsaXAgOiBudWxsLFxuXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXG5cdFx0XHRwcm90b3R5cGVBY3Rpb247XG5cblx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBleGlzdGluZ0FjdGlvbiA9XG5cdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0XHRpZiAoIGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGtub3cgdGhlIGNsaXAsIHNvIHdlIGRvbid0IGhhdmUgdG8gcGFyc2UgYWxsXG5cdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcblx0XHRcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xuXG5cdFx0XHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cblx0XHRcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XG5cblx0XHRcdGlmICggY2xpcCAhPT0gY2xpcE5hbWUgJiYgY2xpcCAhPT0gY2xpcE9iamVjdCApIHtcblxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcIkRpZmZlcmVudCBjbGlwcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGV0ZWN0ZWQhXCIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcblx0XHRpZiAoIGNsaXBPYmplY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuXHRcdC8vIGFsbG9jYXRlIGFsbCByZXNvdXJjZXMgcmVxdWlyZWQgdG8gcnVuIGl0XG5cdFx0dmFyIG5ld0FjdGlvbiA9IG5ldyBUSFJFRS5cblx0XHRcdFx0QW5pbWF0aW9uTWl4ZXIuX0FjdGlvbiggdGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290ICk7XG5cblx0XHR0aGlzLl9iaW5kQWN0aW9uKCBuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApO1xuXG5cdFx0Ly8gYW5kIG1ha2UgdGhlIGFjdGlvbiBrbm93biB0byB0aGUgbWVtb3J5IG1hbmFnZXJcblx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwTmFtZSwgcm9vdFV1aWQgKTtcblxuXHRcdHJldHVybiBuZXdBY3Rpb247XG5cblx0fSxcblxuXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG5cdGV4aXN0aW5nQWN0aW9uOiBmdW5jdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG5cdFx0dmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcblx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0Y2xpcE5hbWUgPSAoIHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyApID8gY2xpcCA6IGNsaXAubmFtZSxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSB8fCBudWxsO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fSxcblxuXHQvLyBkZWFjdGl2YXRlcyBhbGwgcHJldmlvdXNseSBzY2hlZHVsZWQgYWN0aW9uc1xuXHRzdG9wQWxsQWN0aW9uOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcblx0XHRcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG5cdFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xuXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG5cdFx0XHRhY3Rpb25zWyBpIF0ucmVzZXQoKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xuXG5cdFx0XHRiaW5kaW5nc1sgaSBdLnVzZUNvdW50ID0gMDtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gYWR2YW5jZSB0aGUgdGltZSBhbmQgdXBkYXRlIGFwcGx5IHRoZSBhbmltYXRpb25cblx0dXBkYXRlOiBmdW5jdGlvbiggZGVsdGFUaW1lICkge1xuXG5cdFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblxuXHRcdFx0dGltZSA9IHRoaXMudGltZSArPSBkZWx0YVRpbWUsXG5cdFx0XHR0aW1lRGlyZWN0aW9uID0gTWF0aC5zaWduKCBkZWx0YVRpbWUgKSxcblxuXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XG5cblx0XHQvLyBydW4gYWN0aXZlIGFjdGlvbnNcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cblx0XHRcdGlmICggYWN0aW9uLmVuYWJsZWQgKSB7XG5cblx0XHRcdFx0YWN0aW9uLl91cGRhdGUoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcblxuXHRcdFx0YmluZGluZ3NbIGkgXS5hcHBseSggYWNjdUluZGV4ICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XG5cdGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cblx0fSxcblxuXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIGNsaXBcblx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uKCBjbGlwICkge1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0Y2xpcE5hbWUgPSBjbGlwLm5hbWUsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuXHRcdFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxuXHRcdFx0Ly8ganVzdCB0aHJvdyBhd2F5XG5cblx0XHRcdHZhciBhY3Rpb25zVG9SZW1vdmUgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIGFjdGlvbiA9IGFjdGlvbnNUb1JlbW92ZVsgaSBdO1xuXG5cdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHRcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXHRcdFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cdFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuXHRcdFx0XHRhY3Rpb25zLnBvcCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwTmFtZSBdO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciByb290IHRhcmdldCBvYmplY3Rcblx0dW5jYWNoZVJvb3Q6IGZ1bmN0aW9uKCByb290ICkge1xuXG5cdFx0dmFyIHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XG5cblx0XHRmb3IgKCB2YXIgY2xpcE5hbWUgaW4gYWN0aW9uc0J5Q2xpcCApIHtcblxuXHRcdFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0uYWN0aW9uQnlSb290LFxuXHRcdFx0XHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRcdGlmICggYWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xuXG5cdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcblxuXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXG5cdHVuY2FjaGVBY3Rpb246IGZ1bmN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cblx0XHR2YXIgYWN0aW9uID0gdGhpcy5leGlzdGluZ0FjdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICk7XG5cblx0XHRpZiAoIGFjdGlvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5BbmltYXRpb25NaXhlci5wcm90b3R5cGUgKTtcblxuVEhSRUUuQW5pbWF0aW9uTWl4ZXIuX0FjdGlvbiA9XG5cdFx0ZnVuY3Rpb24oIG1peGVyLCBjbGlwLCBsb2NhbFJvb3QgKSB7XG5cblx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcblx0dGhpcy5fY2xpcCA9IGNsaXA7XG5cdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdCB8fCBudWxsO1xuXG5cdHZhciB0cmFja3MgPSBjbGlwLnRyYWNrcyxcblx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHR2YXIgaW50ZXJwb2xhbnRTZXR0aW5ncyA9IHtcblx0XHRcdGVuZGluZ1N0YXJ0OiBcdFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmcsXG5cdFx0XHRlbmRpbmdFbmQ6XHRcdFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmdcblx0fTtcblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xuXHRcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XG5cdFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzXG5cblx0fVxuXG5cdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXG5cdHRoaXMuX2ludGVycG9sYW50cyA9IGludGVycG9sYW50cztcdC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxuXG5cdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXG5cdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuXHR0aGlzLl9jYWNoZUluZGV4ID0gbnVsbDtcdFx0XHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1x0XHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXG5cblx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuXHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XG5cblx0dGhpcy5sb29wID0gVEhSRUUuTG9vcFJlcGVhdDtcblx0dGhpcy5fbG9vcENvdW50ID0gLTE7XG5cblx0Ly8gZ2xvYmFsIG1peGVyIHRpbWUgd2hlbiB0aGUgYWN0aW9uIGlzIHRvIGJlIHN0YXJ0ZWRcblx0Ly8gaXQncyBzZXQgYmFjayB0byAnbnVsbCcgdXBvbiBzdGFydCBvZiB0aGUgYWN0aW9uXG5cdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cblx0Ly8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxuXHQvLyBnZXRzIGNsYW1wZWQgb3Igd3JhcHBlZCB0byAwLi5jbGlwLmR1cmF0aW9uIGFjY29yZGluZyB0byBsb29wXG5cdHRoaXMudGltZSA9IDA7XG5cblx0dGhpcy50aW1lU2NhbGUgPSAxO1xuXHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xuXG5cdHRoaXMud2VpZ2h0ID0gMTtcblx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gMTtcblxuXHR0aGlzLnJlcGV0aXRpb25zID0gSW5maW5pdHk7IFx0XHQvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXG5cblx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcdFx0XHRcdC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcblx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcdFx0XHRcdC8vIHRydWUgLT4gemVybyBlZmZlY3RpdmUgd2VpZ2h0XG5cblx0dGhpcy5jbGFtcFdoZW5GaW5pc2hlZCBcdD0gZmFsc2U7XHQvLyBrZWVwIGZlZWRpbmcgdGhlIGxhc3QgZnJhbWU/XG5cblx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0IFx0PSB0cnVlO1x0XHQvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXG5cdHRoaXMuemVyb1Nsb3BlQXRFbmRcdFx0PSB0cnVlO1x0XHQvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxuXG59O1xuXG5USFJFRS5BbmltYXRpb25NaXhlci5fQWN0aW9uLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uTWl4ZXIuX0FjdGlvbixcblxuXHQvLyBTdGF0ZSAmIFNjaGVkdWxpbmdcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuX21peGVyLl9hY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKCB0aGlzICk7XG5cblx0XHRyZXR1cm4gdGhpcy5yZXNldCgpO1xuXG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcblx0XHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy50aW1lID0gMDtcdFx0XHQvLyByZXN0YXJ0IGNsaXBcblx0XHR0aGlzLl9sb29wQ291bnQgPSAtMTtcdC8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XHQvLyBmb3JnZXQgc2NoZWR1bGluZ1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHRpc1J1bm5pbmc6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5fc3RhcnRUaW1lO1xuXG5cdFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhIHRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmXG5cdFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKVxuXG5cdH0sXG5cblx0Ly8gcmV0dXJuIHRydWUgd2hlbiBwbGF5IGhhcyBiZWVuIGNhbGxlZFxuXHRpc1NjaGVkdWxlZDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XG5cblx0fSxcblxuXHRzdGFydEF0OiBmdW5jdGlvbiggdGltZSApIHtcblxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHNldExvb3A6IGZ1bmN0aW9uKCBtb2RlLCByZXBldGl0aW9ucyApIHtcblxuXHRcdHRoaXMubG9vcCA9IG1vZGU7XG5cdFx0dGhpcy5yZXBldGl0aW9ucyA9IHJlcGV0aXRpb25zO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyBXZWlnaHRcblxuXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuXHQvLyBhbHRob3VnaCAuZW5hYmxlZCA9IGZhbHNlIHlpZWxkcyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIHplcm8sIHRoaXNcblx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uKCB3ZWlnaHQgKSB7XG5cblx0XHR0aGlzLndlaWdodCA9IHdlaWdodDtcblxuXHRcdC8vIG5vdGU6IHNhbWUgbG9naWMgYXMgd2hlbiB1cGRhdGVkIGF0IHJ1bnRpbWVcblx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xuXG5cdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdH0sXG5cblx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxuXHRnZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVdlaWdodDtcblxuXHR9LFxuXG5cdGZhZGVJbjogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMCwgMSApO1xuXG5cdH0sXG5cblx0ZmFkZU91dDogZnVuY3Rpb24oIGR1cmF0aW9uICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xuXG5cdH0sXG5cblx0Y3Jvc3NGYWRlRnJvbTogZnVuY3Rpb24oIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXI7XG5cblx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoIGR1cmF0aW9uICk7XG5cdFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XG5cblx0XHRpZiggd2FycCApIHtcblxuXHRcdFx0dmFyIGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcblx0XHRcdFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcblxuXHRcdFx0XHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXG5cdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcblxuXHRcdFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XG5cdFx0XHR0aGlzLndhcnAoIGVuZFN0YXJ0UmF0aW8sIDEuMCwgZHVyYXRpb24gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Y3Jvc3NGYWRlVG86IGZ1bmN0aW9uKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG5cdFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xuXG5cdH0sXG5cblx0c3RvcEZhZGluZzogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgd2VpZ2h0SW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdGlmICggd2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcblx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggd2VpZ2h0SW50ZXJwb2xhbnQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gVGltZSBTY2FsZSBDb250cm9sXG5cblx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXG5cdC8vIGFsdGhvdWdoIC5wYXVzZWQgPSB0cnVlIHlpZWxkcyBhbiBlZmZlY3RpdmUgdGltZSBzY2FsZSBvZiB6ZXJvLCB0aGlzXG5cdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xuXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcblx0XHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aGlzLnBhdXNlZCA/IDAgOnRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxuXHRnZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZTtcblxuXHR9LFxuXG5cdHNldER1cmF0aW9uOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHRzeW5jV2l0aDogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xuXHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcblxuXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0fSxcblxuXHRoYWx0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cblx0XHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9jdXJyZW50VGltZVNjYWxlLCAwLCBkdXJhdGlvbiApO1xuXG5cdH0sXG5cblx0d2FycDogZnVuY3Rpb24oIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xuXG5cdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWUsXG5cdFx0XHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxuXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcblx0XHRcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cblx0XHR9XG5cblx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cblx0XHR0aW1lc1sgMCBdID0gbm93O1xuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcblxuXHRcdHZhbHVlc1sgMCBdID0gc3RhcnRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XG5cdFx0dmFsdWVzWyAxIF0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHN0b3BXYXJwaW5nOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0aW1lU2NhbGVJbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50O1xuXG5cdFx0aWYgKCB0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuXHRcdFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB0aW1lU2NhbGVJbnRlcnBvbGFudCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyBPYmplY3QgQWNjZXNzb3JzXG5cblx0Z2V0TWl4ZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX21peGVyO1xuXG5cdH0sXG5cblx0Z2V0Q2xpcDogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5fY2xpcDtcblxuXHR9LFxuXG5cdGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIHRoaXMuX2xvY2FsUm9vdCB8fCB0aGlzLl9taXhlci5fcm9vdDtcblxuXHR9LFxuXG5cdC8vIEludGVybmFcblxuXHRfdXBkYXRlOiBmdW5jdGlvbiggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKSB7XG5cdFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxuXG5cdFx0dmFyIHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblxuXHRcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xuXG5cdFx0XHQvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxuXG5cdFx0XHR2YXIgdGltZVJ1bm5pbmcgPSAoIHRpbWUgLSBzdGFydFRpbWUgKSAqIHRpbWVEaXJlY3Rpb247XG5cdFx0XHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xuXG5cdFx0XHRcdHJldHVybjsgLy8geWV0IHRvIGNvbWUgLyBkb24ndCBkZWNpZGUgd2hlbiBkZWx0YSA9IDBcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdGFydFxuXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXG5cdFx0XHRkZWx0YVRpbWUgPSB0aW1lRGlyZWN0aW9uICogdGltZVJ1bm5pbmc7XG5cblx0XHR9XG5cblx0XHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcblxuXHRcdGRlbHRhVGltZSAqPSB0aGlzLl91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKTtcblx0XHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcblxuXHRcdC8vIG5vdGU6IF91cGRhdGVUaW1lIG1heSBkaXNhYmxlIHRoZSBhY3Rpb24gcmVzdWx0aW5nIGluXG5cdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cblx0XHR2YXIgd2VpZ2h0ID0gdGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XG5cblx0XHRpZiAoIHdlaWdodCA+IDAgKSB7XG5cblx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XG5cdFx0XHR2YXIgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdGludGVycG9sYW50c1sgaiBdLmV2YWx1YXRlKCBjbGlwVGltZSApO1xuXHRcdFx0XHRwcm9wZXJ0eU1peGVyc1sgaiBdLmFjY3VtdWxhdGUoIGFjY3VJbmRleCwgd2VpZ2h0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdF91cGRhdGVXZWlnaHQ6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG5cdFx0dmFyIHdlaWdodCA9IDA7XG5cblx0XHRpZiAoIHRoaXMuZW5hYmxlZCApIHtcblxuXHRcdFx0d2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcblxuXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuXHRcdFx0XHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcblxuXHRcdFx0XHRcdHRoaXMuc3RvcEZhZGluZygpO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBmYWRlZCBvdXQsIGRpc2FibGVcblx0XHRcdFx0XHRcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlV2VpZ2h0ID0gd2VpZ2h0O1xuXHRcdHJldHVybiB3ZWlnaHQ7XG5cblx0fSxcblxuXHRfdXBkYXRlVGltZVNjYWxlOiBmdW5jdGlvbiggdGltZSApIHtcblxuXHRcdHZhciB0aW1lU2NhbGUgPSAwO1xuXG5cdFx0aWYgKCAhIHRoaXMucGF1c2VkICkge1xuXG5cdFx0XHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcblxuXHRcdFx0dmFyIGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XG5cblx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XG5cblx0XHRcdFx0dGltZVNjYWxlICo9IGludGVycG9sYW50VmFsdWU7XG5cblx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XG5cblx0XHRcdFx0XHR0aGlzLnN0b3BXYXJwaW5nKCk7XG5cblx0XHRcdFx0XHRpZiAoIHRpbWVTY2FsZSA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXG5cdFx0XHRcdFx0XHR0aGlzLnBhdXNlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIHdhcnAgZG9uZSAtIGFwcGx5IGZpbmFsIHRpbWUgc2NhbGVcblx0XHRcdFx0XHRcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGltZVNjYWxlO1xuXHRcdHJldHVybiB0aW1lU2NhbGU7XG5cblx0fSxcblxuXHRfdXBkYXRlVGltZTogZnVuY3Rpb24oIGRlbHRhVGltZSApIHtcblxuXHRcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xuXG5cdFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcblxuXHRcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXG5cblx0XHRcdGxvb3AgPSB0aGlzLmxvb3AsXG5cdFx0XHRsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQsXG5cblx0XHRcdHBpbmdQb25nID0gZmFsc2U7XG5cblx0XHRzd2l0Y2ggKCBsb29wICkge1xuXG5cdFx0XHRjYXNlIFRIUkVFLkxvb3BPbmNlOlxuXHRcdFx0Y2FzZSBUSFJFRS5Mb29wT25jZUNsYW1wOlxuXG5cdFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtMSApIHtcblxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdFx0dGhpcy5sb29wQ291bnQgPSAwO1xuXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRydWUsIGZhbHNlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aW1lIDwgMCApIHtcblxuXHRcdFx0XHRcdHRpbWUgPSAwO1xuXG5cdFx0XHRcdH0gZWxzZSBicmVhaztcblxuXHRcdFx0XHQvLyByZWFjaGVkIHRoZSBlbmRcblxuXHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlID0gdHJ1ZTtcblx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxuXHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0xIDogMVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgVEhSRUUuTG9vcFBpbmdQb25nOlxuXG5cdFx0XHRcdHBpbmdQb25nID0gdHJ1ZTtcblxuXHRcdFx0Y2FzZSBUSFJFRS5Mb29wUmVwZWF0OlxuXG5cdFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtMSApIHtcblxuXHRcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG5cdFx0XHRcdFx0aWYgKCBkZWx0YVRpbWUgPiAwICkge1xuXG5cdFx0XHRcdFx0XHRsb29wQ291bnQgPSAwO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKFxuXHRcdFx0XHRcdFx0XHRcdHRydWUsIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHBpbmdQb25nICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXG5cdFx0XHRcdFx0XHQvLyB0cmFuc2l0aW9uIHRocm91Z2ggemVybyBjb3VudHMgYXMgYSByZXBldGl0aW9uLFxuXHRcdFx0XHRcdFx0Ly8gc28gbGVhdmUgbG9vcENvdW50IGF0IC0xXG5cblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xuXG5cdFx0XHRcdFx0Ly8gd3JhcCBhcm91bmRcblxuXHRcdFx0XHRcdHZhciBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXG5cdFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblxuXHRcdFx0XHRcdGxvb3BDb3VudCArPSBNYXRoLmFicyggbG9vcERlbHRhICk7XG5cblx0XHRcdFx0XHR2YXIgcGVuZGluZyA9IHRoaXMucmVwZXRpdGlvbnMgLSBsb29wQ291bnQ7XG5cblx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPCAwICkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXG5cblx0XHRcdFx0XHRcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdHRpbWUgPSBkZWx0YVRpbWUgPiAwID8gZHVyYXRpb24gOiAwO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcblx0XHRcdFx0XHRcdFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPiAwID8gMSA6IC0xXG5cdFx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggcGVuZGluZyA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdHJhbnNpdGlvbiB0byBsYXN0IHJvdW5kXG5cblx0XHRcdFx0XHRcdHZhciBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcblxuXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcblx0XHRcdFx0XHRcdHR5cGU6ICdsb29wJywgYWN0aW9uOiB0aGlzLCBsb29wRGVsdGE6IGxvb3BEZWx0YVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBsb29wID09PSBUSFJFRS5Mb29wUGluZ1BvbmcgJiYgKCBsb29wQ291bnQgJiAxICkgPT09IDEgKSB7XG5cblx0XHRcdFx0XHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFwicG9uZyByb3VuZFwiXG5cblx0XHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdFx0cmV0dXJuIHRpbWU7XG5cblx0fSxcblxuXHRfc2V0RW5kaW5nczogZnVuY3Rpb24oIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcblxuXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cblx0XHRpZiAoIHBpbmdQb25nICkge1xuXG5cdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCBcdD0gVEhSRUUuWmVyb1Nsb3BlRW5kaW5nO1xuXHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kXHRcdD0gVEhSRUUuWmVyb1Nsb3BlRW5kaW5nO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxuXG5cdFx0XHRpZiAoIGF0U3RhcnQgKSB7XG5cblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSB0aGlzLnplcm9TbG9wZUF0U3RhcnQgP1xuXHRcdFx0XHRcdFx0VEhSRUUuWmVyb1Nsb3BlRW5kaW5nIDogVEhSRUUuWmVyb0N1cnZhdHVyZUVuZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFRIUkVFLldyYXBBcm91bmRFbmRpbmc7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhdEVuZCApIHtcblxuXHRcdFx0XHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID9cblx0XHRcdFx0XHRcdFRIUkVFLlplcm9TbG9wZUVuZGluZyA6IFRIUkVFLlplcm9DdXJ2YXR1cmVFbmRpbmc7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kIFx0ID0gVEhSRUUuV3JhcEFyb3VuZEVuZGluZztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcblxuXHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxuXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cblx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcblx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XG5cblx0XHR9XG5cblx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG5cdFx0XHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XG5cblx0XHR0aW1lc1sgMCBdID0gbm93OyBcdFx0XHRcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xuXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufTtcblxuLy8gSW1wbGVtZW50YXRpb24gZGV0YWlsczpcblxuT2JqZWN0LmFzc2lnbiggVEhSRUUuQW5pbWF0aW9uTWl4ZXIucHJvdG90eXBlLCB7XG5cblx0X2JpbmRBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApIHtcblxuXHRcdHZhciByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcblx0XHRcdHRyYWNrcyA9IGFjdGlvbi5fY2xpcC50cmFja3MsXG5cdFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcblx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxuXHRcdFx0aW50ZXJwb2xhbnRzID0gYWN0aW9uLl9pbnRlcnBvbGFudHMsXG5cdFx0XHRyb290VXVpZCA9IHJvb3QudXVpZCxcblx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuXHRcdFx0YmluZGluZ3NCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YmluZGluZ3NCeU5hbWUgPSB7fTtcblx0XHRcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cblx0XHRcdHZhciB0cmFjayA9IHRyYWNrc1sgaSBdLFxuXHRcdFx0XHR0cmFja05hbWUgPSB0cmFjay5uYW1lLFxuXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXG5cdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuXHRcdFx0XHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3NcblxuXHRcdFx0XHRcdGlmICggYmluZGluZy5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXRoID0gcHJvdG90eXBlQWN0aW9uICYmIHByb3RvdHlwZUFjdGlvbi5cblx0XHRcdFx0XHRcdF9wcm9wZXJ0eUJpbmRpbmdzWyBpIF0uYmluZGluZy5wYXJzZWRQYXRoO1xuXG5cdFx0XHRcdGJpbmRpbmcgPSBuZXcgVEhSRUUuUHJvcGVydHlNaXhlcihcblx0XHRcdFx0XHRcdFRIUkVFLlByb3BlcnR5QmluZGluZy5jcmVhdGUoIHJvb3QsIHRyYWNrTmFtZSwgcGF0aCApLFxuXHRcdFx0XHRcdFx0dHJhY2suVmFsdWVUeXBlTmFtZSwgdHJhY2suZ2V0VmFsdWVTaXplKCkgKTtcblxuXHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcblxuXHRcdFx0XHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnBvbGFudHNbIGkgXS5yZXN1bHRCdWZmZXIgPSBiaW5kaW5nLmJ1ZmZlcjtcblxuXHRcdH1cblxuXHR9LFxuXG5cdF9hY3RpdmF0ZUFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuXHRcdGlmICggISB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XG5cblx0XHRcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGZvcmdvdHRlbiBieSB0aGUgY2FjaGUsIGJ1dCB0aGUgdXNlclxuXHRcdFx0XHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxuXG5cdFx0XHRcdHZhciByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXG5cdFx0XHRcdFx0Y2xpcE5hbWUgPSBhY3Rpb24uX2NsaXAubmFtZSxcblx0XHRcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF07XG5cblx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxuXHRcdFx0XHRcdFx0YWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF0gKTtcblxuXHRcdFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggYWN0aW9uLCBjbGlwTmFtZSwgcm9vdFV1aWQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cblx0XHRcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBiaW5kaW5nLnVzZUNvdW50ICsrID09PSAwICkge1xuXG5cdFx0XHRcdFx0dGhpcy5fbGVuZEJpbmRpbmcoIGJpbmRpbmcgKTtcblx0XHRcdFx0XHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0X2RlYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG5cdFx0XHQvLyBkZWNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG5cdFx0XHRcdGlmICggLS0gYmluZGluZy51c2VDb3VudCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcblx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gTWVtb3J5IG1hbmFnZXJcblxuXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dGhpcy5fYWN0aW9ucyA9IFtdOyAvLyAnbkFjdGl2ZUFjdGlvbnMnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcblx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cblx0XHR0aGlzLl9hY3Rpb25zQnlDbGlwID0ge307XG5cdFx0Ly8gaW5zaWRlOlxuXHRcdC8vIHtcblx0XHQvLyBcdFx0a25vd25BY3Rpb25zOiBBcnJheTwgX0FjdGlvbiA+XHQtIHVzZWQgYXMgcHJvdG90eXBlc1xuXHRcdC8vIFx0XHRhY3Rpb25CeVJvb3Q6IF9BY3Rpb25cdFx0XHQtIGxvb2t1cFxuXHRcdC8vIH1cblxuXG5cdFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgLy8gJ25BY3RpdmVCaW5kaW5ncycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cblx0XHR0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTsgLy8gaW5zaWRlOiBNYXA8IG5hbWUsIFByb3BlcnR5TWl4ZXIgPlxuXG5cblx0XHR0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzID0gW107IC8vIHNhbWUgZ2FtZSBhcyBhYm92ZVxuXHRcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR0aGlzLnN0YXRzID0ge1xuXG5cdFx0XHRhY3Rpb25zOiB7XG5cdFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDsgfSxcblx0XHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gc2NvcGUuX25BY3RpdmVBY3Rpb25zOyB9XG5cdFx0XHR9LFxuXHRcdFx0YmluZGluZ3M6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkgeyByZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDsgfSxcblx0XHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5nczsgfVxuXHRcdFx0fSxcblx0XHRcdGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcblx0XHRcdFx0Z2V0IHRvdGFsKCkgeyByZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoOyB9LFxuXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHM7IH1cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSxcblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgX0FjdGlvbiBvYmplY3RzXG5cblx0X2lzQWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG5cdFx0dmFyIGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXHRcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xuXG5cdH0sXG5cblx0X2FkZEluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uLCBjbGlwTmFtZSwgcm9vdFV1aWQgKSB7XG5cblx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG5cdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcblx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcblxuXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YWN0aW9uc0ZvckNsaXAgPSB7XG5cblx0XHRcdFx0a25vd25BY3Rpb25zOiBbIGFjdGlvbiBdLFxuXHRcdFx0XHRhY3Rpb25CeVJvb3Q6IHt9XG5cblx0XHRcdH07XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XG5cblx0XHRcdGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0gPSBhY3Rpb25zRm9yQ2xpcDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cblx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XG5cdFx0XHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cblx0XHR9XG5cblx0XHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcblx0XHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xuXG5cdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xuXG5cdH0sXG5cblx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXG5cdFx0XHRjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuXG5cdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XG5cdFx0YWN0aW9ucy5wb3AoKTtcblxuXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cblxuXHRcdHZhciBjbGlwTmFtZSA9IGFjdGlvbi5fY2xpcC5uYW1lLFxuXHRcdFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXG5cdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBOYW1lIF0sXG5cdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxuXG5cdFx0XHRsYXN0S25vd25BY3Rpb24gPVxuXHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcblxuXHRcdFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcblxuXHRcdGxhc3RLbm93bkFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGJ5Q2xpcENhY2hlSW5kZXg7XG5cdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xuXHRcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XG5cblx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xuXG5cblx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuXHRcdFx0cm9vdFV1aWQgPSAoIGFjdGlvbnMuX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZDtcblxuXHRcdGRlbGV0ZSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XG5cblx0XHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcE5hbWUgXTtcblxuXHRcdH1cblxuXHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG5cdH0sXG5cblx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cblx0XHRcdGlmICggLS0gYmluZGluZy5yZWZlcmVuY2VDb3VudCA9PT0gMCApIHtcblxuXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0sXG5cblx0X2xlbmRBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHwgIGluYWN0aXZlIGFjdGlvbnMgIF1cblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxuXHRcdC8vICAgICAgICAgICAgICAgICAgPC1zd2FwLT5cblx0XHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyArKyxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG5cdFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XG5cblx0fSxcblxuXHRfdGFrZUJhY2tBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cblx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cblx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHw8IGluYWN0aXZlIGFjdGlvbnMgIF1cblx0XHQvLyAgICAgICAgYSAgICAgICAgc1xuXHRcdC8vICAgICAgICAgPC1zd2FwLT5cblx0XHQvLyAgICAgICAgcyAgICAgICAgYVxuXG5cdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblxuXHRcdFx0bGFzdEFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYWN0aW9uO1xuXG5cdFx0bGFzdEFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVBY3Rpb247XG5cblx0fSxcblxuXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXG5cblx0X2FkZEluYWN0aXZlQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XG5cblx0XHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cblx0XHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0YmluZGluZ0J5TmFtZSA9IHt9O1xuXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xuXG5cdFx0fVxuXG5cdFx0YmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF0gPSBiaW5kaW5nO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcblx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cblx0fSxcblxuXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXG5cdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG5cdFx0XHR0cmFja05hbWUgPSBwcm9wQmluZGluZy5wYXRoLFxuXHRcdFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXG5cdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cblx0XHRcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxuXHRcdFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XG5cblx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcblx0XHRiaW5kaW5nc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQmluZGluZztcblx0XHRiaW5kaW5ncy5wb3AoKTtcblxuXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblxuXHRcdHJlbW92ZV9lbXB0eV9tYXA6IHtcblxuXHRcdFx0Zm9yICggdmFyIF8gaW4gYmluZGluZ0J5TmFtZSApIGJyZWFrIHJlbW92ZV9lbXB0eV9tYXA7XG5cblx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdF9sZW5kQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXG5cblx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyArKyxcblxuXHRcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuXHRcdGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRmaXJzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcblx0XHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQmluZGluZztcblxuXHR9LFxuXG5cdF90YWtlQmFja0JpbmRpbmc6IGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXG5cdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG5cdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQmluZGluZ3MsXG5cblx0XHRcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcblx0XHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0bGFzdEFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XG5cblx0fSxcblxuXG5cdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXG5cblx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyArKyxcblx0XHRcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aW50ZXJwb2xhbnQgPSBuZXcgVEhSRUUuTGluZWFySW50ZXJwb2xhbnQoXG5cdFx0XHRcdFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXG5cdFx0XHRcdFx0XHQxLCB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyICk7XG5cblx0XHRcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcblx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbnRlcnBvbGFudDtcblxuXHR9LFxuXG5cdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24oIGludGVycG9sYW50ICkge1xuXG5cdFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXG5cdFx0XHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXG5cblx0XHRcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxuXG5cdFx0XHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xuXG5cdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuXHRcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuXHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG5cdFx0aW50ZXJwb2xhbnRzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVJbnRlcnBvbGFudDtcblxuXHR9LFxuXG5cdF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KCAxIClcblxufSApO1xuXG5cbi8vIEZpbGU6c3JjL2FuaW1hdGlvbi9BbmltYXRpb25PYmplY3RHcm91cC5qc1xuXG4vKipcbiAqXG4gKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogXHQtXHRBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxuICogXHRcdGNvbnN0cnVjdG9yIG9yIHRoZSAuY2xpcEFjdGlvbiBtZXRob2Qgb2YgQW5pbWF0aW9uTWl4ZXIuXG4gKlxuICogXHQtXHRJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxuICpcbiAqIFx0LVx0WW91IGNhbiBhbHNvIGFkZCBhbmQgcmVtb3ZlIG9iamVjdHMgbGF0ZXIgd2hlbiB0aGUgbWl4ZXJcbiAqIFx0XHRpcyBydW5uaW5nLlxuICpcbiAqIE5vdGU6XG4gKlxuICogIFx0T2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcbiAqICBcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcbiAqICBcdG9uIHRoZSBncm91cC5cbiAqXG4gKiBMaW1pdGF0aW9uOlxuICpcbiAqIFx0LSBcdFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcbiAqIFx0XHRhbGwgb2JqZWN0cyBpbiB0aGUgZ3JvdXAuXG4gKlxuICogIC1cdEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcbiAqICBcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxuICpcbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5USFJFRS5BbmltYXRpb25PYmplY3RHcm91cCA9IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xuXHR0aGlzLl9vYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG5cdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcdFx0XHQvLyB0aHJlc2hvbGRcblx0Ly8gbm90ZTogcmVhZCBieSBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlXG5cblx0dmFyIGluZGljZXMgPSB7fTtcblx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7XHRcdC8vIGZvciBib29ra2VlcGluZ1xuXG5cdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRpbmRpY2VzWyBhcmd1bWVudHNbIGkgXS51dWlkIF0gPSBpO1xuXG5cdH1cblxuXHR0aGlzLl9wYXRocyA9IFtdO1x0XHRcdFx0XHQvLyBpbnNpZGU6IHN0cmluZ1xuXHR0aGlzLl9wYXJzZWRQYXRocyA9IFtdO1x0XHRcdFx0Ly8gaW5zaWRlOiB7IHdlIGRvbid0IGNhcmUsIGhlcmUgfVxuXHR0aGlzLl9iaW5kaW5ncyA9IFtdOyBcdFx0XHRcdC8vIGluc2lkZTogQXJyYXk8IFByb3BlcnR5QmluZGluZyA+XG5cdHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCA9IHt9OyBcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHRoaXMuc3RhdHMgPSB7XG5cblx0XHRvYmplY3RzOiB7XG5cdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fb2JqZWN0cy5sZW5ndGg7IH0sXG5cdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfOyAgfVxuXHRcdH0sXG5cblx0XHRnZXQgYmluZGluZ3NQZXJPYmplY3QoKSB7IHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoOyB9XG5cblx0fTtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uT2JqZWN0R3JvdXAucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cCxcblxuXHRhZGQ6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRwYXRocyA9IHRoaXMuX3BhdGhzLFxuXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG5cdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXG5cdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcblx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cblx0XHRcdGlmICggaW5kZXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyB1bmtub3duIG9iamVjdCAtPiBhZGQgaXQgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG5cdFx0XHRcdFx0YmluZGluZ3NbIGogXS5wdXNoKFxuXHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuUHJvcGVydHlCaW5kaW5nKFxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xuXG5cdFx0XHRcdHZhciBrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XG5cblx0XHRcdFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cblxuXHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuXHRcdFx0XHRcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cblx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xuXG5cdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XG5cblx0XHRcdFx0XHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcblx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBsYXN0Q2FjaGVkO1xuXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHNpbmNlIHdlIGRvIG5vdCBib3RoZXIgdG8gY3JlYXRlIG5ldyBiaW5kaW5nc1xuXHRcdFx0XHRcdFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcblx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcblxuXHRcdFx0XHRcdFx0YmluZGluZyA9IG5ldyBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcoXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEIFwiICtcblx0XHRcdFx0XHRcdFwiZGV0ZWN0ZWQuIENsZWFuIHRoZSBjYWNoZXMgb3IgcmVjcmVhdGUgeW91ciBcIiArXG5cdFx0XHRcdFx0XHRcImluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4uLlwiICk7XG5cblx0XHRcdH0gLy8gZWxzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgd2hlcmUgd2Ugd2FudCBpdCB0byBiZVxuXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggdmFyX2FyZ3MgKSB7XG5cblx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcblx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuXHRcdFx0XHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICYmIGluZGV4ID49IG5DYWNoZWRPYmplY3RzICkge1xuXG5cdFx0XHRcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IGludG8gdGhlIENBQ0hFRCByZWdpb25cblxuXHRcdFx0XHR2YXIgbGFzdENhY2hlZEluZGV4ID0gbkNhY2hlZE9iamVjdHMgKyssXG5cdFx0XHRcdFx0Zmlyc3RBY3RpdmVPYmplY3QgPSBvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXTtcblxuXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xuXG5cdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGxhc3RDYWNoZWRJbmRleDtcblx0XHRcdFx0b2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF0gPSBvYmplY3Q7XG5cblx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuXHRcdFx0XHRcdFx0Zmlyc3RBY3RpdmUgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdLFxuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcblxuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGZpcnN0QWN0aXZlO1xuXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cblx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG5cdH0sXG5cblx0Ly8gcmVtb3ZlICYgZm9yZ2V0XG5cdHVuY2FjaGU6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcblx0XHRcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXG5cdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuXHRcdFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuXHRcdFx0XHR1dWlkID0gb2JqZWN0LnV1aWQsXG5cdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG5cdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0ZGVsZXRlIGluZGljZXNCeVVVSURbIHV1aWQgXTtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XG5cblx0XHRcdFx0XHQvLyBvYmplY3QgaXMgY2FjaGVkLCBzaHJpbmsgdGhlIENBQ0hFRCByZWdpb25cblxuXHRcdFx0XHRcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXG5cdFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdLFxuXHRcdFx0XHRcdFx0bGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXG5cdFx0XHRcdFx0XHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0XHQvLyBsYXN0IGNhY2hlZCBvYmplY3QgdGFrZXMgdGhpcyBvYmplY3QncyBwbGFjZVxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cblx0XHRcdFx0XHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXG5cdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xuXHRcdFx0XHRcdG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3RPYmplY3Q7XG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG5cdFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcblx0XHRcdFx0XHRcdFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcblxuXHRcdFx0XHRcdHZhciBsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcblx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gaW5kZXg7XG5cdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XG5cdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuXHRcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF07XG5cblx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XG5cdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSAvLyBjYWNoZWQgb3IgYWN0aXZlXG5cblx0XHRcdH0gLy8gaWYgb2JqZWN0IGlzIGtub3duXG5cblx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cblx0fSxcblxuXHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XG5cblx0c3Vic2NyaWJlXzogZnVuY3Rpb24oIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXG5cdFx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjb250YWluZWQgb2JqZWN0cyBpbiB0aGUgZ3JvdXBcblxuXHRcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxuXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF0sXG5cdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGJpbmRpbmdzWyBpbmRleCBdO1xuXG5cdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXG5cdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuXHRcdFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG5cdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcblx0XHRcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheSggbk9iamVjdHMgKTtcblxuXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXG5cdFx0aW5kaWNlc0J5UGF0aFsgcGF0aCBdID0gaW5kZXg7XG5cblx0XHRwYXRocy5wdXNoKCBwYXRoICk7XG5cdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xuXHRcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSBuQ2FjaGVkT2JqZWN0cyxcblx0XHRcdFx0biA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xuXG5cdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGkgXSA9XG5cdFx0XHRcdFx0bmV3IFRIUkVFLlByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYmluZGluZ3NGb3JQYXRoO1xuXG5cdH0sXG5cblx0dW5zdWJzY3JpYmVfOiBmdW5jdGlvbiggcGF0aCApIHtcblx0XHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXG5cdFx0Ly8gdXBkYXRlIHRoZSBhcnJheSBwcmV2aW91c2x5IG9idGFpbmVkIHdpdGggJ3N1YnNjcmliZV8nXG5cblx0XHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcblx0XHRcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgcGF0aHMgPSB0aGlzLl9wYXRocyxcblx0XHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcblx0XHRcdFx0bGFzdEJpbmRpbmdzSW5kZXggPSBiaW5kaW5ncy5sZW5ndGggLSAxLFxuXHRcdFx0XHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcblx0XHRcdFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cblx0XHRcdGluZGljZXNCeVBhdGhbIGxhc3RCaW5kaW5nc1BhdGggXSA9IGluZGV4O1xuXG5cdFx0XHRiaW5kaW5nc1sgaW5kZXggXSA9IGxhc3RCaW5kaW5ncztcblx0XHRcdGJpbmRpbmdzLnBvcCgpO1xuXG5cdFx0XHRwYXJzZWRQYXRoc1sgaW5kZXggXSA9IHBhcnNlZFBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xuXHRcdFx0cGFyc2VkUGF0aHMucG9wKCk7XG5cblx0XHRcdHBhdGhzWyBpbmRleCBdID0gcGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cdFx0XHRwYXRocy5wb3AoKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL0FuaW1hdGlvblV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciB0c2Nod1xuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICovXG5cblRIUkVFLkFuaW1hdGlvblV0aWxzID0ge1xuXG5cdC8vIHNhbWUgYXMgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgYWxzbyB3b3JrcyBvbiB0eXBlZCBhcnJheXNcblx0YXJyYXlTbGljZTogZnVuY3Rpb24oIGFycmF5LCBmcm9tLCB0byApIHtcblxuXHRcdGlmICggVEhSRUUuQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xuXG5cdFx0XHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBhcnJheS5zdWJhcnJheSggZnJvbSwgdG8gKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5LnNsaWNlKCBmcm9tLCB0byApO1xuXG5cdH0sXG5cblx0Ly8gY29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlXG5cdGNvbnZlcnRBcnJheTogZnVuY3Rpb24oIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xuXG5cdFx0aWYgKCAhIGFycmF5IHx8IC8vIGxldCAndW5kZWZpbmVkJyBhbmQgJ251bGwnIHBhc3Ncblx0XHRcdFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gJ251bWJlcicgKSB7XG5cblx0XHRcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFycmF5ICk7IC8vIGNyZWF0ZSBBcnJheVxuXG5cdH0sXG5cblx0aXNUeXBlZEFycmF5OiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcblx0XHRcdFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XG5cblx0fSxcblxuXHQvLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxuXHRnZXRLZXlmcmFtZU9yZGVyOiBmdW5jdGlvbiggdGltZXMgKSB7XG5cblx0XHRmdW5jdGlvbiBjb21wYXJlVGltZSggaSwgaiApIHtcblxuXHRcdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIG4gPSB0aW1lcy5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBBcnJheSggbiApO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcblxuXHRcdHJlc3VsdC5zb3J0KCBjb21wYXJlVGltZSApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9LFxuXG5cdC8vIHVzZXMgdGhlIGFycmF5IHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgJ2dldEtleWZyYW1lT3JkZXInIHRvIHNvcnQgZGF0YVxuXHRzb3J0ZWRBcnJheTogZnVuY3Rpb24oIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcblxuXHRcdHZhciBuVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBkc3RPZmZzZXQgPSAwOyBkc3RPZmZzZXQgIT09IG5WYWx1ZXM7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBzcmNPZmZzZXQgPSBvcmRlclsgaSBdICogc3RyaWRlO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcblxuXHRcdFx0XHRyZXN1bHRbIGRzdE9mZnNldCArKyBdID0gdmFsdWVzWyBzcmNPZmZzZXQgKyBqIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fSxcblxuXHQvLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xuXHRmbGF0dGVuSlNPTjogZnVuY3Rpb24oIGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSApIHtcblxuXHRcdHZhciBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcblxuXHRcdHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgJiYga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0XHR2YXIgdmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXG5cblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cblx0XHRcdGRvIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHRcdHZhbHVlcy5wdXNoLmFwcGx5KCB2YWx1ZXMsIHZhbHVlICk7IC8vIHB1c2ggYWxsIGVsZW1lbnRzXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cblx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG5cdFx0fSBlbHNlIGlmICggdmFsdWUudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXG5cblx0XHRcdGRvIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuXHRcdFx0XHRcdHZhbHVlLnRvQXJyYXkoIHZhbHVlcywgdmFsdWVzLmxlbmd0aCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG5cdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xuXG5cdFx0XHRkbyB7XG5cblx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vS2V5ZnJhbWVUcmFjay5qc1xuXG4vKipcbiAqXG4gKiBBIHRpbWVkIHNlcXVlbmNlIG9mIGtleWZyYW1lcyBmb3IgYSBzcGVjaWZpYyBwcm9wZXJ0eS5cbiAqXG4gKlxuICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICogQGF1dGhvciB0c2Nod1xuICovXG5cblRIUkVFLktleWZyYW1lVHJhY2sgPSBmdW5jdGlvbiAoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cblx0aWYoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggXCJ0cmFjayBuYW1lIGlzIHVuZGVmaW5lZFwiICk7XG5cblx0aWYoIHRpbWVzID09PSB1bmRlZmluZWQgfHwgdGltZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcblxuXHR9XG5cblx0dGhpcy5uYW1lID0gbmFtZTtcblxuXHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xuXHR0aGlzLnZhbHVlcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdmFsdWVzLCB0aGlzLlZhbHVlQnVmZmVyVHlwZSApO1xuXG5cdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XG5cblx0dGhpcy52YWxpZGF0ZSgpO1xuXHR0aGlzLm9wdGltaXplKCk7XG5cbn07XG5cblRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5LZXlmcmFtZVRyYWNrLFxuXG5cdFRpbWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXG5cdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxuXG5cdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBUSFJFRS5JbnRlcnBvbGF0ZUxpbmVhcixcblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuRGlzY3JldGVJbnRlcnBvbGFudChcblx0XHRcdFx0dGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH0sXG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lYXJJbnRlcnBvbGFudChcblx0XHRcdFx0dGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG5cdH0sXG5cblx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiBmdW5jdGlvbiggcmVzdWx0ICkge1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5DdWJpY0ludGVycG9sYW50KFxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0fSxcblxuXHRzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdHZhciBmYWN0b3J5TWV0aG9kID0gdW5kZWZpbmVkO1xuXG5cdFx0c3dpdGNoICggaW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0Y2FzZSBUSFJFRS5JbnRlcnBvbGF0ZURpc2NyZXRlOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlO1xuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFRIUkVFLkludGVycG9sYXRlTGluZWFyOlxuXG5cdFx0XHRcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBUSFJFRS5JbnRlcnBvbGF0ZVNtb290aDpcblxuXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0XHRpZiAoIGZhY3RvcnlNZXRob2QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIG1lc3NhZ2UgPSBcInVuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yIFwiICtcblx0XHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcIiArIHRoaXMubmFtZTtcblxuXHRcdFx0aWYgKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gZmFsbCBiYWNrIHRvIGRlZmF1bHQsIHVubGVzcyB0aGUgZGVmYXVsdCBpdHNlbGYgaXMgbWVzc2VkIHVwXG5cdFx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuXHRcdFx0XHRcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTsgLy8gZmF0YWwsIGluIHRoaXMgY2FzZVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xuXG5cdH0sXG5cblx0Z2V0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24oKSB7XG5cblx0XHRzd2l0Y2ggKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ICkge1xuXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU6XG5cblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlRGlzY3JldGU7XG5cblx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XG5cblx0XHRcdFx0cmV0dXJuIFRIUkVFLkludGVycG9sYXRlTGluZWFyO1xuXG5cdFx0XHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5JbnRlcnBvbGF0ZVNtb290aDtcblxuXHRcdH1cblxuXHR9LFxuXG5cdGdldFZhbHVlU2l6ZTogZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XG5cblx0fSxcblxuXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG5cdHNoaWZ0OiBmdW5jdGlvbiggdGltZU9mZnNldCApIHtcblxuXHRcdGlmKCB0aW1lT2Zmc2V0ICE9PSAwLjAgKSB7XG5cblx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XG5cblx0XHRcdGZvciggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdHRpbWVzWyBpIF0gKz0gdGltZU9mZnNldDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyBzY2FsZSBhbGwga2V5ZnJhbWUgdGltZXMgYnkgYSBmYWN0b3IgKHVzZWZ1bCBmb3IgZnJhbWUgPC0+IHNlY29uZHMgY29udmVyc2lvbnMpXG5cdHNjYWxlOiBmdW5jdGlvbiggdGltZVNjYWxlICkge1xuXG5cdFx0aWYoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xuXG5cdFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xuXG5cdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cblx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuXHR0cmltOiBmdW5jdGlvbiggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xuXG5cdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblx0XHR2YXIgbktleXMgPSB0aW1lcy5sZW5ndGg7XG5cblx0XHR2YXIgZmlyc3RLZXlzVG9SZW1vdmUgPSAwO1xuXHRcdGZvciAoIHZhciBpID0gMTsgaSAhPT0gbktleXM7ICsrIGkgKSB7XG5cblx0XHRcdGlmICggdGltZXNbaV0gPD0gc3RhcnRUaW1lICkgKysgZmlyc3RLZXlzVG9SZW1vdmU7XG5cblx0XHR9XG5cblx0XHR2YXIgbGFzdEtleXNUb1JlbW92ZSA9IDA7XG5cdFx0Zm9yICggdmFyIGkgPSBuS2V5cyAtIDI7IGkgIT09IDA7IC0tIGkgKSB7XG5cblx0XHRcdGlmICggdGltZXNbaV0gPj0gZW5kVGltZSApICsrIGxhc3RLZXlzVG9SZW1vdmU7XG5cdFx0XHRlbHNlIGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGxhc3Qga2V5cyBmaXJzdCBiZWNhdXNlIGl0IGRvZXNuJ3QgYWZmZWN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qga2V5cyAodGhlIG90aGVyd2F5IGFyb3VuZCBkb2Vzbid0IHdvcmsgYXMgZWFzaWx5KVxuXHRcdGlmKCAoIGZpcnN0S2V5c1RvUmVtb3ZlICsgbGFzdEtleXNUb1JlbW92ZSApICE9PSAwICkge1xuXG5cdFx0XHR2YXIgZnJvbSA9IGZpcnN0S2V5c1RvUmVtb3ZlO1xuXHRcdFx0dmFyIHRvID0gbktleXMgLSBsYXN0S2V5c1RvUmVtb3ZlIC0gZmlyc3RLZXlzVG9SZW1vdmU7XG5cblx0XHRcdHRoaXMudGltZXMgPSBUSFJFRS5BbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgZnJvbSwgdG8gKTtcblxuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuXHRcdFx0dmFyIHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IFRIUkVFLkFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHZhbHVlcywgZnJvbSAqIHN0cmlkZSwgdG8gKiBzdHJpZGUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0Ly8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuXHR2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdmFsaWQgPSB0cnVlO1xuXG5cdFx0dmFyIHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG5cdFx0aWYgKCB2YWx1ZVNpemUgLSBNYXRoLmZsb29yKCB2YWx1ZVNpemUgKSAhPT0gMCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJpbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2tcIiwgdGhpcyApO1xuXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcblxuXHRcdFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XG5cblx0XHRpZiggbktleXMgPT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwidHJhY2sgaXMgZW1wdHlcIiwgdGhpcyApO1xuXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHZhciBwcmV2VGltZSA9IG51bGw7XG5cblx0XHRmb3IoIHZhciBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjdXJyVGltZSA9IHRpbWVzWyBpIF07XG5cblx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcInRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIGN1cnJUaW1lICk7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmKCBwcmV2VGltZSAhPT0gbnVsbCAmJiBwcmV2VGltZSA+IGN1cnJUaW1lICkge1xuXG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwib3V0IG9mIG9yZGVyIGtleXNcIiwgdGhpcywgaSwgY3VyclRpbWUsIHByZXZUaW1lICk7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByZXZUaW1lID0gY3VyclRpbWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpZiAoIFRIUkVFLkFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggdmFsdWVzICkgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1sgaSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ2YWx1ZSBpcyBub3QgYSB2YWxpZCBudW1iZXJcIiwgdGhpcywgaSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB2YWxpZDtcblxuXHR9LFxuXG5cdC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcblx0Ly8gKDAsMCwwLDAsMSwxLDEsMCwwLDAsMCwwLDAsMCkgLS0+ICgwLDAsMSwxLDAsMClcblx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcblx0XHRcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxuXHRcdFx0c3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKSxcblxuXHRcdFx0d3JpdGVJbmRleCA9IDE7XG5cblx0XHRmb3IoIHZhciBpID0gMSwgbiA9IHRpbWVzLmxlbmd0aCAtIDE7IGkgPD0gbjsgKysgaSApIHtcblxuXHRcdFx0dmFyIGtlZXAgPSBmYWxzZTtcblxuXHRcdFx0dmFyIHRpbWUgPSB0aW1lc1sgaSBdO1xuXHRcdFx0dmFyIHRpbWVOZXh0ID0gdGltZXNbIGkgKyAxIF07XG5cblx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcblxuXHRcdFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZVsgMCBdICkgKSB7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxuXHRcdFx0XHRcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XG5cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNbIG9mZnNldCArIGogXTtcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0UCArIGogXSB8fFxuXHRcdFx0XHRcdFx0XHR2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXROICsgaiBdICkge1xuXG5cdFx0XHRcdFx0XHRrZWVwID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbi1wbGFjZSBjb21wYWN0aW9uXG5cblx0XHRcdGlmICgga2VlcCApIHtcblxuXHRcdFx0XHRpZiAoIGkgIT09IHdyaXRlSW5kZXggKSB7XG5cblx0XHRcdFx0XHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGkgXTtcblxuXHRcdFx0XHRcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcblx0XHRcdFx0XHRcdHdyaXRlT2Zmc2V0ID0gd3JpdGVJbmRleCAqIHN0cmlkZTtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZXNbIHdyaXRlT2Zmc2V0ICsgaiBdID0gdmFsdWVzWyByZWFkT2Zmc2V0ICsgaiBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xuXG5cdFx0XHR0aGlzLnRpbWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIDAsIHdyaXRlSW5kZXggKTtcblx0XHRcdHRoaXMudmFsdWVzID0gVEhSRUUuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9XG5cbn07XG5cbi8vIFN0YXRpYyBtZXRob2RzOlxuXG5PYmplY3QuYXNzaWduKCBUSFJFRS5LZXlmcmFtZVRyYWNrLCB7XG5cblx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuXHQvLyBhbmQgYXV0b21hdGljIGludm9jYXRpb24gb2YgLnRvSlNPTik6XG5cblx0cGFyc2U6IGZ1bmN0aW9uKCBqc29uICkge1xuXG5cdFx0aWYoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2VcIiApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHRyYWNrVHlwZSA9IFRIUkVFLktleWZyYW1lVHJhY2suX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG5cdFx0aWYgKCBqc29uLnRpbWVzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggXCJsZWdhY3kgSlNPTiBmb3JtYXQgZGV0ZWN0ZWQsIGNvbnZlcnRpbmdcIiApO1xuXG5cdFx0XHR2YXIgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XG5cblx0XHRcdFRIUkVFLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBqc29uLmtleXMsIHRpbWVzLCB2YWx1ZXMsICd2YWx1ZScgKTtcblxuXHRcdFx0anNvbi50aW1lcyA9IHRpbWVzO1xuXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cblx0XHR9XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyBwYXJzZSBtZXRob2Rcblx0XHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3NzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXG5cdFx0XHRyZXR1cm4gbmV3IHRyYWNrVHlwZShcblx0XHRcdFx0XHRqc29uLm5hbWUsIGpzb24udGltZXMsIGpzb24udmFsdWVzLCBqc29uLmludGVycG9sYXRpb24gKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24oIHRyYWNrICkge1xuXG5cdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXG5cdFx0dmFyIGpzb247XG5cblx0XHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXG5cdFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGpzb24gPSB0cmFja1R5cGUudG9KU09OKCB0cmFjayApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXG5cdFx0XHRqc29uID0ge1xuXG5cdFx0XHRcdCduYW1lJzogdHJhY2submFtZSxcblx0XHRcdFx0J3RpbWVzJzogVEhSRUUuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay50aW1lcywgQXJyYXkgKSxcblx0XHRcdFx0J3ZhbHVlcyc6IFRIUkVFLkFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdHJhY2sudmFsdWVzLCBBcnJheSApXG5cblx0XHRcdH07XG5cblx0XHRcdHZhciBpbnRlcnBvbGF0aW9uID0gdHJhY2suZ2V0SW50ZXJwb2xhdGlvbigpO1xuXG5cdFx0XHRpZiAoIGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxuXG5cdFx0cmV0dXJuIGpzb247XG5cblx0fSxcblxuXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24oIHR5cGVOYW1lICkge1xuXG5cdFx0c3dpdGNoKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXG5cdFx0XHRjYXNlIFwic2NhbGFyXCI6XG5cdFx0XHRjYXNlIFwiZG91YmxlXCI6XG5cdFx0XHRjYXNlIFwiZmxvYXRcIjpcblx0XHRcdGNhc2UgXCJudW1iZXJcIjpcblx0XHRcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cblx0XHRcdFx0cmV0dXJuIFRIUkVFLk51bWJlcktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgXCJ2ZWN0b3JcIjpcblx0XHRcdGNhc2UgXCJ2ZWN0b3IyXCI6XG5cdFx0XHRjYXNlIFwidmVjdG9yM1wiOlxuXHRcdFx0Y2FzZSBcInZlY3RvcjRcIjpcblxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcImNvbG9yXCI6XG5cblx0XHRcdFx0cmV0dXJuIFRIUkVFLkNvbG9yS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcInF1YXRlcm5pb25cIjpcblxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG5cblx0XHRcdGNhc2UgXCJib29sXCI6XG5cdFx0XHRjYXNlIFwiYm9vbGVhblwiOlxuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjaztcblxuXHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxuXG5cdFx0XHRcdHJldHVybiBUSFJFRS5TdHJpbmdLZXlmcmFtZVRyYWNrO1xuXG5cdFx0fTtcblxuXHRcdHRocm93IG5ldyBFcnJvciggXCJVbnN1cHBvcnRlZCB0eXBlTmFtZTogXCIgKyB0eXBlTmFtZSApO1xuXG5cdH1cblxufSApO1xuXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vUHJvcGVydHlCaW5kaW5nLmpzXG5cbi8qKlxuICpcbiAqIEEgcmVmZXJlbmNlIHRvIGEgcmVhbCBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcgPSBmdW5jdGlvbiAoIHJvb3ROb2RlLCBwYXRoLCBwYXJzZWRQYXRoICkge1xuXG5cdHRoaXMucGF0aCA9IHBhdGg7XG5cdHRoaXMucGFyc2VkUGF0aCA9IHBhcnNlZFBhdGggfHxcblx0XHRcdFRIUkVFLlByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xuXG5cdHRoaXMubm9kZSA9IFRIUkVFLlByb3BlcnR5QmluZGluZy5maW5kTm9kZShcblx0XHRcdHJvb3ROb2RlLCB0aGlzLnBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCByb290Tm9kZTtcblxuXHR0aGlzLnJvb3ROb2RlID0gcm9vdE5vZGU7XG5cbn07XG5cblRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlByb3BlcnR5QmluZGluZyxcblxuXHRnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcblxuXHRcdHRoaXMuYmluZCgpO1xuXHRcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcblxuXHRcdC8vIE5vdGU6IFRoaXMgY2xhc3MgdXNlcyBhIFN0YXRlIHBhdHRlcm4gb24gYSBwZXItbWV0aG9kIGJhc2lzOlxuXHRcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXG5cdFx0Ly8gcHJvdG90eXBlIHZlcnNpb24gb2YgdGhlc2UgbWV0aG9kcyB3aXRoIG9uZSB0aGF0IHJlcHJlc2VudHNcblx0XHQvLyB0aGUgYm91bmQgc3RhdGUuIFdoZW4gdGhlIHByb3BlcnR5IGlzIG5vdCBmb3VuZCwgdGhlIG1ldGhvZHNcblx0XHQvLyBiZWNvbWUgbm8tb3BzLlxuXG5cdH0sXG5cblx0c2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlX3VuYm91bmQoIHNvdXJjZUFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR0aGlzLmJpbmQoKTtcblx0XHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XG5cblx0fSxcblxuXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG5cdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcblx0XHRcdHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGgsXG5cblx0XHRcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXG5cdFx0XHRwcm9wZXJ0eU5hbWUgPSBwYXJzZWRQYXRoLnByb3BlcnR5TmFtZSxcblx0XHRcdHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XG5cblx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xuXG5cdFx0XHR0YXJnZXRPYmplY3QgPSBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoXG5cdFx0XHRcdFx0dGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHRoaXMucm9vdE5vZGU7XG5cblx0XHRcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYXZhaWxhYmxlO1xuXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmF2YWlsYWJsZTtcblxuIFx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG5cdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6IFwiICsgdGhpcy5wYXRoICsgXCIgYnV0IGl0IHdhc24ndCBmb3VuZC5cIiApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYoIG9iamVjdE5hbWUgKSB7XG5cblx0XHRcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XG5cblx0XHRcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cblx0XHRcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnbWF0ZXJpYWxzJzpcblxuXHRcdFx0XHRcdGlmKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsIGFzIG5vZGUgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFsJywgdGhpcyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXknLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYm9uZXMnOlxuXG5cdFx0XHRcdFx0aWYoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24nLCB0aGlzICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyXG5cdFx0XHRcdFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG5cdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0LnNrZWxldG9uLmJvbmVzO1xuXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxuXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0W2ldLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG5cdFx0XHRcdFx0XHRcdG9iamVjdEluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUsIHVuZGVmaW5lZCcsIHRoaXMgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiICB0cnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkOlwiLCB0aGlzLCB0YXJnZXRPYmplY3QgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gcmVzb2x2ZSBwcm9wZXJ0eVxuXHRcdHZhciBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbIHByb3BlcnR5TmFtZSBdO1xuXG5cdFx0aWYgKCAhIG5vZGVQcm9wZXJ0eSApIHtcblxuXHRcdFx0dmFyIG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIHRyeWluZyB0byB1cGRhdGUgcHJvcGVydHkgZm9yIHRyYWNrOiBcIiArIG5vZGVOYW1lICtcblx0XHRcdFx0XHQnLicgKyBwcm9wZXJ0eU5hbWUgKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiLCB0YXJnZXRPYmplY3QgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdC8vIGRldGVybWluZSB2ZXJzaW9uaW5nIHNjaGVtZVxuXHRcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XG5cblx0XHRpZiAoIHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBtYXRlcmlhbFxuXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xuXHRcdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cblx0XHR9IGVsc2UgaWYgKCB0YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBub2RlIHRyYW5zZm9ybVxuXG5cdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cdFx0XHR0aGlzLnRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdDtcblxuXHRcdH1cblxuXHRcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcblx0XHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcblxuXHRcdGlmICggcHJvcGVydHlJbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXG5cblx0XHRcdGlmICggcHJvcGVydHlOYW1lID09PSBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiICkge1xuXHRcdFx0XHQvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uLCBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXIsIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cblxuXHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG5cdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5JywgdGhpcyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cycsIHRoaXMgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzW2ldLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XG5cblx0XHRcdFx0XHRcdHByb3BlcnR5SW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cblx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcblx0XHRcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cblxuXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkhhc0Zyb21Ub0FycmF5O1xuXG5cdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cblx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcblxuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cblx0XHR9XG5cblx0XHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVsgYmluZGluZ1R5cGUgXTtcblx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xuXG5cdH0sXG5cblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cblx0XHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXG5cdFx0Ly8gbm90ZTogYXZvaWRpbmcgdG8gbXV0YXRlIHRoZSBzaGFwZSBvZiAndGhpcycgdmlhICdkZWxldGUnXG5cdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG5cdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XG5cblx0fVxuXG59O1xuXG5PYmplY3QuYXNzaWduKCBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLCB7IC8vIHByb3RvdHlwZSwgY29udGludWVkXG5cblx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXCJiaW5kXCIgYSBub25leGlzdGVudCBwcm9wZXJ0eVxuXHRfZ2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXG5cdF9zZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24oKSB7fSxcblxuXHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcblx0X2dldFZhbHVlX3VuYm91bmQ6IFRIUkVFLlByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUsXG5cdF9zZXRWYWx1ZV91bmJvdW5kOiBUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxuXG5cdEJpbmRpbmdUeXBlOiB7XG5cdFx0RGlyZWN0OiAwLFxuXHRcdEVudGlyZUFycmF5OiAxLFxuXHRcdEFycmF5RWxlbWVudDogMixcblx0XHRIYXNGcm9tVG9BcnJheTogM1xuXHR9LFxuXG5cdFZlcnNpb25pbmc6IHtcblx0XHROb25lOiAwLFxuXHRcdE5lZWRzVXBkYXRlOiAxLFxuXHRcdE1hdHJpeFdvcmxkTmVlZHNVcGRhdGU6IDJcblx0fSxcblxuXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXG5cdFx0fSxcblxuXHRcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArKyBdID0gc291cmNlWyBpIF07XG5cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcblxuXHRcdH0sXG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZV90b0FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0XSxcblxuXHRTZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZzogW1xuXG5cdFx0W1xuXHRcdFx0Ly8gRGlyZWN0XG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLm5vZGVbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XSwgW1xuXG5cdFx0XHQvLyBFbnRpcmVBcnJheVxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cblx0XHRcdFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuXHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRdLCBbXG5cblx0XHRcdC8vIEFycmF5RWxlbWVudFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnQoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH0sXG5cblx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcblx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdF0sIFtcblxuXHRcdFx0Ly8gSGFzVG9Gcm9tQXJyYXlcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0fSxcblxuXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRdXG5cblx0XVxuXG59ICk7XG5cblRIUkVFLlByb3BlcnR5QmluZGluZy5Db21wb3NpdGUgPVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xuXG5cdHZhciBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8XG5cdFx0XHRUSFJFRS5Qcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcblxuXHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuXHR0aGlzLl9iaW5kaW5ncyA9IHRhcmdldEdyb3VwLnN1YnNjcmliZV8oIHBhdGgsIHBhcnNlZFBhdGggKTtcblxufTtcblxuVEhSRUUuUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlByb3BlcnR5QmluZGluZy5Db21wb3NpdGUsXG5cblx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCBhcnJheSwgb2Zmc2V0ICkge1xuXG5cdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcblxuXHRcdHZhciBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xuXG5cdFx0Ly8gYW5kIG9ubHkgY2FsbCAuZ2V0VmFsdWUgb24gdGhlIGZpcnN0XG5cdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSBiaW5kaW5nLmdldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0fSxcblxuXHRzZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cblx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuXHRcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG5cdFx0XHRiaW5kaW5nc1sgaSBdLnNldFZhbHVlKCBhcnJheSwgb2Zmc2V0ICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRiaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG5cdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG5cdFx0XHRcdG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cblx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5Qcm9wZXJ0eUJpbmRpbmcuY3JlYXRlID0gZnVuY3Rpb24oIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cblx0aWYgKCAhICggcm9vdCBpbnN0YW5jZW9mIFRIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwICkgKSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlByb3BlcnR5QmluZGluZyggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRyZXR1cm4gbmV3IFRIUkVFLlByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLlByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSA9IGZ1bmN0aW9uKCB0cmFja05hbWUgKSB7XG5cblx0Ly8gbWF0Y2hlcyBzdHJpbmdzIGluIHRoZSBmb3JtIG9mOlxuXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVxuXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cblx0Ly8gICAgbm9kZU5hbWUubWF0ZXJpYWwucHJvcGVydHlbYWNjZXNzb3JdXG5cdC8vICAgIHV1aWQucHJvcGVydHlbYWNjZXNzb3JdXG5cdC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXG5cdC8vICAgIHBhcmVudE5hbWUvbm9kZU5hbWUucHJvcGVydHlcblx0Ly8gICAgcGFyZW50TmFtZS9wYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5W2luZGV4XVxuXHQvL1x0ICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxuXHQvLyBjcmVhdGVkIGFuZCB0ZXN0ZWQgdmlhIGh0dHBzOi8vcmVnZXgxMDEuY29tLyNqYXZhc2NyaXB0XG5cblx0dmFyIHJlID0gL14oKFtcXHddK1xcLykqKShbXFx3LVxcZF0rKT8oXFwuKFtcXHddKykoXFxbKFtcXHdcXGRcXFtcXF1cXF8uIF0rKVxcXSk/KT8oXFwuKFtcXHcuXSspKFxcWyhbXFx3XFxkXFxbXFxdXFxfLiBdKylcXF0pPykkLztcblx0dmFyIG1hdGNoZXMgPSByZS5leGVjKHRyYWNrTmFtZSk7XG5cblx0aWYoICEgbWF0Y2hlcyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2Fubm90IHBhcnNlIHRyYWNrTmFtZSBhdCBhbGw6IFwiICsgdHJhY2tOYW1lICk7XG5cdH1cblxuICAgIGlmIChtYXRjaGVzLmluZGV4ID09PSByZS5sYXN0SW5kZXgpIHtcbiAgICAgICAgcmUubGFzdEluZGV4Kys7XG4gICAgfVxuXG5cdHZhciByZXN1bHRzID0ge1xuXHRcdC8vIGRpcmVjdG9yeU5hbWU6IG1hdGNoZXNbMV0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxuXHRcdG5vZGVOYW1lOiBtYXRjaGVzWzNdLCBcdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVkIHJvb3Qgbm9kZS5cblx0XHRvYmplY3ROYW1lOiBtYXRjaGVzWzVdLFxuXHRcdG9iamVjdEluZGV4OiBtYXRjaGVzWzddLFxuXHRcdHByb3BlcnR5TmFtZTogbWF0Y2hlc1s5XSxcblx0XHRwcm9wZXJ0eUluZGV4OiBtYXRjaGVzWzExXVx0Ly8gYWxsb3dlZCB0byBiZSBudWxsLCBzcGVjaWZpZXMgdGhhdCB0aGUgd2hvbGUgcHJvcGVydHkgaXMgc2V0LlxuXHR9O1xuXG5cdGlmKCByZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDAgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbiBub3QgcGFyc2UgcHJvcGVydHlOYW1lIGZyb20gdHJhY2tOYW1lOiBcIiArIHRyYWNrTmFtZSApO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG5cbn07XG5cblRIUkVFLlByb3BlcnR5QmluZGluZy5maW5kTm9kZSA9IGZ1bmN0aW9uKCByb290LCBub2RlTmFtZSApIHtcblxuXHRpZiggISBub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gXCJcIiB8fCBub2RlTmFtZSA9PT0gXCJyb290XCIgfHwgbm9kZU5hbWUgPT09IFwiLlwiIHx8IG5vZGVOYW1lID09PSAtMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XG5cblx0XHRyZXR1cm4gcm9vdDtcblxuXHR9XG5cblx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXG5cdGlmKCByb290LnNrZWxldG9uICkge1xuXG5cdFx0dmFyIHNlYXJjaFNrZWxldG9uID0gZnVuY3Rpb24oIHNrZWxldG9uICkge1xuXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHNrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzW2ldO1xuXG5cdFx0XHRcdGlmKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGJvbmU7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH07XG5cblx0XHR2YXIgYm9uZSA9IHNlYXJjaFNrZWxldG9uKCByb290LnNrZWxldG9uICk7XG5cblx0XHRpZiggYm9uZSApIHtcblxuXHRcdFx0cmV0dXJuIGJvbmU7XG5cblx0XHR9XG5cdH1cblxuXHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXG5cdGlmKCByb290LmNoaWxkcmVuICkge1xuXG5cdFx0dmFyIHNlYXJjaE5vZGVTdWJ0cmVlID0gZnVuY3Rpb24oIGNoaWxkcmVuICkge1xuXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG5cblx0XHRcdFx0aWYoIGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gY2hpbGROb2RlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoIGNoaWxkTm9kZS5jaGlsZHJlbiApO1xuXG5cdFx0XHRcdGlmKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fTtcblxuXHRcdHZhciBzdWJUcmVlTm9kZSA9IHNlYXJjaE5vZGVTdWJ0cmVlKCByb290LmNoaWxkcmVuICk7XG5cblx0XHRpZiggc3ViVHJlZU5vZGUgKSB7XG5cblx0XHRcdHJldHVybiBzdWJUcmVlTm9kZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG5cbn1cblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL1Byb3BlcnR5TWl4ZXIuanNcblxuLyoqXG4gKlxuICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuUHJvcGVydHlNaXhlciA9IGZ1bmN0aW9uICggYmluZGluZywgdHlwZU5hbWUsIHZhbHVlU2l6ZSApIHtcblxuXHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHR0aGlzLnZhbHVlU2l6ZSA9IHZhbHVlU2l6ZTtcblxuXHR2YXIgYnVmZmVyVHlwZSA9IEZsb2F0NjRBcnJheSxcblx0XHRtaXhGdW5jdGlvbjtcblxuXHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcblxuXHRcdGNhc2UgJ3F1YXRlcm5pb24nOlx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2xlcnA7XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRjYXNlICdib29sJzpcblxuXHRcdFx0YnVmZmVyVHlwZSA9IEFycmF5LFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NlbGVjdDtcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0Olx0XHRcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX2xlcnA7XG5cblx0fVxuXG5cdHRoaXMuYnVmZmVyID0gbmV3IGJ1ZmZlclR5cGUoIHZhbHVlU2l6ZSAqIDQgKTtcblx0Ly8gbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgXVxuXHQvL1xuXHQvLyBpbnRlcnBvbGF0b3JzIGNhbiB1c2UgLmJ1ZmZlciBhcyB0aGVpciAucmVzdWx0XG5cdC8vIHRoZSBkYXRhIHRoZW4gZ29lcyB0byAnaW5jb21pbmcnXG5cdC8vXG5cdC8vICdhY2N1MCcgYW5kICdhY2N1MScgYXJlIHVzZWQgZnJhbWUtaW50ZXJsZWF2ZWQgZm9yXG5cdC8vIHRoZSBjdW11bGF0aXZlIHJlc3VsdCBhbmQgYXJlIGNvbXBhcmVkIHRvIGRldGVjdFxuXHQvLyBjaGFuZ2VzXG5cdC8vXG5cdC8vICdvcmlnJyBzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBwcm9wZXJ0eVxuXG5cdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXG5cdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cblx0dGhpcy51c2VDb3VudCA9IDA7XG5cdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xuXG59O1xuXG5USFJFRS5Qcm9wZXJ0eU1peGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuUHJvcGVydHlNaXhlcixcblxuXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXG5cdGFjY3VtdWxhdGU6IGZ1bmN0aW9uKCBhY2N1SW5kZXgsIHdlaWdodCApIHtcblxuXHRcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXG5cdFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcblxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG5cdFx0XHRjdXJyZW50V2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0O1xuXG5cdFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBpbmNvbWluZyAqIHdlaWdodFxuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cblx0XHRcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xuXHRcdFx0dmFyIG1peCA9IHdlaWdodCAvIGN1cnJlbnRXZWlnaHQ7XG5cdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gY3VycmVudFdlaWdodDtcblxuXHR9LFxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBvZiAnYWNjdTxpPicgdG8gdGhlIGJpbmRpbmcgd2hlbiBhY2N1cyBkaWZmZXJcblx0YXBwbHk6IGZ1bmN0aW9uKCBhY2N1SW5kZXggKSB7XG5cblx0XHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cdFx0XHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdG9mZnNldCA9IGFjY3VJbmRleCAqIHN0cmlkZSArIHN0cmlkZSxcblxuXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXG5cdFx0XHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHRcdGlmICggd2VpZ2h0IDwgMSApIHtcblxuXHRcdFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBvcmlnaW5hbCAqICggMSAtIGN1bXVsYXRpdmVXZWlnaHQgKVxuXG5cdFx0XHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XG5cblx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcblx0XHRcdFx0XHRidWZmZXIsIG9mZnNldCwgb3JpZ2luYWxWYWx1ZU9mZnNldCwgMSAtIHdlaWdodCwgc3RyaWRlICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XG5cblx0XHRcdFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXG5cblx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9LFxuXG5cdC8vIHJlbWVtYmVyIHRoZSBzdGF0ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkgYW5kIGNvcHkgaXQgdG8gYm90aCBhY2N1c1xuXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZztcblxuXHRcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG5cdFx0XHRvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcblxuXHRcdGJpbmRpbmcuZ2V0VmFsdWUoIGJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xuXG5cdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuXHRcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcblxuXHRcdFx0YnVmZmVyWyBpIF0gPSBidWZmZXJbIG9yaWdpbmFsVmFsdWVPZmZzZXQgKyAoIGkgJSBzdHJpZGUgKSBdO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcblxuXHR9LFxuXG5cdC8vIGFwcGx5IHRoZSBzdGF0ZSBwcmV2aW91c2x5IHRha2VuIHZpYSAnc2F2ZU9yaWdpbmFsU3RhdGUnIHRvIHRoZSBiaW5kaW5nXG5cdHJlc3RvcmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gdGhpcy52YWx1ZVNpemUgKiAzO1xuXHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuXHR9LFxuXG5cblx0Ly8gbWl4IGZ1bmN0aW9uc1xuXG5cdF9zZWxlY3Q6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHRpZiAoIHQgPj0gMC41ICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuXHRcdFx0XHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHRfc2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHRUSFJFRS5RdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsXG5cdFx0XHRcdGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCApO1xuXG5cdH0sXG5cblx0X2xlcnA6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cblx0XHR2YXIgcyA9IDEgLSB0O1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cblx0XHRcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcblxuXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL0Jvb2xlYW5LZXlmcmFtZVRyYWNrLmpzXG5cbi8qKlxuICpcbiAqIEEgVHJhY2sgb2YgQm9vbGVhbiBrZXlmcmFtZSB2YWx1ZXMuXG4gKlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5USFJFRS5Cb29sZWFuS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcyApIHtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxufTtcblxuVEhSRUUuQm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkJvb2xlYW5LZXlmcmFtZVRyYWNrLFxuXG5cdFZhbHVlVHlwZU5hbWU6ICdib29sJyxcblx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcblxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXBvbGF0ZURpc2NyZXRlLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxuXG5cdC8vIE5vdGU6IEFjdHVhbGx5IHRoaXMgdHJhY2sgY291bGQgaGF2ZSBhIG9wdGltaXplZCAvIGNvbXByZXNzZWRcblx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcblx0Ly8gY29tcHV0ZXMgXCJmaXJzdFZhbHVlIF4gaXNPZGQoIGluZGV4IClcIi5cblxufSApO1xuXG4vLyBGaWxlOnNyYy9hbmltYXRpb24vdHJhY2tzL051bWJlcktleWZyYW1lVHJhY2suanNcblxuLyoqXG4gKlxuICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufTtcblxuVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTnVtYmVyS2V5ZnJhbWVUcmFjayxcblxuXHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJyxcblxuXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5qc1xuXG4vKipcbiAqXG4gKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxuICpcbiAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAqIEBhdXRob3IgdHNjaHdcbiAqL1xuXG5USFJFRS5RdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufTtcblxuVEhSRUUuUXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cblx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUSFJFRS5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLFxuXG5cdFZhbHVlVHlwZU5hbWU6ICdxdWF0ZXJuaW9uJyxcblxuXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cblx0RGVmYXVsdEludGVycG9sYXRpb246IFRIUkVFLkludGVycG9sYXRlTGluZWFyLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KFxuXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cblx0fSxcblxuXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZCAvLyBub3QgeWV0IGltcGxlbWVudGVkXG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9TdHJpbmdLZXlmcmFtZVRyYWNrLmpzXG5cbi8qKlxuICpcbiAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufTtcblxuVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuU3RyaW5nS2V5ZnJhbWVUcmFjayxcblxuXHRWYWx1ZVR5cGVOYW1lOiAnc3RyaW5nJyxcblx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcblxuXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogVEhSRUUuSW50ZXBvbGF0ZURpc2NyZXRlLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxuXG5cdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXG5cbn0gKTtcblxuLy8gRmlsZTpzcmMvYW5pbWF0aW9uL3RyYWNrcy9WZWN0b3JLZXlmcmFtZVRyYWNrLmpzXG5cbi8qKlxuICpcbiAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxuICpcbiAqXG4gKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gKiBAYXV0aG9yIHRzY2h3XG4gKi9cblxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IGZ1bmN0aW9uICggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuXHRUSFJFRS5LZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxufTtcblxuVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFRIUkVFLktleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yS2V5ZnJhbWVUcmFjayxcblxuXHRWYWx1ZVR5cGVOYW1lOiAndmVjdG9yJ1xuXG5cdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxufSApO1xuXG4vLyBGaWxlOnNyYy9hdWRpby9BdWRpby5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQXVkaW8gPSBmdW5jdGlvbiAoIGxpc3RlbmVyICkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQXVkaW8nO1xuXG5cdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG5cdHRoaXMuc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuXHR0aGlzLnNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcblxuXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuXHR0aGlzLmdhaW4uY29ubmVjdCggbGlzdGVuZXIuZ2V0SW5wdXQoKSApO1xuXG5cdHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcblxuXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG5cdHRoaXMucGxheWJhY2tSYXRlID0gMTtcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuXHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xuXG5cdHRoaXMuZmlsdGVyID0gbnVsbDtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldE91dHB1dCA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gdGhpcy5nYWluO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggZmlsZSApIHtcblxuXHR2YXIgYnVmZmVyID0gbmV3IFRIUkVFLkF1ZGlvQnVmZmVyKCB0aGlzLmNvbnRleHQgKTtcblx0YnVmZmVyLmxvYWQoIGZpbGUgKTtcblxuXHR0aGlzLnNldEJ1ZmZlciggYnVmZmVyICk7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXROb2RlU291cmNlID0gZnVuY3Rpb24gKCBhdWRpb05vZGUgKSB7XG5cblx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcblx0dGhpcy5zb3VyY2VUeXBlID0gJ2F1ZGlvTm9kZSc7XG5cdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xuXHR0aGlzLmNvbm5lY3QoKTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldEJ1ZmZlciA9IGZ1bmN0aW9uICggYXVkaW9CdWZmZXIgKSB7XG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRhdWRpb0J1ZmZlci5vblJlYWR5KCBmdW5jdGlvbiggYnVmZmVyICkge1xuXG5cdFx0c2NvcGUuc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcblx0XHRzY29wZS5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XG5cdFx0aWYgKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcblxuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcblx0XHRyZXR1cm47XG5cblx0fVxuXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdHJldHVybjtcblxuXHR9XG5cblx0dmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuXHRzb3VyY2UuYnVmZmVyID0gdGhpcy5zb3VyY2UuYnVmZmVyO1xuXHRzb3VyY2UubG9vcCA9IHRoaXMuc291cmNlLmxvb3A7XG5cdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcblx0c291cmNlLnN0YXJ0KCAwLCB0aGlzLnN0YXJ0VGltZSApO1xuXHRzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cblx0dGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdHRoaXMuc291cmNlID0gc291cmNlO1xuXG5cdHRoaXMuY29ubmVjdCgpO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHR0aGlzLnNvdXJjZS5zdG9wKCk7XG5cdHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcblx0XHRyZXR1cm47XG5cblx0fVxuXG5cdHRoaXMuc291cmNlLnN0b3AoKTtcblx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xuXG5cdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cblx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHZhbHVlID0gbnVsbDtcblxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0dGhpcy5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcblx0XHR0aGlzLmNvbm5lY3QoKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5maWx0ZXIgPSB2YWx1ZTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRQbGF5YmFja1JhdGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdHJldHVybjtcblxuXHR9XG5cblx0dGhpcy5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG5cdFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gdGhpcy5wbGF5YmFja1JhdGU7XG5cblx0fVxuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuZ2V0UGxheWJhY2tSYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiB0aGlzLnBsYXliYWNrUmF0ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLm9uRW5kZWQgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHR0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5nZXRMb29wID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XG5cbn07XG5cblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmdldFZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvQW5hbHlzZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvQW5hbHlzZXIgPSBmdW5jdGlvbiAoIGF1ZGlvLCBmZnRTaXplICkge1xuXG5cdHRoaXMuYW5hbHlzZXIgPSBhdWRpby5jb250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG5cdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemUgIT09IHVuZGVmaW5lZCA/IGZmdFNpemUgOiAyMDQ4O1xuXG5cdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XG5cblx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xuXG59O1xuXG5USFJFRS5BdWRpb0FuYWx5c2VyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQXVkaW9BbmFseXNlcixcblxuXHRnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKCB0aGlzLmRhdGEgKTtcblx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvYXVkaW8vQXVkaW9CdWZmZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvQnVmZmVyID0gZnVuY3Rpb24gKCBjb250ZXh0ICkge1xuXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cdHRoaXMucmVhZHkgPSBmYWxzZTtcblx0dGhpcy5yZWFkeUNhbGxiYWNrcyA9IFtdO1xuXG59O1xuXG5USFJFRS5BdWRpb0J1ZmZlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggZmlsZSApIHtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdHJlcXVlc3Qub3BlbiggJ0dFVCcsIGZpbGUsIHRydWUgKTtcblx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXHRyZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uICggZSApIHtcblxuXHRcdHNjb3BlLmNvbnRleHQuZGVjb2RlQXVkaW9EYXRhKCB0aGlzLnJlc3BvbnNlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuXHRcdFx0c2NvcGUuYnVmZmVyID0gYnVmZmVyO1xuXHRcdFx0c2NvcGUucmVhZHkgPSB0cnVlO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzY29wZS5yZWFkeUNhbGxiYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0c2NvcGUucmVhZHlDYWxsYmFja3NbIGkgXSggc2NvcGUuYnVmZmVyICk7XG5cblx0XHRcdH1cblxuXHRcdFx0c2NvcGUucmVhZHlDYWxsYmFja3MgPSBbXTtcblxuXHRcdH0gKTtcblxuXHR9O1xuXHRyZXF1ZXN0LnNlbmQoKTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuQXVkaW9CdWZmZXIucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdGlmICggdGhpcy5yZWFkeSApIHtcblxuXHRcdGNhbGxiYWNrKCB0aGlzLmJ1ZmZlciApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9hdWRpby9Qb3NpdGlvbmFsQXVkaW8uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpbyA9IGZ1bmN0aW9uICggbGlzdGVuZXIgKSB7XG5cblx0VEhSRUUuQXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcblxuXHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cbn07XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5BdWRpby5wcm90b3R5cGUgKTtcblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb3NpdGlvbmFsQXVkaW87XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0T3V0cHV0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiB0aGlzLnBhbm5lcjtcblxufTtcblxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5zZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5wYW5uZXIucmVmRGlzdGFuY2UgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuUG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZS5nZXRSZWZEaXN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XG5cbn07XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuc2V0Um9sbG9mZkZhY3RvciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmdldFJvbGxvZmZGYWN0b3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG5cbn07XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuc2V0RGlzdGFuY2VNb2RlbCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLmdldERpc3RhbmNlTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XG5cbn07XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuc2V0TWF4RGlzdGFuY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdHRoaXMucGFubmVyLm1heERpc3RhbmNlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLlBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUuZ2V0TWF4RGlzdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xuXG59O1xuXG5USFJFRS5Qb3NpdGlvbmFsQXVkaW8ucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cblx0XHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuXHRcdHRoaXMucGFubmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cblx0fTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2F1ZGlvL0F1ZGlvTGlzdGVuZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcblxuXHR0aGlzLmNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG5cdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG5cdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHR0aGlzLmZpbHRlciA9IG51bGw7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkF1ZGlvTGlzdGVuZXI7XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLmdldElucHV0ID0gZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiB0aGlzLmdhaW47XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnJlbW92ZUZpbHRlciA9IGZ1bmN0aW9uICggKSB7XG5cblx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuXHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuXHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblx0XHR0aGlzLmZpbHRlciA9IG51bGw7XG5cblx0fVxuXG59O1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS5zZXRGaWx0ZXIgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cblx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG5cdH1cblxuXHR0aGlzLmZpbHRlciA9IHZhbHVlO1xuXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcblx0dGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gdGhpcy5maWx0ZXI7XG5cbn07XG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIucHJvdG90eXBlLnNldE1hc3RlclZvbHVtZSA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuZ2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxufTtcblxuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblx0dmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cblx0XHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuXHRcdHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcblx0XHR2YXIgdXAgPSB0aGlzLnVwO1xuXG5cdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG5cdFx0b3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuXHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG5cdFx0bGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9DYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcblxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbn07XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmE7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuZ2V0V29ybGREaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG5cdH07XG5cbn0oKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gVGhpcyByb3V0aW5lIGRvZXMgbm90IHN1cHBvcnQgY2FtZXJhcyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXG5cblx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cblx0XHRtMS5sb29rQXQoIHRoaXMucG9zaXRpb24sIHZlY3RvciwgdGhpcy51cCApO1xuXG5cdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuXHR9O1xuXG59KCk7XG5cblRIUkVFLkNhbWVyYS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG59O1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBzb3VyY2UubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0N1YmVDYW1lcmEuanNcblxuLyoqXG4gKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAqXHQtIHJlbmRlcnMgc2NlbmUgaW50byBheGlzLWFsaWduZWQgY3ViZVxuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZUNhbWVyYSA9IGZ1bmN0aW9uICggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xuXG5cdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcblxuXHR2YXIgY2FtZXJhUFggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhUFgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApICk7XG5cdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG5cdHZhciBjYW1lcmFOWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuXHRjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcblxuXHR2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG5cdGNhbWVyYVBZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcblxuXHR2YXIgY2FtZXJhTlkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcblx0Y2FtZXJhTlkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XG5cblx0dmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG5cdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XG5cdGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xuXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcblxuXHR2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcblx0Y2FtZXJhTloubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxICkgKTtcblx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XG5cblx0dmFyIG9wdGlvbnMgPSB7IGZvcm1hdDogVEhSRUUuUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IFRIUkVFLkxpbmVhckZpbHRlciwgbWluRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIgfTtcblxuXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgb3B0aW9ucyApO1xuXG5cdHRoaXMudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcblx0XHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAwO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBYLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAzO1xuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5ZLCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuXHR9O1xuXG59O1xuXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG5cdHRoaXMuem9vbSA9IDE7XG5cblx0dGhpcy5sZWZ0ID0gbGVmdDtcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xuXHR0aGlzLnRvcCA9IHRvcDtcblx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmE7XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHR2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xuXHR2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XG5cdHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggY3ggLSBkeCwgY3ggKyBkeCwgY3kgKyBkeSwgY3kgLSBkeSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XG5cdHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XG5cdHRoaXMudG9wID0gc291cmNlLnRvcDtcblx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xuXHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcblx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuXG5cdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHR2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XG5cdGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG5cdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcblx0ZGF0YS5vYmplY3QudG9wID0gdGhpcy50b3A7XG5cdGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuXHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcblxuXHRyZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvY2FtZXJhcy9QZXJzcGVjdGl2ZUNhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqL1xuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSA9IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQZXJzcGVjdGl2ZUNhbWVyYSc7XG5cblx0dGhpcy56b29tID0gMTtcblxuXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XG5cdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuXHR0aGlzLmZhciA9IGZhciAhPT0gdW5kZWZpbmVkID8gZmFyIDogMjAwMDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSApO1xuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmE7XG5cblxuLyoqXG4gKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXG4gKiAzNW1tIChmdWxsLWZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcblxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xuXG5cdHRoaXMuZm92ID0gMiAqIFRIUkVFLk1hdGgucmFkVG9EZWcoIE1hdGguYXRhbiggZnJhbWVIZWlnaHQgLyAoIGZvY2FsTGVuZ3RoICogMiApICkgKTtcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuLyoqXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gKlxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgQSB8IEIgfCBDIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEQgfCBFIHwgRiB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG4gKlxuICogICB2YXIgdyA9IDE5MjA7XG4gKiAgIHZhciBoID0gMTA4MDtcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuICpcbiAqICAgLS1BLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1CLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1DLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1ELS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1FLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1GLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcbiAqXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuXHR0aGlzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcblx0dGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcblx0dGhpcy54ID0geDtcblx0dGhpcy55ID0geTtcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZm92ID0gVEhSRUUuTWF0aC5yYWRUb0RlZyggMiAqIE1hdGguYXRhbiggTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRoaXMuZm92ICkgKiAwLjUgKSAvIHRoaXMuem9vbSApICk7XG5cblx0aWYgKCB0aGlzLmZ1bGxXaWR0aCApIHtcblxuXHRcdHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcblx0XHR2YXIgdG9wID0gTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XG5cdFx0dmFyIGJvdHRvbSA9IC0gdG9wO1xuXHRcdHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xuXHRcdHZhciByaWdodCA9IGFzcGVjdCAqIHRvcDtcblx0XHR2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XG5cdFx0dmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcblxuXHRcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcblx0XHRcdGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuXHRcdFx0bGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcblx0XHRcdHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcblx0XHRcdHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcblx0XHRcdHRoaXMubmVhcixcblx0XHRcdHRoaXMuZmFyXG5cdFx0KTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggZm92LCB0aGlzLmFzcGVjdCwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuXHR0aGlzLmFzcGVjdCA9IHNvdXJjZS5hc3BlY3Q7XG5cdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuXHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cblx0dGhpcy56b29tID0gc291cmNlLnpvb207XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0dmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuXHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xuXHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcblx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG5cdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG5cdHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL1N0ZXJlb0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU3RlcmVvQ2FtZXJhID0gZnVuY3Rpb24gKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG5cdFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLmNhbGwoIHRoaXMsIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblxuXHR0aGlzLmZvY2FsTGVuZ3RoID0gMTI1O1xuXG5cdHRoaXMuY2FtZXJhTCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHR0aGlzLmNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xuXHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMuY2FtZXJhUiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSgpO1xuXHR0aGlzLmNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xuXHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5TdGVyZW9DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlICk7XG5USFJFRS5TdGVyZW9DYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3RlcmVvQ2FtZXJhO1xuXG5USFJFRS5TdGVyZW9DYW1lcmEucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGZvY2FsTGVuZ3RoLCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyO1xuXG5cdHZhciBleWVSaWdodCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdHZhciBleWVMZWZ0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlTWF0cml4V29ybGQgKCBmb3JjZSApIHtcblxuXHRcdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG5cdFx0dmFyIG5lZWRzVXBkYXRlID0gZm9jYWxMZW5ndGggIT09IHRoaXMuZm9jYWxMZW5ndGggfHwgZm92ICE9PSB0aGlzLmZvdiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFzcGVjdCAhPT0gdGhpcy5hc3BlY3QgfHwgbmVhciAhPT0gdGhpcy5uZWFyIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmFyICE9PSB0aGlzLmZhcjtcblxuXHRcdGlmICggbmVlZHNVcGRhdGUgKSB7XG5cblx0XHRcdGZvY2FsTGVuZ3RoID0gdGhpcy5mb2NhbExlbmd0aDtcblx0XHRcdGZvdiA9IHRoaXMuZm92O1xuXHRcdFx0YXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG5cdFx0XHRuZWFyID0gdGhpcy5uZWFyO1xuXHRcdFx0ZmFyID0gdGhpcy5mYXI7XG5cblx0XHRcdC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cblx0XHRcdC8vIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9zdGVyZW9ncmFwaGljcy9zdGVyZW9yZW5kZXIvXG5cblx0XHRcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XG5cdFx0XHR2YXIgZXllU2VwID0gZm9jYWxMZW5ndGggLyAzMCAqIDAuNTtcblx0XHRcdHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXAgKiBuZWFyIC8gZm9jYWxMZW5ndGg7XG5cdFx0XHR2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcblx0XHRcdHZhciB4bWluLCB4bWF4O1xuXG5cdFx0XHQvLyB0cmFuc2xhdGUgeE9mZnNldFxuXG5cdFx0XHRleWVMZWZ0LmVsZW1lbnRzWyAxMiBdID0gLSBleWVTZXA7XG5cdFx0XHRleWVSaWdodC5lbGVtZW50c1sgMTIgXSA9IGV5ZVNlcDtcblxuXHRcdFx0Ly8gZm9yIGxlZnQgZXllXG5cblx0XHRcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cdFx0XHR4bWF4ID0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcblxuXHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIG5lYXIgLyAoIHhtYXggLSB4bWluICk7XG5cdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XG5cblx0XHRcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcblxuXHRcdFx0Ly8gZm9yIHJpZ2h0IGV5ZVxuXG5cdFx0XHR4bWluID0gLSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgLSBleWVTZXBPblByb2plY3Rpb247XG5cblx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuXHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG5cdFx0XHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XG5cdFx0dGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllUmlnaHQgKTtcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0xpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaWdodCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCA/IGludGVuc2l0eSA6IDE7XG5cblx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xuXG59O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpZ2h0O1xuXG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdHRoaXMuaW50ZW5zaXR5ID0gc291cmNlLmludGVuc2l0eTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHR2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG5cdGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cblx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cblx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG5cdGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuXHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcblx0aWYgKCB0aGlzLmV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5leHBvbmVudCA9IHRoaXMuZXhwb25lbnQ7XG5cblx0cmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9MaWdodFNoYWRvdy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTGlnaHRTaGFkb3cgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHR0aGlzLmNhbWVyYSA9IGNhbWVyYTtcblxuXHR0aGlzLmJpYXMgPSAwO1xuXHR0aGlzLmRhcmtuZXNzID0gMTtcblxuXHR0aGlzLm1hcFNpemUgPSBuZXcgVEhSRUUuVmVjdG9yMiggNTEyLCA1MTIgKTtcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cdHRoaXMubWF0cml4ID0gbnVsbDtcblxufTtcblxuVEhSRUUuTGlnaHRTaGFkb3cucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5MaWdodFNoYWRvdyxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xuXG5cdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XG5cdFx0dGhpcy5kYXJrbmVzcyA9IHNvdXJjZS5kYXJrbmVzcztcblxuXHRcdHRoaXMubWFwU2l6ZS5jb3B5KCBzb3VyY2UubWFwU2l6ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0FtYmllbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQW1iaWVudExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XG5cbn07XG5cblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkFtYmllbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BbWJpZW50TGlnaHQ7XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9EaXJlY3Rpb25hbExpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSApIHtcblxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xuXG5cdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XG5cdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuXHR0aGlzLnNoYWRvdyA9IG5ldyBUSFJFRS5MaWdodFNoYWRvdyggbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcblxufTtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGlyZWN0aW9uYWxMaWdodDtcblxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXG5cdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvSGVtaXNwaGVyZUxpZ2h0LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQgPSBmdW5jdGlvbiAoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG5cdFRIUkVFLkxpZ2h0LmNhbGwoIHRoaXMsIHNreUNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHR0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XG5cblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBncm91bmRDb2xvciApO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5MaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvUG9pbnRMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuXG5USFJFRS5Qb2ludExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XG5cblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcblxuXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XG5cdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuXHR0aGlzLnNoYWRvdyA9IG5ldyBUSFJFRS5MaWdodFNoYWRvdyggbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCA5MCwgMSwgMC41LCA1MDAgKSApO1xuXG59O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0O1xuXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0VEhSRUUuTGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5kaXN0YW5jZSA9IHNvdXJjZS5kaXN0YW5jZTtcblx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcblxuXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1Nwb3RMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BvdExpZ2h0ID0gZnVuY3Rpb24gKCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50LCBkZWNheSApIHtcblxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cblx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cblx0dGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcblx0dGhpcy51cGRhdGVNYXRyaXgoKTtcblxuXHR0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcblx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcblx0dGhpcy5leHBvbmVudCA9ICggZXhwb25lbnQgIT09IHVuZGVmaW5lZCApID8gZXhwb25lbnQgOiAxMDtcblx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG5cdHRoaXMuc2hhZG93ID0gbmV3IFRIUkVFLkxpZ2h0U2hhZG93KCBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDUwLCAxLCAwLjUsIDUwMCApICk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcG90TGlnaHQ7XG5cblRIUkVFLlNwb3RMaWdodC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLkxpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XG5cdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XG5cdHRoaXMuZXhwb25lbnQgPSBzb3VyY2UuZXhwb25lbnQ7XG5cdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XG5cblx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cblx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ2FjaGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhY2hlID0ge1xuXG5cdGVuYWJsZWQ6IGZhbHNlLFxuXG5cdGZpbGVzOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG5cdFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG5cdFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmZpbGVzID0ge307XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XG5cbn07XG5cblRIUkVFLkxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkxvYWRlcixcblxuXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG5cdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cblx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG5cdFx0cGFydHMucG9wKCk7XG5cblx0XHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cblx0fSxcblxuXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xuXG5cdFx0dmFyIGFycmF5ID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xuXG5cdFx0XHRhcnJheVsgaSBdID0gdGhpcy5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5O1xuXG5cdH0sXG5cblx0Y3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIGNvbG9yLCB0ZXh0dXJlTG9hZGVyLCBtYXRlcmlhbExvYWRlcjtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcblx0XHRcdGlmICggdGV4dHVyZUxvYWRlciA9PT0gdW5kZWZpbmVkICkgdGV4dHVyZUxvYWRlciA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCk7XG5cdFx0XHRpZiAoIG1hdGVyaWFsTG9hZGVyID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbExvYWRlciA9IG5ldyBUSFJFRS5NYXRlcmlhbExvYWRlcigpO1xuXG5cdFx0XHQvLyBjb252ZXJ0IGZyb20gb2xkIG1hdGVyaWFsIGZvcm1hdFxuXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSB7fTtcblxuXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIHBhdGgsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFx0XHRcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcblx0XHRcdFx0dmFyIGxvYWRlciA9IFRIUkVFLkxvYWRlci5IYW5kbGVycy5nZXQoIGZ1bGxQYXRoICk7XG5cblx0XHRcdFx0dmFyIHRleHR1cmU7XG5cblx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XG5cdFx0XHRcdFx0dGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggcmVwZWF0ICk7XG5cblx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXHRcdFx0XHRcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFMgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDAgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHRcdGlmICggd3JhcFsgMSBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcblx0XHRcdFx0XHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0XHRcdFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XG5cblx0XHRcdFx0cmV0dXJuIHV1aWQ7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9cblxuXHRcdFx0dmFyIGpzb24gPSB7XG5cdFx0XHRcdHV1aWQ6IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCksXG5cdFx0XHRcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xuXHRcdFx0fTtcblxuXHRcdFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBtWyBuYW1lIF07XG5cblx0XHRcdFx0c3dpdGNoICggbmFtZSApIHtcblx0XHRcdFx0XHRjYXNlICdEYmdDb2xvcic6XG5cdFx0XHRcdFx0Y2FzZSAnRGJnSW5kZXgnOlxuXHRcdFx0XHRcdGNhc2UgJ29wdGljYWxEZW5zaXR5Jzpcblx0XHRcdFx0XHRjYXNlICdpbGx1bWluYXRpb24nOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnRGJnTmFtZSc6XG5cdFx0XHRcdFx0XHRqc29uLm5hbWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2JsZW5kaW5nJzpcblx0XHRcdFx0XHRcdGpzb24uYmxlbmRpbmcgPSBUSFJFRVsgdmFsdWUgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2NvbG9yQW1iaWVudCc6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IGNvbG9yQW1iaWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkJyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JEaWZmdXNlJzpcblx0XHRcdFx0XHRcdGpzb24uY29sb3IgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb2xvclNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXIgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdjb2xvckVtaXNzaXZlJzpcblx0XHRcdFx0XHRcdGpzb24uZW1pc3NpdmUgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdzcGVjdWxhckNvZWYnOlxuXHRcdFx0XHRcdFx0anNvbi5zaGluaW5lc3MgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3NoYWRpbmcnOlxuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnYmFzaWMnICkganNvbi50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcblx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlJzpcblx0XHRcdFx0XHRcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVJlcGVhdCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0Jzpcblx0XHRcdFx0XHRcdGpzb24ubGlnaHRNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTGlnaHRSZXBlYXQsIG0ubWFwTGlnaHRPZmZzZXQsIG0ubWFwTGlnaHRXcmFwLCBtLm1hcExpZ2h0QW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0T2Zmc2V0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XG5cdFx0XHRcdFx0XHRqc29uLmFvTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBBT09mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQU9XcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcCc6XG5cdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wU2NhbGUnOlxuXHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBSZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBCdW1wQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWwnOlxuXHRcdFx0XHRcdFx0anNvbi5ub3JtYWxNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTm9ybWFsUmVwZWF0LCBtLm1hcE5vcm1hbE9mZnNldCwgbS5tYXBOb3JtYWxXcmFwLCBtLm1hcE5vcm1hbEFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbEZhY3Rvcic6XG5cdFx0XHRcdFx0XHRqc29uLm5vcm1hbFNjYWxlID0gWyB2YWx1ZSwgdmFsdWUgXTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcE5vcm1hbFJlcGVhdCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsT2Zmc2V0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxBbmlzb3Ryb3B5Jzpcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcblx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyT2Zmc2V0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhcldyYXAnOlxuXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYSc6XG5cdFx0XHRcdFx0XHRqc29uLmFscGhhTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFscGhhUmVwZWF0LCBtLm1hcEFscGhhT2Zmc2V0LCBtLm1hcEFscGhhV3JhcCwgbS5tYXBBbHBoYUFuaXNvdHJvcHkgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhUmVwZWF0Jzpcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XG5cdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFXcmFwJzpcblx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZmxpcFNpZGVkJzpcblx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnZG91YmxlU2lkZWQnOlxuXHRcdFx0XHRcdFx0anNvbi5zaWRlID0gVEhSRUUuRG91YmxlU2lkZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XG5cdFx0XHRcdFx0XHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2RlcHRoVGVzdCc6XG5cdFx0XHRcdFx0Y2FzZSAnZGVwdGhXcml0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnY29sb3JXcml0ZSc6XG5cdFx0XHRcdFx0Y2FzZSAnb3BhY2l0eSc6XG5cdFx0XHRcdFx0Y2FzZSAncmVmbGVjdGl2aXR5Jzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG5cdFx0XHRcdFx0Y2FzZSAndmlzaWJsZSc6XG5cdFx0XHRcdFx0Y2FzZSAnd2lyZWZyYW1lJzpcblx0XHRcdFx0XHRcdGpzb25bIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcblx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcblx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICdmYWNlJyApIGpzb24udmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiBVbnN1cHBvcnRlZCcsIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi50eXBlID09PSAnTWVzaEJhc2ljTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uZW1pc3NpdmU7XG5cdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xuXG5cdFx0XHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuXHRcdFx0bWF0ZXJpYWxMb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cblx0XHRcdHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xuXG5cdFx0fTtcblxuXHR9ICkoKVxuXG59O1xuXG5USFJFRS5Mb2FkZXIuSGFuZGxlcnMgPSB7XG5cblx0aGFuZGxlcnM6IFtdLFxuXG5cdGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xuXG5cdFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XG5cblx0fSxcblxuXHRnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcblxuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpICs9IDIgKSB7XG5cblx0XHRcdHZhciByZWdleCA9IGhhbmRsZXJzWyBpIF07XG5cdFx0XHR2YXIgbG9hZGVyICA9IGhhbmRsZXJzWyBpICsgMSBdO1xuXG5cdFx0XHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLlhIUkxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcblxuXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggb25Mb2FkICkge1xuXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdG9uTG9hZCggY2FjaGVkICk7XG5cblx0XHRcdFx0fSwgMCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjYWNoZWQ7XG5cblx0XHR9XG5cblx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSggJ3RleHQvcGxhaW4nICk7XG5cdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XG5cblx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0dmFyIHJlc3BvbnNlID0gZXZlbnQudGFyZ2V0LnJlc3BvbnNlO1xuXG5cdFx0XHRUSFJFRS5DYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnN0YXR1cyA9PT0gMjAwICkge1xuXG5cdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuc3RhdHVzID09PSAwICkge1xuXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxuXHRcdFx0XHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlhIUkxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XG5cblx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xuXG5cdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cblx0XHRcdFx0b25Qcm9ncmVzcyggZXZlbnQgKTtcblxuXHRcdFx0fSwgZmFsc2UgKTtcblxuXHRcdH1cblxuXHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cdFx0aWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcblxuXHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xuXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0cmV0dXJuIHJlcXVlc3Q7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRSZXNwb25zZVR5cGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvSW1hZ2VMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkltYWdlTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5JbWFnZUxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkltYWdlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG5cdFx0aWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0XHRpZiAoIG9uTG9hZCApIHtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRvbkxvYWQoIGNhY2hlZCApO1xuXG5cdFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0XHR9LCAwICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2FjaGVkO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2ltZycgKTtcblxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0VEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdH0sIGZhbHNlICk7XG5cblx0XHRpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0XHRvblByb2dyZXNzKCBldmVudCApO1xuXG5cdFx0XHR9LCBmYWxzZSApO1xuXG5cdFx0fVxuXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuXHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG5cdFx0fSwgZmFsc2UgKTtcblxuXHRcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG5cdFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0pTT05Mb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5KU09OTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XG5cdFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcblxuXHR9XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkpTT05Mb2FkZXIsXG5cblx0Ly8gRGVwcmVjYXRlZFxuXG5cdGdldCBzdGF0dXNEb21FbGVtZW50ICgpIHtcblxuXHRcdGlmICggdGhpcy5fc3RhdHVzRG9tRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLl9zdGF0dXNEb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblxuXHRcdH1cblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IC5zdGF0dXNEb21FbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdHJldHVybiB0aGlzLl9zdGF0dXNEb21FbGVtZW50O1xuXG5cdH0sXG5cblx0bG9hZDogZnVuY3Rpb24oIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gXCJzdHJpbmdcIiApID8gdGhpcy50ZXh0dXJlUGF0aCA6IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcblx0XHRcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cblx0XHRcdGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2YXIgdHlwZSA9IG1ldGFkYXRhLnR5cGU7XG5cblx0XHRcdFx0aWYgKCB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuT2JqZWN0TG9hZGVyIGluc3RlYWQuJyApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzY2VuZScgKSB7XG5cblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBvYmplY3QgPSBzY29wZS5wYXJzZSgganNvbiwgdGV4dHVyZVBhdGggKTtcblx0XHRcdG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XG5cblx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0fSxcblxuXHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCksXG5cdFx0c2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuXHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cblx0XHRwYXJzZVNraW4oKTtcblx0XHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXHRcdHBhcnNlQW5pbWF0aW9ucygpO1xuXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuXHRcdFx0ZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaSwgaiwgZmksXG5cblx0XHRcdG9mZnNldCwgekxlbmd0aCxcblxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxuXG5cdFx0XHR0eXBlLFxuXHRcdFx0aXNRdWFkLFxuXHRcdFx0aGFzTWF0ZXJpYWwsXG5cdFx0XHRoYXNGYWNlVmVydGV4VXYsXG5cdFx0XHRoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLFxuXHRcdFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXG5cblx0XHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXG5cblx0XHRcdHV2TGF5ZXIsIHV2LCB1LCB2LFxuXG5cdFx0XHRmYWNlcyA9IGpzb24uZmFjZXMsXG5cdFx0XHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXG5cdFx0XHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxuXHRcdFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXG5cblx0XHRcdG5VdkxheWVycyA9IDA7XG5cblx0XHRcdGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHRcdHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblx0XHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvZmZzZXQgPSAwO1xuXHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xuXG5cdFx0XHRcdHR5cGUgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblxuXHRcdFx0XHRpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcblx0XHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xuXHRcdFx0XHRoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcblx0XHRcdFx0aGFzRmFjZVZlcnRleE5vcm1hbCA9IGlzQml0U2V0KCB0eXBlLCA1ICk7XG5cdFx0XHRcdGhhc0ZhY2VDb2xvclx0ICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XG5cdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidHlwZVwiLCB0eXBlLCBcImJpdHNcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XG5cblx0XHRcdFx0aWYgKCBpc1F1YWQgKSB7XG5cblx0XHRcdFx0XHRmYWNlQSA9IG5ldyBUSFJFRS5GYWNlMygpO1xuXHRcdFx0XHRcdGZhY2VBLmEgPSBmYWNlc1sgb2Zmc2V0IF07XG5cdFx0XHRcdFx0ZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG5cdFx0XHRcdFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cblx0XHRcdFx0XHRmYWNlQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xuXHRcdFx0XHRcdGZhY2VCLmEgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuXHRcdFx0XHRcdGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuXHRcdFx0XHRcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG5cdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XG5cblx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0ZmFjZUEubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdFx0XHRmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHRvIGdldCBmYWNlIDw9PiB1diBpbmRleCBjb3JyZXNwb25kZW5jZVxuXG5cdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgKyAxIF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG5cdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XG5cblx0XHRcdFx0XHRcdGZhY2VBLm5vcm1hbC5zZXQoXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGZhY2VCLm5vcm1hbC5jb3B5KCBmYWNlQS5ub3JtYWwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cblx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xuXHRcdFx0XHRcdFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcblxuXHRcdFx0XHRcdH1cblxuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0XHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VCICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcblx0XHRcdFx0XHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXHRcdFx0XHRcdGlmICggaGFzTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cdFx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cblx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleFV2ICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XG5cdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XG5cblx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuXHRcdFx0XHRcdFx0ZmFjZS5ub3JtYWwuc2V0KFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG5cdFx0XHRcdFx0XHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcblx0XHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCBdXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXHRcdFx0XHRcdFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBjb2xvcnNbIGNvbG9ySW5kZXggXSApICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XG5cblx0XHRcdHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuXHRcdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xuXG5cdFx0XHRcdFx0dmFyIHggPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5XZWlnaHRzWyBpIF07XG5cdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcblx0XHRcdFx0XHR2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuXHRcdFx0XHRcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XG5cblx0XHRcdFx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICgganNvbi5za2luSW5kaWNlcyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbi5za2luSW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG5cdFx0XHRcdFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcblx0XHRcdFx0XHR2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xuXG5cdFx0XHRcdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcblx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xuXG5cdFx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XG5cdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xuXG5cdFx0XHRcdFx0dmFyIGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cdFx0XHRcdFx0dmFyIHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuXHRcdFx0XHRcdGZvciAoIHZhciB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdFx0XHRcdHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0dmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xuXHRcdFx0XHRcdFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xuXG5cdFx0XHRcdFx0XHRkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgJiYganNvbi5tb3JwaENvbG9ycy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IFwibW9ycGhDb2xvcnNcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcblxuXHRcdFx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHRcdFx0dmFyIG1vcnBoQ29sb3JzID0ganNvbi5tb3JwaENvbG9yc1sgMCBdLmNvbG9ycztcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0ZmFjZXNbIGkgXS5jb2xvci5mcm9tQXJyYXkoIG1vcnBoQ29sb3JzLCBpICogMyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCkge1xuXG5cdFx0XHR2YXIgb3V0cHV0QW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0XHQvLyBwYXJzZSBvbGQgc3R5bGUgQm9uZS9IaWVyYXJjaHkgYW5pbWF0aW9uc1xuXHRcdFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcblxuXHRcdFx0aWYgKCBqc29uLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmNvbmNhdCgganNvbi5hbmltYXRpb25zICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uc1sgaSBdLCBnZW9tZXRyeS5ib25lcyApO1xuXHRcdFx0XHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBwYXJzZSBpbXBsaWNpdCBtb3JwaCBhbmltYXRpb25zXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0XHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxuXHRcdFx0XHR2YXIgbW9ycGhBbmltYXRpb25DbGlwcyA9IFRIUkVFLkFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cywgMTAgKTtcblx0XHRcdFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvdXRwdXRBbmltYXRpb25zLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5hbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucztcblxuXHRcdH07XG5cblx0XHRpZiAoIGpzb24ubWF0ZXJpYWxzID09PSB1bmRlZmluZWQgfHwganNvbi5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHZhciBtYXRlcmlhbHMgPSBUSFJFRS5Mb2FkZXIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0xvYWRpbmdNYW5hZ2VyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkaW5nTWFuYWdlciA9IGZ1bmN0aW9uICggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIGlzTG9hZGluZyA9IGZhbHNlLCBpdGVtc0xvYWRlZCA9IDAsIGl0ZW1zVG90YWwgPSAwO1xuXG5cdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcblx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG5cdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG5cdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cblx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuXHRcdGl0ZW1zVG90YWwgKys7XG5cblx0XHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGlmICggc2NvcGUub25TdGFydCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aXNMb2FkaW5nID0gdHJ1ZTtcblxuXHR9O1xuXG5cdHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG5cdFx0aXRlbXNMb2FkZWQgKys7XG5cblx0XHRpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcblxuXHRcdFx0aXNMb2FkaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0c2NvcGUub25Mb2FkKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cblx0XHRpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0c2NvcGUub25FcnJvciggdXJsICk7XG5cblx0XHR9XG5cblx0fTtcblxufTtcblxuVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IFRIUkVFLkxvYWRpbmdNYW5hZ2VyKCk7XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQnVmZmVyR2VvbWV0cnlMb2FkZXIuanNcblxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XHJcblxyXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLkJ1ZmZlckdlb21ldHJ5TG9hZGVyLFxyXG5cclxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcclxuXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcclxuXHJcblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XHJcblxyXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcclxuXHJcblx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBpbmRleC50eXBlIF0oIGluZGV4LmFycmF5ICk7XHJcblx0XHRcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCAxICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcclxuXHJcblx0XHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XHJcblx0XHRcdHZhciB0eXBlZEFycmF5ID0gbmV3IHNlbGZbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBncm91cHMgPSBqc29uLmRhdGEuZ3JvdXBzIHx8IGpzb24uZGF0YS5kcmF3Y2FsbHMgfHwganNvbi5kYXRhLm9mZnNldHM7XHJcblxyXG5cdFx0aWYgKCBncm91cHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBib3VuZGluZ1NwaGVyZSA9IGpzb24uZGF0YS5ib3VuZGluZ1NwaGVyZTtcclxuXHJcblx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBjZW50ZXIsIGJvdW5kaW5nU3BoZXJlLnJhZGl1cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2VvbWV0cnk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9NYXRlcmlhbExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cdHRoaXMudGV4dHVyZXMgPSB7fTtcblxufTtcblxuVEhSRUUuTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NYXRlcmlhbExvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0VGV4dHVyZXM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnRleHR1cmVzID0gdmFsdWU7XG5cblx0fSxcblxuXHRnZXRUZXh0dXJlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cblx0XHR2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xuXG5cdFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZXh0dXJlc1sgbmFtZSBdO1xuXG5cdH0sXG5cblx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsganNvbi50eXBlIF07XG5cblx0XHRpZiAoIGpzb24udXVpZCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcblx0XHRpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcblx0XHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xuXHRcdGlmICgganNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xuXHRcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xuXHRcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XG5cdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcblx0XHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcblx0XHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3Jtcztcblx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcblx0XHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcblx0XHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcblx0XHRpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hhZGluZyA9IGpzb24uc2hhZGluZztcblx0XHRpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcblx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcblx0XHRpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcblx0XHRpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcblx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcblx0XHRpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcblx0XHRpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcblx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcblx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdC8vIGZvciBQb2ludHNNYXRlcmlhbFxuXHRcdGlmICgganNvbi5zaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplID0ganNvbi5zaXplO1xuXHRcdGlmICgganNvbi5zaXplQXR0ZW51YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGpzb24uc2l6ZUF0dGVudWF0aW9uO1xuXG5cdFx0Ly8gbWFwc1xuXG5cdFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1hcCApO1xuXG5cdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG1hdGVyaWFsLmFscGhhTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XG5cdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XG5cdFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XG5cblx0XHRpZiAoIGpzb24ubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XG5cdFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBub3JtYWxTY2FsZSA9IGpzb24ubm9ybWFsU2NhbGU7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XG5cblx0XHRcdFx0bm9ybWFsU2NhbGUgPSBbIG5vcm1hbFNjYWxlLCBub3JtYWxTY2FsZSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGVyaWFsLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoKS5mcm9tQXJyYXkoIG5vcm1hbFNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uZGlzcGxhY2VtZW50TWFwICk7XG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZSA9IGpzb24uZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0XHRpZiAoIGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XG5cdFx0aWYgKCBqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzTWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLm1ldGFsbmVzc01hcCApO1xuXG5cdFx0aWYgKCBqc29uLmVtaXNzaXZlTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xuXHRcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSB0aGlzLmdldFRleHR1cmUoIGpzb24uc3BlY3VsYXJNYXAgKTtcblxuXHRcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5nZXRUZXh0dXJlKCBqc29uLmVudk1hcCApO1xuXHRcdFx0bWF0ZXJpYWwuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uLnJlZmxlY3Rpdml0eSApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGpzb24ucmVmbGVjdGl2aXR5O1xuXG5cdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xuXHRcdGlmICgganNvbi5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG5cdFx0aWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IHRoaXMuZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xuXHRcdGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0Ly8gTWVzaEZhY2VNYXRlcmlhbFxuXG5cdFx0aWYgKCBqc29uLm1hdGVyaWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9PYmplY3RMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk9iamVjdExvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblx0dGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xuXG59O1xuXG5USFJFRS5PYmplY3RMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3RMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XG5cblx0XHRcdHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRzY29wZS5wYXJzZSggSlNPTi5wYXJzZSggdGV4dCApLCBvbkxvYWQgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cblx0XHR2YXIgZ2VvbWV0cmllcyA9IHRoaXMucGFyc2VHZW9tZXRyaWVzKCBqc29uLmdlb21ldHJpZXMgKTtcblxuXHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH0gKTtcblxuXHRcdHZhciB0ZXh0dXJlcyAgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLnBhcnNlTWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZXMgKTtcblxuXHRcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cblx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcblxuXHRcdFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cblx0fSxcblxuXHRwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuXHRcdHZhciBnZW9tZXRyaWVzID0ge307XG5cblx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKTtcblx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGdlb21ldHJ5O1xuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdQbGFuZUdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0JveEdlb21ldHJ5Jzpcblx0XHRcdFx0XHRjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGVwdGgsXG5cdFx0XHRcdFx0XHRcdGRhdGEud2lkdGhTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aFNlZ21lbnRzXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuc2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXNUb3AsXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzQm90dG9tLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5vcGVuRW5kZWQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdTcGhlcmVHZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnBoaUxlbmd0aCxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLndpZHRoU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU3RhcnQsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEuZGV0YWlsXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XG5cblx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmRldGFpbFxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdSaW5nR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5SaW5nR2VvbWV0cnkoXG5cdFx0XHRcdFx0XHRcdGRhdGEuaW5uZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEub3V0ZXJSYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhTGVuZ3RoXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0dlb21ldHJ5KFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuXHRcdFx0XHRcdFx0XHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxuXG5cdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeShcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpdXMsXG5cdFx0XHRcdFx0XHRcdGRhdGEudHViZSxcblx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcblx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG5cdFx0XHRcdFx0XHRcdGRhdGEucCxcblx0XHRcdFx0XHRcdFx0ZGF0YS5xLFxuXHRcdFx0XHRcdFx0XHRkYXRhLmhlaWdodFNjYWxlXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBidWZmZXJHZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YS5kYXRhLCB0aGlzLnRleHR1cmVQYXRoICkuZ2VvbWV0cnk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFwiJyArIGRhdGEudHlwZSArICdcIicgKTtcblxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XG5cblx0XHRcdFx0Z2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGdlb21ldHJpZXM7XG5cblx0fSxcblxuXHRwYXJzZU1hdGVyaWFsczogZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlcyApIHtcblxuXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuXHRcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLk1hdGVyaWFsTG9hZGVyKCk7XG5cdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBsb2FkZXIucGFyc2UoIGpzb25bIGkgXSApO1xuXHRcdFx0XHRtYXRlcmlhbHNbIG1hdGVyaWFsLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG5cdH0sXG5cblx0cGFyc2VBbmltYXRpb25zOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cblx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjbGlwID0gVEhSRUUuQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvblsgaSBdICk7XG5cblx0XHRcdGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFuaW1hdGlvbnM7XG5cblx0fSxcblxuXHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXHRcdHZhciBpbWFnZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xuXG5cdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cblx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG5cdFx0XHR2YXIgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cblx0XHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcblx0XHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xuXHRcdFx0XHR2YXIgcGF0aCA9IC9eKFxcL1xcLyl8KFthLXpdKzooXFwvXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcblxuXHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2VzO1xuXG5cdH0sXG5cblx0cGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBqc29uLCBpbWFnZXMgKSB7XG5cblx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcblxuXHRcdFx0aWYgKCB0eXBlb2YoIHZhbHVlICkgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XG5cblx0XHRcdHJldHVybiBUSFJFRVsgdmFsdWUgXTtcblxuXHRcdH1cblxuXHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG5cdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuXHRcdFx0XHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XG5cdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuXHRcdFx0XHRpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nICk7XG5cdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEub2Zmc2V0WyAwIF0sIGRhdGEub2Zmc2V0WyAxIF0gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggZGF0YS5yZXBlYXRbIDAgXSwgZGF0YS5yZXBlYXRbIDEgXSApO1xuXHRcdFx0XHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyICk7XG5cdFx0XHRcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIgKTtcblx0XHRcdFx0aWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcblx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhLndyYXAgKSApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSApO1xuXHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZXM7XG5cblx0fSxcblxuXHRwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cblx0XHRcdHZhciBvYmplY3Q7XG5cblx0XHRcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xuXG5cdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRNYXRlcmlhbCggbmFtZSApIHtcblxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnU2NlbmUnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNjZW5lKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoIGRhdGEubGVmdCwgZGF0YS5yaWdodCwgZGF0YS50b3AsIGRhdGEuYm90dG9tLCBkYXRhLm5lYXIsIGRhdGEuZmFyICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLmV4cG9uZW50LCBkYXRhLmRlY2F5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01lc2gnOlxuXG5cdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKTtcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTE9EJzpcblxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5MT0QoKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0xpbmUnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnUG9pbnRDbG91ZCc6XG5cdFx0XHRcdGNhc2UgJ1BvaW50cyc6XG5cblx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdTcHJpdGUnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnR3JvdXAnOlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cblx0XHRcdH1cblxuXHRcdFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XG5cblx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcblx0XHRcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xuXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZiAoIGRhdGEucG9zaXRpb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIGRhdGEucG9zaXRpb24gKTtcblx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG5cdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcblx0XHRcdGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuXHRcdFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xuXHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG5cdFx0XHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgY2hpbGQgaW4gZGF0YS5jaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGRhdGEuY2hpbGRyZW5bIGNoaWxkIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcblxuXHRcdFx0XHR2YXIgbGV2ZWxzID0gZGF0YS5sZXZlbHM7XG5cblx0XHRcdFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xuXG5cdFx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG5cdFx0fVxuXG5cdH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cblx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0b25Mb2FkKCB0ZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5wYXRoID0gdmFsdWU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0N1YmVUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuQ3ViZVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBbXSApO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblxuXHRcdHZhciBsb2FkZWQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmxzWyBpIF0sIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG5cdFx0XHRcdGxvYWRlZCArKztcblxuXHRcdFx0XHRpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9CaW5hcnlUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBOaWtvcyBNLiAvIGh0dHBzOi8vZ2l0aHViLmNvbS9mb28xMjMvXG4gKlxuICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuICovXG5cblRIUkVFLkRhdGFUZXh0dXJlTG9hZGVyID0gVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5USFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQmluYXJ5VGV4dHVyZUxvYWRlcixcblxuXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG5cdFx0dmFyIHNjb3BlID0gdGhpcztcblxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCk7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cblx0XHRcdHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XG5cblx0XHRcdGlmICggISB0ZXhEYXRhICkgcmV0dXJuO1xuXG5cdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuXHRcdFx0fSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG5cdFx0XHRcdHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHR0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0XHRcdHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuXHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cblx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cblx0XHRcdH1cblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pcG1hcHMgKSB7XG5cblx0XHRcdFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcblxuXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHRcdFx0fVxuXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cblx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cblx0XHR2YXIgaW1hZ2VzID0gW107XG5cblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuXHRcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cblx0XHR2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuXHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xuXG5cdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGltYWdlc1sgaSBdID0ge1xuXHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcblx0XHRcdFx0XHRmb3JtYXQ6IHRleERhdGFzLmZvcm1hdCxcblx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0bG9hZGVkICs9IDE7XG5cblx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxIClcblx0XHRcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG5cdFx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuXHRcdFx0dmFyIGxvYWRlZCA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XG5cblx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cblx0XHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG5cdFx0XHRcdHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG5cdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG5cdFx0XHRcdFx0dmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcblxuXHRcdFx0XHRcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xuXG5cdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcblx0XHRcdFx0XHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcblx0XHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhcy5taXBtYXBzO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRleERhdGFzLm1pcG1hcENvdW50ID09PSAxICkge1xuXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG5cdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrIH0gKTtcblxuXHR0aGlzLnV1aWQgPSBUSFJFRS5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXHR0aGlzLnR5cGUgPSAnTWF0ZXJpYWwnO1xuXG5cdHRoaXMuc2lkZSA9IFRIUkVFLkZyb250U2lkZTtcblxuXHR0aGlzLm9wYWNpdHkgPSAxO1xuXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG5cblx0dGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xuXG5cdHRoaXMuYmxlbmRTcmMgPSBUSFJFRS5TcmNBbHBoYUZhY3Rvcjtcblx0dGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XG5cdHRoaXMuYmxlbmRFcXVhdGlvbiA9IFRIUkVFLkFkZEVxdWF0aW9uO1xuXHR0aGlzLmJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cblx0dGhpcy5kZXB0aEZ1bmMgPSBUSFJFRS5MZXNzRXF1YWxEZXB0aDtcblx0dGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuXHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG5cdHRoaXMuY29sb3JXcml0ZSA9IHRydWU7XG5cblx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG5cdHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xuXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xuXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cblx0dGhpcy5hbHBoYVRlc3QgPSAwO1xuXG5cdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cblx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuXHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTWF0ZXJpYWwsXG5cblx0Z2V0IG5lZWRzVXBkYXRlICgpIHtcblxuXHRcdHJldHVybiB0aGlzLl9uZWVkc1VwZGF0ZTtcblxuXHR9LFxuXG5cdHNldCBuZWVkc1VwZGF0ZSAoIHZhbHVlICkge1xuXG5cdFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudXBkYXRlKCk7XG5cblx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcblxuXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcblxuXHRcdFx0dmFyIG5ld1ZhbHVlID0gdmFsdWVzWyBrZXkgXTtcblxuXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRlcmlhbDogJ1wiICsga2V5ICsgXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXCIgKTtcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5cIiArIHRoaXMudHlwZSArIFwiOiAnXCIgKyBrZXkgKyBcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cIiApO1xuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xuXG5cdFx0XHRcdGN1cnJlbnRWYWx1ZS5jb3B5KCBuZXdWYWx1ZSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cblx0XHRcdFx0Ly8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBpc1Jvb3QgPSBtZXRhID09PSB1bmRlZmluZWQ7XG5cblx0XHRpZiAoIGlzUm9vdCApIHtcblxuXHRcdFx0bWV0YSA9IHtcblx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuXHRcdFx0XHRpbWFnZXM6IHt9XG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0dmFyIGRhdGEgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdNYXRlcmlhbCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxuXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcblx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG5cdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG5cdFx0aWYgKCB0aGlzLmNvbG9yIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuXHRcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IDAuNSApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XG5cdFx0aWYgKCB0aGlzLm1ldGFsbmVzcyA+IDAgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXG5cdFx0aWYgKCB0aGlzLmVtaXNzaXZlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLmVtaXNzaXZlID0gdGhpcy5lbWlzc2l2ZS5nZXRIZXgoKTtcblx0XHRpZiAoIHRoaXMuc3BlY3VsYXIgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xuXHRcdGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XG5cblx0XHRpZiAoIHRoaXMubWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuYWxwaGFNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMubGlnaHRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMuYnVtcE1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuXHRcdH1cblx0XHRpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuXHRcdFx0ZGF0YS5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXG5cdFx0fVxuXHRcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuXG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG5cdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdGRhdGEuZGlzcGxhY2VtZW50QmlhcyA9IHRoaXMuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdH1cblx0XHRpZiAoIHRoaXMucm91Z2huZXNzTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRpZiAoIHRoaXMubWV0YWxuZXNzTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblxuXHRcdGlmICggdGhpcy5lbWlzc2l2ZU1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXHRcdGlmICggdGhpcy5zcGVjdWxhck1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG5cdFx0aWYgKCB0aGlzLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG5cblx0XHRcdGRhdGEuZW52TWFwID0gdGhpcy5lbnZNYXAudG9KU09OKCBtZXRhICkudXVpZDtcblx0XHRcdGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XG5cdFx0aWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcblxuXHRcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZlcnRleENvbG9ycyAhPT0gVEhSRUUuTm9Db2xvcnMgKSBkYXRhLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXHRcdGlmICggdGhpcy5zaGFkaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zaGFkaW5nICE9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkgZGF0YS5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXHRcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYmxlbmRpbmcgIT09IFRIUkVFLk5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XG5cdFx0aWYgKCB0aGlzLnNpZGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNpZGUgIT09IFRIUkVFLkZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcblxuXHRcdGlmICggdGhpcy5vcGFjaXR5IDwgMSApIGRhdGEub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblx0XHRpZiAoIHRoaXMudHJhbnNwYXJlbnQgPT09IHRydWUgKSBkYXRhLnRyYW5zcGFyZW50ID0gdGhpcy50cmFuc3BhcmVudDtcblx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG5cdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXG5cblx0XHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlICggY2FjaGUgKSB7XG5cblx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcblxuXHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcblx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG5cdFx0XHRcdHZhbHVlcy5wdXNoKCBkYXRhICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlcztcblxuXHRcdH1cblxuXHRcdGlmICggaXNSb290ICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG5cdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuXHRcdFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuXHRcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xuXG5cdFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XG5cdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuXHRcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XG5cblx0XHR0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuXHRcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XG5cdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG5cdFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XG5cdFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xuXG5cdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xuXHRcdHRoaXMuZGVwdGhUZXN0ID0gc291cmNlLmRlcHRoVGVzdDtcblx0XHR0aGlzLmRlcHRoV3JpdGUgPSBzb3VyY2UuZGVwdGhXcml0ZTtcblxuXHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXG5cdFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xuXG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gc291cmNlLnBvbHlnb25PZmZzZXQ7XG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG5cdFx0dGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzb3VyY2UucG9seWdvbk9mZnNldFVuaXRzO1xuXG5cdFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xuXG5cdFx0dGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcblxuXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XG5cblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG5cdHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuXHR0aGlzLmxpbmV3aWR0aCA9IHNvdXJjZS5saW5ld2lkdGg7XG5cdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xuXHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2NhbGU6IDxmbG9hdD4sXG4gKiAgZGFzaFNpemU6IDxmbG9hdD4sXG4gKiAgZ2FwU2l6ZTogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnNcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0dGhpcy5saW5ld2lkdGggPSAxO1xuXG5cdHRoaXMuc2NhbGUgPSAxO1xuXHR0aGlzLmRhc2hTaXplID0gMztcblx0dGhpcy5nYXBTaXplID0gMTtcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHRcblx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXG5cdHRoaXMuc2NhbGUgPSBzb3VyY2Uuc2NhbGU7XG5cdHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XG5cdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoQmFzaWNNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZW1pc3NpdmVcblxuXHR0aGlzLm1hcCA9IG51bGw7XG5cblx0dGhpcy5hb01hcCA9IG51bGw7XG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsO1xuXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG5cdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHR0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmFvTWFwID0gbnVsbDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuXHR0aGlzLmVudk1hcCA9IG51bGw7XG5cdHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuXHR0aGlzLmZvZyA9IHRydWU7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cblx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcblxuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG5cdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFBob25nTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxuICogIHNoaW5pbmVzczogPGZsb2F0PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gKlxuICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAqXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gKlxuICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcbiAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXHR0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xuXHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmFvTWFwID0gbnVsbDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG5cdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG5cdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDtcblxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuXHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuXHR0aGlzLnNoaW5pbmVzcyA9IHNvdXJjZS5zaGluaW5lc3M7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXG5cdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG5cdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHR0aGlzLnNoYWRpbmcgPSBzb3VyY2Uuc2hhZGluZztcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaFN0YW5kYXJkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICByb3VnaG5lc3M6IDxmbG9hdD4sXG4gKiAgbWV0YWxuZXNzOiA8ZmxvYXQ+LFxuXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICpcbiAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAqXG4gKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gKlxuICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgbWV0YWxuZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGVudk1hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKlx0Zm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcblxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cdHRoaXMucm91Z2huZXNzID0gMC41O1xuXHR0aGlzLm1ldGFsbmVzcyA9IDAuNTtcblxuXHR0aGlzLmVtaXNzaXZlID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApO1xuXG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcblx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmFvTWFwID0gbnVsbDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcblxuXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG5cdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG5cdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblxuXHR0aGlzLm1ldGFsbmVzc01hcCA9IG51bGw7XG5cblx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cblx0dGhpcy5lbnZNYXAgPSBudWxsO1xuXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcblxuXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cblx0dGhpcy5mb2cgPSB0cnVlO1xuXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cdHRoaXMucm91Z2huZXNzID0gc291cmNlLnJvdWdobmVzcztcblx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xuXG5cdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG5cdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcblx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuXG5cdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XG5cblx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG5cdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcblx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcblx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cblx0dGhpcy5yb3VnaG5lc3NNYXAgPSBzb3VyY2Uucm91Z2huZXNzTWFwO1xuXG5cdHRoaXMubWV0YWxuZXNzTWFwID0gc291cmNlLm1ldGFsbmVzc01hcDtcblxuXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG5cdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcblx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSBzb3VyY2UuZW52TWFwSW50ZW5zaXR5O1xuXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG5cblx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hEZXB0aE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbDtcblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hOb3JtYWxNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTXVsdGlNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTXVsdGlNYXRlcmlhbCA9IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy50eXBlID0gJ011bHRpTWF0ZXJpYWwnO1xuXG5cdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5NdWx0aU1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTXVsdGlNYXRlcmlhbCxcblxuXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuXHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjIsXG5cdFx0XHRcdHR5cGU6ICdtYXRlcmlhbCcsXG5cdFx0XHRcdGdlbmVyYXRvcjogJ01hdGVyaWFsRXhwb3J0ZXInXG5cdFx0XHR9LFxuXHRcdFx0dXVpZDogdGhpcy51dWlkLFxuXHRcdFx0dHlwZTogdGhpcy50eXBlLFxuXHRcdFx0bWF0ZXJpYWxzOiBbXVxuXHRcdH07XG5cblx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5tYXRlcmlhbHM7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbWF0ZXJpYWxzWyBpIF0udG9KU09OKCBtZXRhICk7XG5cdFx0XHRkZWxldGUgbWF0ZXJpYWwubWV0YWRhdGE7XG5cblx0XHRcdG91dHB1dC5tYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuXHRcdH1cblxuXHRcdG91dHB1dC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0cmV0dXJuIG91dHB1dDtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5tYXRlcmlhbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRtYXRlcmlhbC5tYXRlcmlhbHMucHVzaCggdGhpcy5tYXRlcmlhbHNbIGkgXS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRtYXRlcmlhbC52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1BvaW50c01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNpemU6IDxmbG9hdD4sXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlBvaW50c01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cblx0dGhpcy5tYXAgPSBudWxsO1xuXG5cdHRoaXMuc2l6ZSA9IDE7XG5cdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG5cdHRoaXMuZm9nID0gdHJ1ZTtcblxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50c01hdGVyaWFsO1xuXG5USFJFRS5Qb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cblx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG5cdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHRyZXR1cm4gdGhpcztcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL1NoYWRlck1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcbiAqXG4gKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxuICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICBsaWdodHM6IDxib29sPixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICpcdGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdTaGFkZXJNYXRlcmlhbCc7XG5cblx0dGhpcy5kZWZpbmVzID0ge307XG5cdHRoaXMudW5pZm9ybXMgPSB7fTtcblxuXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcblxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG5cdHRoaXMubGluZXdpZHRoID0gMTtcblxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cblx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cblxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cblx0dGhpcy5leHRlbnNpb25zID0ge1xuXHRcdGRlcml2YXRpdmVzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuXHRcdGZyYWdEZXB0aDogZmFsc2UsIC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXG5cdFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xuXHRcdHNoYWRlclRleHR1cmVMT0Q6IGZhbHNlIC8vIHNldCB0byB1c2Ugc2hhZGVyIHRleHR1cmUgTE9EXG5cdH07XG5cblx0Ly8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG5cdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cblx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuXHRcdCdjb2xvcic6IFsgMSwgMSwgMSBdLFxuXHRcdCd1dic6IFsgMCwgMCBdLFxuXHRcdCd1djInOiBbIDAsIDAgXVxuXHR9O1xuXG5cdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuXHRpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdGlmICggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gc291cmNlLmZyYWdtZW50U2hhZGVyO1xuXHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XG5cblx0dGhpcy51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xuXG5cdHRoaXMuZGVmaW5lcyA9IHNvdXJjZS5kZWZpbmVzO1xuXG5cdHRoaXMuc2hhZGluZyA9IHNvdXJjZS5zaGFkaW5nO1xuXG5cdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG5cdHRoaXMuZm9nID0gc291cmNlLmZvZztcblxuXHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG5cblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xuXG5cdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG5cblx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cblx0dGhpcy5leHRlbnNpb25zID0gc291cmNlLmV4dGVuc2lvbnM7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cblx0dmFyIGRhdGEgPSBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuXHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcztcblx0ZGF0YS52ZXJ0ZXhTaGFkZXIgPSB0aGlzLnZlcnRleFNoYWRlcjtcblx0ZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XG5cblx0cmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9SYXdTaGFkZXJNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0VEhSRUUuU2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xuXG5cdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XG5cbn07XG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWw7XG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdHRoaXMubWFwID0gbnVsbDtcblxuXHR0aGlzLnJvdGF0aW9uID0gMDtcblxuXHR0aGlzLmZvZyA9IGZhbHNlO1xuXG5cdC8vIHNldCBwYXJhbWV0ZXJzXG5cblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGVNYXRlcmlhbDtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cblx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcblxuXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL1RleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqL1xuXG5USFJFRS5UZXh0dXJlID0gZnVuY3Rpb24gKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogVEhSRUUuVGV4dHVyZUlkQ291bnQgKysgfSApO1xuXG5cdHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cdHRoaXMuc291cmNlRmlsZSA9ICcnO1xuXG5cdHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfSU1BR0U7XG5cdHRoaXMubWlwbWFwcyA9IFtdO1xuXG5cdHRoaXMubWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5UZXh0dXJlLkRFRkFVTFRfTUFQUElORztcblxuXHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cblx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuXHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcblxuXHR0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcblx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGU7XG5cblx0dGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xuXHR0aGlzLnJlcGVhdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcblx0dGhpcy5mbGlwWSA9IHRydWU7XG5cdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDsgLy8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXG5cblx0dGhpcy52ZXJzaW9uID0gMDtcblx0dGhpcy5vblVwZGF0ZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcblRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVEhSRUUuVVZNYXBwaW5nO1xuXG5USFJFRS5UZXh0dXJlLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZSxcblxuXHRzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcblxuXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG5cdH0sXG5cblx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0XHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xuXHRcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XG5cblx0XHR0aGlzLm1hcHBpbmcgPSBzb3VyY2UubWFwcGluZztcblxuXHRcdHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG5cdFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcblxuXHRcdHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcblx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cblx0XHR0aGlzLmFuaXNvdHJvcHkgPSBzb3VyY2UuYW5pc290cm9weTtcblxuXHRcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcblx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuXHRcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcblx0XHR0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XG5cblx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG5cdFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XG5cdFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcblx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdFx0aWYgKCBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcblxuXHRcdFx0dmFyIGNhbnZhcztcblxuXHRcdFx0aWYgKCBpbWFnZS50b0RhdGFVUkwgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjYW52YXMgPSBpbWFnZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdFx0XHRjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuXHRcdFx0XHRjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApLmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XG5cblx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9qcGVnJywgMC42ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBvdXRwdXQgPSB7XG5cdFx0XHRtZXRhZGF0YToge1xuXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG5cdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcblx0XHRcdFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG5cdFx0XHR9LFxuXG5cdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cblx0XHRcdG1hcHBpbmc6IHRoaXMubWFwcGluZyxcblxuXHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcblx0XHRcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXG5cdFx0XHR3cmFwOiBbIHRoaXMud3JhcFMsIHRoaXMud3JhcFQgXSxcblxuXHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcblx0XHRcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG5cdFx0XHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcblx0XHR9O1xuXG5cdFx0aWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcblxuXHRcdFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuXHRcdFx0aWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aW1hZ2UudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XG5cdFx0XHRcdFx0dXVpZDogaW1hZ2UudXVpZCxcblx0XHRcdFx0XHR1cmw6IGdldERhdGFVUkwoIGltYWdlIClcblx0XHRcdFx0fTtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xuXG5cdFx0fVxuXG5cdFx0bWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gPSBvdXRwdXQ7XG5cblx0XHRyZXR1cm4gb3V0cHV0O1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fSxcblxuXHR0cmFuc2Zvcm1VdjogZnVuY3Rpb24gKCB1diApIHtcblxuXHRcdGlmICggdGhpcy5tYXBwaW5nICE9PSBUSFJFRS5VVk1hcHBpbmcgKSAgcmV0dXJuO1xuXG5cdFx0dXYubXVsdGlwbHkoIHRoaXMucmVwZWF0ICk7XG5cdFx0dXYuYWRkKCB0aGlzLm9mZnNldCApO1xuXG5cdFx0aWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLlJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0dXYueCA9IHV2LnggPCAwID8gMCA6IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxuXG5cdFx0XHRcdFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XG5cblx0XHRcdHN3aXRjaCAoIHRoaXMud3JhcFQgKSB7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5SZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuXHRcdFx0XHRcdHV2LnkgPSB1di55IDwgMCA/IDAgOiAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuXHRcdFx0XHRcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0dXYueSA9IE1hdGguY2VpbCggdXYueSApIC0gdXYueTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuZmxpcFkgKSB7XG5cblx0XHRcdHV2LnkgPSAxIC0gdXYueTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5cblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ2FudmFzVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ2FudmFzVGV4dHVyZSA9IGZ1bmN0aW9uICggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5DYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbnZhc1RleHR1cmU7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0N1YmVUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlVGV4dHVyZSA9IGZ1bmN0aW9uICggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuXHR0aGlzLmZsaXBZID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5DdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlVGV4dHVyZTtcblxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXHRcblx0dGhpcy5pbWFnZXMgPSBzb3VyY2UuaW1hZ2VzO1xuXHRcblx0cmV0dXJuIHRoaXM7XG5cbn07XG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9Db21wcmVzc2VkVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcblxuXHRUSFJFRS5UZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG5cdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuXHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xuXHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxuXG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuXHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXG5cdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcblxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uICggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG5cdFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTmVhcmVzdEZpbHRlcjtcblx0XG5cdHRoaXMuZmxpcFkgPSBmYWxzZTtcblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EYXRhVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiAoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSggdXBkYXRlICk7XG5cblx0XHRpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPT09IHZpZGVvLkhBVkVfRU5PVUdIX0RBVEEgKSB7XG5cblx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0dXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZpZGVvVGV4dHVyZTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Hcm91cC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR3JvdXAgPSBmdW5jdGlvbiAoKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdHcm91cCc7XG5cbn07XG5cblRIUkVFLkdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuR3JvdXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JvdXA7XG4vLyBGaWxlOnNyYy9vYmplY3RzL1BvaW50cy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2ludHMnO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxufTtcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50cztcblxuVEhSRUUuUG9pbnRzLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cblx0XHR2YXIgb2JqZWN0ID0gdGhpcztcblx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHR2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG5cdFx0dmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRmdW5jdGlvbiB0ZXN0UG9pbnQoIHBvaW50LCBpbmRleCApIHtcblxuXHRcdFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuXHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xuXHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXG5cdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXG5cdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxuXHRcdFx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRcdFx0b2JqZWN0OiBvYmplY3RcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGEgPSBpbmRpY2VzWyBpIF07XG5cblx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblxuXHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XG5cblx0XHRcdFx0XHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cbn0oKSApO1xuXG5USFJFRS5Qb2ludHMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cblx0aWYgKCBtb2RlID09PSAxICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5MaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xpbmUnO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0dmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xuXHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcblxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuXHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG5cdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG5cdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG5cdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvL1xuXG5cdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuXHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cblx0XHR2YXIgdlN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIGludGVyUmF5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHR2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuXHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuXHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuXHRcdFx0XHRcdHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcblxuXHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG5cdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuXHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG5cdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcblx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxuXHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcblx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cblx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XG5cdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XG5cblx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG5cdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cblx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuXHRcdFx0XHRcdFx0aW5kZXg6IGksXG5cdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuXHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHRcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xuXG5cdFx0XHRcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cblx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuXHRcdFx0XHRcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuXHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuXHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcblx0XHRcdFx0XHRpbmRleDogaSxcblx0XHRcdFx0XHRmYWNlOiBudWxsLFxuXHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcblx0XHRcdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG4vLyBERVBSRUNBVEVEXG5cblRIUkVFLkxpbmVTdHJpcCA9IDA7XG5USFJFRS5MaW5lUGllY2VzID0gMTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lU2VnbWVudHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxpbmVTZWdtZW50cyA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG5cdFRIUkVFLkxpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ0xpbmVTZWdtZW50cyc7XG5cbn07XG5cblRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVTZWdtZW50cztcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9NZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICovXG5cblRIUkVFLk1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ01lc2gnO1xuXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuXHR0aGlzLmRyYXdNb2RlID0gVEhSRUUuVHJpYW5nbGVzRHJhd01vZGU7XG5cblx0dGhpcy51cGRhdGVNb3JwaFRhcmdldHMoKTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLk1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaDtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuc2V0RHJhd01vZGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdHRoaXMuZHJhd01vZGUgPSB2YWx1ZTtcblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xuXG5cdGlmICggdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG5cdFx0dGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtIDE7XG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcblx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG5cdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xuXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuXHRpZiAoIHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5WyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xuXG5cdH1cblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWU6IG1vcnBoIHRhcmdldCAnICsgbmFtZSArICcgZG9lcyBub3QgZXhpc3QuIFJldHVybmluZyAwLicgKTtcblxuXHRyZXR1cm4gMDtcblxufTtcblxuXG5USFJFRS5NZXNoLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXHR2YXIgc3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG5cdHZhciB2QSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2QyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0dmFyIHRlbXBBID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHRlbXBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHRlbXBDID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR2YXIgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblx0dmFyIHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cdHZhciB1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG5cdHZhciBiYXJ5Y29vcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRmdW5jdGlvbiB1dkludGVyc2VjdGlvbiggcG9pbnQsIHAxLCBwMiwgcDMsIHV2MSwgdXYyLCB1djMgKSB7XG5cblx0XHRUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcblxuXHRcdHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcblx0XHR1djIubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC55ICk7XG5cdFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xuXG5cdFx0dXYxLmFkZCggdXYyICkuYWRkKCB1djMgKTtcblxuXHRcdHJldHVybiB1djEuY2xvbmUoKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICkge1xuXG5cdFx0dmFyIGludGVyc2VjdDtcblx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cblx0XHRpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUsIHBvaW50ICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBwb2ludCApO1xuXHRcdGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuXHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50V29ybGQgKTtcblxuXHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0XHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxuXHRcdFx0b2JqZWN0OiBvYmplY3Rcblx0XHR9O1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbnMsIHV2cywgYSwgYiwgYyApIHtcblxuXHRcdHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXHRcdHZCLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXHRcdHZDLmZyb21BcnJheSggcG9zaXRpb25zLCBjICogMyApO1xuXG5cdFx0dmFyIGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCB2QSwgdkIsIHZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRcdGlmICggdXZzICkge1xuXG5cdFx0XHRcdHV2QS5mcm9tQXJyYXkoIHV2cywgYSAqIDIgKTtcblx0XHRcdFx0dXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xuXHRcdFx0XHR1dkMuZnJvbUFycmF5KCB1dnMsIGMgKiAyICk7XG5cblx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCAgdkEsIHZCLCB2QywgIHV2QSwgdXZCLCB1dkMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKTtcblx0XHRcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG5cdFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG5cdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cblx0XHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcblx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG5cdFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdC8vXG5cblx0XHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XG5cdFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuXHRcdC8vIENoZWNrIGJvdW5kaW5nQm94IGJlZm9yZSBjb250aW51aW5nXG5cblx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHJheS5pbnRlcnNlY3RzQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciB1dnMsIGludGVyc2VjdGlvbjtcblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGEsIGIsIGM7XG5cdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR1dnMgPSBhdHRyaWJ1dGVzLnV2LmFycmF5O1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdGEgPSBpbmRpY2VzWyBpIF07XG5cdFx0XHRcdFx0YiA9IGluZGljZXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0YyA9IGluZGljZXNbIGkgKyAyIF07XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xuXHRcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSArPSA5ICkge1xuXG5cdFx0XHRcdFx0YSA9IGkgLyAzO1xuXHRcdFx0XHRcdGIgPSBhICsgMTtcblx0XHRcdFx0XHRjID0gYSArIDI7XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb25zLCB1dnMsIGEsIGIsIGMgKTtcblxuXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uaW5kZXggPSBhOyAvLyB0cmlhbmdsZSBudW1iZXIgaW4gcG9zaXRpb25zIGJ1ZmZlciBzZW1hbnRpY3Ncblx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgZnZBLCBmdkIsIGZ2Qztcblx0XHRcdHZhciBpc0ZhY2VNYXRlcmlhbCA9IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbDtcblx0XHRcdHZhciBtYXRlcmlhbHMgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XG5cblx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXHRcdFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG5cdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblx0XHRcdGlmICggZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkgdXZzID0gZmFjZVZlcnRleFV2cztcblxuXHRcdFx0Zm9yICggdmFyIGYgPSAwLCBmbCA9IGZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcblx0XHRcdFx0dmFyIGZhY2VNYXRlcmlhbCA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWxzWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcblxuXHRcdFx0XHRmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG5cdFx0XHRcdGZ2QiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcblx0XHRcdFx0ZnZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xuXG5cdFx0XHRcdGlmICggZmFjZU1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG5cdFx0XHRcdFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG5cdFx0XHRcdFx0dkEuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0dkIuc2V0KCAwLCAwLCAwICk7XG5cdFx0XHRcdFx0dkMuc2V0KCAwLCAwLCAwICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgdCA9IDAsIHRsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdCA8IHRsOyB0ICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XG5cblx0XHRcdFx0XHRcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XG5cblx0XHRcdFx0XHRcdHZhciB0YXJnZXRzID0gbW9ycGhUYXJnZXRzWyB0IF0udmVydGljZXM7XG5cblx0XHRcdFx0XHRcdHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGZ2QSApLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRcdHZCLmFkZFNjYWxlZFZlY3RvciggdGVtcEIuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5iIF0sIGZ2QiApLCBpbmZsdWVuY2UgKTtcblx0XHRcdFx0XHRcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZBLmFkZCggZnZBICk7XG5cdFx0XHRcdFx0dkIuYWRkKCBmdkIgKTtcblx0XHRcdFx0XHR2Qy5hZGQoIGZ2QyApO1xuXG5cdFx0XHRcdFx0ZnZBID0gdkE7XG5cdFx0XHRcdFx0ZnZCID0gdkI7XG5cdFx0XHRcdFx0ZnZDID0gdkM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgZnZBLCBmdkIsIGZ2QywgaW50ZXJzZWN0aW9uUG9pbnQgKTtcblxuXHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdFx0XHRcdGlmICggdXZzICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdXZzX2YgPSB1dnNbIGYgXTtcblx0XHRcdFx0XHRcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XG5cdFx0XHRcdFx0XHR1dkIuY29weSggdXZzX2ZbIDEgXSApO1xuXHRcdFx0XHRcdFx0dXZDLmNvcHkoIHV2c19mWyAyIF0gKTtcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCBmdkEsIGZ2QiwgZnZDLCB1dkEsIHV2QiwgdXZDICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0JvbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdCb25lJztcblxuXHR0aGlzLnNraW4gPSBza2luO1xuXG59O1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cdFxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblx0XG5cdHRoaXMuc2tpbiA9IHNvdXJjZS5za2luO1xuXHRcblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU2tlbGV0b24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2VsZXRvbiA9IGZ1bmN0aW9uICggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHR0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcblxuXHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHQvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cblx0Ym9uZXMgPSBib25lcyB8fCBbXTtcblxuXHR0aGlzLmJvbmVzID0gYm9uZXMuc2xpY2UoIDAgKTtcblxuXHQvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cblx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXG5cdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuXHRcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXG5cdFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXG5cdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG5cdFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXG5cblx0XHRcblx0XHR2YXIgc2l6ZSA9IE1hdGguc3FydCggdGhpcy5ib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcblx0XHRzaXplID0gVEhSRUUuTWF0aC5uZXh0UG93ZXJPZlR3byggTWF0aC5jZWlsKCBzaXplICkgKTtcblx0XHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcblxuXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG5cdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cblx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG5cdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB0aGlzLmJvbmVzLmxlbmd0aCApO1xuXG5cdH1cblxuXHQvLyB1c2UgdGhlIHN1cHBsaWVkIGJvbmUgaW52ZXJzZXMgb3IgY2FsY3VsYXRlIHRoZSBpbnZlcnNlc1xuXG5cdGlmICggYm9uZUludmVyc2VzID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XG5cblx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25JbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcblxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggbmV3IFRIUkVFLk1hdHJpeDQoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2FsY3VsYXRlSW52ZXJzZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuXHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdHZhciBpbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdGlmICggdGhpcy5ib25lc1sgYiBdICkge1xuXG5cdFx0XHRpbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGJvbmU7XG5cblx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXG5cblx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cblx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG5cdFx0aWYgKCBib25lICkge1xuXG5cdFx0XHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuXHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cblx0XHRpZiAoIGJvbmUgKSB7XG5cblx0XHRcdGlmICggYm9uZS5wYXJlbnQgKSB7XG5cblx0XHRcdFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG5cdFx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XG5cblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuXHRcdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1cblxuXHRcdFx0dmFyIG1hdHJpeCA9IHRoaXMuYm9uZXNbIGIgXSA/IHRoaXMuYm9uZXNbIGIgXS5tYXRyaXhXb3JsZCA6IHRoaXMuaWRlbnRpdHlNYXRyaXg7XG5cblx0XHRcdG9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblx0XHRcdG9mZnNldE1hdHJpeC5mbGF0dGVuVG9BcnJheU9mZnNldCggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cblx0XHRcdHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0gKSgpO1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5Ta2VsZXRvbiggdGhpcy5ib25lcywgdGhpcy5ib25lSW52ZXJzZXMsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NraW5uZWRNZXNoLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cbiAqL1xuXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cblx0dGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcblxuXHR0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xuXHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHQvLyBpbml0IGJvbmVzXG5cblx0Ly8gVE9ETzogcmVtb3ZlIGJvbmUgY3JlYXRpb24gYXMgdGhlcmUgaXMgbm8gcmVhc29uIChvdGhlciB0aGFuXG5cdC8vIGNvbnZlbmllbmNlKSBmb3IgVEhSRUUuU2tpbm5lZE1lc2ggdG8gZG8gdGhpcy5cblxuXHR2YXIgYm9uZXMgPSBbXTtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0dmFyIGJvbmUsIGdib25lO1xuXG5cdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG5cdFx0XHRib25lID0gbmV3IFRIUkVFLkJvbmUoIHRoaXMgKTtcblx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuXHRcdFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcblx0XHRcdGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcblx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcblx0XHRcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcblxuXHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XG5cblx0XHRcdGlmICggZ2JvbmUucGFyZW50ICE9PSAtIDEgJiYgZ2JvbmUucGFyZW50ICE9PSBudWxsICkge1xuXG5cdFx0XHRcdGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHR0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cdHRoaXMuYmluZCggbmV3IFRIUkVFLlNrZWxldG9uKCBib25lcywgdW5kZWZpbmVkLCB1c2VWZXJ0ZXhUZXh0dXJlICksIHRoaXMubWF0cml4V29ybGQgKTtcblxufTtcblxuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tpbm5lZE1lc2g7XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG5cdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuXHRpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuXHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG5cdH1cblxuXHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cblx0dGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XG5cblx0XHRcdHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG5cdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuXHRcdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH0gZWxzZSBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuXHRcdHZhciB2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG5cdFx0dmFyIHNraW5XZWlnaHQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNraW5XZWlnaHQuY291bnQ7IGkgKysgKSB7XG5cblx0XHRcdHZlYy54ID0gc2tpbldlaWdodC5nZXRYKCBpICk7XG5cdFx0XHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xuXHRcdFx0dmVjLnogPSBza2luV2VpZ2h0LmdldFooIGkgKTtcblx0XHRcdHZlYy53ID0gc2tpbldlaWdodC5nZXRXKCBpICk7XG5cblx0XHRcdHZhciBzY2FsZSA9IDEuMCAvIHZlYy5sZW5ndGhNYW5oYXR0YW4oKTtcblxuXHRcdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XG5cblx0XHRcdFx0dmVjLm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuXHRcdFx0fVxuXG5cdFx0XHRza2luV2VpZ2h0LnNldFhZWlcoIGksIHZlYy54LCB2ZWMueSwgdmVjLnosIHZlYy53ICk7XG5cblx0XHR9XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiggZm9yY2UgKSB7XG5cblx0VEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgdHJ1ZSApO1xuXG5cdGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJhdHRhY2hlZFwiICkge1xuXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gXCJkZXRhY2hlZFwiICkge1xuXG5cdFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJpbmRNYXRyaXggKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2ggdW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG5cblx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvTE9ELmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkxPRCA9IGZ1bmN0aW9uICgpIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xPRCc7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblx0XHRsZXZlbHM6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHR2YWx1ZTogW11cblx0XHR9LFxuXHRcdG9iamVjdHM6IHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxPRDogLm9iamVjdHMgaGFzIGJlZW4gcmVuYW1lZCB0byAubGV2ZWxzLicgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMubGV2ZWxzO1xuXG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG5cbn07XG5cblxuVEhSRUUuTE9ELnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTE9ELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxPRDtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5hZGRMZXZlbCA9IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcblxuXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcblxuXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcblxuXHRcdGlmICggZGlzdGFuY2UgPCBsZXZlbHNbIGwgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdGxldmVscy5zcGxpY2UoIGwsIDAsIHsgZGlzdGFuY2U6IGRpc3RhbmNlLCBvYmplY3Q6IG9iamVjdCB9ICk7XG5cblx0dGhpcy5hZGQoIG9iamVjdCApO1xuXG59O1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmdldE9iamVjdEZvckRpc3RhbmNlID0gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcblxufTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG5cdFx0dGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XG5cblx0XHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XG5cblx0XHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuXHRcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cblx0XHRcdGxldmVsc1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcblxuXHRcdFx0XHRcdGxldmVsc1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cbn0oKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xuXG5cdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cblx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG5cdHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cblx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cblx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cblx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xuXHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcblx0XHRcdGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxuXHRcdH0gKTtcblxuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL29iamVjdHMvU3ByaXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3ByaXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMiwgIDAsIDIsIDMgXSApO1xuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIC0gMC41LCAtIDAuNSwgMCwgICAwLjUsIC0gMC41LCAwLCAgIDAuNSwgMC41LCAwLCAgIC0gMC41LCAwLjUsIDAgXSApO1xuXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggWyAwLCAwLCAgIDEsIDAsICAgMSwgMSwgICAwLCAxIF0gKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG5cdHJldHVybiBmdW5jdGlvbiBTcHJpdGUoIG1hdGVyaWFsICkge1xuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cblx0XHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cdFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcblxuXHR9O1xuXG59ICkoKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgZGlzdGFuY2VTcSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VTcVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XG5cdFx0dmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55O1xuXG5cdFx0aWYgKCBkaXN0YW5jZVNxID4gZ3Vlc3NTaXplU3EgKSB7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdGludGVyc2VjdHMucHVzaCgge1xuXG5cdFx0XHRkaXN0YW5jZTogTWF0aC5zcXJ0KCBkaXN0YW5jZVNxICksXG5cdFx0XHRwb2ludDogdGhpcy5wb3NpdGlvbixcblx0XHRcdGZhY2U6IG51bGwsXG5cdFx0XHRvYmplY3Q6IHRoaXNcblxuXHRcdH0gKTtcblxuXHR9O1xuXG59KCkgKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlID0gVEhSRUUuU3ByaXRlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5sZW5zRmxhcmVzID0gW107XG5cblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cblx0aWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxlbnNGbGFyZTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XG5cdGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcblx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cdGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cblx0ZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcblx0XHR0ZXh0dXJlOiB0ZXh0dXJlLFx0Ly8gVEhSRUUuVGV4dHVyZVxuXHRcdHNpemU6IHNpemUsIFx0XHQvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsIFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxuXHRcdHg6IDAsIHk6IDAsIHo6IDAsXHQvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIGluIGZyb250IHogPSAxIGlzIGJhY2tcblx0XHRzY2FsZTogMSwgXHRcdC8vIHNjYWxlXG5cdFx0cm90YXRpb246IDAsIFx0XHQvLyByb3RhdGlvblxuXHRcdG9wYWNpdHk6IG9wYWNpdHksXHQvLyBvcGFjaXR5XG5cdFx0Y29sb3I6IGNvbG9yLFx0XHQvLyBjb2xvclxuXHRcdGJsZW5kaW5nOiBibGVuZGluZ1x0Ly8gYmxlbmRpbmdcblx0fSApO1xuXG59O1xuXG4vKlxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXG4gKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxuICovXG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUudXBkYXRlTGVuc0ZsYXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xuXHR2YXIgZmxhcmU7XG5cdHZhciB2ZWNYID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xuXHR2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcblxuXHRmb3IgKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xuXG5cdFx0ZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcblxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG5cdFx0ZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcblxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xuXHRcdGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdHRoaXMucG9zaXRpb25TY3JlZW4uY29weSggc291cmNlLnBvc2l0aW9uU2NyZWVuICk7XG5cdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmxlbnNGbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCBzb3VyY2UubGVuc0ZsYXJlc1sgaSBdICk7XG5cblx0fVxuXG5cdHJldHVybiB0aGlzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvU2NlbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNjZW5lID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xuXG5cdHRoaXMuZm9nID0gbnVsbDtcblx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlOyAvLyBjaGVja2VkIGJ5IHRoZSByZW5kZXJlclxuXG59O1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLlNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNjZW5lO1xuXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG5cdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuXHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2cuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Gb2cgPSBmdW5jdGlvbiAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cblx0dGhpcy5uYW1lID0gJyc7XG5cblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcblxufTtcblxuVEhSRUUuRm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9zY2VuZXMvRm9nRXhwMi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZ0V4cDIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZW5zaXR5ICkge1xuXG5cdHRoaXMubmFtZSA9ICcnO1xuXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yICk7XG5cdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcblxufTtcblxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5Gb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsuanNcblxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7fTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhbWFwX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYW1hcF9wYXJzX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfQUxQSEFNQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGF0ZXN0X2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhbHBoYXRlc3RfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIEFMUEhBVEVTVFxcblxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbWJpZW50X3BhcnMuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FtYmllbnRfcGFycycgXSA9XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxudmVjMyBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiB2ZWMzIGFtYmllbnRMaWdodENvbG9yICkge1xcblxcblxcdHJldHVybiBQSSAqIGFtYmllbnRMaWdodENvbG9yO1xcblxcbn1cXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gKCB0ZXh0dXJlMkQoIGFvTWFwLCB2VXYyICkuciAtIDEuMCApICogYW9NYXBJbnRlbnNpdHkgKyAxLjA7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2FvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9BT01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2JlZ2luX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYmVnaW5fdmVydGV4JyBdID1cIlxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9iZWdpbm5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2JlZ2lubm9ybWFsX3ZlcnRleCcgXSA9XCJcXG52ZWMzIG9iamVjdE5vcm1hbCA9IHZlYzMoIG5vcm1hbCApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9ic2Rmcy5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYnNkZnMnIF0gPVwiZmxvYXQgY2FsY0xpZ2h0QXR0ZW51YXRpb24oIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcblxcblxcdGlmICggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXG5cXG5cXHQgIHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0cmV0dXJuIDEuMDtcXG5cXG59XFxuXFxuXFxudmVjMyBCUkRGX0RpZmZ1c2VfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxuXFxufSAvLyB2YWxpZGF0ZWRcXG5cXG5cXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBkb3RMSCApIHtcXG5cXG5cXHQvLyBPcmlnaW5hbCBhcHByb3hpbWF0aW9uIGJ5IENocmlzdG9waGUgU2NobGljayAnOTRcXG5cXHQvLztmbG9hdCBmcmVzbmVsID0gcG93KCAxLjAgLSBkb3RMSCwgNS4wICk7XFxuXFxuXFx0Ly8gT3B0aW1pemVkIHZhcmlhbnQgKHByZXNlbnRlZCBieSBFcGljIGF0IFNJR0dSQVBIICcxMylcXG5cXHRmbG9hdCBmcmVzbmVsID0gZXhwMiggKCAtNS41NTQ3MyAqIGRvdExIIC0gNi45ODMxNiApICogZG90TEggKTtcXG5cXG5cXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXG5cXG59IC8vIHZhbGlkYXRlZFxcblxcblxcbi8vIE1pY3JvZmFjZXQgTW9kZWxzIGZvciBSZWZyYWN0aW9uIHRocm91Z2ggUm91Z2ggU3VyZmFjZXMgLSBlcXVhdGlvbiAoMzQpXFxuLy8gaHR0cDovL2dyYXBoaWNyYW50cy5ibG9nc3BvdC5jb20vMjAxMy8wOC9zcGVjdWxhci1icmRmLXJlZmVyZW5jZS5odG1sXFxuLy8gYWxwaGEgaXMgXFxcInJvdWdobmVzcyBzcXVhcmVkXFxcIiBpbiBEaXNuZXnigJlzIHJlcGFyYW1ldGVyaXphdGlvblxcbmZsb2F0IEdfR0dYX1NtaXRoKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcblxcblxcdC8vIGdlb21ldHJ5IHRlcm0gPSBHKGwp4ouFRyh2KSAvIDQobuKLhWwpKG7ii4V2KVxcblxcblxcdGZsb2F0IGEyID0gYWxwaGEgKiBhbHBoYTtcXG5cXG5cXHRmbG9hdCBnbCA9IGRvdE5MICsgcG93KCBhMiArICggMS4wIC0gYTIgKSAqIGRvdE5MICogZG90TkwsIDAuNSApO1xcblxcblxcdGZsb2F0IGd2ID0gZG90TlYgKyBwb3coIGEyICsgKCAxLjAgLSBhMiApICogZG90TlYgKiBkb3ROViwgMC41ICk7XFxuXFxuXFx0cmV0dXJuIDEuMCAvICggZ2wgKiBndiApO1xcblxcbn0gLy8gdmFsaWRhdGVkXFxuXFxuXFxuLy8gTWljcm9mYWNldCBNb2RlbHMgZm9yIFJlZnJhY3Rpb24gdGhyb3VnaCBSb3VnaCBTdXJmYWNlcyAtIGVxdWF0aW9uICgzMylcXG4vLyBodHRwOi8vZ3JhcGhpY3JhbnRzLmJsb2dzcG90LmNvbS8yMDEzLzA4L3NwZWN1bGFyLWJyZGYtcmVmZXJlbmNlLmh0bWxcXG4vLyBhbHBoYSBpcyBcXFwicm91Z2huZXNzIHNxdWFyZWRcXFwiIGluIERpc25leeKAmXMgcmVwYXJhbWV0ZXJpemF0aW9uXFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXG5cXG5cXHRmbG9hdCBhMiA9IGFscGhhICogYWxwaGE7XFxuXFxuXFx0ZmxvYXQgZGVub20gPSBkb3ROSCAqIGRvdE5IICogKCBhMiAtIDEuMCApICsgMS4wOyAvLyBhdm9pZCBhbHBoYSA9IDAgd2l0aCBkb3ROSCA9IDFcXG5cXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gKCBkZW5vbSAqIGRlbm9tICk7XFxuXFxufVxcblxcblxcbi8vIEdHWCBEaXN0cmlidXRpb24sIFNjaGxpY2sgRnJlc25lbCwgR0dYLVNtaXRoIFZpc2liaWxpdHlcXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcblxcdGZsb2F0IGFscGhhID0gcm91Z2huZXNzICogcm91Z2huZXNzOyAvLyBVRTQncyByb3VnaG5lc3NcXG5cXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcblxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdGZsb2F0IGRvdE5IID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoYWxmRGlyICkgKTtcXG5cXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXG5cXG5cXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuXFx0ZmxvYXQgRyA9IEdfR0dYX1NtaXRoKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG5cXG59IC8vIHZhbGlkYXRlZFxcblxcblxcbi8vIHJlZjogaHR0cHM6Ly93d3cudW5yZWFsZW5naW5lLmNvbS9ibG9nL3BoeXNpY2FsbHktYmFzZWQtc2hhZGluZy1vbi1tb2JpbGUgLSBlbnZpcm9ubWVudEJSREYgZm9yIEdHWCBvbiBtb2JpbGVcXG52ZWMzIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFxuXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxuXFxuXFx0Y29uc3QgdmVjNCBjMSA9IHZlYzQoIDEsIDAuMDQyNSwgMS4wNCwgLSAwLjA0ICk7XFxuXFxuXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXG5cXG5cXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXG5cXG5cXHR2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcblxcblxcdHJldHVybiBzcGVjdWxhckNvbG9yICogQUIueCArIEFCLnk7XFxuXFxufSAvLyB2YWxpZGF0ZWRcXG5cXG5cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViAqLyApIHtcXG5cXG5cXHQvLyBnZW9tZXRyeSB0ZXJtIGlzIChuIGRvdCBsKShuIGRvdCB2KSAvIDQobiBkb3QgbCkobiBkb3QgdilcXG5cXHRyZXR1cm4gMC4yNTtcXG5cXG59XFxuXFxuZmxvYXQgRF9CbGlublBob25nKCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcblxcblxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogKCBzaGluaW5lc3MgKiAwLjUgKyAxLjAgKSAqIHBvdyggZG90TkgsIHNoaW5pbmVzcyApO1xcblxcbn1cXG5cXG52ZWMzIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXG5cXG5cXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcblxcblxcdC8vZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHQvL2Zsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxuXFx0ZmxvYXQgZG90TEggPSBzYXR1cmF0ZSggZG90KCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiwgaGFsZkRpciApICk7XFxuXFxuXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcblxcblxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGRvdE5MLCBkb3ROViAqLyApO1xcblxcblxcdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG5cXG59IC8vIHZhbGlkYXRlZFxcblxcbi8vIHNvdXJjZTogaHR0cDovL3NpbW9uc3RlY2hibG9nLmJsb2dzcG90LmNhLzIwMTEvMTIvbWljcm9mYWNldC1icmRmLmh0bWxcXG5mbG9hdCBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcyApIHtcXG5cXHRyZXR1cm4gKCAyLjAgLyBzcXVhcmUoIGdneFJvdWdobmVzcyArIDAuMDAwMSApIC0gMi4wICk7XFxufVwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcblxcdC8vIERlcml2YXRpdmUgbWFwcyAtIGJ1bXAgbWFwcGluZyB1bnBhcmFtZXRyaXplZCBzdXJmYWNlcyBieSBNb3J0ZW4gTWlra2Vsc2VuXFxuXFx0Ly8gaHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXFxuXFxuXFx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXFxuXFxuXFx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFxuXFx0XFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblxcdFxcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXG5cXHRcXHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXFx0XFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXFx0XFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxuXFxuXFx0XFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFxuXFx0fVxcblxcblxcdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuXFx0XFx0dmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFx0XFx0Ly8gbm9ybWFsaXplZFxcblxcblxcdFxcdHZlYzMgUjEgPSBjcm9zcyggdlNpZ21hWSwgdk4gKTtcXG5cXHRcXHR2ZWMzIFIyID0gY3Jvc3MoIHZOLCB2U2lnbWFYICk7XFxuXFxuXFx0XFx0ZmxvYXQgZkRldCA9IGRvdCggdlNpZ21hWCwgUjEgKTtcXG5cXG5cXHRcXHR2ZWMzIHZHcmFkID0gc2lnbiggZkRldCApICogKCBkSGR4eS54ICogUjEgKyBkSGR4eS55ICogUjIgKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuXFx0fVxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb2xvcl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc192ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9DT0xPUlxcblxcblxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG5cXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9jb21tb24uZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2NvbW1vbicgXSA9XCIjZGVmaW5lIFBJIDMuMTQxNTlcXG4jZGVmaW5lIFBJMiA2LjI4MzE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJIDAuMzE4MzA5ODg2MThcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXG4jZGVmaW5lIEVQU0lMT04gMWUtNlxcblxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcblxcbmZsb2F0IHNxdWFyZSggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfVxcbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7IHJldHVybiBkb3QoIGNvbG9yLCB2ZWMzKCAwLjMzMzMgKSApOyB9XFxuXFxuXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxufTtcXG5cXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcblxcdHZlYzMgZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGRpcmVjdFNwZWN1bGFyO1xcblxcdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcblxcdHZlYzMgaW5kaXJlY3RTcGVjdWxhcjtcXG59O1xcblxcbnN0cnVjdCBHZW9tZXRyaWNDb250ZXh0IHtcXG5cXHR2ZWMzIHBvc2l0aW9uO1xcblxcdHZlYzMgbm9ybWFsO1xcblxcdHZlYzMgdmlld0RpcjtcXG59O1xcblxcblxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxuXFxufVxcblxcbi8vIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvR0xTTF9Qcm9ncmFtbWluZy9BcHBseWluZ19NYXRyaXhfVHJhbnNmb3JtYXRpb25zXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxuXFxuXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuXFx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcblxcblxcdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXG5cXG59XFxuXFxuZmxvYXQgc2lkZU9mUGxhbmUoIGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblxcdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxuXFxufVxcblxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcblxcdHJldHVybiBsaW5lRGlyZWN0aW9uICogKCBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludE9uUGxhbmUgLSBwb2ludE9uTGluZSApIC8gZG90KCBwbGFuZU5vcm1hbCwgbGluZURpcmVjdGlvbiApICkgKyBwb2ludE9uTGluZTtcXG5cXG59XFxuXFxudmVjMyBpbnB1dFRvTGluZWFyKCBpbiB2ZWMzIGEgKSB7XFxuXFxuXFx0I2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuXFx0XFx0cmV0dXJuIHBvdyggYSwgdmVjMyggZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICkgKTtcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdHJldHVybiBhO1xcblxcblxcdCNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuXFx0I2lmZGVmIEdBTU1BX09VVFBVVFxcblxcblxcdFxcdHJldHVybiBwb3coIGEsIHZlYzMoIDEuMCAvIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRyZXR1cm4gYTtcXG5cXG5cXHQjZW5kaWZcXG5cXG59XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0bm9ybWFsX3ZlcnRleCcgXSA9XCIjaWZkZWYgRkxJUF9TSURFRFxcblxcblxcdG9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XFxuXFxuI2VuZGlmXFxuXFxudmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGlzcGxhY2VtZW50bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZGlzcGxhY2VtZW50bWFwX3ZlcnRleCcgXSA9XCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbCAqICggdGV4dHVyZTJEKCBkaXNwbGFjZW1lbnRNYXAsIHV2ICkueCAqIGRpc3BsYWNlbWVudFNjYWxlICsgZGlzcGxhY2VtZW50QmlhcyApO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9kaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Rpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCcgXSA9XCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudFNjYWxlO1xcblxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW1pc3NpdmVtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2VtaXNzaXZlbWFwX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXG5cXG5cXHRlbWlzc2l2ZUNvbG9yLnJnYiA9IGlucHV0VG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IucmdiICk7XFxuXFxuXFx0dG90YWxFbWlzc2l2ZUxpZ2h0ICo9IGVtaXNzaXZlQ29sb3IucmdiO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG5cXHRcXHQvLyBUcmFuc2Zvcm1pbmcgTm9ybWFsIFZlY3RvcnMgd2l0aCB0aGUgSW52ZXJzZSBUcmFuc2Zvcm1hdGlvblxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcblxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXHRcXHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHRlbnZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBlbnZDb2xvci54eXogKTtcXG5cXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZW52bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX2ZyYWdtZW50JyBdID1cIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgfHwgZGVmaW5lZCggU1RBTkRBUkQgKVxcblxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcblxcdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zdGl5O1xcbiNlbmRpZlxcblxcbiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXG5cXHQjZWxzZVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVudk1hcDtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxuXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggU1RBTkRBUkQgKVxcblxcblxcdFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblxcdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX3ZlcnRleCcgXSA9XCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HICkgJiYgISBkZWZpbmVkKCBTVEFOREFSRCApXFxuXFxuXFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcblxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdlbnZtYXBfdmVydGV4JyBdID1cIiNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfQlVNUE1BUCApICYmICEgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApICYmICEgZGVmaW5lZCggUEhPTkcgKSAmJiAhIGRlZmluZWQoIFNUQU5EQVJEIClcXG5cXG5cXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXG5cXHRcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcblxcdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX0ZPR1xcblxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXFx0XFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnRGVwdGhFWFQgLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cXHQjZWxzZVxcblxcblxcdFxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgRk9HX0VYUDJcXG5cXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XFxuXFxuXFx0I2VuZGlmXFxuXFx0XFxuXFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9mb2dfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZm9nX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9GT0dcXG5cXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcblxcdCNlbHNlXFxuXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblxcdCNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGFycy5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3BhcnMnIF0gPVwiI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcblxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXG5cXHQgIHZlYzMgZGlyZWN0aW9uO1xcblxcdCAgdmVjMyBjb2xvcjtcXG5cXHQgIGludCBzaGFkb3c7XFxuXFx0fTtcXG5cXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFxuXFx0SW5jaWRlbnRMaWdodCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0KCBjb25zdCBpbiBEaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0SW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5cXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFxuXFx0XFx0cmV0dXJuIGRpcmVjdExpZ2h0O1xcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG5cXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRzdHJ1Y3QgUG9pbnRMaWdodCB7XFxuXFx0ICB2ZWMzIHBvc2l0aW9uO1xcblxcdCAgdmVjMyBjb2xvcjtcXG5cXHQgIGZsb2F0IGRpc3RhbmNlO1xcblxcdCAgZmxvYXQgZGVjYXk7XFxuXFx0ICBpbnQgc2hhZG93O1xcblxcdH07XFxuXFxuXFx0dW5pZm9ybSBQb2ludExpZ2h0IHBvaW50TGlnaHRzWyBOVU1fUE9JTlRfTElHSFRTIF07XFxuXFxuXFx0SW5jaWRlbnRMaWdodCBnZXRQb2ludERpcmVjdExpZ2h0KCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0SW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXG5cXG5cXHRcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodC5kaXN0YW5jZSwgcG9pbnRMaWdodC5kZWNheSApO1xcblxcblxcdFxcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cXHQgIHZlYzMgcG9zaXRpb247XFxuXFx0ICB2ZWMzIGRpcmVjdGlvbjtcXG5cXHQgIHZlYzMgY29sb3I7XFxuXFx0ICBmbG9hdCBkaXN0YW5jZTtcXG5cXHQgIGZsb2F0IGRlY2F5O1xcblxcdCAgZmxvYXQgYW5nbGVDb3M7XFxuXFx0ICBmbG9hdCBleHBvbmVudDtcXG5cXHQgIGludCBzaGFkb3c7XFxuXFx0fTtcXG5cXG5cXHR1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXG5cXHRJbmNpZGVudExpZ2h0IGdldFNwb3REaXJlY3RMaWdodCggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcblxcblxcdFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiwgc3BvdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcblxcdFxcdGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodC5hbmdsZUNvcyApIHtcXG5cXG5cXHRcXHRcXHRmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHQuZGlyZWN0aW9uLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRcXHRzcG90RWZmZWN0ID0gc2F0dXJhdGUoIHBvdyggc2F0dXJhdGUoIHNwb3RFZmZlY3QgKSwgc3BvdExpZ2h0LmV4cG9uZW50ICkgKTtcXG5cXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSAoIHNwb3RFZmZlY3QgKiBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICkgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBkaXJlY3RMaWdodDtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuXFxuI2lmIE5VTV9IRU1JX0xJR0hUUyA+IDBcXG5cXG5cXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXG5cXHQgIHZlYzMgZGlyZWN0aW9uO1xcblxcdCAgdmVjMyBza3lDb2xvcjtcXG5cXHQgIHZlYzMgZ3JvdW5kQ29sb3I7XFxuXFx0fTtcXG5cXG5cXHR1bmlmb3JtIEhlbWlzcGhlcmVMaWdodCBoZW1pc3BoZXJlTGlnaHRzWyBOVU1fSEVNSV9MSUdIVFMgXTtcXG5cXG5cXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxuXFxuXFx0XFx0cmV0dXJuIFBJICogbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXFxuXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCAvKmNvbnN0IGluIFNwZWN1bGFyTGlnaHRQcm9iZSBzcGVjdWxhckxpZ2h0UHJvYmUsKi8gY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcblxcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cXHRcXHRcXHRmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcblxcblxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0ZmxvYXQgZmxpcE5vcm1hbCA9IDEuMDtcXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggZ2VvbWV0cnkubm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblxcblxcdFxcdFxcdC8vIFRPRE86IHJlcGxhY2Ugd2l0aCBwcm9wZXJseSBmaWx0ZXJlZCBjdWJlbWFwcyBhbmQgYWNjZXNzIHRoZSBpcnJhZGlhbmNlIExPRCBsZXZlbCwgYmUgaXQgdGhlIGxhc3QgTE9EIGxldmVsXFxuXFx0XFx0XFx0Ly8gb2YgYSBzcGVjdWxhciBjdWJlbWFwLCBvciBqdXN0IHRoZSBkZWZhdWx0IGxldmVsIG9mIGEgc3BlY2lhbGx5IGNyZWF0ZWQgaXJyYWRpYW5jZSBjdWJlbWFwLlxcblxcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxuXFxuXFx0XFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHRcXHQvLyBmb3JjZSB0aGUgYmlhcyBoaWdoIHRvIGdldCB0aGUgbGFzdCBMT0QgbGV2ZWwgYXMgaXQgaXMgdGhlIG1vc3QgYmx1cnJlZC5cXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHR2ZWMzIGVudk1hcENvbG9yID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0ZW52TWFwQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW52TWFwQ29sb3IucmdiICk7XFxuXFxuXFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcblxcdH1cXG5cXG5cXHQvLyB0YWtlbiBmcm9tIGhlcmU6IGh0dHA6Ly9jYXN1YWwtZWZmZWN0cy5ibG9nc3BvdC5jYS8yMDExLzA4L3BsYXVzaWJsZS1lbnZpcm9ubWVudC1saWdodGluZy1pbi10d28uaHRtbFxcblxcdGZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXG5cXG5cXHRcXHQvL2Zsb2F0IGVudk1hcFdpZHRoID0gcG93KCAyLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxuXFx0XFx0Ly9mbG9hdCBkZXNpcmVkTUlQTGV2ZWwgPSBsb2cyKCBlbnZNYXBXaWR0aCAqIHNxcnQoIDMuMCApICkgLSAwLjUgKiBsb2cyKCBzcXVhcmUoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQgKSArIDEuMCApO1xcblxcblxcdFxcdGZsb2F0IG1heE1JUExldmVsU2NhbGFyID0gZmxvYXQoIG1heE1JUExldmVsICk7XFxuXFx0XFx0ZmxvYXQgZGVzaXJlZE1JUExldmVsID0gbWF4TUlQTGV2ZWxTY2FsYXIgLSAwLjc5MjQ4IC0gMC41ICogbG9nMiggc3F1YXJlKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICkgKyAxLjAgKTtcXG5cXG5cXHRcXHQvLyBjbGFtcCB0byBhbGxvd2FibGUgTE9EIHJhbmdlcy5cXG5cXHRcXHRyZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1xcblxcblxcdH1cXG5cXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCAvKmNvbnN0IGluIFNwZWN1bGFyTGlnaHRQcm9iZSBzcGVjdWxhckxpZ2h0UHJvYmUsKi8gY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcblxcblxcdFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCApO1xcblxcblxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuXFxuXFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0ZmxvYXQgc3BlY3VsYXJNSVBMZXZlbCA9IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIG1heE1JUExldmVsICk7XFxuXFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG5cXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxuXFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXG5cXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVJlZmxlY3RWZWMsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXG5cXHRcXHRcXHQjZW5kaWZcXG5cXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG5cXG5cXHRcXHRcXHR2ZWMyIHNhbXBsZVVWO1xcblxcdFxcdFxcdHNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueSAqIDAuNSArIDAuNSApO1xcblxcdFxcdFxcdHNhbXBsZVVWLnggPSBhdGFuKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy56LCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXG5cXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcblxcdFxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcblxcdFxcdFxcdCNlbmRpZlxcblxcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFxuXFx0XFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcblxcblxcdFxcdFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFxuXFx0XFx0XFx0I2Vsc2VcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxuXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0ZW52TWFwQ29sb3IucmdiID0gaW5wdXRUb0xpbmVhciggZW52TWFwQ29sb3IucmdiICk7XFxuXFxuXFx0XFx0cmV0dXJuIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4JyBdID1cInZlYzMgZGlmZnVzZSA9IHZlYzMoIDEuMCApO1xcblxcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxuZ2VvbWV0cnkucG9zaXRpb24gPSBtdlBvc2l0aW9uLnh5ejtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggLW12UG9zaXRpb24ueHl6ICk7XFxuXFxuR2VvbWV0cmljQ29udGV4dCBiYWNrR2VvbWV0cnk7XFxuYmFja0dlb21ldHJ5LnBvc2l0aW9uID0gZ2VvbWV0cnkucG9zaXRpb247XFxuYmFja0dlb21ldHJ5Lm5vcm1hbCA9IC1nZW9tZXRyeS5ub3JtYWw7XFxuYmFja0dlb21ldHJ5LnZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcblxcbnZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcXG4jZW5kaWZcXG5cXG4jaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgPSBnZXRQb2ludERpcmVjdExpZ2h0KCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcblxcdFxcdHZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0fVxcblxcbiNlbmRpZlxcblxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgPSBnZXRTcG90RGlyZWN0TGlnaHQoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHR2ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxuXFxuXFx0XFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFxuXFx0XFx0I2lmZGVmIERPVUJMRV9TSURFRFxcblxcblxcdFxcdFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcblxcdFxcdCNlbmRpZlxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0SW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCA9IGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHQoIGRpcmVjdGlvbmFsTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0ZmxvYXQgZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0dmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcblxcdFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcblxcblxcdFxcdCNpZmRlZiBET1VCTEVfU0lERURcXG5cXG5cXHRcXHRcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuXFx0e1xcblxcblxcblxcdFxcdCNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZMaWdodEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0XFx0XFx0XFx0dkxpZ2h0QmFjayArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGJhY2tHZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdCNlbmRpZlxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHQjZW5kaWZcXG5cXG5cXHR9XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX3Bob25nX2ZyYWdtZW50JyBdID1cIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcbm1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhcjtcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG5cXG4jZW5kaWZcXG5cXG5cXG5zdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHtcXG5cXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdHZlYzNcXHRzcGVjdWxhckNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJTaGluaW5lc3M7XFxuXFx0ZmxvYXRcXHRzcGVjdWxhclN0cmVuZ3RoO1xcblxcbn07XFxuXFxudm9pZCBSRV9EaXJlY3RfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIFBJICogZGlyZWN0TGlnaHQuY29sb3I7IC8vIHB1bmN0dWFsIGxpZ2h0XFxuXFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxuXFxufVxcblxcbnZvaWQgUkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmcoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXG59XFxuXFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfQmxpbm5QaG9uZ1xcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXG5cXG4jZGVmaW5lIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QoIG1hdGVyaWFsIClcXHQoMClcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3Bob25nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ192ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG5cXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfc3RhbmRhcmRfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19zdGFuZGFyZF9mcmFnbWVudCcgXSA9XCJTdGFuZGFyZE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggMC4wNCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3N0YW5kYXJkX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19zdGFuZGFyZF9wYXJzX2ZyYWdtZW50JyBdID1cInN0cnVjdCBTdGFuZGFyZE1hdGVyaWFsIHtcXG5cXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0dmVjM1xcdHNwZWN1bGFyQ29sb3I7XFxuXFxufTtcXG5cXG52b2lkIFJFX0RpcmVjdF9TdGFuZGFyZCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gU3RhbmRhcmRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yOyAvLyBwdW5jdHVhbCBsaWdodFxcblxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXG59XFxuXFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfU3RhbmRhcmQoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gU3RhbmRhcmRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxuXFxufVxcblxcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9TdGFuZGFyZCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gU3RhbmRhcmRNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSByYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXG59XFxuXFxuI2RlZmluZSBSRV9EaXJlY3RcXHRcXHRcXHRcXHRSRV9EaXJlY3RfU3RhbmRhcmRcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9TdGFuZGFyZFxcbiNkZWZpbmUgUkVfSW5kaXJlY3RTcGVjdWxhclxcdFxcdFJFX0luZGlyZWN0U3BlY3VsYXJfU3RhbmRhcmRcXG5cXG4jZGVmaW5lIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzIClcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRzX3RlbXBsYXRlLmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfdGVtcGxhdGUnIF0gPVwiLy9cXG4vLyBUaGlzIGlzIGEgdGVtcGxhdGUgdGhhdCBjYW4gYmUgdXNlZCB0byBsaWdodCBhIG1hdGVyaWFsLCBpdCB1c2VzIHBsdWdnYWJsZSBSZW5kZXJFcXVhdGlvbnMgKFJFKVxcbi8vICAgZm9yIHNwZWNpZmljIGxpZ2h0aW5nIHNjZW5hcmlvcy5cXG4vL1xcbi8vIEluc3RydWN0aW9ucyBmb3IgdXNlOlxcbi8vICAtIEVuc3VyZSB0aGF0IGJvdGggUkVfRGlyZWN0LCBSRV9JbmRpcmVjdERpZmZ1c2UgYW5kIFJFX0luZGlyZWN0U3BlY3VsYXIgYXJlIGRlZmluZWRcXG4vLyAgLSBJZiB5b3UgaGF2ZSBkZWZpbmVkIGFuIFJFX0luZGlyZWN0U3BlY3VsYXIsIHlvdSBuZWVkIHRvIGFsc28gcHJvdmlkZSBhIE1hdGVyaWFsX0xpZ2h0UHJvYmVMT0QuIDwtLS0tID8/P1xcbi8vICAtIENyZWF0ZSBhIG1hdGVyaWFsIHBhcmFtZXRlciB0aGF0IGlzIHRvIGJlIHBhc3NlZCBhcyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRvIHlvdXIgbGlnaHRpbmcgZnVuY3Rpb25zLlxcbi8vXFxuLy8gVE9ETzpcXG4vLyAgLSBBZGQgYXJlYSBsaWdodCBzdXBwb3J0Llxcbi8vICAtIEFkZCBzcGhlcmUgbGlnaHQgc3VwcG9ydC5cXG4vLyAgLSBBZGQgZGlmZnVzZSBsaWdodCBwcm9iZSAoaXJyYWRpYW5jZSBjdWJlbWFwKSBzdXBwb3J0Llxcbi8vXFxuXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5cXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcblxcdFxcdFBvaW50TGlnaHQgcG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxuXFxuXFx0XFx0SW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCA9IGdldFBvaW50RGlyZWN0TGlnaHQoIHBvaW50TGlnaHQsIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHRcXHRpZiAoIHBvaW50TGlnaHQuc2hhZG93ID4gLSAxICkge1xcblxcdFxcdFxcdGZvciAoIGludCBqID0gMDsgaiA8IE5VTV9TSEFET1dTOyBqICsrICkge1xcblxcdFxcdFxcdFxcdGlmICggaiA9PSBwb2ludExpZ2h0LnNoYWRvdyApIHtcXG5cXHRcXHRcXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBzaGFkb3dzWyBqIF07XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgKCBOVU1fU1BPVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0U3BvdExpZ2h0IHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXG5cXHRcXHRJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ID0gZ2V0U3BvdERpcmVjdExpZ2h0KCBzcG90TGlnaHQsIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHRcXHRpZiAoIHNwb3RMaWdodC5zaGFkb3cgPiAtIDEgKSB7XFxuXFx0XFx0XFx0Zm9yICggaW50IGogPSAwOyBqIDwgTlVNX1NIQURPV1M7IGogKysgKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCBqID09IHNwb3RMaWdodC5zaGFkb3cgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc2hhZG93c1sgaiBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmICggTlVNX0RJUl9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXG5cXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcblxcdFxcdEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgPSBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0KCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSApO1xcblxcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0aWYgKCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvdyA+IC0gMSApIHtcXG5cXHRcXHRcXHRmb3IgKCBpbnQgaiA9IDA7IGogPCBOVU1fU0hBRE9XUzsgaiArKyApIHtcXG5cXHRcXHRcXHRcXHRpZiAoIGogPT0gZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc2hhZG93c1sgaiBdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxuXFxuXFx0e1xcblxcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxuXFxuXFx0XFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcblxcblxcdFxcdFxcdGlycmFkaWFuY2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7IC8vIGZhY3RvciBvZiBQSSBzaG91bGQgbm90IGJlIHByZXNlbnQ7IGluY2x1ZGVkIGhlcmUgdG8gcHJldmVudCBicmVha2FnZVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcblxcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpcnJhZGlhbmNlICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0Ly8gI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBTVEFOREFSRCApXFxuXFxuXFx0XFx0XFx0Ly8gVE9ETywgcmVwbGFjZSA4IHdpdGggdGhlIHJlYWwgbWF4TUlQTGV2ZWxcXG5cXHRcXHRcXHQvLyBpcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIC8qbGlnaHRQcm9iZSwqLyBnZW9tZXRyeSwgOCApOyAvLyBjb21tZW50IG91dCB1bnRpbCBzZWFtcyBhcmUgZml4ZWRcXG5cXG5cXHRcXHQvLyAjZW5kaWZcXG5cXG5cXHRcXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXG5cXG5cXHR7XFxuXFxuXFx0XFx0Ly8gVE9ETywgcmVwbGFjZSA4IHdpdGggdGhlIHJlYWwgbWF4TUlQTGV2ZWxcXG5cXHRcXHR2ZWMzIHJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIC8qc3BlY3VsYXJMaWdodFByb2JlLCovIGdlb21ldHJ5LCBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxuXFxuXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhciggcmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpbmVhcl90b19nYW1tYV9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50JyBdID1cIlxcblxcdG91dGdvaW5nTGlnaHQgPSBsaW5lYXJUb091dHB1dCggb3V0Z29pbmdMaWdodCApO1xcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfZnJhZ21lbnQnIF0gPVwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFxuXFx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMih2RnJhZ0RlcHRoKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG5cXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuXFx0XFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cXHR2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XFxuXFxuXFx0dGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblxcblxcdGRpZmZ1c2VDb2xvciAqPSB0ZXhlbENvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9NQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWFwX3BhcnRpY2xlX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBVU0VfTUFQXFxuXFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX01BUFxcblxcblxcdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21ldGFsbmVzc21hcF9mcmFnbWVudCcgXSA9XCJmbG9hdCBtZXRhbG5lc3NGYWN0b3IgPSBtZXRhbG5lc3M7XFxuXFxuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXG5cXHR2ZWM0IHRleGVsTWV0YWxuZXNzID0gdGV4dHVyZTJEKCBtZXRhbG5lc3NNYXAsIHZVdiApO1xcblxcdG1ldGFsbmVzc0ZhY3RvciAqPSB0ZXhlbE1ldGFsbmVzcy5yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXG5cXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBobm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGhub3JtYWxfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21vcnBodGFyZ2V0X3BhcnNfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXG5cXG5cXHQjZWxzZVxcblxcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbW9ycGh0YXJnZXRfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxuXFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDEgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDYgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA2IF07XFxuXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbm9ybWFsX2ZyYWdtZW50JyBdID1cIiNpZmRlZiBGTEFUX1NIQURFRFxcblxcblxcdHZlYzMgZmR4ID0gZEZkeCggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcblxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCBjcm9zcyggZmR4LCBmZHkgKSApO1xcblxcbiNlbHNlXFxuXFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIHZOb3JtYWwgKTtcXG5cXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuXFx0XFx0bm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxtYXBfcGFyc19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG5vcm1hbE1hcDtcXG5cXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuXFx0Ly8gUGVyLVBpeGVsIFRhbmdlbnQgU3BhY2UgTm9ybWFsIE1hcHBpbmdcXG5cXHQvLyBodHRwOi8vaGFja3NvZmxpZmUuYmxvZ3Nwb3QuY2gvMjAwOS8xMS9wZXItcGl4ZWwtdGFuZ2VudC1zcGFjZS1ub3JtYWwtbWFwcGluZy5odG1sXFxuXFxuXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG5cXHRcXHR2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMzIHExID0gZEZkeSggZXllX3Bvcy54eXogKTtcXG5cXHRcXHR2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcblxcdFxcdHZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XFxuXFxuXFx0XFx0dmVjMyBTID0gbm9ybWFsaXplKCBxMCAqIHN0MS50IC0gcTEgKiBzdDAudCApO1xcblxcdFxcdHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuXFx0XFx0dmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG5cXHRcXHR2ZWMzIG1hcE4gPSB0ZXh0dXJlMkQoIG5vcm1hbE1hcCwgdlV2ICkueHl6ICogMi4wIC0gMS4wO1xcblxcdFxcdG1hcE4ueHkgPSBub3JtYWxTY2FsZSAqIG1hcE4ueHk7XFxuXFx0XFx0bWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuXFx0XFx0cmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcblxcdH1cXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvcHJvamVjdF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3Byb2plY3RfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiBza2lubmVkO1xcblxcbiNlbHNlXFxuXFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcbiNlbmRpZlxcblxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAncm91Z2huZXNzbWFwX2ZyYWdtZW50JyBdID1cImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG5cXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLnI7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3JvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfZnJhZ21lbnQnIF0gPVwidmVjMyBzaGFkb3dNYXNrID0gdmVjMyggMS4wICk7XFxuXFxuI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG5cXHRmbG9hdCBzaGFkb3dzWyBOVU1fU0hBRE9XUyBdO1xcblxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TSEFET1dTOyBpICsrICkge1xcblxcblxcdFxcdGZsb2F0IHRleGVsU2l6ZVkgPSAgMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuXFx0XFx0ZmxvYXQgc2hhZG93ID0gMC4wO1xcblxcbiNpZmRlZiBQT0lOVF9MSUdIVF9TSEFET1dTXFxuXFxuXFx0XFx0Ly8gdG8gc2F2ZSBvbiB1bmlmb3JtIHNwYWNlLCB3ZSB1c2UgdGhlIHNpZ24gb2YgQHNoYWRvd0RhcmtuZXNzWyBpIF0gdG8gZGV0ZXJtaW5lXFxuXFx0XFx0Ly8gd2hldGhlciBvciBub3QgdGhpcyBsaWdodCBpcyBhIHBvaW50IGxpZ2h0ICggc2hhZG93RGFya25lc3NbIGkgXSA8IDAgPT0gcG9pbnQgbGlnaHQpXFxuXFx0XFx0Ym9vbCBpc1BvaW50TGlnaHQgPSBzaGFkb3dEYXJrbmVzc1sgaSBdIDwgMC4wO1xcblxcblxcdFxcdGlmICggaXNQb2ludExpZ2h0ICkge1xcblxcblxcdFxcdFxcdC8vIGdldCB0aGUgcmVhbCBzaGFkb3cgZGFya25lc3NcXG5cXHRcXHRcXHRmbG9hdCByZWFsU2hhZG93RGFya25lc3MgPSBhYnMoIHNoYWRvd0RhcmtuZXNzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHQvLyBmb3IgcG9pbnQgbGlnaHRzLCB0aGUgdW5pZm9ybSBAdlNoYWRvd0Nvb3JkIGlzIHJlLXB1cnBvc2VkIHRvIGhvbGRcXG5cXHRcXHRcXHQvLyB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGlnaHQgdG8gdGhlIHdvcmxkLXNwYWNlIHBvc2l0aW9uIG9mIHRoZSBmcmFnbWVudC5cXG5cXHRcXHRcXHR2ZWMzIGxpZ2h0VG9Qb3NpdGlvbiA9IHZTaGFkb3dDb29yZFsgaSBdLnh5ejtcXG5cXG5cXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcblxcdFxcdFxcdC8vIGJkM0QgPSBiYXNlIGRpcmVjdGlvbiAzRFxcblxcdFxcdFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0Ly8gZHAgPSBkaXN0YW5jZSBmcm9tIGxpZ2h0IHRvIGZyYWdtZW50IHBvc2l0aW9uXFxuXFx0XFx0XFx0ZmxvYXQgZHAgPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdC8vIGJhc2UgbWVhc3VyZW1lbnRcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcblxcdFxcdFxcdC8vIERyID0gZGlzayByYWRpdXNcXG5cXG5cXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXHRcXHRcXHRjb25zdCBmbG9hdCBEciA9IDEuMjU7XFxuXFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcblxcdFxcdFxcdGNvbnN0IGZsb2F0IERyID0gMi4yNTtcXG5cXHQjZW5kaWZcXG5cXG5cXHRcXHRcXHQvLyBvcyA9IG9mZnNldCBzY2FsZVxcblxcdFxcdFxcdGZsb2F0IG9zID0gRHIgKiAgMi4wICogdGV4ZWxTaXplWTtcXG5cXG5cXHRcXHRcXHRjb25zdCB2ZWMzIEdzZCA9IHZlYzMoIC0gMSwgMCwgMSApO1xcblxcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp4eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHh6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54enogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnp6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenh4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eHggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenp5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eHkgKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh4eSAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueHp5ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC56eXogKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnh5eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2Quenl4ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC54eXggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl6eiAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXHRcXHRcXHRhZGp1c3RTaGFkb3dWYWx1ZTFLKCBkcCwgdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgY3ViZVRvVVYoIGJkM0QgKyBHc2QueXh6ICogb3MsIHRleGVsU2l6ZVkgKSApLCBzaGFkb3dCaWFzWyBpIF0sIHNoYWRvdyApO1xcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCArIEdzZC55eHggKiBvcywgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFx0XFx0XFx0YWRqdXN0U2hhZG93VmFsdWUxSyggZHAsIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIGN1YmVUb1VWKCBiZDNEICsgR3NkLnl6eCAqIG9zLCB0ZXhlbFNpemVZICkgKSwgc2hhZG93Qmlhc1sgaSBdLCBzaGFkb3cgKTtcXG5cXG5cXHRcXHRcXHRzaGFkb3cgKj0gcmVhbFNoYWRvd0RhcmtuZXNzICogKCAxLjAgLyAyMS4wICk7XFxuXFxuXFx0I2Vsc2UgLy8gbm8gcGVyY2VudGFnZS1jbG9zZXIgZmlsdGVyaW5nOlxcblxcblxcdFxcdFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHAgPSBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdGFkanVzdFNoYWRvd1ZhbHVlMUsoIGRwLCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplWSApICksIHNoYWRvd0JpYXNbIGkgXSwgc2hhZG93ICk7XFxuXFxuXFx0XFx0XFx0c2hhZG93ICo9IHJlYWxTaGFkb3dEYXJrbmVzcztcXG5cXG5cXHQjZW5kaWZcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcbiNlbmRpZiAvLyBQT0lOVF9MSUdIVF9TSEFET1dTXFxuXFxuXFx0XFx0XFx0ZmxvYXQgdGV4ZWxTaXplWCA9ICAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcXG5cXG5cXHRcXHRcXHR2ZWMzIHNoYWRvd0Nvb3JkID0gdlNoYWRvd0Nvb3JkWyBpIF0ueHl6IC8gdlNoYWRvd0Nvb3JkWyBpIF0udztcXG5cXG5cXHRcXHRcXHQvLyBpZiAoIHNvbWV0aGluZyAmJiBzb21ldGhpbmcgKSBicmVha3MgQVRJIE9wZW5HTCBzaGFkZXIgY29tcGlsZXJcXG5cXHRcXHRcXHQvLyBpZiAoIGFsbCggc29tZXRoaW5nLCBzb21ldGhpbmcgKSApIHVzaW5nIHRoaXMgaW5zdGVhZFxcblxcblxcdFxcdFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXG5cXHRcXHRcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFxuXFx0XFx0XFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcblxcblxcdFxcdFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXG5cXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXG5cXG5cXHRcXHRcXHRcXHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcblxcdFxcdFxcdFxcdC8vICg5IHBpeGVsIGtlcm5lbClcXG5cXHRcXHRcXHRcXHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuXFx0XFx0XFx0XFx0LypcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG11c3QgZW5yb2xsIGxvb3AgbWFudWFsbHlcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBmbG9hdCB5ID0gLTEuMjU7IHkgPD0gMS4yNTsgeSArPSAxLjI1IClcXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBmbG9hdCB4ID0gLTEuMjU7IHggPD0gMS4yNTsgeCArPSAxLjI1ICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBkb2Vzbid0IHNlZW0gdG8gcHJvZHVjZSBhbnkgbm90aWNlYWJsZSB2aXN1YWwgZGlmZmVyZW5jZSBjb21wYXJlZCB0byBzaW1wbGUgdGV4dHVyZTJEIGxvb2t1cFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vdmVjNCByZ2JhRGVwdGggPSB0ZXh0dXJlMkRQcm9qKCBzaGFkb3dNYXBbIGkgXSwgdmVjNCggdlNoYWRvd0Nvb3JkWyBpIF0udyAqICggdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKSwgMC4wNSwgdlNoYWRvd0Nvb3JkWyBpIF0udyApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93ICs9IDEuMDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93IC89IDkuMDtcXG5cXHRcXHRcXHRcXHQqL1xcblxcblxcdFxcdFxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGNvbnN0IGZsb2F0IFNoYWRvd0RlbHRhID0gMS4wIC8gOS4wO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHhQaXhlbE9mZnNldCA9IHRleGVsU2l6ZVg7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgeVBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWTtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkeDAgPSAtIDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZHkwID0gLSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgZHkxID0gMS4yNSAqIHlQaXhlbE9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcblxcdFxcdFxcdFxcdGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBTaGFkb3dEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gU2hhZG93RGVsdGE7XFxuXFxuXFx0XFx0XFx0XFx0ZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IFNoYWRvd0RlbHRhO1xcblxcblxcdFxcdFxcdFxcdHNoYWRvdyAqPSBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXG5cXHRcXHRcXHRcXHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xcblxcdFxcdFxcdFxcdC8vICg5IHBpeGVsIGtlcm5lbClcXG5cXHRcXHRcXHRcXHQvLyBodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdQQ0YvXFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgeFBpeGVsT2Zmc2V0ID0gdGV4ZWxTaXplWDtcXG5cXHRcXHRcXHRcXHRmbG9hdCB5UGl4ZWxPZmZzZXQgPSB0ZXhlbFNpemVZO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IGR4MCA9IC0gMS4wICogeFBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gMS4wICogeVBpeGVsT2Zmc2V0O1xcblxcdFxcdFxcdFxcdGZsb2F0IGR4MSA9IDEuMCAqIHhQaXhlbE9mZnNldDtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkeTEgPSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuXFx0XFx0XFx0XFx0bWF0MyBzaGFkb3dLZXJuZWw7XFxuXFx0XFx0XFx0XFx0bWF0MyBkZXB0aEtlcm5lbDtcXG5cXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsgMCBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsgMCBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsgMCBdWyAyIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsgMSBdWyAwIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG5cXHRcXHRcXHRcXHRkZXB0aEtlcm5lbFsgMSBdWyAxIF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWyAxIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWyAyIF1bIDAgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWyAyIF1bIDEgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcblxcdFxcdFxcdFxcdGRlcHRoS2VybmVsWyAyIF1bIDIgXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1xcblxcblxcdFxcdFxcdFxcdHZlYzMgc2hhZG93WiA9IHZlYzMoIHNoYWRvd0Nvb3JkLnogKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dLZXJuZWxbIDAgXSA9IHZlYzMoIGxlc3NUaGFuKCBkZXB0aEtlcm5lbFsgMCBdLCBzaGFkb3daICkgKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dLZXJuZWxbIDAgXSAqPSB2ZWMzKCAwLjI1ICk7XFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWyAxIF0gPSB2ZWMzKCBsZXNzVGhhbiggZGVwdGhLZXJuZWxbIDEgXSwgc2hhZG93WiApICk7XFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWyAxIF0gKj0gdmVjMyggMC4yNSApO1xcblxcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFsgMiBdID0gdmVjMyggbGVzc1RoYW4oIGRlcHRoS2VybmVsWyAyIF0sIHNoYWRvd1ogKSApO1xcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFsgMiBdICo9IHZlYzMoIDAuMjUgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbIGkgXS54eSApO1xcblxcblxcdFxcdFxcdFxcdHNoYWRvd0tlcm5lbFsgMCBdID0gbWl4KCBzaGFkb3dLZXJuZWxbIDEgXSwgc2hhZG93S2VybmVsWyAwIF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFx0XFx0XFx0XFx0c2hhZG93S2VybmVsWyAxIF0gPSBtaXgoIHNoYWRvd0tlcm5lbFsgMiBdLCBzaGFkb3dLZXJuZWxbIDEgXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IHNoYWRvd1ZhbHVlcztcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWyAwIF1bIDEgXSwgc2hhZG93S2VybmVsWyAwIF1bIDAgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMueSA9IG1peCggc2hhZG93S2VybmVsWyAwIF1bIDIgXSwgc2hhZG93S2VybmVsWyAwIF1bIDEgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMueiA9IG1peCggc2hhZG93S2VybmVsWyAxIF1bIDEgXSwgc2hhZG93S2VybmVsWyAxIF1bIDAgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWyAxIF1bIDIgXSwgc2hhZG93S2VybmVsWyAxIF1bIDEgXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3cgPSBkb3QoIHNoYWRvd1ZhbHVlcywgdmVjNCggMS4wICkgKSAqIHNoYWRvd0RhcmtuZXNzWyBpIF07XFxuXFxuXFx0I2Vsc2UgLy8gbm8gcGVyY2VudGFnZS1jbG9zZXIgZmlsdGVyaW5nOlxcblxcblxcdFxcdFxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93Qmlhc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3cgPSBzaGFkb3dEYXJrbmVzc1sgaSBdO1xcblxcblxcdCNlbmRpZlxcblxcblxcdFxcdFxcdH1cXG5cXG4jaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuXFx0XFx0XFx0aWYgKCBpbkZydXN0dW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpID09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b3V0Z29pbmdMaWdodCAqPSB2ZWMzKCAxLjAsIDAuNSwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggaSA9PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG91dGdvaW5nTGlnaHQgKj0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b3V0Z29pbmdMaWdodCAqPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgUE9JTlRfTElHSFRfU0hBRE9XU1xcblxcblxcdFxcdH1cXG5cXG4jZW5kaWZcXG5cXG5cXHRcXHRzaGFkb3dNYXNrID0gc2hhZG93TWFzayAqIHZlYzMoIDEuMCAtIHNoYWRvdyApO1xcblxcblxcdFxcdHNoYWRvd3NbIGkgXSA9IDEuMCAtIHNoYWRvdztcXG5cXG5cXHR9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc19mcmFnbWVudCcgXSA9XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTlVNX1NIQURPV1MgXTtcXG5cXHR1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTlVNX1NIQURPV1MgXTtcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBOVU1fU0hBRE9XUyBdO1xcblxcdHVuaWZvcm0gZmxvYXQgc2hhZG93Qmlhc1sgTlVNX1NIQURPV1MgXTtcXG5cXG5cXHR2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBOVU1fU0hBRE9XUyBdO1xcblxcblxcdGZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XFxuXFxuXFx0XFx0Y29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblxcdFxcdGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG5cXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFxuXFx0fVxcblxcblxcdCNpZmRlZiBQT0lOVF9MSUdIVF9TSEFET1dTXFxuXFxuXFx0XFx0Ly8gYWRqdXN0U2hhZG93VmFsdWUxSygpIHVwYWNrcyB0aGUgZGVwdGggdmFsdWUgc3RvcmVkIGluIEB0ZXh0dXJlRGF0YSwgYWRkcyBAYmlhcyB0byBpdCwgYW5kIHRoZW5cXG5cXHRcXHQvLyBjb21hcHJlcyB0aGUgcmVzdWx0IHdpdGggQHRlc3REZXB0aC4gSWYgQHRlc3REZXB0aCBpcyBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byB0aGF0IHJlc3VsdCwgdGhlblxcblxcdFxcdC8vIEBzaGFkb3dWYWx1ZSBpcyBpbmNyZW1lbnRlZCBieSAxLjAuXFxuXFxuXFx0XFx0dm9pZCBhZGp1c3RTaGFkb3dWYWx1ZTFLKCBjb25zdCBmbG9hdCB0ZXN0RGVwdGgsIGNvbnN0IHZlYzQgdGV4dHVyZURhdGEsIGNvbnN0IGZsb2F0IGJpYXMsIGlub3V0IGZsb2F0IHNoYWRvd1ZhbHVlICkge1xcblxcblxcdFxcdFxcdGNvbnN0IHZlYzQgYml0U2ggPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1xcblxcdFxcdFxcdGlmICggdGVzdERlcHRoID49IGRvdCggdGV4dHVyZURhdGEsIGJpdFNoICkgKiAxMDAwLjAgKyBiaWFzIClcXG5cXHRcXHRcXHRcXHRzaGFkb3dWYWx1ZSArPSAxLjA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGN1YmVUb1VWKCkgbWFwcyBhIDNEIGRpcmVjdGlvbiB2ZWN0b3Igc3VpdGFibGUgZm9yIGN1YmUgdGV4dHVyZSBtYXBwaW5nIHRvIGEgMkRcXG5cXHRcXHQvLyB2ZWN0b3Igc3VpdGFibGUgZm9yIDJEIHRleHR1cmUgbWFwcGluZy4gVGhpcyBjb2RlIHVzZXMgdGhlIGZvbGxvd2luZyBsYXlvdXQgZm9yIHRoZVxcblxcdFxcdC8vIDJEIHRleHR1cmU6XFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyB4elhaXFxuXFx0XFx0Ly8gIHkgWVxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXFxuXFx0XFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXFxuXFx0XFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXFxuXFx0XFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXFxuXFx0XFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXFxuXFx0XFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyBTb3VyY2UgYW5kIHRlc3QgYmVkOlxcblxcdFxcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3RzY2h3L2RhMTBjNDNjNDY3Y2U4YWZkMGM0XFxuXFxuXFx0XFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcblxcblxcdFxcdFxcdC8vIE51bWJlciBvZiB0ZXhlbHMgdG8gYXZvaWQgYXQgdGhlIGVkZ2Ugb2YgZWFjaCBzcXVhcmVcXG5cXG5cXHRcXHRcXHR2ZWMzIGFic1YgPSBhYnMoIHYgKTtcXG5cXG5cXHRcXHRcXHQvLyBJbnRlcnNlY3QgdW5pdCBjdWJlXFxuXFxuXFx0XFx0XFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXFx0XFx0XFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXG5cXHRcXHRcXHQvLyBBcHBseSBzY2FsZSB0byBhdm9pZCBzZWFtc1xcblxcblxcdFxcdFxcdC8vIHR3byB0ZXhlbHMgbGVzcyBwZXIgc3F1YXJlIChvbmUgdGV4ZWwgd2lsbCBkbyBmb3IgTkVBUkVTVClcXG5cXHRcXHRcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFxuXFx0XFx0XFx0Ly8gVW53cmFwXFxuXFxuXFx0XFx0XFx0Ly8gc3BhY2U6IC0xIC4uLiAxIHJhbmdlIGZvciBlYWNoIHNxdWFyZVxcblxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0Ly8gI1gjI1xcdFxcdGRpbSAgICA6PSAoIDQgLCAyIClcXG5cXHRcXHRcXHQvLyAgIyAjXFx0XFx0Y2VudGVyIDo9ICggMSAsIDEgKVxcblxcblxcdFxcdFxcdHZlYzIgcGxhbmFyID0gdi54eTtcXG5cXG5cXHRcXHRcXHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcblxcdFxcdFxcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXG5cXG5cXHRcXHRcXHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2LnogPiAwLjAgKVxcblxcdFxcdFxcdFxcdFxcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgc2lnblggPSBzaWduKCB2LnggKTtcXG5cXHRcXHRcXHRcXHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcblxcdFxcdFxcdFxcdHBsYW5hci54ID0gdi54ICsgMi4wICogc2lnblkgKyAyLjA7XFxuXFx0XFx0XFx0XFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gVHJhbnNmb3JtIHRvIFVWIHNwYWNlXFxuXFxuXFx0XFx0XFx0Ly8gc2NhbGUgOj0gMC41IC8gZGltXFxuXFx0XFx0XFx0Ly8gdHJhbnNsYXRlIDo9ICggY2VudGVyICsgMC41ICkgLyBkaW1cXG5cXHRcXHRcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdCNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zaGFkb3dtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX3ZlcnRleCcgXSA9XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblxcdHVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE5VTV9TSEFET1dTIF07XFxuXFx0dmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTlVNX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3ZlcnRleCcgXSA9XCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TSEFET1dTOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZTaGFkb3dDb29yZFsgaSBdID0gc2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcblxcblxcdH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcblxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcblxcdG1hdDQgYm9uZU1hdFogPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueiApO1xcblxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ19wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfcGFyc192ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcblxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4SW52ZXJzZTtcXG5cXG5cXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVXaWR0aDtcXG5cXHRcXHR1bmlmb3JtIGludCBib25lVGV4dHVyZUhlaWdodDtcXG5cXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXFx0XFx0XFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxuXFx0XFx0XFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcdFxcdFxcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXG5cXHRcXHRcXHRmbG9hdCBkeCA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG5cXHRcXHRcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG5cXHRcXHRcXHR2ZWM0IHYxID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAwLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHY0ID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAzLjUgKSwgeSApICk7XFxuXFxuXFx0XFx0XFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHR1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXG5cXHRcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuXFx0XFx0XFx0bWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG5cXHRcXHRcXHRyZXR1cm4gYm9uZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0I2VuZGlmXFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5pbmdfdmVydGV4JyBdID1cIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHR2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcblxcblxcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcblxcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcblxcdHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5vcm1hbF92ZXJ0ZXgnIF0gPVwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcblxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC53ICogYm9uZU1hdFc7XFxuXFx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcblxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfZnJhZ21lbnQnIF0gPVwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG5cXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG5cXG4jZWxzZVxcblxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfZnJhZ21lbnQnIF0gPVwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuXFx0dmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3BhcnNfdmVydGV4JyBdID1cIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcblxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvdXYyX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXYyX3ZlcnRleCcgXSA9XCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG5cXHR2VXYyID0gdXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX2ZyYWdtZW50JyBdID1cIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1dl9wYXJzX3ZlcnRleCcgXSA9XCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXG5cXG5cXHR2YXJ5aW5nIHZlYzIgdlV2O1xcblxcdHVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfdmVydGV4JyBdID1cIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcblxcdHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay93b3JsZHBvc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3dvcmxkcG9zX3ZlcnRleCcgXSA9XCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgfHwgZGVmaW5lZCggU1RBTkRBUkQgKSB8fCBkZWZpbmVkKCBMQU1CRVJUICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcblxcblxcdCNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG5cXHRcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuXFxuXFx0I2Vsc2VcXG5cXG5cXHRcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXG5cXG5cXHQjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcblxuXHRtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcblxuXHRcdHZhciBtZXJnZWQgPSB7fTtcblxuXHRcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuXHRcdFx0Zm9yICggdmFyIHAgaW4gdG1wICkge1xuXG5cdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtZXJnZWQ7XG5cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cblx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cblx0XHRcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG5cdFx0XHRcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuXHRcdFx0XHRpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNMaWIuanNcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG5cdGNvbW1vbjoge1xuXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cblx0XHRcInNwZWN1bGFyTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiYWxwaGFNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cblx0XHRcImVudk1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcImZsaXBFbnZNYXBcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcblx0XHRcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9XG5cblx0fSxcblxuXHRhb21hcDoge1xuXG5cdFx0XCJhb01hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcImFvTWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG5cdH0sXG5cblx0bGlnaHRtYXA6IHtcblxuXHRcdFwibGlnaHRNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cdFx0XCJsaWdodE1hcEludGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuXHR9LFxuXG5cdGVtaXNzaXZlbWFwOiB7XG5cblx0XHRcImVtaXNzaXZlTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXG5cdH0sXG5cblx0YnVtcG1hcDoge1xuXG5cdFx0XCJidW1wTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiYnVtcFNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9XG5cblx0fSxcblxuXHRub3JtYWxtYXA6IHtcblxuXHRcdFwibm9ybWFsTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwibm9ybWFsU2NhbGVcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9XG5cblx0fSxcblxuXHRkaXNwbGFjZW1lbnRtYXA6IHtcblxuXHRcdFwiZGlzcGxhY2VtZW50TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwiZGlzcGxhY2VtZW50U2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XCJkaXNwbGFjZW1lbnRCaWFzXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMCB9XG5cblx0fSxcblxuXHRyb3VnaG5lc3NtYXA6IHtcblxuXHRcdFwicm91Z2huZXNzTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRtZXRhbG5lc3NtYXA6IHtcblxuXHRcdFwibWV0YWxuZXNzTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9XG5cblx0fSxcblxuXHRmb2c6IHtcblxuXHRcdFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcblx0XHRcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXG5cdFx0XCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XG5cblx0fSxcblxuXHRhbWJpZW50OiB7XG5cblx0XHRcImFtYmllbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH1cblxuXHR9LFxuXG5cdGxpZ2h0czoge1xuXG5cdFx0XCJkaXJlY3Rpb25hbExpZ2h0c1wiIDogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0XCJkaXJlY3Rpb25cIjogeyB0eXBlOiBcInYzXCIgfSxcblx0XHRcdFwiY29sb3JcIjogeyB0eXBlOiBcImNcIiB9LFxuXHRcdFx0XCJzaGFkb3dcIjogeyB0eXBlOiBcImlcIiB9XG5cdFx0fSB9LFxuXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRzXCIgOiB7IHR5cGU6IFwic2FcIiwgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxuXHRcdFx0XCJza3lDb2xvclwiOiB7IHR5cGU6IFwiY1wiIH0sXG5cdFx0XHRcImdyb3VuZENvbG9yXCI6IHsgdHlwZTogXCJjXCIgfVxuXHRcdH0gfSxcblxuXHRcdFwicG9pbnRMaWdodHNcIiA6IHsgdHlwZTogXCJzYVwiLCB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcblx0XHRcdFwiY29sb3JcIjogeyB0eXBlOiBcImNcIiB9LFxuXHRcdFx0XCJwb3NpdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxuXHRcdFx0XCJkZWNheVwiOiB7IHR5cGU6IFwiZlwiIH0sXG5cdFx0XHRcImRpc3RhbmNlXCI6IHsgdHlwZTogXCJmXCIgfSxcblx0XHRcdFwic2hhZG93XCI6IHsgdHlwZTogXCJpXCIgfVxuXHRcdH0gfSxcblxuXHRcdFwic3BvdExpZ2h0c1wiIDogeyB0eXBlOiBcInNhXCIsIHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuXHRcdFx0XCJjb2xvclwiOiB7IHR5cGU6IFwiY1wiIH0sXG5cdFx0XHRcInBvc2l0aW9uXCI6IHsgdHlwZTogXCJ2M1wiIH0sXG5cdFx0XHRcImRpcmVjdGlvblwiOiB7IHR5cGU6IFwidjNcIiB9LFxuXHRcdFx0XCJkaXN0YW5jZVwiOiB7IHR5cGU6IFwiZlwiIH0sXG5cdFx0XHRcImFuZ2xlQ29zXCI6IHsgdHlwZTogXCJmXCIgfSxcblx0XHRcdFwiZXhwb25lbnRcIjogeyB0eXBlOiBcImZcIiB9LFxuXHRcdFx0XCJkZWNheVwiOiB7IHR5cGU6IFwiZlwiIH0sXG5cdFx0XHRcInNoYWRvd1wiOiB7IHR5cGU6IFwiaVwiIH1cblx0XHR9IH1cblxuXHR9LFxuXG5cdHBvaW50czoge1xuXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XCJzY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfVxuXG5cdH0sXG5cblx0c2hhZG93bWFwOiB7XG5cblx0XHRcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MnZcIiwgdmFsdWU6IFtdIH0sXG5cblx0XHRcInNoYWRvd0JpYXNcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cdFx0XCJzaGFkb3dEYXJrbmVzc1wiOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG5cdFx0XCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xuXG4vKipcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5cblRIUkVFLlNoYWRlckxpYiA9IHtcblxuXHQnYmFzaWMnOiB7XG5cblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfRU5WTUFQXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwiXHQjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQ7XCIsXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcIlx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZGlmZnVzZUNvbG9yLnJnYjtcIixcblx0XHRcdFwiXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwicmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IHNoYWRvd01hc2s7XCIsXG5cblx0XHRcdFx0XCJ2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdH0sXG5cblx0J2xhbWJlcnQnOiB7XG5cblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZW1pc3NpdmVtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImFtYmllbnRcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXG5cblx0XHRcdHtcblx0XHRcdFx0XCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9XG5cdFx0XHR9XG5cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCIjZGVmaW5lIExBTUJFUlRcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXG5cblx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJzZGZzXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX2xhbWJlcnRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cblx0XHRcdFwiXHR2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFtYmllbnRfcGFyc1wiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXHRcdFx0XCJcdHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1wiLFxuXHRcdFx0XCJcdHZlYzMgdG90YWxFbWlzc2l2ZUxpZ2h0ID0gZW1pc3NpdmU7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbWlzc2l2ZW1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0Ly8gZm9ybWVyIGxpZ2h0bWFwX2ZyYWdtZW50Lmdsc2xcblx0XHRcdFwiXHQjaWZkZWYgVVNFX0xJR0hUTUFQXCIsXG5cblx0XHRcdFwiXHRcdHRvdGFsQW1iaWVudExpZ2h0ICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1wiLCAvLyBmYWN0b3Igb2YgUEkgc2hvdWxkIG5vdCBiZSBwcmVzZW50OyBpbmNsdWRlZCBoZXJlIHRvIHByZXZlbnQgYnJlYWthZ2VcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vIGZvcm1lciBhb21hcF9mcmFnbWVudC5nbHNsXG5cdFx0XHRcIlx0I2lmZGVmIFVTRV9BT01BUFwiLFxuXG5cdFx0XHRcIlx0XHR0b3RhbEFtYmllbnRMaWdodCAqPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcIlx0I2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG5cdFx0XHRcIlx0XHRpZiAoIGdsX0Zyb250RmFjaW5nIClcIixcblx0XHRcdFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yLnJnYiAqICggdkxpZ2h0RnJvbnQgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblx0XHRcdFwiXHRcdGVsc2VcIixcblx0XHRcdFwiXHRcdFx0b3V0Z29pbmdMaWdodCArPSBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yLnJnYiAqICggdkxpZ2h0QmFjayAqIHNoYWRvd01hc2sgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxFbWlzc2l2ZUxpZ2h0O1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0b3V0Z29pbmdMaWdodCArPSBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yLnJnYiAqICggdkxpZ2h0RnJvbnQgKiBzaGFkb3dNYXNrICsgdG90YWxBbWJpZW50TGlnaHQgKSArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIlx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0fSxcblxuXHQncGhvbmcnOiB7XG5cblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZW1pc3NpdmVtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcG1hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZGlzcGxhY2VtZW50bWFwXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhbWJpZW50XCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG5cdFx0XHR7XG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcblx0XHRcdFx0XCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuXHRcdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfVxuXHRcdFx0fVxuXG5cdFx0XSApLFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwiI2RlZmluZSBQSE9OR1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG5cdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcblxuXHRcdFx0XCJcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG5cdFx0XHRcIiNlbmRpZlwiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3Bob25nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxuXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnNkZnNcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW1iaWVudF9wYXJzXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19wYXJzXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJ1bXBtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJub3JtYWxtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXHRcdFx0XCJcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XCIsXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdC8vIGFjY3VtdWxhdGlvblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfdGVtcGxhdGVcIiBdLFxuXG5cdFx0XHRcdC8vIG1vZHVsYXRpb25cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwidmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cdCdzdGFuZGFyZCc6IHtcblxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJhb21hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodG1hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJlbWlzc2l2ZW1hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wbWFwXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm5vcm1hbG1hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJkaXNwbGFjZW1lbnRtYXBcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwicm91Z2huZXNzbWFwXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcIm1ldGFsbmVzc21hcFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiYW1iaWVudFwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuXHRcdFx0e1xuXHRcdFx0XHRcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH0sXG5cdFx0XHRcdFwicm91Z2huZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjUgfSxcblx0XHRcdFx0XCJtZXRhbG5lc3NcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAgfSxcblx0XHRcdFx0XCJlbnZNYXBJbnRlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0gLy8gdGVtcG9yYXJ5XG5cdFx0XHR9XG5cblx0XHRdICksXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCIjZGVmaW5lIFNUQU5EQVJEXCIsXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXG5cblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLCAvLyBTVEFOREFSRFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2Ml92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2lubm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBobm9ybWFsX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIiNpZm5kZWYgRkxBVF9TSEFERURcIiwgLy8gTm9ybWFsIGNvbXB1dGVkIHdpdGggZGVyaXZhdGl2ZXMgd2hlbiBGTEFUX1NIQURFRFxuXG5cdFx0XHRcIlx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuXHRcdFx0XCIjZW5kaWZcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkaXNwbGFjZW1lbnRtYXBfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcIiNkZWZpbmUgU1RBTkRBUkRcIixcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtZXRhbG5lc3M7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcIiwgLy8gdGVtcG9yYXJ5XG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XCIsXG5cblx0XHRcdFwiI2lmbmRlZiBGTEFUX1NIQURFRFwiLFxuXG5cdFx0XHRcIlx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cblx0XHRcdFwiI2VuZGlmXCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhb21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJic2Rmc1wiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbWJpZW50X3BhcnNcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3BhcnNcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRzX3N0YW5kYXJkX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXHRcdFx0XCJcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XCIsXG5cdFx0XHRcIlx0dmVjMyB0b3RhbEVtaXNzaXZlTGlnaHQgPSBlbWlzc2l2ZTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInJvdWdobmVzc21hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1ldGFsbmVzc21hcF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm5vcm1hbF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVtaXNzaXZlbWFwX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdC8vIGFjY3VtdWxhdGlvblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfc3RhbmRhcmRfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfdGVtcGxhdGVcIiBdLFxuXG5cdFx0XHRcdC8vIG1vZHVsYXRpb25cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFwidmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVMaWdodDtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwiXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cdCdwb2ludHMnOiB7XG5cblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJwb2ludHNcIiBdLFxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2l6ZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXCIsXG5cdFx0XHRcIlx0XHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XCIsXG5cdFx0XHRcIlx0I2Vsc2VcIixcblx0XHRcdFwiXHRcdGdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcIlx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsXG5cdFx0XHRcIlx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfZnJhZ21lbnRcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwiXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIHNoYWRvd01hc2s7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdH0sXG5cblx0J2Rhc2hlZCc6IHtcblxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxuXG5cdFx0XHR7XG5cdFx0XHRcdFwic2NhbGVcIiAgICA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwiZGFzaFNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG5cdFx0XHRcdFwidG90YWxTaXplXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyIH1cblx0XHRcdH1cblxuXHRcdF0gKSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXG5cdFx0XHRcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXG5cblx0XHRcdFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIlx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxuXG5cdFx0XHRcIlx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZGFzaFNpemU7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcIlx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXG5cblx0XHRcdFwiXHRcdGRpc2NhcmQ7XCIsXG5cblx0XHRcdFwiXHR9XCIsXG5cblx0XHRcdFwiXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcIixcblx0XHRcdFwiXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdH0sXG5cblx0J2RlcHRoJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cdFx0XHRcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1OZWFyO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG1GYXI7XCIsXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG5cdFx0XHRcIlx0XHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdEZXB0aEVYVCAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG5cdFx0XHRcIlx0I2Vsc2VcIixcblxuXHRcdFx0XCJcdFx0ZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG5cdFx0XHRcIlx0I2VuZGlmXCIsXG5cblx0XHRcdFwiXHRmbG9hdCBjb2xvciA9IDEuMCAtIHNtb290aHN0ZXAoIG1OZWFyLCBtRmFyLCBkZXB0aCApO1wiLFxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0fSxcblxuXHQnbm9ybWFsJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblxuXHRcdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH1cblxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwiXHR2Tm9ybWFsID0gbm9ybWFsaXplKCBub3JtYWxNYXRyaXggKiBub3JtYWwgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJiZWdpbl92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJwcm9qZWN0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwifVwiXG5cblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuNSAqIG5vcm1hbGl6ZSggdk5vcm1hbCApICsgMC41LCBvcGFjaXR5ICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdCdjdWJlJzoge1xuXG5cdFx0dW5pZm9ybXM6IHtcblx0XHRcdFwidEN1YmVcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcblx0XHRcdFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0gMSB9XG5cdFx0fSxcblxuXHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFwiXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XCIsXG5cblx0XHRcdFwiXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1wiLFxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdCdlcXVpcmVjdCc6IHtcblxuXHRcdHVuaWZvcm1zOiB7XG5cdFx0XHRcInRFcXVpcmVjdFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuXHRcdFx0XCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH1cblx0XHR9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XCJcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuXHRcdFx0XCJcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcIixcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0Ly8gXCJcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmVDdWJlKCB0Q3ViZSwgdmVjMyggdEZsaXAgKiB2V29ybGRQb3NpdGlvbi54LCB2V29ybGRQb3NpdGlvbi55eiApICk7XCIsXG5cdFx0XHRcdFwidmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XCIsXG5cdFx0XHRcdFwidmVjMiBzYW1wbGVVVjtcIixcblx0XHRcdFx0XCJzYW1wbGVVVi55ID0gc2F0dXJhdGUoIHRGbGlwICogZGlyZWN0aW9uLnkgKiAtMC41ICsgMC41ICk7XCIsXG5cdFx0XHRcdFwic2FtcGxlVVYueCA9IGF0YW4oIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XCIsXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XCIsXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cdC8qIERlcHRoIGVuY29kaW5nIGludG8gUkdCQSB0ZXh0dXJlXG5cdCAqXG5cdCAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxuXHQgKiBodHRwOi8vc3BpZGVyZ2wub3JnL2V4YW1wbGUucGhwP2lkPTZcblx0ICpcblx0ICogb3JpZ2luYWxseSBmcm9tXG5cdCAqIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvNDQyMTM4LXBhY2tpbmctYS1mbG9hdC1pbnRvLWEtYThyOGc4YjgtdGV4dHVyZS1zaGFkZXIvcGFnZV9fd2hpY2hwYWdlX18xJTI1RUYlMjVCRiUyNUJEXG5cdCAqXG5cdCAqIHNlZSBhbHNvXG5cdCAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuXHQgKi9cblxuXHQnZGVwdGhSR0JBJzoge1xuXG5cdFx0dW5pZm9ybXM6IHt9LFxuXG5cdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYmVnaW5fdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwicHJvamVjdF92ZXJ0ZXhcIiBdLFxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwidmVjNCBwYWNrX2RlcHRoKCBjb25zdCBpbiBmbG9hdCBkZXB0aCApIHtcIixcblxuXHRcdFx0XCJcdGNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXG5cdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRfbWFzayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxuXHRcdFx0XCJcdHZlYzQgcmVzID0gbW9kKCBkZXB0aCAqIGJpdF9zaGlmdCAqIHZlYzQoIDI1NSApLCB2ZWM0KCAyNTYgKSApIC8gdmVjNCggMjU1ICk7XCIsIC8vIFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdF9zaGlmdCApO1wiLFxuXHRcdFx0XCJcdHJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxuXHRcdFx0XCJcdHJldHVybiByZXM7XCIsXG5cblx0XHRcdFwifVwiLFxuXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cblx0XHRcdFwiXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG5cdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0RlcHRoRVhUICk7XCIsXG5cblx0XHRcdFwiXHQjZWxzZVwiLFxuXG5cdFx0XHRcIlx0XHRnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogKTtcIixcblxuXHRcdFx0XCJcdCNlbmRpZlwiLFxuXG5cdFx0XHRcdC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApO1wiLFxuXHRcdFx0XHQvL1wiZmxvYXQgeiA9ICggKCBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53ICkgLSAzLjAgKSAvICggNDAwMC4wIC0gMy4wICk7XCIsXG5cdFx0XHRcdC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggeiApO1wiLFxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHZlYzQoIHosIHosIHosIDEuMCApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9LFxuXG5cblx0J2Rpc3RhbmNlUkdCQSc6IHtcblxuXHRcdHVuaWZvcm1zOiB7XG5cblx0XHRcdFwibGlnaHRQb3NcIjogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApIH1cblxuXHRcdH0sXG5cblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XCIsXG5cblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG5cblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImJlZ2luX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInByb2plY3RfdmVydGV4XCIgXSxcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcblxuXHRcdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0XCJ9XCJcblxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxuXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgbGlnaHRQb3M7XCIsXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2V29ybGRQb3NpdGlvbjtcIixcblxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcblxuXHRcdFx0XCJ2ZWM0IHBhY2sxSyAoIGZsb2F0IGRlcHRoICkge1wiLFxuXG5cdFx0XHRcIiAgIGRlcHRoIC89IDEwMDAuMDtcIixcblx0XHRcdFwiICAgY29uc3QgdmVjNCBiaXRTaCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuICBcdFx0XHRcIlx0Y29uc3QgdmVjNCBiaXRNc2sgPSB2ZWM0KCAwLjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCwgMS4wIC8gMjU2LjAgKTtcIixcbiAgIFx0XHRcdFwiXHR2ZWM0IHJlcyA9IGZyYWN0KCBkZXB0aCAqIGJpdFNoICk7XCIsXG4gICBcdFx0XHRcIlx0cmVzIC09IHJlcy54eHl6ICogYml0TXNrO1wiLFxuICAgXHRcdFx0XCJcdHJldHVybiByZXM7IFwiLFxuXG5cdFx0XHRcIn1cIixcblxuXHRcdFx0XCJmbG9hdCB1bnBhY2sxSyAoIHZlYzQgY29sb3IgKSB7XCIsXG5cblx0XHRcdFwiXHRjb25zdCB2ZWM0IGJpdFNoID0gdmVjNCggMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gKCAyNTYuMCAqIDI1Ni4wICksIDEuMCAvIDI1Ni4wLCAxLjAgKTtcIixcblx0XHRcdFwiXHRyZXR1cm4gZG90KCBjb2xvciwgYml0U2ggKSAqIDEwMDAuMDtcIixcblxuXHRcdFx0XCJ9XCIsXG5cblx0XHRcdFwidm9pZCBtYWluICgpIHtcIixcblxuXHRcdFx0XCJcdGdsX0ZyYWdDb2xvciA9IHBhY2sxSyggbGVuZ3RoKCB2V29ybGRQb3NpdGlvbi54eXogLSBsaWdodFBvcy54eXogKSApO1wiLFxuXG5cdFx0XHRcIn1cIlxuXG5cdFx0XS5qb2luKCBcIlxcblwiIClcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlcmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLldlYkdMUmVuZGVyZXIgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cblx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgVEhSRUUuUkVWSVNJT04gKTtcblxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuXHR2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICksXG5cdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxuXG5cdF93aWR0aCA9IF9jYW52YXMud2lkdGgsXG5cdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcblxuXHRwaXhlbFJhdGlvID0gMSxcblxuXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXG5cdF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxuXHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxuXHRfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcblx0X3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlLFxuXG5cdF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxuXHRfY2xlYXJBbHBoYSA9IDA7XG5cblx0dmFyIGxpZ2h0cyA9IFtdO1xuXG5cdHZhciBvcGFxdWVPYmplY3RzID0gW107XG5cdHZhciBvcGFxdWVPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG5cdHZhciB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG5cblx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKTtcblxuXG5cdHZhciBzcHJpdGVzID0gW107XG5cdHZhciBsZW5zRmxhcmVzID0gW107XG5cblx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuXHR0aGlzLmRvbUVsZW1lbnQgPSBfY2FudmFzO1xuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xuXG5cdC8vIGNsZWFyaW5nXG5cblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcblx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG5cdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XG5cblx0Ly8gc2NlbmUgZ3JhcGhcblxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcblxuXHR0aGlzLmdhbW1hRmFjdG9yID0gMi4wO1x0Ly8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuXHR0aGlzLmdhbW1hT3V0cHV0ID0gZmFsc2U7XG5cblx0Ly8gbW9ycGhzXG5cblx0dGhpcy5tYXhNb3JwaFRhcmdldHMgPSA4O1xuXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XG5cblx0Ly8gZmxhZ3NcblxuXHR0aGlzLmF1dG9TY2FsZUN1YmVtYXBzID0gdHJ1ZTtcblxuXHQvLyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG5cblx0dmFyIF90aGlzID0gdGhpcyxcblxuXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxuXG5cdF9jdXJyZW50Vmlld3BvcnQgPSBudWxsLFxuXHRfY3VycmVudFByb2dyYW0gPSBudWxsLFxuXHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGwsXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXG5cdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcblxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXG5cblx0X3NjaXNzb3IgPSBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgX2NhbnZhcy53aWR0aCwgX2NhbnZhcy5oZWlnaHQgKSxcblx0X3NjaXNzb3JUZXN0ID0gZmFsc2UsXG5cblx0X3ZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIF9jYW52YXMud2lkdGgsIF9jYW52YXMuaGVpZ2h0ICksXG5cblx0Ly8gZnJ1c3R1bVxuXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblxuXHQgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG5cdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuXHQvLyBsaWdodCBhcnJheXMgY2FjaGVcblxuXHRfbGlnaHRzID0ge1xuXG5cdFx0aGFzaDogJycsXG5cblx0XHRhbWJpZW50OiBbIDAsIDAsIDAgXSxcblx0XHRkaXJlY3Rpb25hbDogW10sXG5cdFx0cG9pbnQ6IFtdLFxuXHRcdHNwb3Q6IFtdLFxuXHRcdGhlbWk6IFtdLFxuXG5cdFx0c2hhZG93czogW10sXG5cdFx0c2hhZG93c1BvaW50TGlnaHQ6IDBcblxuXHR9LFxuXG5cdC8vIGluZm9cblxuXHRfaW5mb01lbW9yeSA9IHtcblxuXHRcdGdlb21ldHJpZXM6IDAsXG5cdFx0dGV4dHVyZXM6IDBcblxuXHR9LFxuXG5cdF9pbmZvUmVuZGVyID0ge1xuXG5cdFx0Y2FsbHM6IDAsXG5cdFx0dmVydGljZXM6IDAsXG5cdFx0ZmFjZXM6IDAsXG5cdFx0cG9pbnRzOiAwXG5cblx0fTtcblxuXHR0aGlzLmluZm8gPSB7XG5cblx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxuXHRcdG1lbW9yeTogX2luZm9NZW1vcnksXG5cdFx0cHJvZ3JhbXM6IG51bGxcblxuXHR9O1xuXG5cblx0Ly8gaW5pdGlhbGl6ZVxuXG5cdHZhciBfZ2w7XG5cblx0dHJ5IHtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0ge1xuXHRcdFx0YWxwaGE6IF9hbHBoYSxcblx0XHRcdGRlcHRoOiBfZGVwdGgsXG5cdFx0XHRzdGVuY2lsOiBfc3RlbmNpbCxcblx0XHRcdGFudGlhbGlhczogX2FudGlhbGlhcyxcblx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcblx0XHRcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuXHRcdH07XG5cblx0XHRfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzICk7XG5cblx0XHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0Lic7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG5cdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgZXJyb3IgKTtcblxuXHR9XG5cblx0dmFyIGV4dGVuc2lvbnMgPSBuZXcgVEhSRUUuV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcblxuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xuXHRleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblx0ZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdGlmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG5cdFx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xuXG5cdH1cblxuXHR2YXIgY2FwYWJpbGl0aWVzID0gbmV3IFRIUkVFLldlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKTtcblxuXHR2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xuXHR2YXIgcHJvcGVydGllcyA9IG5ldyBUSFJFRS5XZWJHTFByb3BlcnRpZXMoKTtcblx0dmFyIG9iamVjdHMgPSBuZXcgVEhSRUUuV2ViR0xPYmplY3RzKCBfZ2wsIHByb3BlcnRpZXMsIHRoaXMuaW5mbyApO1xuXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFRIUkVFLldlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xuXHR2YXIgbGlnaHRDYWNoZSA9IG5ldyBUSFJFRS5XZWJHTExpZ2h0cygpO1xuXG5cdHRoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcblxuXHR2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXHR2YXIgaW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkge1xuXG5cdFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gcGl4ZWxSYXRpbyA6IDE7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdsQ2xlYXJDb2xvciggciwgZywgYiwgYSApIHtcblxuXHRcdGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcblxuXHRcdH1cblxuXHRcdF9nbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlKCkge1xuXG5cdFx0c3RhdGUuaW5pdCgpO1xuXG5cdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3IgKTtcblx0XHRzdGF0ZS52aWV3cG9ydCggX3ZpZXdwb3J0ICk7XG5cblx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2V0R0xTdGF0ZSgpIHtcblxuXHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG5cdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xuXG5cdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cblx0XHRzdGF0ZS5yZXNldCgpO1xuXG5cdH1cblxuXHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdHRoaXMuY29udGV4dCA9IF9nbDtcblx0dGhpcy5jYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXRpZXM7XG5cdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG5cdHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG5cdHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuXHQvLyBzaGFkb3cgbWFwXG5cblx0dmFyIHNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFNoYWRvd01hcCggdGhpcywgX2xpZ2h0cywgb2JqZWN0cyApO1xuXG5cdHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xuXG5cblx0Ly8gUGx1Z2luc1xuXG5cdHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XG5cdHZhciBsZW5zRmxhcmVQbHVnaW4gPSBuZXcgVEhSRUUuTGVuc0ZsYXJlUGx1Z2luKCB0aGlzLCBsZW5zRmxhcmVzICk7XG5cblx0Ly8gQVBJXG5cblx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9nbDtcblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2dsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG5cblx0fTtcblxuXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKS5sb3NlQ29udGV4dCgpO1xuXG5cdH07XG5cblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgdmFsdWU7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF4QW5pc290cm9weSgpIHtcblxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xuXG5cdFx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhbHVlID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHR9O1xuXG5cdH0gKSgpO1xuXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGNhcGFiaWxpdGllcy5wcmVjaXNpb247XG5cblx0fTtcblxuXHR0aGlzLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gcGl4ZWxSYXRpbztcblxuXHR9O1xuXG5cdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSBwaXhlbFJhdGlvID0gdmFsdWU7XG5cblx0fTtcblxuXHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IF93aWR0aCxcblx0XHRcdGhlaWdodDogX2hlaWdodFxuXHRcdH07XG5cblx0fTtcblxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xuXG5cdFx0X3dpZHRoID0gd2lkdGg7XG5cdFx0X2hlaWdodCA9IGhlaWdodDtcblxuXHRcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG5cdFx0aWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cblx0XHR9XG5cblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0X3ZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApLm11bHRpcGx5U2NhbGFyKCBwaXhlbFJhdGlvICk7XG5cblx0XHRzdGF0ZS52aWV3cG9ydCggX3ZpZXdwb3J0ICk7XG5cblx0fTtcblxuXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cblx0XHRfc2Npc3Nvci5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKS5tdWx0aXBseVNjYWxhciggcGl4ZWxSYXRpbyApO1xuXG5cdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3IgKTtcblxuXHR9O1xuXG5cdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XG5cblx0XHRfc2Npc3NvclRlc3QgPSBib29sZWFuO1xuXG5cdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcblxuXHR9O1xuXG5cdC8vIENsZWFyaW5nXG5cblx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xuXG5cdH07XG5cblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XG5cblx0XHRfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XG5cblx0XHRfY2xlYXJBbHBoYSA9IGFscGhhICE9PSB1bmRlZmluZWQgPyBhbHBoYSA6IDE7XG5cblx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cblx0fTtcblxuXHR0aGlzLmdldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gX2NsZWFyQWxwaGE7XG5cblx0fTtcblxuXHR0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoIGFscGhhICkge1xuXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcblxuXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuXHR9O1xuXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuXHRcdHZhciBiaXRzID0gMDtcblxuXHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCB8fCBjb2xvciApIGJpdHMgfD0gX2dsLkNPTE9SX0JVRkZFUl9CSVQ7XG5cdFx0aWYgKCBkZXB0aCA9PT0gdW5kZWZpbmVkIHx8IGRlcHRoICkgYml0cyB8PSBfZ2wuREVQVEhfQlVGRkVSX0JJVDtcblx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG5cdFx0X2dsLmNsZWFyKCBiaXRzICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5DT0xPUl9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRfZ2wuY2xlYXIoIF9nbC5ERVBUSF9CVUZGRVJfQklUICk7XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdF9nbC5jbGVhciggX2dsLlNURU5DSUxfQlVGRkVSX0JJVCApO1xuXG5cdH07XG5cblx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XG5cblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cblx0fTtcblxuXHQvLyBSZXNldFxuXG5cdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xuXG5cdHRoaXMuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XG5cblx0fTtcblxuXHQvLyBFdmVudHNcblxuXHRmdW5jdGlvbiBvbkNvbnRleHRMb3N0KCBldmVudCApIHtcblxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRyZXNldEdMU3RhdGUoKTtcblx0XHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG5cdFx0cHJvcGVydGllcy5jbGVhcigpO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBvblRleHR1cmVEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuXG5cdH1cblxuXHRmdW5jdGlvbiBvblJlbmRlclRhcmdldERpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG5cdFx0ZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xuXG5cdFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG5cdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG5cdH1cblxuXHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXG5cblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XG5cblx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdC8vIGN1YmUgdGV4dHVyZVxuXG5cdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gMkQgdGV4dHVyZVxuXG5cdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIHRleHR1cmUgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG5cblx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0IHx8IHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xuXHRcdFx0XHRfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICk7XG5cblx0XHR9XG5cblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggcmVuZGVyVGFyZ2V0ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cblx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIG1hdGVyaWFsICk7XG5cblx0fVxuXG5cblx0ZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XG5cblx0XHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKS5wcm9ncmFtO1xuXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHRcdGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtSW5mbyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBCdWZmZXIgcmVuZGVyaW5nXG5cblx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XG5cblx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG5cdFx0dmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XG5cblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XG5cblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XG5cblx0XHRcdGlmICggbWF0ZXJpYWwudHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyAmJiBtYXRlcmlhbC50eXBlICE9PSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XG5cblx0XHRcdFx0XHR2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XG5cblx0XHRcdFx0XHR2YXIgbnggPSAoIGFycmF5WyBpICsgMCBdICsgYXJyYXlbIGkgKyAzIF0gKyBhcnJheVsgaSArIDYgXSApIC8gMztcblx0XHRcdFx0XHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcblx0XHRcdFx0XHR2YXIgbnogPSAoIGFycmF5WyBpICsgMiBdICsgYXJyYXlbIGkgKyA1IF0gKyBhcnJheVsgaSArIDggXSApIC8gMztcblxuXHRcdFx0XHRcdGFycmF5WyBpICsgMCBdID0gbng7XG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAxIF0gPSBueTtcblx0XHRcdFx0XHRhcnJheVsgaSArIDIgXSA9IG56O1xuXG5cdFx0XHRcdFx0YXJyYXlbIGkgKyAzIF0gPSBueDtcblx0XHRcdFx0XHRhcnJheVsgaSArIDQgXSA9IG55O1xuXHRcdFx0XHRcdGFycmF5WyBpICsgNSBdID0gbno7XG5cblx0XHRcdFx0XHRhcnJheVsgaSArIDYgXSA9IG54O1xuXHRcdFx0XHRcdGFycmF5WyBpICsgNyBdID0gbnk7XG5cdFx0XHRcdFx0YXJyYXlbIGkgKyA4IF0gPSBuejtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XG5cblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcblxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG5cdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcblxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xuXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XG5cblx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xuXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuXHRcdG9iamVjdC5jb3VudCA9IDA7XG5cblx0fTtcblxuXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcblxuXHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG5cdFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcblx0XHR2YXIgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgbWF0ZXJpYWwud2lyZWZyYW1lO1xuXG5cdFx0aWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xuXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0Ly8gbW9ycGggdGFyZ2V0c1xuXG5cdFx0dmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cblx0XHRpZiAoIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgaW5mbHVlbmNlID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBpIF07XG5cdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGFjdGl2ZUluZmx1ZW5jZXMuc29ydCggYWJzTnVtZXJpY2FsU29ydCApO1xuXG5cdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID4gOCApIHtcblxuXHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aCA9IDg7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF07XG5cdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XG5cblx0XHRcdFx0aWYgKCBpbmZsdWVuY2VbIDAgXSAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IGluZmx1ZW5jZVsgMSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGksIG1vcnBoQXR0cmlidXRlcy5ub3JtYWxbIGluZGV4IF0gKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciB1bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKTtcblxuXHRcdFx0aWYgKCB1bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xZnYoIHVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgbW9ycGhJbmZsdWVuY2VzICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG5cdFx0XHRpbmRleCA9IG9iamVjdHMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0cmVuZGVyZXIgPSBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XG5cdFx0XHRyZW5kZXJlci5zZXRJbmRleCggaW5kZXggKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XG5cblx0XHR9XG5cblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XG5cblx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGluZGV4ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9cblxuXHRcdHZhciBkYXRhU3RhcnQgPSAwO1xuXHRcdHZhciBkYXRhQ291bnQgPSBJbmZpbml0eTtcblxuXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cblx0XHRcdGRhdGFDb3VudCA9IGluZGV4LmNvdW50O1xuXG5cdFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0ZGF0YUNvdW50ID0gcG9zaXRpb24uY291bnQ7XG5cblx0XHR9XG5cblx0XHR2YXIgcmFuZ2VTdGFydCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5zdGFydDtcblx0XHR2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudDtcblxuXHRcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCA6IDA7XG5cdFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50IDogSW5maW5pdHk7XG5cblx0XHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIGRhdGFTdGFydCwgcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xuXHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFTdGFydCArIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xuXG5cdFx0dmFyIGRyYXdDb3VudCA9IE1hdGgubWF4KCAwLCBkcmF3RW5kIC0gZHJhd1N0YXJ0ICsgMSApO1xuXG5cdFx0Ly9cblxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cblx0XHRcdFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcblx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3dpdGNoICggb2JqZWN0LmRyYXdNb2RlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5UcmlhbmdsZXNEcmF3TW9kZTpcblx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5UcmlhbmdsZVN0cmlwRHJhd01vZGU6XG5cdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfU1RSSVAgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5UcmlhbmdsZUZhbkRyYXdNb2RlOlxuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cblx0XHRcdHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cblx0XHRcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxuXG5cdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVTZWdtZW50cyApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHMgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cblx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApIHtcblxuXHRcdHZhciBleHRlbnNpb247XG5cblx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIuc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBzdGFydEluZGV4ID09PSB1bmRlZmluZWQgKSBzdGFydEluZGV4ID0gMDtcblxuXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cblx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuXHRcdHZhciBwcm9ncmFtQXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG5cdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcblxuXHRcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGUgPSBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBvYmplY3RzLmdldEF0dHJpYnV0ZUJ1ZmZlciggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcblxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xuXHRcdFx0XHRcdFx0dmFyIHN0cmlkZSA9IGRhdGEuc3RyaWRlO1xuXHRcdFx0XHRcdFx0dmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcblxuXHRcdFx0XHRcdFx0aWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCBzdHJpZGUgKiBkYXRhLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5ULCAoIHN0YXJ0SW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogc2l6ZSAqIDQgKTsgLy8gNCBieXRlcyBwZXIgRmxvYXQzMlxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0fVxuXG5cdC8vIFNvcnRpbmdcblxuXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYWJzKCBiWyAwIF0gKSAtIE1hdGguYWJzKCBhWyAwIF0gKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLm9iamVjdC5yZW5kZXJPcmRlciAhPT0gYi5vYmplY3QucmVuZGVyT3JkZXIgKSB7XG5cblx0XHRcdHJldHVybiBhLm9iamVjdC5yZW5kZXJPcmRlciAtIGIub2JqZWN0LnJlbmRlck9yZGVyO1xuXG5cdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcblxuXHRcdFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xuXG5cdFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XG5cblx0XHRpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cblx0XHR9IGlmICggYS56ICE9PSBiLnogKSB7XG5cblx0XHRcdHJldHVybiBiLnogLSBhLno7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gYS5pZCAtIGIuaWQ7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFJlbmRlcmluZ1xuXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XG5cblx0XHRpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuXHRcdC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcblxuXHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuXHRcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxuXG5cdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuXHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gbnVsbCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xuXG5cdFx0b3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcblx0XHR0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG5cblx0XHRzcHJpdGVzLmxlbmd0aCA9IDA7XG5cdFx0bGVuc0ZsYXJlcy5sZW5ndGggPSAwO1xuXG5cdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSApO1xuXG5cdFx0b3BhcXVlT2JqZWN0cy5sZW5ndGggPSBvcGFxdWVPYmplY3RzTGFzdEluZGV4ICsgMTtcblx0XHR0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ICsgMTtcblxuXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cblx0XHRcdG9wYXF1ZU9iamVjdHMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblx0XHRcdHRyYW5zcGFyZW50T2JqZWN0cy5zb3J0KCByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUgKTtcblxuXHRcdH1cblxuXHRcdHNldHVwTGlnaHRzKCBsaWdodHMsIGNhbWVyYSApO1xuXG5cdFx0Ly9cblxuXHRcdHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcblxuXHRcdC8vXG5cblx0XHRfaW5mb1JlbmRlci5jYWxscyA9IDA7XG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgPSAwO1xuXHRcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcblx0XHRfaW5mb1JlbmRlci5wb2ludHMgPSAwO1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuXHRcdH1cblxuXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcblxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XG5cblx0XHR9XG5cblx0XHQvL1xuXG5cdFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xuXG5cdFx0XHR2YXIgb3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG5cblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcblx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgZm9nICk7XG5cblx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cblx0XHRcdHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBmb2cgKTtcblxuXHRcdH1cblxuXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG5cdFx0c3ByaXRlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXHRcdGxlbnNGbGFyZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50Vmlld3BvcnQgKTtcblxuXHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApICYmXG5cdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgJiZcblx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRcdHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXG5cblx0XHRzdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG5cdFx0c3RhdGUuc2V0Q29sb3JXcml0ZSggdHJ1ZSApO1xuXG5cdFx0Ly8gX2dsLmZpbmlzaCgpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gcHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCB6LCBncm91cCApIHtcblxuXHRcdHZhciBhcnJheSwgaW5kZXg7XG5cblx0XHQvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcblxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cblx0XHRcdGFycmF5ID0gdHJhbnNwYXJlbnRPYmplY3RzO1xuXHRcdFx0aW5kZXggPSArKyB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXg7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRhcnJheSA9IG9wYXF1ZU9iamVjdHM7XG5cdFx0XHRpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XG5cblx0XHR9XG5cblx0XHQvLyByZWN5Y2xlIGV4aXN0aW5nIHJlbmRlciBpdGVtIG9yIGdyb3cgdGhlIGFycmF5XG5cblx0XHR2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xuXG5cdFx0aWYgKCByZW5kZXJJdGVtICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJlbmRlckl0ZW0uaWQgPSBvYmplY3QuaWQ7XG5cdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcblx0XHRcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcblx0XHRcdHJlbmRlckl0ZW0ubWF0ZXJpYWwgPSBtYXRlcmlhbDtcblx0XHRcdHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XG5cdFx0XHRyZW5kZXJJdGVtLmdyb3VwID0gZ3JvdXA7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZW5kZXJJdGVtID0ge1xuXHRcdFx0XHRpZDogb2JqZWN0LmlkLFxuXHRcdFx0XHRvYmplY3Q6IG9iamVjdCxcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cdFx0XHRcdHo6IF92ZWN0b3IzLnosXG5cdFx0XHRcdGdyb3VwOiBncm91cFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gYXNzZXJ0KCBpbmRleCA9PT0gYXJyYXkubGVuZ3RoICk7XG5cdFx0XHRhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpZ2h0ICkge1xuXG5cdFx0XHRcdGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0c3ByaXRlcy5wdXNoKCBvYmplY3QgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcblxuXHRcdFx0XHRsZW5zRmxhcmVzLnB1c2goIG9iamVjdCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cblx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBudWxsLCBvYmplY3QubWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApIHtcblxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG5cdFx0XHRcdFx0b2JqZWN0LnNrZWxldG9uLnVwZGF0ZSgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTXVsdGlNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXHRcdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbHNbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XG5cblx0XHRcdHZhciBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcblx0XHRcdHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcblx0XHRcdHZhciBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XG5cblx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcblxuXHRcdFx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuXHRcdFx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cblx0XHRcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuXHRcdFx0XHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xuXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcblxuXHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoIG1hdGVyaWFsLCBfbGlnaHRzLCBmb2csIG9iamVjdCApO1xuXHRcdHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbTtcblx0XHR2YXIgcHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gbmV3IG1hdGVyaWFsXG5cdFx0XHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cblx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XG5cblx0XHRcdC8vIGNoYW5nZWQgZ2xzbCBvciBwYXJhbWV0ZXJzXG5cdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG5cdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBzYW1lIGdsc2wgYW5kIHVuaWZvcm0gbGlzdFxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxuXHRcdFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9ncmFtQ2hhbmdlICkge1xuXG5cdFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cblx0XHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyID0ge1xuXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXG5cdFx0XHRcdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxuXHRcdFx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdFx0XHRmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyXG5cdFx0XHRcdH07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XG5cdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcblx0XHRcdFx0XHR1bmlmb3JtczogbWF0ZXJpYWwudW5pZm9ybXMsXG5cdFx0XHRcdFx0dmVydGV4U2hhZGVyOiBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG5cdFx0XHRcdH07XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyO1xuXG5cdFx0XHRwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApO1xuXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9IHByb2dyYW07XG5cdFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcblxuXHRcdH1cblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cblx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xuXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XG5cblx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSBbXTtcblxuXHRcdHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zLFxuXHRcdFx0dW5pZm9ybUxvY2F0aW9ucyA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XG5cblx0XHRmb3IgKCB2YXIgdSBpbiB1bmlmb3JtcyApIHtcblxuXHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1sgdSBdO1xuXG5cdFx0XHRpZiAoIGxvY2F0aW9uICkge1xuXG5cdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3Jtc1sgdSBdLCBsb2NhdGlvbiBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcblx0XHRcdFx0bWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHRtYXRlcmlhbC5saWdodHMgKSB7XG5cblx0XHRcdC8vIHN0b3JlIHRoZSBsaWdodCBzZXR1cCBpdCB3YXMgY3JlYXRlZCBmb3JcblxuXHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBfbGlnaHRzLmhhc2g7XG5cblx0XHRcdC8vIHdpcmUgdXAgdGhlIG1hdGVyaWFsIHRvIHRoaXMgcmVuZGVyZXIncyBsaWdodGluZyBzdGF0ZVxuXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IF9saWdodHMuYW1iaWVudDtcblx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbDtcblx0XHRcdHVuaWZvcm1zLnBvaW50TGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5wb2ludDtcblx0XHRcdHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBfbGlnaHRzLnNwb3Q7XG5cdFx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gX2xpZ2h0cy5oZW1pO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZGV0ZWN0IGR5bmFtaWMgdW5pZm9ybXNcblxuXHRcdG1hdGVyaWFsUHJvcGVydGllcy5oYXNEeW5hbWljVW5pZm9ybXMgPSBmYWxzZTtcblxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybSA9IG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3RbIGogXVsgMCBdO1xuXG5cdFx0XHRpZiAoIHVuaWZvcm0uZHluYW1pYyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuaGFzRHluYW1pY1VuaWZvcm1zID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG5cdFx0c2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWUgKSB7XG5cblx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBUSFJFRS5Ob0JsZW5kaW5nICk7XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5zZXREZXB0aEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xuXHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xuXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIG1hdGVyaWFsLmNvbG9yV3JpdGUgKTtcblx0XHRzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKSB7XG5cblx0XHRtYXRlcmlhbC5zaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlID8gc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICkgOiBzdGF0ZS5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cdFx0c3RhdGUuc2V0RmxpcFNpZGVkKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuXHRcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcblxuXHRcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcblxuXHRcdGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gX2xpZ2h0cy5oYXNoICkge1xuXG5cdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xuXHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuXHRcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcblx0XHR2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSxcblx0XHRcdHBfdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCksXG5cdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG5cblx0XHRpZiAoIHByb2dyYW0uaWQgIT09IF9jdXJyZW50UHJvZ3JhbSApIHtcblxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApO1xuXHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbS5pZDtcblxuXHRcdFx0cmVmcmVzaFByb2dyYW0gPSB0cnVlO1xuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xuXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuXHRcdFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cblx0XHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XG5cblx0XHRcdFx0Ly8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcblx0XHRcdFx0Ly8gbm93LCBpbiBjYXNlIHRoaXMgbWF0ZXJpYWwgc3VwcG9ydHMgbGlnaHRzIC0gb3IgbGF0ZXIsIHdoZW5cblx0XHRcdFx0Ly8gdGhlIG5leHQgbWF0ZXJpYWwgdGhhdCBkb2VzIGdldHMgYWN0aXZhdGVkOlxuXG5cdFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHRcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxuXHRcdFx0XHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcdFx0Ly8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIG1hdGVyaWFsIHNwZWNpZmljIHVuaWZvcm1zXG5cdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsLmVudk1hcCApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggcF91bmlmb3Jtcy5jYW1lcmFQb3NpdGlvbiwgX3ZlY3RvcjMueCwgX3ZlY3RvcjMueSwgX3ZlY3RvcjMueiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLnZpZXdNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2Vcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcblx0XHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuXHRcdFx0aWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4LCBmYWxzZSwgb2JqZWN0LmJpbmRNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZSAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXhJbnZlcnNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeEludmVyc2UsIGZhbHNlLCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UuZWxlbWVudHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdHZhciB0ZXh0dXJlVW5pdCA9IGdldFRleHR1cmVVbml0KCk7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIG9iamVjdC5za2VsZXRvbi5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlV2lkdGggIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVXaWR0aCwgb2JqZWN0LnNrZWxldG9uLmJvbmVUZXh0dXJlV2lkdGggKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG5cdFx0XHRcdGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5za2VsZXRvbi5ib25lTWF0cmljZXMgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwubGlnaHRzICkge1xuXG5cdFx0XHRcdC8vIHRoZSBjdXJyZW50IG1hdGVyaWFsIHJlcXVpcmVzIGxpZ2h0aW5nIGluZm9cblxuXHRcdFx0XHQvLyBub3RlOiBhbGwgbGlnaHRpbmcgdW5pZm9ybXMgYXJlIGFsd2F5cyBzZXQgY29ycmVjdGx5XG5cdFx0XHRcdC8vIHRoZXkgc2ltcGx5IHJlZmVyZW5jZSB0aGUgcmVuZGVyZXIncyBzdGF0ZSBmb3IgdGhlaXJcblx0XHRcdFx0Ly8gdmFsdWVzXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIHVzZSB0aGUgY3VycmVudCBtYXRlcmlhbCdzIC5uZWVkc1VwZGF0ZSBmbGFncyB0byBzZXRcblx0XHRcdFx0Ly8gdGhlIEdMIHN0YXRlIHdoZW4gcmVxdWlyZWRcblxuXHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXG5cblx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludHNNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQb2ludHMoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hTdGFuZGFyZE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG5cdFx0XHRcdG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNoYWRvd01hcC5lbmFibGVkICkge1xuXG5cdFx0XHRcdGlmICggb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgISBtYXRlcmlhbC5fc2hhZG93UGFzcyApIHtcblxuXHRcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyggbV91bmlmb3JtcywgY2FtZXJhICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGxvYWQgY29tbW9uIHVuaWZvcm1zXG5cblx0XHRcdGxvYWRVbmlmb3Jtc0dlbmVyaWMoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgKTtcblxuXHRcdH1cblxuXHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuXHRcdGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMuaGFzRHluYW1pY1VuaWZvcm1zID09PSB0cnVlICkge1xuXG5cdFx0XHR1cGRhdGVEeW5hbWljVW5pZm9ybXMoIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG9iamVjdCwgY2FtZXJhICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRHluYW1pY1VuaWZvcm1zICggdW5pZm9ybXMsIG9iamVjdCwgY2FtZXJhICkge1xuXG5cdFx0dmFyIGR5bmFtaWNVbmlmb3JtcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcblx0XHRcdHZhciBvblVwZGF0ZUNhbGxiYWNrID0gdW5pZm9ybS5vblVwZGF0ZUNhbGxiYWNrO1xuXG5cdFx0XHRpZiAoIG9uVXBkYXRlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRvblVwZGF0ZUNhbGxiYWNrLmJpbmQoIHVuaWZvcm0gKSggb2JqZWN0LCBjYW1lcmEgKTtcblx0XHRcdFx0ZHluYW1pY1VuaWZvcm1zLnB1c2goIHVuaWZvcm1zWyBqIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0bG9hZFVuaWZvcm1zR2VuZXJpYyggZHluYW1pY1VuaWZvcm1zICk7XG5cblx0fVxuXG5cdC8vIFVuaWZvcm1zIChyZWZyZXNoIHVuaWZvcm1zIG9iamVjdHMpXG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cblx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG5cblx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlO1xuXG5cdFx0fVxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cdFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdGlmICggbWF0ZXJpYWwuYW9NYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG5cdFx0XHR1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdFx0Ly8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG5cdFx0Ly8gMS4gY29sb3IgbWFwXG5cdFx0Ly8gMi4gc3BlY3VsYXIgbWFwXG5cdFx0Ly8gMy4gbm9ybWFsIG1hcFxuXHRcdC8vIDQuIGJ1bXAgbWFwXG5cdFx0Ly8gNS4gYWxwaGEgbWFwXG5cdFx0Ly8gNi4gZW1pc3NpdmUgbWFwXG5cblx0XHR2YXIgdXZTY2FsZU1hcDtcblxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5idW1wTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwucm91Z2huZXNzTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XG5cblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aWYgKCB1dlNjYWxlTWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdFx0dXZTY2FsZU1hcCA9IHV2U2NhbGVNYXAudGV4dHVyZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XG5cdFx0XHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XG5cblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cblx0XHR9XG5cblx0XHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XG5cdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggbWF0ZXJpYWwuZW52TWFwIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkgPyAxIDogLSAxO1xuXG5cdFx0dW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xuXHRcdHVuaWZvcm1zLnJlZnJhY3Rpb25SYXRpby52YWx1ZSA9IG1hdGVyaWFsLnJlZnJhY3Rpb25SYXRpbztcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XG5cdFx0dW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xuXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblx0XHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cblx0XHRcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xuXHRcdFx0dmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XG5cblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XG5cblx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcblxuXHRcdGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG5cdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXG5cdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcblxuXHRcdFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0ICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XG5cdFx0dW5pZm9ybXMuc2hpbmluZXNzLnZhbHVlID0gTWF0aC5tYXgoIG1hdGVyaWFsLnNoaW5pbmVzcywgMWUtNCApOyAvLyB0byBwcmV2ZW50IHBvdyggMC4wLCAwLjAgKVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcblx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG5cdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cblx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG5cdFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xuXG5cdFx0aWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5tZXRhbG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xuXG5cdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuXHRcdFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cblx0XHRcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcblx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cblx0XHRcdC8vdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwOyAvLyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxuXHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cblx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUgKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cblx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXHRcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyAoIHVuaWZvcm1zLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcblxuXHRcdFx0dmFyIHNoYWRvd3MgPSBfbGlnaHRzLnNoYWRvd3M7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYWRvd3MubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgbGlnaHQgPSBzaGFkb3dzWyBpIF07XG5cdFx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XG5cblx0XHRcdFx0XHQvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2hhZG93IG1hdHJpeCB0byBiZSBhIHRyYW5zbGF0aW9uLW9ubHkgbWF0cml4XG5cdFx0XHRcdFx0Ly8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxuXHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKTtcblx0XHRcdFx0XHRzaGFkb3cubWF0cml4LmlkZW50aXR5KCkuc2V0UG9zaXRpb24oIF92ZWN0b3IzICk7XG5cblx0XHRcdFx0XHQvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2lnbiBvZiB0aGUgc2hhZG93RGFya25lc3MgdW5pZm9ybSB0byBiZSBuZWdhdGl2ZVxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBpIF0gPSAtIHNoYWRvdy5kYXJrbmVzcztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93RGFya25lc3MudmFsdWVbIGkgXSA9IHNoYWRvdy5kYXJrbmVzcztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93Qmlhcy52YWx1ZVsgaSBdID0gc2hhZG93LmJpYXM7XG5cdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaSBdID0gc2hhZG93Lm1hcDtcblx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZS52YWx1ZVsgaSBdID0gc2hhZG93Lm1hcFNpemU7XG5cdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaSBdID0gc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBVbmlmb3JtcyAobG9hZCB0byBHUFUpXG5cblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zTWF0cmljZXMgKCB1bmlmb3Jtcywgb2JqZWN0ICkge1xuXG5cdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuXHRcdGlmICggdW5pZm9ybXMubm9ybWFsTWF0cml4ICkge1xuXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Lm5vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcblxuXHRcdHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xuXG5cdFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xuXG5cdFx0fVxuXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcblxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zR2VuZXJpYyAoIHVuaWZvcm1zICkge1xuXG5cdFx0dmFyIHRleHR1cmUsIHRleHR1cmVVbml0O1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHVuaWZvcm1zLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgdW5pZm9ybSA9IHVuaWZvcm1zWyBqIF1bIDAgXTtcblxuXHRcdFx0Ly8gbmVlZHNVcGRhdGUgcHJvcGVydHkgaXMgbm90IGFkZGVkIHRvIGFsbCB1bmlmb3Jtcy5cblx0XHRcdGlmICggdW5pZm9ybS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0dmFyIHR5cGUgPSB1bmlmb3JtLnR5cGU7XG5cdFx0XHR2YXIgdmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xuXHRcdFx0dmFyIGxvY2F0aW9uID0gdW5pZm9ybXNbIGogXVsgMSBdO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJzFpJzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICcxZic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xZiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2YnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGYoIGxvY2F0aW9uLCB2YWx1ZVsgMCBdLCB2YWx1ZVsgMSBdLCB2YWx1ZVsgMiBdLCB2YWx1ZVsgMyBdICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWl2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2l2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMWZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnMmZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnM2Z2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnNGZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnTWF0cml4MmZ2Jzpcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDJmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ01hdHJpeDNmdic6XG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdNYXRyaXg0ZnYnOlxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Ly9cblxuXHRcdFx0XHRjYXNlICdpJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBpbnRlZ2VyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdmJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBmbG9hdFxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndjInOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndjMnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjNcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndjQnOlxuXG5cdFx0XHRcdFx0Ly8gc2luZ2xlIFRIUkVFLlZlY3RvcjRcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYyc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuQ29sb3Jcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Lypcblx0XHRcdFx0Y2FzZSAncyc6XG5cblx0XHRcdFx0XHQvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzLlxuXHRcdFx0XHRcdGZvciggdmFyIHByb3BlcnR5TmFtZSBpbiB1bmlmb3JtLnByb3BlcnRpZXMgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IHVuaWZvcm0ucHJvcGVydGllc1sgcHJvcGVydHlOYW1lIF07XG5cdFx0XHRcdFx0XHR2YXIgbG9jYXRpb25Qcm9wZXJ0eSA9ICBsb2NhdGlvblsgcHJvcGVydHlOYW1lIF07XG5cdFx0XHRcdFx0XHR2YXIgdmFsdWVQcm9wZXJ0eSA9IHZhbHVlWyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0XHRcdFx0c3dpdGNoKCBwcm9wZXJ0eS50eXBlICkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdpJzpcblx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5ICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2YnOlxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAndjInOlxuXHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtMmYoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkueCwgdmFsdWVQcm9wZXJ0eS55ICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3YzJzpcblx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LngsIHZhbHVlUHJvcGVydHkueSwgdmFsdWVQcm9wZXJ0eS56ICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ3Y0Jzpcblx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LngsIHZhbHVlUHJvcGVydHkueSwgdmFsdWVQcm9wZXJ0eS56LCB2YWx1ZVByb3BlcnR5LncgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS5yLCB2YWx1ZVByb3BlcnR5LmcsIHZhbHVlUHJvcGVydHkuYiApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHQqL1xuXG5cdFx0XHRcdGNhc2UgJ3NhJzpcblxuXHRcdFx0XHRcdC8vIFRPRE86IE9wdGltaXplIHRoaXMuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgcHJvcGVydHlOYW1lIGluIHVuaWZvcm0ucHJvcGVydGllcyApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcGVydHkgPSB1bmlmb3JtLnByb3BlcnRpZXNbIHByb3BlcnR5TmFtZSBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgbG9jYXRpb25Qcm9wZXJ0eSA9ICBsb2NhdGlvblsgaSBdWyBwcm9wZXJ0eU5hbWUgXTtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlUHJvcGVydHkgPSB2YWx1ZVsgaSBdWyBwcm9wZXJ0eU5hbWUgXTtcblxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBwcm9wZXJ0eS50eXBlICkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2knOlxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnZic6XG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd2Mic6XG5cdFx0XHRcdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvblByb3BlcnR5LCB2YWx1ZVByb3BlcnR5LngsIHZhbHVlUHJvcGVydHkueSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAndjMnOlxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm0zZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnksIHZhbHVlUHJvcGVydHkueiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAndjQnOlxuXHRcdFx0XHRcdFx0XHRcdFx0X2dsLnVuaWZvcm00ZiggbG9jYXRpb25Qcm9wZXJ0eSwgdmFsdWVQcm9wZXJ0eS54LCB2YWx1ZVByb3BlcnR5LnksIHZhbHVlUHJvcGVydHkueiwgdmFsdWVQcm9wZXJ0eS53ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0XHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIGxvY2F0aW9uUHJvcGVydHksIHZhbHVlUHJvcGVydHkuciwgdmFsdWVQcm9wZXJ0eS5nLCB2YWx1ZVByb3BlcnR5LmIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2l2MSc6XG5cblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIChKUyBvciB0eXBlZCBhcnJheSlcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpdic6XG5cblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZnYxJzpcblxuXHRcdFx0XHRcdC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdmdic6XG5cblx0XHRcdFx0XHQvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Yydic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IyXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMiA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkyICs9IDIgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMiArIDAgXSA9IHZhbHVlWyBpIF0ueDtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMiArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Yzdic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMyAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpMyA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGkzICs9IDMgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDAgXSA9IHZhbHVlWyBpIF0ueDtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpMyArIDIgXSA9IHZhbHVlWyBpIF0uejtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3Y0dic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKyssIGk0ICs9IDQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBpNCArIDMgXSA9IHZhbHVlWyBpIF0udztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ20yJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgyZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ20zJzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgzXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ20zdic6XG5cblx0XHRcdFx0XHQvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSAqIHZhbHVlLmxlbmd0aCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDkgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtNCc6XG5cblx0XHRcdFx0XHQvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtNHYnOlxuXG5cdFx0XHRcdFx0Ly8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxuXG5cdFx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogMTYgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0JzpcblxuXHRcdFx0XHRcdC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxuXG5cdFx0XHRcdFx0dGV4dHVyZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuXHRcdFx0XHRcdF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XG5cdFx0XHRcdFx0XHQgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cblxuXHRcdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG5cdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCApIHtcblxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZS50ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3R2JzpcblxuXHRcdFx0XHRcdC8vIGFycmF5IG9mIFRIUkVFLlRleHR1cmUgKDJkIG9yIGN1YmUpXG5cblx0XHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gW107XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIGkgXSA9IGdldFRleHR1cmVVbml0KCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0dGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcblx0XHRcdFx0XHRcdHRleHR1cmVVbml0ID0gdW5pZm9ybS5fYXJyYXlbIGkgXTtcblxuXHRcdFx0XHRcdFx0aWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVRleHR1cmUgfHxcblx0XHRcdFx0XHRcdFx0ICggdGV4dHVyZS5pbWFnZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cblxuXHRcdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcblxuXHRcdFx0XHRcdFx0XHRzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUudGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVW5rbm93biB1bmlmb3JtIHR5cGU6ICcgKyB0eXBlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBMaWdodHMgKCBsaWdodHMsIGNhbWVyYSApIHtcblxuXHRcdHZhciBsLCBsbCwgbGlnaHQsXG5cdFx0ciA9IDAsIGcgPSAwLCBiID0gMCxcblx0XHRjb2xvcixcblx0XHRpbnRlbnNpdHksXG5cdFx0ZGlzdGFuY2UsXG5cblx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSxcblxuXHRcdGRpcmVjdGlvbmFsTGVuZ3RoID0gMCxcblx0XHRwb2ludExlbmd0aCA9IDAsXG5cdFx0c3BvdExlbmd0aCA9IDAsXG5cdFx0aGVtaUxlbmd0aCA9IDAsXG5cblx0XHRzaGFkb3dzTGVuZ3RoID0gMDtcblxuXHRcdF9saWdodHMuc2hhZG93c1BvaW50TGlnaHQgPSAwO1xuXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xuXHRcdFx0aW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xuXHRcdFx0ZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkFtYmllbnRMaWdodCApIHtcblxuXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG5cdFx0XHRcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcblx0XHRcdFx0YiArPSBjb2xvci5iICogaW50ZW5zaXR5O1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSB7XG5cblx0XHRcdFx0dmFyIHVuaWZvcm1zID0gbGlnaHRDYWNoZS5nZXQoIGxpZ2h0ICk7XG5cblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSBzaGFkb3dzTGVuZ3RoO1xuXG5cdFx0XHRcdFx0X2xpZ2h0cy5zaGFkb3dzWyBzaGFkb3dzTGVuZ3RoICsrIF0gPSBsaWdodDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gLSAxO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsWyBkaXJlY3Rpb25hbExlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcblxuXHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBsaWdodENhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXHRcdFx0XHR1bmlmb3Jtcy5kZWNheSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IHNoYWRvd3NMZW5ndGg7XG5cblx0XHRcdFx0XHRfbGlnaHRzLnNoYWRvd3NbIHNoYWRvd3NMZW5ndGggKysgXSA9IGxpZ2h0O1xuXHRcdFx0XHRcdF9saWdodHMuc2hhZG93c1BvaW50TGlnaHQgKys7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IC0gMTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2xpZ2h0cy5wb2ludFsgcG9pbnRMZW5ndGggKysgXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuXHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBsaWdodENhY2hlLmdldCggbGlnaHQgKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuXHRcdFx0XHR1bmlmb3Jtcy5hbmdsZUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5leHBvbmVudCA9IGxpZ2h0LmV4cG9uZW50O1xuXHRcdFx0XHR1bmlmb3Jtcy5kZWNheSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xuXG5cdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IHNoYWRvd3NMZW5ndGg7XG5cblx0XHRcdFx0XHRfbGlnaHRzLnNoYWRvd3NbIHNoYWRvd3NMZW5ndGggKysgXSA9IGxpZ2h0O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3cgPSAtIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9saWdodHMuc3BvdFsgc3BvdExlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG5cdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG5cdFx0XHRcdHVuaWZvcm1zLnNreUNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXHRcdFx0XHR1bmlmb3Jtcy5ncm91bmRDb2xvci5jb3B5KCBsaWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0XHRfbGlnaHRzLmhlbWlbIGhlbWlMZW5ndGggKysgXSA9IHVuaWZvcm1zO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRfbGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG5cdFx0X2xpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuXHRcdF9saWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuXHRcdF9saWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG5cdFx0X2xpZ2h0cy5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcblx0XHRfbGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcblx0XHRfbGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuXHRcdF9saWdodHMuc2hhZG93cy5sZW5ndGggPSBzaGFkb3dzTGVuZ3RoO1xuXG5cdFx0X2xpZ2h0cy5oYXNoID0gZGlyZWN0aW9uYWxMZW5ndGggKyAnLCcgKyBwb2ludExlbmd0aCArICcsJyArIHNwb3RMZW5ndGggKyAnLCcgKyBoZW1pTGVuZ3RoICsgJywnICsgc2hhZG93c0xlbmd0aDtcblxuXHR9XG5cblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xuXG5cdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cblx0XHRpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cblx0XHRcdHN0YXRlLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyApIHtcblxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ1cgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VCYWNrICkge1xuXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVF9BTkRfQkFDSyApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN0YXRlLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gVGV4dHVyZXNcblxuXHRmdW5jdGlvbiBzZXRUZXh0dXJlUGFyYW1ldGVycyAoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdHZhciBleHRlbnNpb247XG5cblx0XHRpZiAoIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFMgKSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBUICkgKTtcblxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLndyYXBTICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4nLCB0ZXh0dXJlICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG5cdFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLicsIHRleHR1cmUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiApIHtcblxuXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5IYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG5cblx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XG5cblx0XHRcdFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIF90aGlzLmdldE1heEFuaXNvdHJvcHkoKSApICk7XG5cdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG5cdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcblx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xuXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cblx0XHR0ZXh0dXJlLmltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xuXG5cdFx0aWYgKCB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCB0ZXh0dXJlLmltYWdlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHR0ZXh0dXJlLmltYWdlID0gbWFrZVBvd2VyT2ZUd28oIHRleHR1cmUuaW1hZ2UgKTtcblxuXHRcdH1cblxuXHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2UsXG5cdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG5cdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcblx0XHRnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cblx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXG5cdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgKSB7XG5cblx0XHRcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG5cdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcblx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG5cdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnVwbG9hZFRleHR1cmUoKVwiICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gcmVndWxhciBUZXh0dXJlIChpbWFnZSwgdmlkZW8sIGNhbnZhcylcblxuXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcblx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xuXHRcdFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXG5cblx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xuXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCB0ZXh0dXJlLmltYWdlICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cblx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XG5cblx0fVxuXG5cdHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cblx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyB1bmRlZmluZWQnLCB0ZXh0dXJlICk7XG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplICggaW1hZ2UsIG1heFNpemUgKSB7XG5cblx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG5cdFx0XHQvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxuXHRcdFx0Ly8gcHJlbXVsdGlwbGllZCBhbHBoYS5cblxuXHRcdFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XG5cblx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIHRvbyBiaWcgKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xuXG5cdFx0XHRyZXR1cm4gY2FudmFzO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xuXG5cdFx0cmV0dXJuIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcblxuXHRcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIHRydWU7XG5cdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gVEhSRUUuTGluZWFyRmlsdGVyICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcblxuXHRcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgKSB7XG5cblx0XHRcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuXHRcdFx0Y2FudmFzLndpZHRoID0gVEhSRUUuTWF0aC5uZWFyZXN0UG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKTtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBUSFJFRS5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgbm90IHBvd2VyIG9mIHR3byAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XG5cblx0XHRcdHJldHVybiBjYW52YXM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW1hZ2U7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlICggdGV4dHVyZSwgc2xvdCApIHtcblxuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XG5cblx0XHRcdFx0aWYgKCAhIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XG5cblx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG5cdFx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRcdFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuXHRcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcblx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSB0ZXh0dXJlLmltYWdlWyAwIF0gaW5zdGFuY2VvZiBUSFJFRS5EYXRhVGV4dHVyZTtcblxuXHRcdFx0XHR2YXIgY3ViZUltYWdlID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcblx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG5cdFx0XHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdICk7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIiApO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuXHRcdFx0XHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uID0gdGV4dHVyZS52ZXJzaW9uO1xuXG5cdFx0XHRcdGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEN1YmVUZXh0dXJlRHluYW1pYyAoIHRleHR1cmUsIHNsb3QgKSB7XG5cblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XG5cblx0fVxuXG5cdC8vIFJlbmRlciB0YXJnZXRzXG5cblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSAoIGZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQgKSB7XG5cblx0XHR2YXIgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZm9ybWF0ICk7XG5cdFx0dmFyIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XG5cdFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcblx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlICggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGSVhNRTogV2UgZG9uJ3Qgc3VwcG9ydCAhZGVwdGggIXN0ZW5jaWxcblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuXG5cdFx0fVxuXG5cdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gU2V0dXAgR0wgcmVzb3VyY2VzIGZvciBhIG5vbi10ZXh0dXJlIGRlcHRoIGJ1ZmZlclxuXHRmdW5jdGlvbiBzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXG5cdFx0aWYgKCBpc0N1YmUgKSB7XG5cblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XG5cdFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0XHRcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cblx0XHR9XG5cblx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHR9XG5cblx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcblx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcblxuXHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG5cdFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XG5cblx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXHRcdHZhciBpc1RhcmdldFBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuXHRcdC8vIFNldHVwIGZyYW1lYnVmZmVyXG5cblx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cblx0XHR9XG5cblx0XHQvLyBTZXR1cCBjb2xvciBidWZmZXJcblxuXHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuXHRcdFx0XHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblx0XHRcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFXzJEICk7XG5cblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gU2V0dXAgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVyc1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgKSB7XG5cblx0XHRcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLnNldFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0ICkge1xuXG5cdFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG5cblx0XHRpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuXHRcdH1cblxuXHRcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApO1xuXHRcdHZhciBmcmFtZWJ1ZmZlciwgc2Npc3Nvciwgc2Npc3NvclRlc3QsIHZpZXdwb3J0O1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG5cdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG5cdFx0XHR9XG5cblx0XHRcdHNjaXNzb3IgPSByZW5kZXJUYXJnZXQuc2Npc3Nvcjtcblx0XHRcdHNjaXNzb3JUZXN0ID0gcmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0O1xuXG5cdFx0XHR2aWV3cG9ydCA9IHJlbmRlclRhcmdldC52aWV3cG9ydDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGZyYW1lYnVmZmVyID0gbnVsbDtcblxuXHRcdFx0c2Npc3NvciA9IF9zY2lzc29yO1xuXHRcdFx0c2Npc3NvclRlc3QgPSBfc2Npc3NvclRlc3Q7XG5cblx0XHRcdHZpZXdwb3J0ID0gX3ZpZXdwb3J0O1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcblxuXHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG5cblx0XHR9XG5cblx0XHRzdGF0ZS5zY2lzc29yKCBzY2lzc29yICk7XG5cdFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIHNjaXNzb3JUZXN0ICk7XG5cblx0XHRzdGF0ZS52aWV3cG9ydCggdmlld3BvcnQgKTtcblxuXHRcdGlmICggaXNDdWJlICkge1xuXG5cdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCAwICk7XG5cblx0XHR9XG5cblx0XHRfY3VycmVudFZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cblx0fTtcblxuXHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xuXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuXHRcdGlmICggZnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdHZhciByZXN0b3JlID0gZmFsc2U7XG5cblx0XHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cblx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdHJlc3RvcmUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcblxuXHRcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0XG5cdFx0XHRcdFx0JiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICkgIT09IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5JTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVCApICkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGV4dHVyZS50eXBlICE9PSBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlXG5cdFx0XHRcdFx0JiYgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFIClcblx0XHRcdFx0XHQmJiAhICggdGV4dHVyZS50eXBlID09PSBUSFJFRS5GbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKVxuXHRcdFx0XHRcdCYmICEgKCB0ZXh0dXJlLnR5cGUgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgKSApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gVW5zaWduZWRCeXRlVHlwZSBvciBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIHR5cGUuJyApO1xuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcblxuXHRcdFx0XHRcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApLCBidWZmZXIgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGZpbmFsbHkge1xuXG5cdFx0XHRcdGlmICggcmVzdG9yZSApIHtcblxuXHRcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XG5cblx0XHR2YXIgdGFyZ2V0ID0gcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID8gX2dsLlRFWFRVUkVfQ1VCRV9NQVAgOiBfZ2wuVEVYVFVSRV8yRDtcblx0XHR2YXIgdGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgdGV4dHVyZSApO1xuXHRcdF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgbnVsbCApO1xuXG5cdH1cblxuXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xuXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcblxuXHRcdGlmICggZiA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xuXG5cdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gX2dsLkxJTkVBUjtcblxuXHR9XG5cblx0Ly8gTWFwIHRocmVlLmpzIGNvbnN0YW50cyB0byBXZWJHTCBjb25zdGFudHNcblxuXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCAoIHAgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuUkVQRUFUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBfZ2wuQ0xBTVBfVE9fRURHRTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX0JZVEU7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuRmxvYXRUeXBlICkgcmV0dXJuIF9nbC5GTE9BVDtcblxuXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLkhhbGZGbG9hdFR5cGUgKSByZXR1cm4gZXh0ZW5zaW9uLkhBTEZfRkxPQVRfT0VTO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JGb3JtYXQgKSByZXR1cm4gX2dsLlJHQjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFGb3JtYXQgKSByZXR1cm4gX2dsLlJHQkE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5MVU1JTkFOQ0VfQUxQSEE7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNUO1xuXG5cdFx0aWYgKCBwID09PSBUSFJFRS5aZXJvRmFjdG9yICkgcmV0dXJuIF9nbC5aRVJPO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lRmFjdG9yICkgcmV0dXJuIF9nbC5PTkU7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19DT0xPUjtcblx0XHRpZiAoIHAgPT09IFRIUkVFLlNyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEE7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9BTFBIQTtcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQUxQSEE7XG5cblx0XHRpZiAoIHAgPT09IFRIUkVFLkRzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5EU1RfQ09MT1I7XG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xuXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDFfRVhUO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzJCUFBWMV9JTUc7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XG5cblx0XHR9XG5cblx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XG5cblx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5NaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gMDtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIE1hcml1cyBLaW50ZWwgLyBodHRwczovL2dpdGh1Yi5jb20va2ludGVsXG4gKi9cblxuLypcbiBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcbiAqIFRleHR1cmUgcGFyYW1ldGVycyBmb3IgYW4gYXV0by1nZW5lcmF0ZWQgdGFyZ2V0IHRleHR1cmVcbiAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXG4qL1xuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cblx0dGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuXHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG5cdHRoaXMuc2Npc3NvciA9IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuXHR0aGlzLnZpZXdwb3J0ID0gbmV3IFRIUkVFLlZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuXHR0aGlzLnRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5ICk7XG5cblx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xuXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQsXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0aWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG5cdFx0XHR0aGlzLndpZHRoID0gd2lkdGg7XG5cdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0dGhpcy5kaXNwb3NlKCk7XG5cblx0XHR9XG5cblx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXHRcdHRoaXMuc2Npc3Nvci5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cblx0fSxcblxuXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuXHRcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xuXG5cdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcblxuXHRcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XG5cblx0XHR0aGlzLmRlcHRoQnVmZmVyID0gc291cmNlLmRlcHRoQnVmZmVyO1xuXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuXG5cdFx0dGhpcy5zaGFyZURlcHRoRnJvbSA9IHNvdXJjZS5zaGFyZURlcHRoRnJvbTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH0sXG5cblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cblx0VEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG5cdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlciA9IGZ1bmN0aW9uICggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApIHtcblxuXHR2YXIgbW9kZTtcblxuXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuXHRcdG1vZGUgPSB2YWx1ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cblx0XHRfZ2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cblx0XHRfaW5mb1JlbmRlci5jYWxscyArKztcblx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblx0XHRpZiAoIG1vZGUgPT09IF9nbC5UUklBTkdMRVMgKSBfaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0aWYgKCBwb3NpdGlvbiBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBwb3NpdGlvbi5kYXRhLmNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgMCwgcG9zaXRpb24uY291bnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdHRoaXMucmVuZGVyID0gcmVuZGVyO1xuXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXIgPSBmdW5jdGlvbiAoIF9nbCwgZXh0ZW5zaW9ucywgX2luZm9SZW5kZXIgKSB7XG5cblx0dmFyIG1vZGU7XG5cblx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XG5cblx0XHRtb2RlID0gdmFsdWU7XG5cblx0fVxuXG5cdHZhciB0eXBlLCBzaXplO1xuXG5cdGZ1bmN0aW9uIHNldEluZGV4KCBpbmRleCApIHtcblxuXHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cblx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuXHRcdFx0c2l6ZSA9IDQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuXHRcdFx0c2l6ZSA9IDI7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuXG5cdFx0X2dsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xuXG5cdFx0X2luZm9SZW5kZXIuY2FsbHMgKys7XG5cdFx0X2luZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG5cdFx0aWYgKCBtb2RlID09PSBfZ2wuVFJJQU5HTEVTICkgX2luZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XG5cblx0XHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG5cdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIHNpemUsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cblx0fVxuXG5cdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XG5cdHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcblx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XG5cdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xFeHRlbnNpb25zLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xFeHRlbnNpb25zID0gZnVuY3Rpb24gKCBnbCApIHtcblxuXHR2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG5cdFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIGV4dGVuc2lvbnNbIG5hbWUgXTtcblxuXHRcdH1cblxuXHRcdHZhciBleHRlbnNpb247XG5cblx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG5cdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcblx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xuXG5cdFx0fVxuXG5cdFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xuXG5cdFx0cmV0dXJuIGV4dGVuc2lvbjtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xDYXBhYmlsaXRpZXMuanNcblxuVEhSRUUuV2ViR0xDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbiAoIGdsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICkge1xuXG5cdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xuXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XG5cblx0XHRcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuXHRcdFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuICdoaWdocCc7XG5cblx0XHRcdH1cblxuXHRcdFx0cHJlY2lzaW9uID0gJ21lZGl1bXAnO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcblxuXHRcdFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcblx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cblx0XHRcdFx0cmV0dXJuICdtZWRpdW1wJztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuICdsb3dwJztcblxuXHR9XG5cblx0dGhpcy5nZXRNYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb247XG5cblx0dGhpcy5wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxuXHR0aGlzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA6IGZhbHNlO1xuXG5cdHRoaXMubWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cdHRoaXMubWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuXHR0aGlzLm1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XG5cdHRoaXMubWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuXHR0aGlzLm1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xuXHR0aGlzLm1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuXHR0aGlzLm1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG5cdHRoaXMubWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xuXG5cdHRoaXMudmVydGV4VGV4dHVyZXMgPSB0aGlzLm1heFZlcnRleFRleHR1cmVzID4gMDtcblx0dGhpcy5mbG9hdEZyYWdtZW50VGV4dHVyZXMgPSAhISBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHR0aGlzLmZsb2F0VmVydGV4VGV4dHVyZXMgPSB0aGlzLnZlcnRleFRleHR1cmVzICYmIHRoaXMuZmxvYXRGcmFnbWVudFRleHR1cmVzO1xuXG5cdHZhciBfbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCB0aGlzLnByZWNpc2lvbiApO1xuXG5cdGlmICggX21heFByZWNpc2lvbiAhPT0gdGhpcy5wcmVjaXNpb24gKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHRoaXMucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBfbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XG5cdFx0dGhpcy5wcmVjaXNpb24gPSBfbWF4UHJlY2lzaW9uO1xuXG5cdH1cblxuXHRpZiAoIHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApIHtcblxuXHRcdHRoaXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xHZW9tZXRyaWVzLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xHZW9tZXRyaWVzID0gZnVuY3Rpb24gKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcblxuXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGdldCggb2JqZWN0ICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0aWYgKCBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0fVxuXG5cdFx0Z2VvbWV0cnkuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG5cdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5O1xuXG5cdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5O1xuXG5cdFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdFx0aWYgKCBnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRnZW9tZXRyeS5fYnVmZmVyR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gPSBidWZmZXJnZW9tZXRyeTtcblxuXHRcdGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XG5cblx0XHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIG9uR2VvbWV0cnlEaXNwb3NlKCBldmVudCApIHtcblxuXHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcblx0XHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG5cdFx0aWYgKCBidWZmZXJnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xuXG5cdFx0fVxuXG5cdFx0ZGVsZXRlQXR0cmlidXRlcyggYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlcyApO1xuXG5cdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG5cdFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cblx0XHQvLyBUT0RPXG5cblx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICkge1xuXG5cdFx0XHRkZWxldGVBdHRyaWJ1dGUoIHByb3BlcnR5LndpcmVmcmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIGdlb21ldHJ5ICk7XG5cblx0XHR2YXIgYnVmZmVycHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggYnVmZmVyZ2VvbWV0cnkgKTtcblxuXHRcdGlmICggYnVmZmVycHJvcGVydHkud2lyZWZyYW1lICkge1xuXG5cdFx0XHRkZWxldGVBdHRyaWJ1dGUoIGJ1ZmZlcnByb3BlcnR5LndpcmVmcmFtZSApO1xuXG5cdFx0fVxuXG5cdFx0cHJvcGVydGllcy5kZWxldGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cblx0XHQvL1xuXG5cdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyAtLTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHR2YXIgYnVmZmVyID0gZ2V0QXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKTtcblxuXHRcdGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGdsLmRlbGV0ZUJ1ZmZlciggYnVmZmVyICk7XG5cdFx0XHRyZW1vdmVBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBkZWxldGVBdHRyaWJ1dGVzKCBhdHRyaWJ1dGVzICkge1xuXG5cdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBuYW1lIF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlQnVmZmVyKCBhdHRyaWJ1dGUgKSB7XG5cblx0XHRpZiAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlLmRhdGEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHByb3BlcnRpZXMuZGVsZXRlKCBhdHRyaWJ1dGUgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5nZXQgPSBnZXQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTExpZ2h0cy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMTGlnaHRzID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciBsaWdodHMgPSB7fTtcblxuXHR0aGlzLmdldCA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0XHRpZiAoIGxpZ2h0c1sgbGlnaHQuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRyZXR1cm4gbGlnaHRzWyBsaWdodC5pZCBdO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHVuaWZvcm1zO1xuXG5cdFx0c3dpdGNoICggbGlnaHQudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0Jzpcblx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHRcdHNreUNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoKSxcblx0XHRcdFx0XHRncm91bmRDb2xvcjogbmV3IFRIUkVFLkNvbG9yKClcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdFx0Y29sb3I6IG5ldyBUSFJFRS5Db2xvcigpLFxuXHRcdFx0XHRcdHNoYWRvdzogLTFcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuXHRcdFx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRcdFx0XHRjb2xvcjogbmV3IFRIUkVFLkNvbG9yKCksXG5cdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG5cdFx0XHRcdFx0ZGVjYXk6IDAsXG5cdFx0XHRcdFx0c2hhZG93OiAtMVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnU3BvdExpZ2h0Jzpcblx0XHRcdFx0dW5pZm9ybXMgPSB7XG5cdFx0XHRcdFx0cG9zaXRpb246IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdFx0XHRcdGNvbG9yOiBuZXcgVEhSRUUuQ29sb3IoKSxcblx0XHRcdFx0XHRkaXN0YW5jZTogMCxcblx0XHRcdFx0XHRhbmdsZUNvczogMCxcblx0XHRcdFx0XHRleHBvbmVudDogMCxcblx0XHRcdFx0XHRkZWNheTogMCxcblx0XHRcdFx0XHRzaGFkb3c6IC0xXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0bGlnaHRzWyBsaWdodC5pZCBdID0gdW5pZm9ybXM7XG5cblx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0fTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMT2JqZWN0cy5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMT2JqZWN0cyA9IGZ1bmN0aW9uICggZ2wsIHByb3BlcnRpZXMsIGluZm8gKSB7XG5cblx0dmFyIGdlb21ldHJpZXMgPSBuZXcgVEhSRUUuV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApO1xuXG5cdC8vXG5cblx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XG5cblx0XHQvLyBUT0RPOiBBdm9pZCB1cGRhdGluZyB0d2ljZSAod2hlbiB1c2luZyBzaGFkb3dNYXApLiBNYXliZSBhZGQgZnJhbWUgY291bnRlci5cblxuXHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcblxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHRcdGdlb21ldHJ5LnVwZGF0ZUZyb21PYmplY3QoIG9iamVjdCApO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG5cdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0dXBkYXRlQXR0cmlidXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuXHRcdH1cblxuXHRcdC8vIG1vcnBoIHRhcmdldHNcblxuXHRcdHZhciBtb3JwaEF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXM7XG5cblx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBnZW9tZXRyeTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHR2YXIgZGF0YSA9ICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSA/IGF0dHJpYnV0ZS5kYXRhIDogYXR0cmlidXRlO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Y3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cblx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcblxuXHRcdFx0dXBkYXRlQnVmZmVyKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLCBkYXRhLCBidWZmZXJUeXBlICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG5cdFx0dmFyIHVzYWdlID0gZGF0YS5keW5hbWljID8gZ2wuRFlOQU1JQ19EUkFXIDogZ2wuU1RBVElDX0RSQVc7XG5cblx0XHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLmFycmF5LCB1c2FnZSApO1xuXG5cdFx0YXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuXHRcdGlmICggZGF0YS5keW5hbWljID09PSBmYWxzZSB8fCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAtIDEgKSB7XG5cblx0XHRcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGRhdGEuYXJyYXkgKTtcblxuXHRcdH0gZWxzZSBpZiAoIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTE9iamVjdHMudXBkYXRlQnVmZmVyOiBkeW5hbWljIFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSBtYXJrZWQgYXMgbmVlZHNVcGRhdGUgYnV0IHVwZGF0ZVJhbmdlLmNvdW50IGlzIDAsIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHNldCBtZXRob2RzIG9yIHVwZGF0aW5nIG1hbnVhbGx5LicgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcblx0XHRcdFx0XHRcdFx0ICBkYXRhLmFycmF5LnN1YmFycmF5KCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCwgZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQgKyBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ICkgKTtcblxuXHRcdFx0ZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXG5cblx0XHR9XG5cblx0XHRhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gPSBkYXRhLnZlcnNpb247XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG5cdFx0aWYgKCBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZSApLl9fd2ViZ2xCdWZmZXI7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuXHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHJldHVybiBwcm9wZXJ0eS53aXJlZnJhbWU7XG5cblx0XHR9XG5cblx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBwb3NpdGlvbiA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHQvLyBjb25zb2xlLnRpbWUoICd3aXJlZnJhbWUnICk7XG5cblx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG5cdFx0XHR2YXIgZWRnZXMgPSB7fTtcblx0XHRcdHZhciBhcnJheSA9IGluZGV4LmFycmF5O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcblx0XHRcdFx0dmFyIGIgPSBhcnJheVsgaSArIDEgXTtcblx0XHRcdFx0dmFyIGMgPSBhcnJheVsgaSArIDIgXTtcblxuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGEsIGIgKSApIGluZGljZXMucHVzaCggYSwgYiApO1xuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGIsIGMgKSApIGluZGljZXMucHVzaCggYiwgYyApO1xuXHRcdFx0XHRpZiAoIGNoZWNrRWRnZSggZWRnZXMsIGMsIGEgKSApIGluZGljZXMucHVzaCggYywgYSApO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSAoIGFycmF5Lmxlbmd0aCAvIDMgKSAtIDE7IGkgPCBsOyBpICs9IDMgKSB7XG5cblx0XHRcdFx0dmFyIGEgPSBpICsgMDtcblx0XHRcdFx0dmFyIGIgPSBpICsgMTtcblx0XHRcdFx0dmFyIGMgPSBpICsgMjtcblxuXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xuXG5cdFx0dmFyIFR5cGVBcnJheSA9IHBvc2l0aW9uLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuXHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVHlwZUFycmF5KCBpbmRpY2VzICksIDEgKTtcblxuXHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG5cdFx0cHJvcGVydHkud2lyZWZyYW1lID0gYXR0cmlidXRlO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tFZGdlKCBlZGdlcywgYSwgYiApIHtcblxuXHRcdGlmICggYSA+IGIgKSB7XG5cblx0XHRcdHZhciB0bXAgPSBhO1xuXHRcdFx0YSA9IGI7XG5cdFx0XHRiID0gdG1wO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGxpc3QgPSBlZGdlc1sgYSBdO1xuXG5cdFx0aWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGVkZ2VzWyBhIF0gPSBbIGIgXTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fSBlbHNlIGlmICggbGlzdC5pbmRleE9mKCBiICkgPT09IC0xICkge1xuXG5cdFx0XHRsaXN0LnB1c2goIGIgKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH1cblxuXHR0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlciA9IGdldEF0dHJpYnV0ZUJ1ZmZlcjtcblx0dGhpcy5nZXRXaXJlZnJhbWVBdHRyaWJ1dGUgPSBnZXRXaXJlZnJhbWVBdHRyaWJ1dGU7XG5cblx0dGhpcy51cGRhdGUgPSB1cGRhdGU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcblxuVEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuXHQvLyBUT0RPOiBDb21iaW5lIHRoZSByZWdleFxuXHR2YXIgc3RydWN0UmUgPSAvXihbXFx3XFxkX10rKVxcLihbXFx3XFxkX10rKSQvO1xuXHR2YXIgYXJyYXlTdHJ1Y3RSZSA9IC9eKFtcXHdcXGRfXSspXFxbKFxcZCspXFxdXFwuKFtcXHdcXGRfXSspJC87XG5cdHZhciBhcnJheVJlID0gL14oW1xcd1xcZF9dKylcXFswXFxdJC87XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVFeHRlbnNpb25zKCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCByZW5kZXJlckV4dGVuc2lvbnMgKSB7XG5cblx0XHRleHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuXHRcdHZhciBjaHVua3MgPSBbXG5cdFx0XHQoIGV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgfHwgcGFyYW1ldGVycy5idW1wTWFwIHx8IHBhcmFtZXRlcnMubm9ybWFsTWFwIHx8IHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgKSA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcblx0XHRcdCggZXh0ZW5zaW9ucy5mcmFnRGVwdGggfHwgcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGUnIDogJycsXG5cdFx0XHQoIGV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZHJhd19idWZmZXJzJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsXG5cdFx0XHQoIGV4dGVuc2lvbnMuc2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyApID8gJyNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZScgOiAnJyxcblx0XHRdO1xuXG5cdFx0cmV0dXJuIGNodW5rcy5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcblxuXHRcdHZhciBjaHVua3MgPSBbXTtcblxuXHRcdGZvciAoIHZhciBuYW1lIGluIGRlZmluZXMgKSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuXHRcdFx0Y2h1bmtzLnB1c2goICcjZGVmaW5lICcgKyBuYW1lICsgJyAnICsgdmFsdWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZmV0Y2hVbmlmb3JtTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cblx0XHR2YXIgdW5pZm9ybXMgPSB7fTtcblxuXHRcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xuXG5cdFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKTtcblx0XHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xuXHRcdFx0dmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cblx0XHRcdC8vY29uc29sZS5sb2coXCJUSFJFRS5XZWJHTFByb2dyYW06IEFDVElWRSBVTklGT1JNOlwiLCBuYW1lKTtcblxuXHRcdFx0dmFyIG1hdGNoZXMgPSBzdHJ1Y3RSZS5leGVjKCBuYW1lICk7XG5cdFx0XHRpZiAoIG1hdGNoZXMgKSB7XG5cblx0XHRcdFx0dmFyIHN0cnVjdE5hbWUgPSBtYXRjaGVzWyAxIF07XG5cdFx0XHRcdHZhciBzdHJ1Y3RQcm9wZXJ0eSA9IG1hdGNoZXNbIDIgXTtcblxuXHRcdFx0XHR2YXIgdW5pZm9ybXNTdHJ1Y3QgPSB1bmlmb3Jtc1sgc3RydWN0TmFtZSBdO1xuXG5cdFx0XHRcdGlmICggISB1bmlmb3Jtc1N0cnVjdCApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zU3RydWN0ID0gdW5pZm9ybXNbIHN0cnVjdE5hbWUgXSA9IHt9O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR1bmlmb3Jtc1N0cnVjdFsgc3RydWN0UHJvcGVydHkgXSA9IGxvY2F0aW9uO1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9XG5cblx0XHRcdG1hdGNoZXMgPSBhcnJheVN0cnVjdFJlLmV4ZWMoIG5hbWUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaGVzICkge1xuXG5cdFx0XHRcdHZhciBhcnJheU5hbWUgPSBtYXRjaGVzWyAxIF07XG5cdFx0XHRcdHZhciBhcnJheUluZGV4ID0gbWF0Y2hlc1sgMiBdO1xuXHRcdFx0XHR2YXIgYXJyYXlQcm9wZXJ0eSA9IG1hdGNoZXNbIDMgXTtcblxuXHRcdFx0XHR2YXIgdW5pZm9ybXNBcnJheSA9IHVuaWZvcm1zWyBhcnJheU5hbWUgXTtcblxuXHRcdFx0XHRpZiAoICEgdW5pZm9ybXNBcnJheSApIHtcblxuXHRcdFx0XHRcdHVuaWZvcm1zQXJyYXkgPSB1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBbXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHVuaWZvcm1zQXJyYXlJbmRleCA9IHVuaWZvcm1zQXJyYXlbIGFycmF5SW5kZXggXTtcblxuXHRcdFx0XHRpZiAoICEgdW5pZm9ybXNBcnJheUluZGV4ICkge1xuXG5cdFx0XHRcdFx0dW5pZm9ybXNBcnJheUluZGV4ID0gdW5pZm9ybXNBcnJheVsgYXJyYXlJbmRleCBdID0ge307XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVuaWZvcm1zQXJyYXlJbmRleFsgYXJyYXlQcm9wZXJ0eSBdID0gbG9jYXRpb247XG5cblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0Y2hlcyA9IGFycmF5UmUuZXhlYyggbmFtZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoZXMgKSB7XG5cblx0XHRcdFx0dmFyIGFycmF5TmFtZSA9IG1hdGNoZXNbIDEgXTtcblxuXHRcdFx0XHR1bmlmb3Jtc1sgYXJyYXlOYW1lIF0gPSBsb2NhdGlvbjtcblxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1bmlmb3Jtc1sgbmFtZSBdID0gbG9jYXRpb247XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHt9O1xuXG5cdFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuXHRcdFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcblx0XHRcdHZhciBuYW1lID0gaW5mby5uYW1lO1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6XCIsIG5hbWUsIGkgKTtcblxuXHRcdFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcblxuXHRcdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cblx0XHR2YXIgZ2wgPSByZW5kZXJlci5jb250ZXh0O1xuXG5cdFx0dmFyIGV4dGVuc2lvbnMgPSBtYXRlcmlhbC5leHRlbnNpb25zO1xuXHRcdHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcblxuXHRcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG5cdFx0dmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNoYWRvd01hcCApIHtcblxuXHRcdFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0YnO1xuXG5cdFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG5cdFx0XHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRl9TT0ZUJztcblxuXHRcdH1cblxuXHRcdHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuXHRcdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xuXHRcdHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xuXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5DdWJlUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcblx0XHRcdFx0Y2FzZSBUSFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcblx0XHRcdFx0XHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0VRVUlSRUMnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6XG5cdFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9TUEhFUkUnO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xuXG5cdFx0XHRcdGNhc2UgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuXHRcdFx0XHRcdGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGUkFDVElPTic7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcblxuXHRcdFx0XHRjYXNlIFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uOlxuXHRcdFx0XHRcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5NaXhPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBUSFJFRS5BZGRPcGVyYXRpb246XG5cdFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcblxuXHRcdC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCByZW5kZXJlci5leHRlbnNpb25zICk7XG5cblx0XHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG5cdFx0Ly9cblxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0dmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCA9ICcnO1xuXHRcdFx0cHJlZml4RnJhZ21lbnQgPSAnJztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHByZWZpeFZlcnRleCA9IFtcblxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgZmxvYXQ7Jyxcblx0XHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG5cdFx0XHRcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLm5hbWUsXG5cblx0XHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXG5cblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuXHRcdFx0XHQnI2RlZmluZSBOVU1fRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5udW1EaXJMaWdodHMsXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMsXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5udW1TcG90TGlnaHRzLFxuXHRcdFx0XHQnI2RlZmluZSBOVU1fSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyxcblxuXHRcdFx0XHQnI2RlZmluZSBOVU1fU0hBRE9XUyAnICsgcGFyYW1ldGVycy5udW1TaGFkb3dzLFxuXG5cdFx0XHRcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMucG9pbnRMaWdodFNoYWRvd3MgPiAwID8gJyNkZWZpbmUgUE9JTlRfTElHSFRfU0hBRE9XUycgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgcmVuZGVyZXIuZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cblxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuXHRcdFx0XHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7Jyxcblx0XHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuXHRcdFx0XHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXG5cdFx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG5cdFx0XHRcdCcjaWZkZWYgVVNFX0NPTE9SJyxcblxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxuXG5cdFx0XHRcdCcjZW5kaWYnLFxuXG5cdFx0XHRcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXG5cblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuXHRcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7Jyxcblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXG5cblx0XHRcdFx0J1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXG5cblx0XHRcdFx0J1x0I2Vsc2UnLFxuXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ1OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXG5cdFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cblx0XHRcdFx0J1x0I2VuZGlmJyxcblxuXHRcdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0XHQnI2lmZGVmIFVTRV9TS0lOTklORycsXG5cblx0XHRcdFx0J1x0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXG5cdFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcblxuXHRcdFx0XHQnI2VuZGlmJyxcblxuXHRcdFx0XHQnXFxuJ1xuXG5cdFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXG5cdFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuXHRcdFx0XHRjdXN0b21FeHRlbnNpb25zLFxuXG5cdFx0XHRcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuXHRcdFx0XHQncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cblx0XHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuXHRcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm51bURpckxpZ2h0cyxcblx0XHRcdFx0JyNkZWZpbmUgTlVNX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyxcblx0XHRcdFx0JyNkZWZpbmUgTlVNX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMsXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzLFxuXG5cdFx0XHRcdCcjZGVmaW5lIE5VTV9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm51bVNoYWRvd3MsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5hbHBoYVRlc3QgPyAnI2RlZmluZSBBTFBIQVRFU1QgJyArIHBhcmFtZXRlcnMuYWxwaGFUZXN0IDogJycsXG5cblx0XHRcdFx0cmVuZGVyZXIuZ2FtbWFJbnB1dCA/ICcjZGVmaW5lIEdBTU1BX0lOUFVUJyA6ICcnLFxuXHRcdFx0XHRyZW5kZXJlci5nYW1tYU91dHB1dCA/ICcjZGVmaW5lIEdBTU1BX09VVFBVVCcgOiAnJyxcblx0XHRcdFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcblxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxuXHRcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwVHlwZURlZmluZSA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuXHRcdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cblx0XHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcblx0XHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMucG9pbnRMaWdodFNoYWRvd3MgPiAwID8gJyNkZWZpbmUgUE9JTlRfTElHSFRfU0hBRE9XUycgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG5cdFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuXHRcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsXG5cblx0XHRcdFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG5cdFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuXHRcdFx0XHQnXFxuJ1xuXG5cdFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuXHRcdH1cblxuXHRcdHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xuXHRcdHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xuXG5cdFx0dmFyIGdsVmVydGV4U2hhZGVyID0gVEhSRUUuV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG5cdFx0dmFyIGdsRnJhZ21lbnRTaGFkZXIgPSBUSFJFRS5XZWJHTFNoYWRlciggZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRHbHNsICk7XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cblx0XHQvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG5cblx0XHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cblx0XHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Ly8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXG5cdFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuXHRcdH1cblxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG5cdFx0dmFyIHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICk7XG5cdFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xuXG5cdFx0dmFyIHJ1bm5hYmxlID0gdHJ1ZTtcblx0XHR2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcblxuXHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdHJ1bm5hYmxlID0gZmFsc2U7XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XG5cblx0XHR9IGVsc2UgaWYgKCBwcm9ncmFtTG9nICE9PSAnJyApIHtcblxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xuXG5cdFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XG5cblx0XHRcdGhhdmVEaWFnbm9zdGljcyA9IGZhbHNlO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XG5cblx0XHRcdHRoaXMuZGlhZ25vc3RpY3MgPSB7XG5cblx0XHRcdFx0cnVubmFibGU6IHJ1bm5hYmxlLFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cblx0XHRcdFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcblxuXHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHtcblxuXHRcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuXHRcdFx0XHRcdHByZWZpeDogcHJlZml4VmVydGV4XG5cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjoge1xuXG5cdFx0XHRcdFx0bG9nOiBmcmFnbWVudExvZyxcblx0XHRcdFx0XHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9O1xuXG5cdFx0fVxuXG5cdFx0Ly8gY2xlYW4gdXBcblxuXHRcdGdsLmRlbGV0ZVNoYWRlciggZ2xWZXJ0ZXhTaGFkZXIgKTtcblx0XHRnbC5kZWxldGVTaGFkZXIoIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xuXG5cdFx0dmFyIGNhY2hlZFVuaWZvcm1zO1xuXG5cdFx0dGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Y2FjaGVkVW5pZm9ybXMgPSBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG5cdFx0fTtcblxuXHRcdC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cblx0XHR2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuXHRcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGNhY2hlZEF0dHJpYnV0ZXM7XG5cblx0XHR9O1xuXG5cdFx0Ly8gZnJlZSByZXNvdXJjZVxuXG5cdFx0dGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcblx0XHRcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcblxuXHRcdH07XG5cblx0XHQvLyBERVBSRUNBVEVEXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXG5cdFx0XHR1bmlmb3Jtczoge1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xuXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9ICk7XG5cblxuXHRcdC8vXG5cblx0XHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQgKys7XG5cdFx0dGhpcy5jb2RlID0gY29kZTtcblx0XHR0aGlzLnVzZWRUaW1lcyA9IDE7XG5cdFx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcblx0XHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuXHRcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW1zLmpzXG5cblRIUkVFLldlYkdMUHJvZ3JhbXMgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XG5cblx0dmFyIHByb2dyYW1zID0gW107XG5cblx0dmFyIHNoYWRlcklEcyA9IHtcblx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcblx0XHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuXHRcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuXHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0Jyxcblx0XHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcblx0XHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3N0YW5kYXJkJyxcblx0XHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcblx0XHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuXHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xuXHR9O1xuXG5cdHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcblx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJlbnZNYXBcIiwgXCJlbnZNYXBNb2RlXCIsXG5cdFx0XCJsaWdodE1hcFwiLCBcImFvTWFwXCIsIFwiZW1pc3NpdmVNYXBcIiwgXCJidW1wTWFwXCIsIFwibm9ybWFsTWFwXCIsIFwiZGlzcGxhY2VtZW50TWFwXCIsIFwic3BlY3VsYXJNYXBcIixcblx0XHRcInJvdWdobmVzc01hcFwiLCBcIm1ldGFsbmVzc01hcFwiLFxuXHRcdFwiYWxwaGFNYXBcIiwgXCJjb21iaW5lXCIsIFwidmVydGV4Q29sb3JzXCIsIFwiZm9nXCIsIFwidXNlRm9nXCIsIFwiZm9nRXhwXCIsXG5cdFx0XCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxuXHRcdFwibWF4Qm9uZXNcIiwgXCJ1c2VWZXJ0ZXhUZXh0dXJlXCIsIFwibW9ycGhUYXJnZXRzXCIsIFwibW9ycGhOb3JtYWxzXCIsXG5cdFx0XCJtYXhNb3JwaFRhcmdldHNcIiwgXCJtYXhNb3JwaE5vcm1hbHNcIixcblx0XHRcIm51bURpckxpZ2h0c1wiLCBcIm51bVBvaW50TGlnaHRzXCIsIFwibnVtU3BvdExpZ2h0c1wiLCBcIm51bUhlbWlMaWdodHNcIixcblx0XHRcIm51bVNoYWRvd3NcIiwgXCJzaGFkb3dNYXBFbmFibGVkXCIsIFwicG9pbnRMaWdodFNoYWRvd3NcIixcblx0XHRcInNoYWRvd01hcFR5cGVcIiwgXCJzaGFkb3dNYXBEZWJ1Z1wiLFxuXHRcdFwiYWxwaGFUZXN0XCIsIFwiZG91YmxlU2lkZWRcIiwgXCJmbGlwU2lkZWRcIlxuXHRdO1xuXG5cblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcblxuXHRcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuXHRcdFx0cmV0dXJuIDEwMjQ7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXG5cdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyIHRvIGJlIHVzZWQgd2l0aCBtdWx0aXBsZSBvYmplY3RzIClcblx0XHRcdC8vXG5cdFx0XHQvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xuXHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXG5cdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cblx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBjYXBhYmlsaXRpZXMubWF4VmVydGV4VW5pZm9ybXM7XG5cdFx0XHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xuXG5cdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cblx0XHRcdFx0bWF4Qm9uZXMgPSBNYXRoLm1pbiggb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCwgbWF4Qm9uZXMgKTtcblxuXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRvbyBtYW55IGJvbmVzIC0gJyArIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKyAnLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0ICcgKyBtYXhCb25lcyArICcgKHRyeSBPcGVuR0wgaW5zdGVhZCBvZiBBTkdMRSknICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXhCb25lcztcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApIHtcblxuXHRcdHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xuXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcblxuXHRcdHZhciBtYXhCb25lcyA9IGFsbG9jYXRlQm9uZXMoIG9iamVjdCApO1xuXHRcdHZhciBwcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcblxuXHRcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMuZ2V0TWF4UHJlY2lzaW9uKCBtYXRlcmlhbC5wcmVjaXNpb24gKTtcblxuXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgcGFyYW1ldGVycyA9IHtcblxuXHRcdFx0c2hhZGVySUQ6IHNoYWRlcklELFxuXG5cdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcblx0XHRcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcblxuXHRcdFx0bWFwOiAhISBtYXRlcmlhbC5tYXAsXG5cdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcblx0XHRcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcblx0XHRcdGxpZ2h0TWFwOiAhISBtYXRlcmlhbC5saWdodE1hcCxcblx0XHRcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcblx0XHRcdGVtaXNzaXZlTWFwOiAhISBtYXRlcmlhbC5lbWlzc2l2ZU1hcCxcblx0XHRcdGJ1bXBNYXA6ICEhIG1hdGVyaWFsLmJ1bXBNYXAsXG5cdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcblx0XHRcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxuXHRcdFx0cm91Z2huZXNzTWFwOiAhISBtYXRlcmlhbC5yb3VnaG5lc3NNYXAsXG5cdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcblx0XHRcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcblx0XHRcdGFscGhhTWFwOiAhISBtYXRlcmlhbC5hbHBoYU1hcCxcblxuXHRcdFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXG5cblx0XHRcdGZvZzogZm9nLFxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXG5cdFx0XHRmb2dFeHA6IGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIsXG5cblx0XHRcdGZsYXRTaGFkaW5nOiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyxcblxuXHRcdFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG5cdFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBjYXBhYmlsaXRpZXMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcblxuXHRcdFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxuXHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxuXHRcdFx0dXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgJiYgb2JqZWN0ICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSxcblxuXHRcdFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXG5cdFx0XHRtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxuXHRcdFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXG5cblx0XHRcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcblx0XHRcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxuXHRcdFx0bnVtU3BvdExpZ2h0czogbGlnaHRzLnNwb3QubGVuZ3RoLFxuXHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuXG5cdFx0XHRudW1TaGFkb3dzOiBsaWdodHMuc2hhZG93cy5sZW5ndGgsXG5cdFx0XHRwb2ludExpZ2h0U2hhZG93czogbGlnaHRzLnNoYWRvd3NQb2ludExpZ2h0LFxuXG5cdFx0XHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBsaWdodHMuc2hhZG93cy5sZW5ndGggPiAwLFxuXHRcdFx0c2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXG5cdFx0XHRzaGFkb3dNYXBEZWJ1ZzogcmVuZGVyZXIuc2hhZG93TWFwLmRlYnVnLFxuXG5cdFx0XHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcblx0XHRcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlLFxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxuXG5cdFx0fTtcblxuXHRcdHJldHVybiBwYXJhbWV0ZXJzO1xuXG5cdH07XG5cblx0dGhpcy5nZXRQcm9ncmFtQ29kZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cblx0XHR2YXIgY2h1bmtzID0gW107XG5cblx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cblx0XHRcdGNodW5rcy5wdXNoKCBwYXJhbWV0ZXJzLnNoYWRlcklEICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjaHVua3MucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcblx0XHRcdGNodW5rcy5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBtYXRlcmlhbC5kZWZpbmVzICkge1xuXG5cdFx0XHRcdGNodW5rcy5wdXNoKCBuYW1lICk7XG5cdFx0XHRcdGNodW5rcy5wdXNoKCBtYXRlcmlhbC5kZWZpbmVzWyBuYW1lIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcGFyYW1ldGVyTmFtZSA9IHBhcmFtZXRlck5hbWVzWyBpIF07XG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVyTmFtZSApO1xuXHRcdFx0Y2h1bmtzLnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWUgXSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCk7XG5cblx0fTtcblxuXHR0aGlzLmFjcXVpcmVQcm9ncmFtID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycywgY29kZSApIHtcblxuXHRcdHZhciBwcm9ncmFtO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG5cdFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xuXG5cdFx0XHR2YXIgcHJvZ3JhbUluZm8gPSBwcm9ncmFtc1sgcCBdO1xuXG5cdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cblx0XHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xuXHRcdFx0XHQrKyBwcm9ncmFtLnVzZWRUaW1lcztcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHByb2dyYW0gPSBuZXcgVEhSRUUuV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblx0XHRcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBwcm9ncmFtO1xuXG5cdH07XG5cblx0dGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBwcm9ncmFtICkge1xuXG5cdFx0aWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxuXHRcdFx0dmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XG5cdFx0XHRwcm9ncmFtc1sgaSBdID0gcHJvZ3JhbXNbIHByb2dyYW1zLmxlbmd0aCAtIDEgXTtcblx0XHRcdHByb2dyYW1zLnBvcCgpO1xuXG5cdFx0XHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xuXHRcdFx0cHJvZ3JhbS5kZXN0cm95KCk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XG5cdHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtcztcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMUHJvcGVydGllcy5qc1xuXG4vKipcbiogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cbiovXG5cblRIUkVFLldlYkdMUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgcHJvcGVydGllcyA9IHt9O1xuXG5cdHRoaXMuZ2V0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHR2YXIgdXVpZCA9IG9iamVjdC51dWlkO1xuXHRcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XG5cblx0XHRpZiAoIG1hcCA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRtYXAgPSB7fTtcblx0XHRcdHByb3BlcnRpZXNbIHV1aWQgXSA9IG1hcDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXA7XG5cblx0fTtcblxuXHR0aGlzLmRlbGV0ZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdFx0ZGVsZXRlIHByb3BlcnRpZXNbIG9iamVjdC51dWlkIF07XG5cblx0fTtcblxuXHR0aGlzLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cHJvcGVydGllcyA9IHt9O1xuXG5cdH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xuXG5USFJFRS5XZWJHTFNoYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XG5cblx0XHR2YXIgbGluZXMgPSBzdHJpbmcuc3BsaXQoICdcXG4nICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaW5lcy5qb2luKCAnXFxuJyApO1xuXG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cblx0XHR2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cblx0XHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuXHRcdH1cblxuXHRcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cblx0XHQvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG5cdFx0cmV0dXJuIHNoYWRlcjtcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZG93TWFwLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMgKSB7XG5cblx0dmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0LFxuXHRfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGUsXG5cdF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG5cdF9sb29rVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0X2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cblx0X3JlbmRlckxpc3QgPSBbXSxcblxuXHRfTW9ycGhpbmdGbGFnID0gMSxcblx0X1NraW5uaW5nRmxhZyA9IDIsXG5cblx0X051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyA9ICggX01vcnBoaW5nRmxhZyB8IF9Ta2lubmluZ0ZsYWcgKSArIDEsXG5cblx0X2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXG5cdF9kaXN0YW5jZU1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApO1xuXG5cdHZhciBjdWJlRGlyZWN0aW9ucyA9IFtcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0gMSApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwIClcblx0XTtcblxuXHR2YXIgY3ViZVVwcyA9IFtcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICksIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICksXHRuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLSAxIClcblx0XTtcblxuXHR2YXIgY3ViZTJEVmlld1BvcnRzID0gW1xuXHRcdG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksIG5ldyBUSFJFRS5WZWN0b3I0KCksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKSwgbmV3IFRIUkVFLlZlY3RvcjQoKVxuXHRdO1xuXG5cdC8vIGluaXRcblxuXHR2YXIgZGVwdGhTaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwiZGVwdGhSR0JBXCIgXTtcblx0dmFyIGRlcHRoVW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBkZXB0aFNoYWRlci51bmlmb3JtcyApO1xuXG5cdHZhciBkaXN0YW5jZVNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJkaXN0YW5jZVJHQkFcIiBdO1xuXHR2YXIgZGlzdGFuY2VVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRpc3RhbmNlU2hhZGVyLnVuaWZvcm1zICk7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzOyArKyBpICkge1xuXG5cdFx0dmFyIHVzZU1vcnBoaW5nID0gKCBpICYgX01vcnBoaW5nRmxhZyApICE9PSAwO1xuXHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcblxuXHRcdHZhciBkZXB0aE1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCB7XG5cdFx0XHR1bmlmb3JtczogZGVwdGhVbmlmb3Jtcyxcblx0XHRcdHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuXHRcdFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcblx0XHRcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xuXHRcdH0gKTtcblxuXHRcdGRlcHRoTWF0ZXJpYWwuX3NoYWRvd1Bhc3MgPSB0cnVlO1xuXG5cdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xuXG5cdFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcblx0XHRcdHVuaWZvcm1zOiBkaXN0YW5jZVVuaWZvcm1zLFxuXHRcdFx0dmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXG5cdFx0XHRmcmFnbWVudFNoYWRlcjogZGlzdGFuY2VTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG5cdFx0XHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxuXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXG5cdFx0fSApO1xuXG5cdFx0ZGlzdGFuY2VNYXRlcmlhbC5fc2hhZG93UGFzcyA9IHRydWU7XG5cblx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XG5cblx0fVxuXG5cdC8vXG5cblx0dmFyIHNjb3BlID0gdGhpcztcblxuXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuXHR0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy50eXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xuXHR0aGlzLmN1bGxGYWNlID0gVEhSRUUuQ3VsbEZhY2VGcm9udDtcblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcblxuXHRcdHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcblxuXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cdFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cblx0XHRfZ2wuY2xlYXJDb2xvciggMSwgMSwgMSwgMSApO1xuXHRcdF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcblx0XHRfc3RhdGUuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXHRcdF9nbC5jdWxsRmFjZSggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgPyBfZ2wuRlJPTlQgOiBfZ2wuQkFDSyApO1xuXHRcdF9zdGF0ZS5zZXREZXB0aFRlc3QoIHRydWUgKTtcblx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cblx0XHQvLyByZW5kZXIgZGVwdGggbWFwXG5cblx0XHR2YXIgc2hhZG93cyA9IF9saWdodHMuc2hhZG93cztcblxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzaGFkb3dzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGlnaHQgPSBzaGFkb3dzWyBpIF07XG5cblx0XHRcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XG5cdFx0XHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcblx0XHRcdHZhciBzaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XG5cblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdGZhY2VDb3VudCA9IDY7XG5cdFx0XHRcdGlzUG9pbnRMaWdodCA9IHRydWU7XG5cblx0XHRcdFx0dmFyIHZwV2lkdGggPSBzaGFkb3dNYXBTaXplLnggLyA0LjA7XG5cdFx0XHRcdHZhciB2cEhlaWdodCA9IHNoYWRvd01hcFNpemUueSAvIDIuMDtcblxuXHRcdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcblx0XHRcdFx0Ly8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyAgeHpYWlxuXHRcdFx0XHQvLyAgIHkgWVxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cblx0XHRcdFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXG5cdFx0XHRcdC8vIFkgLSBQb3NpdGl2ZSB5IGRpcmVjdGlvblxuXHRcdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cblx0XHRcdFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXG5cdFx0XHRcdC8vIHogLSBOZWdhdGl2ZSB6IGRpcmVjdGlvblxuXG5cdFx0XHRcdC8vIHBvc2l0aXZlIFhcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFhcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0Ly8gcG9zaXRpdmUgWlxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDIgXS5zZXQoIHZwV2lkdGggKiAzLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcblx0XHRcdFx0Ly8gbmVnYXRpdmUgWlxuXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXHRcdFx0XHQvLyBwb3NpdGl2ZSBZXG5cdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cdFx0XHRcdC8vIG5lZ2F0aXZlIFlcblx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyA1IF0uc2V0KCB2cFdpZHRoLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGZhY2VDb3VudCA9IDE7XG5cdFx0XHRcdGlzUG9pbnRMaWdodCA9IGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcblxuXHRcdFx0XHR2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG5cdFx0XHRcdGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuXHRcdFx0XHRcdHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xuXG5cdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHNoYWRvd01hcFNpemUueCwgc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XG5cdFx0XHRcdHNoYWRvdy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdC8vXG5cblx0XHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5hc3BlY3QgPSBzaGFkb3dNYXBTaXplLnggLyBzaGFkb3dNYXBTaXplLnk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHNoYWRvd01hcCA9IHNoYWRvdy5tYXA7XG5cdFx0XHR2YXIgc2hhZG93TWF0cml4ID0gc2hhZG93Lm1hdHJpeDtcblxuXHRcdFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRzaGFkb3dDYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXG5cdFx0XHRfcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBzaGFkb3dNYXAgKTtcblx0XHRcdF9yZW5kZXJlci5jbGVhcigpO1xuXG5cdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcCBmb3IgZWFjaCBjdWJlIGZhY2UgKGlmIG9tbmktZGlyZWN0aW9uYWwpIG9yXG5cdFx0XHQvLyBydW4gYSBzaW5nbGUgcGFzcyBpZiBub3RcblxuXHRcdFx0Zm9yICggdmFyIGZhY2UgPSAwOyBmYWNlIDwgZmFjZUNvdW50OyBmYWNlICsrICkge1xuXG5cdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xuXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuY29weSggc2hhZG93Q2FtZXJhLnBvc2l0aW9uICk7XG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XG5cdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwLmNvcHkoIGN1YmVVcHNbIGZhY2UgXSApO1xuXHRcdFx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XG5cblx0XHRcdFx0XHR2YXIgdnBEaW1lbnNpb25zID0gY3ViZTJEVmlld1BvcnRzWyBmYWNlIF07XG5cdFx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KCB2cERpbWVuc2lvbnMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X2xvb2tUYXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcblx0XHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHQvLyBjb21wdXRlIHNoYWRvdyBtYXRyaXhcblxuXHRcdFx0XHRzaGFkb3dNYXRyaXguc2V0KFxuXHRcdFx0XHRcdDAuNSwgMC4wLCAwLjAsIDAuNSxcblx0XHRcdFx0XHQwLjAsIDAuNSwgMC4wLCAwLjUsXG5cdFx0XHRcdFx0MC4wLCAwLjAsIDAuNSwgMC41LFxuXHRcdFx0XHRcdDAuMCwgMC4wLCAwLjAsIDEuMFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRcdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxuXG5cdFx0XHRcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cblx0XHRcdFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xuXG5cdFx0XHRcdF9yZW5kZXJMaXN0Lmxlbmd0aCA9IDA7XG5cblx0XHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgc2hhZG93Q2FtZXJhICk7XG5cblx0XHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXBcblx0XHRcdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBvYmplY3QgPSBfcmVuZGVyTGlzdFsgaiBdO1xuXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IF9vYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0XHRcdFx0XHR2YXIgbWF0ZXJpYWxzID0gbWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xuXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXHRcdFx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgbXVzdCBjYWxsIF9yZW5kZXJlci5yZXNldEdMU3RhdGUoKSBhdCB0aGUgZW5kIG9mIGVhY2ggaXRlcmF0aW9uIG9mXG5cdFx0XHQvLyB0aGUgbGlnaHQgbG9vcCBpbiBvcmRlciB0byBmb3JjZSBtYXRlcmlhbCB1cGRhdGVzIGZvciBlYWNoIGxpZ2h0LlxuXHRcdFx0X3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Ly8gUmVzdG9yZSBHTCBzdGF0ZS5cblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG5cdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cdFx0X3JlbmRlcmVyLnNldENsZWFyQ29sb3IoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcblxuXHRcdF9zdGF0ZS5lbmFibGUoIF9nbC5CTEVORCApO1xuXG5cdFx0aWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG5cdFx0fVxuXG5cdFx0X3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG5cdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgbGlnaHRQb3NpdGlvbldvcmxkICkge1xuXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG5cdFx0dmFyIG5ld01hdGVyaWFsID0gbnVsbDtcblxuXHRcdHZhciBtYXRlcmlhbFZhcmlhbnRzID0gX2RlcHRoTWF0ZXJpYWxzO1xuXHRcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xuXG5cdFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XG5cblx0XHRcdG1hdGVyaWFsVmFyaWFudHMgPSBfZGlzdGFuY2VNYXRlcmlhbHM7XG5cdFx0XHRjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EaXN0YW5jZU1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xuXG5cdFx0XHR2YXIgdXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcblxuXHRcdFx0dmFyIHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XG5cblx0XHRcdHZhciB2YXJpYW50SW5kZXggPSAwO1xuXG5cdFx0XHRpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XG5cdFx0XHRpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XG5cblx0XHRcdG5ld01hdGVyaWFsID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRuZXdNYXRlcmlhbCA9IGN1c3RvbU1hdGVyaWFsO1xuXG5cdFx0fVxuXG5cdFx0bmV3TWF0ZXJpYWwudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG5cdFx0bmV3TWF0ZXJpYWwud2lyZWZyYW1lID0gbWF0ZXJpYWwud2lyZWZyYW1lO1xuXHRcdG5ld01hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuXHRcdGlmICggaXNQb2ludExpZ2h0ICYmIG5ld01hdGVyaWFsLnVuaWZvcm1zLmxpZ2h0UG9zICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdG5ld01hdGVyaWFsLnVuaWZvcm1zLmxpZ2h0UG9zLnZhbHVlLmNvcHkoIGxpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld01hdGVyaWFsO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhICkge1xuXG5cdFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XG5cblx0XHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApICYmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50cyApICkge1xuXG5cdFx0XHRpZiAoIG9iamVjdC5jYXN0U2hhZG93ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cdFx0XHRcdFx0X3JlbmRlckxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEsIHNoYWRvd0NhbWVyYSApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU3RhdGUuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTFN0YXRlID0gZnVuY3Rpb24gKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1UaHJlZVRvR0wgKSB7XG5cblx0dmFyIF90aGlzID0gdGhpcztcblxuXHR2YXIgbmV3QXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xuXHR2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggMTYgKTtcblx0dmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG5cblx0dmFyIGNhcGFiaWxpdGllcyA9IHt9O1xuXG5cdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG5cdHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG5cdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcblx0dmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuXHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG5cdHZhciBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XG5cblx0dmFyIGN1cnJlbnRDb2xvcldyaXRlID0gbnVsbDtcblxuXHR2YXIgY3VycmVudFN0ZW5jaWxXcml0ZSA9IG51bGw7XG5cdHZhciBjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xuXHR2YXIgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xuXHR2YXIgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcblx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCAgPSBudWxsO1xuXHR2YXIgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG5cdHZhciBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcblxuXHR2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cblx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG5cdHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuXHR2YXIgY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbDtcblxuXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cblx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcblx0dmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cblx0dmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblx0dmFyIGN1cnJlbnRWaWV3cG9ydCA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Z2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xuXHRcdGdsLmNsZWFyRGVwdGgoIDEgKTtcblx0XHRnbC5jbGVhclN0ZW5jaWwoIDAgKTtcblxuXHRcdHRoaXMuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcblx0XHR0aGlzLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cblx0XHR0aGlzLmVuYWJsZSggZ2wuQkxFTkQgKTtcblx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cblx0fTtcblxuXHR0aGlzLmluaXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRuZXdBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5lbmFibGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGF0dHJpYnV0ZSApIHtcblxuXHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG5cdFx0XHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XG5cdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IDAgKSB7XG5cblx0XHRcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cblx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgMCApO1xuXHRcdFx0YXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdID0gMDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciA9IGZ1bmN0aW9uICggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKSB7XG5cblx0XHRuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cblx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuXHRcdFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuXHRcdH1cblxuXHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSBtZXNoUGVyQXR0cmlidXRlICkge1xuXG5cdFx0XHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcblx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XG5cblx0XHRcdFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XG5cdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xuXHRcdFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZGlzYWJsZSA9IGZ1bmN0aW9uICggaWQgKSB7XG5cblx0XHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XG5cblx0XHRcdGdsLmRpc2FibGUoIGlkICk7XG5cdFx0XHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0aWYgKCBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPT09IG51bGwgKSB7XG5cblx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG5cdFx0XHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XG5cdFx0XHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgKSB7XG5cblx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMucHVzaCggZm9ybWF0c1sgaSBdICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xuXG5cdH07XG5cblx0dGhpcy5zZXRCbGVuZGluZyA9IGZ1bmN0aW9uICggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhICkge1xuXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5CTEVORCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgKSB7XG5cblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORSApO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcblxuXHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cblxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuXHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk11bHRpcGx5QmxlbmRpbmcgKSB7XG5cblx0XHRcdFx0Ly8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG5cblx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcblx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuXHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblxuXHRcdH1cblxuXHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG5cdFx0XHRibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcblx0XHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuXHRcdFx0YmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cblx0XHRcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xuXG5cdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XG5cblx0XHRcdFx0Y3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuXHRcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG5cdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmMgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0ICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyY0FscGhhICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdEFscGhhICkgKTtcblxuXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG5cdFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcblx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG5cdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0ID0gbnVsbDtcblx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuXHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcblxuXHRcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xuXG5cdFx0XHRpZiAoIGRlcHRoRnVuYyApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLk5ldmVyRGVwdGg6XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcblxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5MZXNzRGVwdGg6XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLkxlc3NFcXVhbERlcHRoOlxuXG5cdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRXF1YWxEZXB0aDpcblxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBUSFJFRS5HcmVhdGVyRGVwdGg6XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XG5cblx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50RGVwdGhGdW5jID0gZGVwdGhGdW5jO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zZXREZXB0aFRlc3QgPSBmdW5jdGlvbiAoIGRlcHRoVGVzdCApIHtcblxuXHRcdGlmICggZGVwdGhUZXN0ICkge1xuXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldERlcHRoV3JpdGUgPSBmdW5jdGlvbiAoIGRlcHRoV3JpdGUgKSB7XG5cblx0XHQvLyBUT0RPOiBSZW5hbWUgdG8gc2V0RGVwdGhNYXNrXG5cblx0XHRpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xuXG5cdFx0XHRnbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcblx0XHRcdGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcblxuXHRcdC8vIFRPRE86IFJlbmFtZSB0byBzZXRDb2xvck1hc2tcblxuXHRcdGlmICggY3VycmVudENvbG9yV3JpdGUgIT09IGNvbG9yV3JpdGUgKSB7XG5cblx0XHRcdGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xuXHRcdFx0Y3VycmVudENvbG9yV3JpdGUgPSBjb2xvcldyaXRlO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zZXRTdGVuY2lsRnVuYyA9IGZ1bmN0aW9uICggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICkge1xuXG5cdFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XG5cdFx0XHRcdCBjdXJyZW50U3RlbmNpbFJlZiBcdCE9PSBzdGVuY2lsUmVmIFx0fHxcblx0XHRcdFx0IGN1cnJlbnRTdGVuY2lsTWFzayAhPT0gc3RlbmNpbE1hc2sgKSB7XG5cblx0XHRcdGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICk7XG5cblx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xuXHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgID0gc3RlbmNpbFJlZjtcblx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zZXRTdGVuY2lsT3AgPSBmdW5jdGlvbiAoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcblxuXHRcdGlmICggY3VycmVudFN0ZW5jaWxGYWlsXHQgIT09IHN0ZW5jaWxGYWlsIFx0fHxcblx0XHRcdFx0IGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxuXHRcdFx0XHQgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xuXG5cdFx0XHRnbC5zdGVuY2lsT3AoIHN0ZW5jaWxGYWlsLCAgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcblxuXHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsICA9IHN0ZW5jaWxGYWlsO1xuXHRcdFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcblx0XHRcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldFN0ZW5jaWxUZXN0ID0gZnVuY3Rpb24gKCBzdGVuY2lsVGVzdCApIHtcblxuXHRcdGlmICggc3RlbmNpbFRlc3QgKSB7XG5cblx0XHRcdHRoaXMuZW5hYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnNldFN0ZW5jaWxXcml0ZSA9IGZ1bmN0aW9uICggc3RlbmNpbFdyaXRlICkge1xuXG5cdFx0Ly8gVE9ETzogUmVuYW1lIHRvIHNldFN0ZW5jaWxNYXNrXG5cblx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsV3JpdGUgIT09IHN0ZW5jaWxXcml0ZSApIHtcblxuXHRcdFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxXcml0ZSApO1xuXHRcdFx0Y3VycmVudFN0ZW5jaWxXcml0ZSA9IHN0ZW5jaWxXcml0ZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuXHRcdFx0aWYgKCBmbGlwU2lkZWQgKSB7XG5cblx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuc2V0TGluZVdpZHRoID0gZnVuY3Rpb24gKCB3aWR0aCApIHtcblxuXHRcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cblx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuXHRcdFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5zZXRQb2x5Z29uT2Zmc2V0ID0gZnVuY3Rpb24gKCBwb2x5Z29uT2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG5cdFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICkge1xuXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHBvbHlnb25PZmZzZXQgJiYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XG5cblx0XHRcdGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcblxuXHRcdFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG5cdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLmdldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0cmV0dXJuIGN1cnJlbnRTY2lzc29yVGVzdDtcblxuXHR9O1xuXG5cdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIHNjaXNzb3JUZXN0ICkge1xuXG5cdFx0Y3VycmVudFNjaXNzb3JUZXN0ID0gc2Npc3NvclRlc3Q7XG5cblx0XHRpZiAoIHNjaXNzb3JUZXN0ICkge1xuXG5cdFx0XHR0aGlzLmVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLmRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gdGV4dHVyZVxuXG5cdHRoaXMuYWN0aXZlVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xTbG90ICkge1xuXG5cdFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xuXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcblxuXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG5cdFx0XHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuYmluZFRleHR1cmUgPSBmdW5jdGlvbiAoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xuXG5cdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0X3RoaXMuYWN0aXZlVGV4dHVyZSgpO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcblxuXHRcdGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcblx0XHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcblxuXHRcdH1cblxuXHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKTtcblxuXHRcdFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XG5cdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdHRoaXMuY29tcHJlc3NlZFRleEltYWdlMkQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0cnkge1xuXG5cdFx0XHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy50ZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG5cdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly9cblxuXHR0aGlzLnNjaXNzb3IgPSBmdW5jdGlvbiAoIHNjaXNzb3IgKSB7XG5cblx0XHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcblxuXHRcdFx0Z2wuc2Npc3Nvciggc2Npc3Nvci54LCBzY2lzc29yLnksIHNjaXNzb3Iueiwgc2Npc3Nvci53ICk7XG5cdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnZpZXdwb3J0ID0gZnVuY3Rpb24gKCB2aWV3cG9ydCApIHtcblxuXHRcdGlmICggY3VycmVudFZpZXdwb3J0LmVxdWFscyggdmlld3BvcnQgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdGdsLnZpZXdwb3J0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56LCB2aWV3cG9ydC53ICk7XG5cdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdC8vXG5cblx0dGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xuXG5cdFx0XHRcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuXHRcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y2FwYWJpbGl0aWVzID0ge307XG5cblx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG5cdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblxuXHRcdGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcblx0XHRjdXJyZW50Q29sb3JXcml0ZSA9IG51bGw7XG5cblx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcblxuXHR9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvcGx1Z2lucy9MZW5zRmxhcmVQbHVnaW4uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MZW5zRmxhcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBmbGFyZXMgKSB7XG5cblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcblx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuXHR2YXIgaGFzVmVydGV4VGV4dHVyZTtcblxuXHR2YXIgdGVtcFRleHR1cmUsIG9jY2x1c2lvblRleHR1cmU7XG5cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblx0XHRcdC0gMSwgLSAxLCAgMCwgMCxcblx0XHRcdCAxLCAtIDEsICAxLCAwLFxuXHRcdFx0IDEsICAxLCAgMSwgMSxcblx0XHRcdC0gMSwgIDEsICAwLCAxXG5cdFx0XSApO1xuXG5cdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG5cdFx0XHQwLCAxLCAyLFxuXHRcdFx0MCwgMiwgM1xuXHRcdF0gKTtcblxuXHRcdC8vIGJ1ZmZlcnNcblxuXHRcdHZlcnRleEJ1ZmZlciAgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblx0XHRlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdC8vIHRleHR1cmVzXG5cblx0XHR0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG5cdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcblx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cblx0XHRoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XG5cblx0XHR2YXIgc2hhZGVyO1xuXG5cdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xuXG5cdFx0XHRzaGFkZXIgPSB7XG5cblx0XHRcdFx0dmVydGV4U2hhZGVyOiBbXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXHRcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuXHRcdFx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxuXG5cdFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxuXG5cdFx0XHRcdFx0XHRcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cblx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7XCIsXG5cdFx0XHRcdFx0XHRcdFwidlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5nIC8gOS4wO1wiLFxuXHRcdFx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ICo9ICAgICAgIHZpc2liaWxpdHkuYiAvIDkuMDtcIixcblx0XHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXHRcdFx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cblx0XHRcdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG5cdFx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuXHRcdFx0XHRmcmFnbWVudFNoYWRlcjogW1xuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcblx0XHRcdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXG5cblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFx0Ly8gcGluayBzcXVhcmVcblxuXHRcdFx0XHRcdFx0XCJpZiAoIHJlbmRlclR5cGUgPT0gMCApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyByZXN0b3JlXG5cblx0XHRcdFx0XHRcdFwifSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG5cdFx0XHRcdFx0XHQvLyBmbGFyZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cblx0XHRcdFx0XHRcdFwifVwiLFxuXG5cdFx0XHRcdFx0XCJ9XCJcblxuXHRcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKVxuXG5cdFx0XHR9O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0c2hhZGVyID0ge1xuXG5cdFx0XHRcdHZlcnRleFNoYWRlcjogW1xuXG5cdFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcblx0XHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cblx0XHRcdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cblx0XHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuXHRcdFx0XHRcdFx0XCJ2VVYgPSB1djtcIixcblxuXHRcdFx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG5cdFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblx0XHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG5cdFx0XHRcdFx0XHRcIn1cIixcblxuXHRcdFx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHZlYzQoICggcG9zICogc2NhbGUgKyBzY3JlZW5Qb3NpdGlvbi54eSApLnh5LCBzY3JlZW5Qb3NpdGlvbi56LCAxLjAgKTtcIixcblxuXHRcdFx0XHRcdFwifVwiXG5cblx0XHRcdFx0XS5qb2luKCBcIlxcblwiICksXG5cblx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IFtcblxuXHRcdFx0XHRcdFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsXG5cblx0XHRcdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXHRcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG5cdFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuXG5cdFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cblx0XHRcdFx0XHRcdC8vIHBpbmsgc3F1YXJlXG5cblx0XHRcdFx0XHRcdFwiaWYgKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gcmVzdG9yZVxuXG5cdFx0XHRcdFx0XHRcIn0gZWxzZSBpZiAoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuXHRcdFx0XHRcdFx0Ly8gZmxhcmVcblxuXHRcdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxuXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcIixcblx0XHRcdFx0XHRcdFx0XCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXG5cblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG5cdFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxuXHRcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG5cdFx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuXHRcdFx0XHRcdFx0XCJ9XCIsXG5cblx0XHRcdFx0XHRcIn1cIlxuXG5cdFx0XHRcdF0uam9pbiggXCJcXG5cIiApXG5cblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XG5cblx0XHRhdHRyaWJ1dGVzID0ge1xuXHRcdFx0dmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0dXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXG5cdFx0fTtcblxuXHRcdHVuaWZvcm1zID0ge1xuXHRcdFx0cmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcblx0XHRcdG1hcDogICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcblx0XHRcdG9jY2x1c2lvbk1hcDogICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcblx0XHRcdG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXG5cdFx0XHRjb2xvcjogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcblx0XHRcdHNjYWxlOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxuXHRcdFx0cm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXG5cdFx0XHRzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxuXHRcdH07XG5cblx0fVxuXG5cdC8qXG5cdCAqIFJlbmRlciBsZW5zIGZsYXJlc1xuXHQgKiBNZXRob2Q6IHJlbmRlcnMgMTZ4MTYgMHhmZjAwZmYtY29sb3JlZCBwb2ludHMgc2NhdHRlcmVkIG92ZXIgdGhlIGxpZ2h0IHNvdXJjZSBhcmVhLFxuXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxuXHQgKi9cblxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgdmlld3BvcnQgKSB7XG5cblx0XHRpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cblx0XHR2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZhciBpbnZBc3BlY3QgPSB2aWV3cG9ydC53IC8gdmlld3BvcnQueixcblx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnQueiAqIDAuNSxcblx0XHRcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0LncgKiAwLjU7XG5cblx0XHR2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnQudyxcblx0XHRcdHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuXHRcdHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAwICksXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XG5cblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0aW5pdCgpO1xuXG5cdFx0fVxuXG5cdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG5cdFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudmVydGV4ICk7XG5cdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXG5cdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcblxuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XG5cdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG5cdFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cdFx0c3RhdGUuc2V0RGVwdGhXcml0ZSggZmFsc2UgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRzaXplID0gMTYgLyB2aWV3cG9ydC53O1xuXHRcdFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cblx0XHRcdC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxuXG5cdFx0XHR2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcblxuXHRcdFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xuXG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG5cdFx0XHQvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXG5cblx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xuXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuXHRcdFx0Ly8gc2NyZWVuIGN1bGxcblxuXHRcdFx0aWYgKCBoYXNWZXJ0ZXhUZXh0dXJlIHx8IChcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0LnogJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0LncgKSApIHtcblxuXHRcdFx0XHQvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxuXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCB2aWV3cG9ydC54ICsgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHZpZXdwb3J0LnkgKyBzY3JlZW5Qb3NpdGlvblBpeGVscy55IC0gOCwgMTYsIDE2LCAwICk7XG5cblxuXHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXG5cblx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XG5cdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXG5cdFx0XHRcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XG5cdFx0XHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cblx0XHRcdFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXG5cblx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcblx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcblx0XHRcdFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHZpZXdwb3J0LnggKyBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgdmlld3BvcnQueSArIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcblx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG5cdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG5cdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG5cdFx0XHRcdC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cblx0XHRcdFx0ZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKTtcblxuXHRcdFx0XHRpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xuXG5cdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVuZGVyIGZsYXJlc1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xuXHRcdFx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xuXG5cdFx0XHRcdFx0aWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xuXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XG5cblx0XHRcdFx0XHRcdHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0Lnc7XG5cblx0XHRcdFx0XHRcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuXHRcdFx0XHRcdFx0c2NhbGUueSA9IHNpemU7XG5cblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcblx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xuXG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIHNwcml0ZS5vcGFjaXR5ICk7XG5cdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cblx0XHRcdFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xuXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcblxuXHRcdFx0XHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIHRydWUgKTtcblxuXHRcdHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoIHNoYWRlciApIHtcblxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cblx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xuXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNwcml0ZXMgKSB7XG5cblx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblx0dmFyIHN0YXRlID0gcmVuZGVyZXIuc3RhdGU7XG5cblx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcblx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuXG5cdHZhciB0ZXh0dXJlO1xuXG5cdC8vIGRlY29tcG9zZSBtYXRyaXhXb3JsZFxuXG5cdHZhciBzcHJpdGVQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cdHZhciBzcHJpdGVTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblx0XHRcdC0gMC41LCAtIDAuNSwgIDAsIDAsXG5cdFx0XHQgIDAuNSwgLSAwLjUsICAxLCAwLFxuXHRcdFx0ICAwLjUsICAgMC41LCAgMSwgMSxcblx0XHRcdC0gMC41LCAgIDAuNSwgIDAsIDFcblx0XHRdICk7XG5cblx0XHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcblx0XHRcdDAsIDEsIDIsXG5cdFx0XHQwLCAyLCAzXG5cdFx0XSApO1xuXG5cdFx0dmVydGV4QnVmZmVyICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXHRcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG5cdFx0cHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcblxuXHRcdGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRwb3NpdGlvbjpcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICdwb3NpdGlvbicgKSxcblx0XHRcdHV2Olx0XHRcdFx0XHRnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sICd1dicgKVxuXHRcdH07XG5cblx0XHR1bmlmb3JtcyA9IHtcblx0XHRcdHV2T2Zmc2V0Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxuXHRcdFx0dXZTY2FsZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxuXG5cdFx0XHRyb3RhdGlvbjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcblx0XHRcdHNjYWxlOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXG5cblx0XHRcdGNvbG9yOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXG5cdFx0XHRtYXA6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXG5cdFx0XHRvcGFjaXR5Olx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXG5cblx0XHRcdG1vZGVsVmlld01hdHJpeDogXHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXG5cdFx0XHRwcm9qZWN0aW9uTWF0cml4Olx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcblxuXHRcdFx0Zm9nVHlwZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxuXHRcdFx0Zm9nRGVuc2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxuXHRcdFx0Zm9nTmVhcjpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxuXHRcdFx0Zm9nRmFyOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxuXHRcdFx0Zm9nQ29sb3I6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXG5cblx0XHRcdGFscGhhVGVzdDpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcblx0XHR9O1xuXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdFx0Y2FudmFzLndpZHRoID0gODtcblx0XHRjYW52YXMuaGVpZ2h0ID0gODtcblxuXHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcblx0XHRjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG5cdFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG5cdFx0dGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcblx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG5cdFx0Ly8gc2V0dXAgZ2xcblxuXHRcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRpbml0KCk7XG5cblx0XHR9XG5cblx0XHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cblx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblx0XHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcblx0XHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cblx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cblx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuXHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XG5cblx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XG5cdFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuXHRcdGlmICggZm9nICkge1xuXG5cdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XG5cblx0XHRcdGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcblxuXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDEgKTtcblx0XHRcdFx0b2xkRm9nVHlwZSA9IDE7XG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZ0V4cDIgKSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMiApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gMjtcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcblx0XHRcdHNjZW5lRm9nVHlwZSA9IDA7XG5cblx0XHR9XG5cblxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuXHRcdFx0c3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcblx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xuXG5cdFx0fVxuXG5cdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG5cdFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cblx0XHR2YXIgc2NhbGUgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblx0XHRcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuXHRcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG5cdFx0XHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cblx0XHRcdHNjYWxlWyAwIF0gPSBzcHJpdGVTY2FsZS54O1xuXHRcdFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XG5cblx0XHRcdHZhciBmb2dUeXBlID0gMDtcblxuXHRcdFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG5cdFx0XHRcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBvbGRGb2dUeXBlICE9PSBmb2dUeXBlICkge1xuXG5cdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xuXHRcdFx0XHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIDEsIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcblx0XHRcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcblxuXHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcblx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG5cdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xuXHRcdFx0c3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcblx0XHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlKCBtYXRlcmlhbC5tYXAsIDAgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlKCB0ZXh0dXJlLCAwICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblx0XHR9XG5cblx0XHQvLyByZXN0b3JlIGdsXG5cblx0XHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5cdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtICgpIHtcblxuXHRcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG5cdFx0dmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuXHRcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cblx0XHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xuXG5cdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuXHRcdFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7Jyxcblx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgcm90YXRpb247Jyxcblx0XHRcdCd1bmlmb3JtIHZlYzIgc2NhbGU7Jyxcblx0XHRcdCd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7Jyxcblx0XHRcdCd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxuXG5cdFx0XHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247Jyxcblx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG5cdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG5cdFx0XHQndm9pZCBtYWluKCkgeycsXG5cblx0XHRcdFx0J3ZVViA9IHV2T2Zmc2V0ICsgdXYgKiB1dlNjYWxlOycsXG5cblx0XHRcdFx0J3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxuXG5cdFx0XHRcdCd2ZWMyIHJvdGF0ZWRQb3NpdGlvbjsnLFxuXHRcdFx0XHQncm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG5cdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcblxuXHRcdFx0XHQndmVjNCBmaW5hbFBvc2l0aW9uOycsXG5cblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxuXHRcdFx0XHQnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247Jyxcblx0XHRcdFx0J2ZpbmFsUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogZmluYWxQb3NpdGlvbjsnLFxuXG5cdFx0XHRcdCdnbF9Qb3NpdGlvbiA9IGZpbmFsUG9zaXRpb247JyxcblxuXHRcdFx0J30nXG5cblx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuXHRcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcblxuXHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cblx0XHRcdCd1bmlmb3JtIHZlYzMgY29sb3I7Jyxcblx0XHRcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7Jyxcblx0XHRcdCd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuXHRcdFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7Jyxcblx0XHRcdCd1bmlmb3JtIHZlYzMgZm9nQ29sb3I7Jyxcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7Jyxcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7Jyxcblx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0ZhcjsnLFxuXHRcdFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXG5cblx0XHRcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXG5cblx0XHRcdCd2b2lkIG1haW4oKSB7JyxcblxuXHRcdFx0XHQndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXG5cblx0XHRcdFx0J2lmICggdGV4dHVyZS5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxuXG5cdFx0XHRcdCdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciAqIHRleHR1cmUueHl6LCB0ZXh0dXJlLmEgKiBvcGFjaXR5ICk7JyxcblxuXHRcdFx0XHQnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxuXG5cdFx0XHRcdFx0J2Zsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudzsnLFxuXHRcdFx0XHRcdCdmbG9hdCBmb2dGYWN0b3IgPSAwLjA7JyxcblxuXHRcdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxuXG5cdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApOycsXG5cblx0XHRcdFx0XHQnfSBlbHNlIHsnLFxuXG5cdFx0XHRcdFx0XHQnY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXG5cdFx0XHRcdFx0XHQnZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7Jyxcblx0XHRcdFx0XHRcdCdmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXG5cblx0XHRcdFx0XHQnfScsXG5cblx0XHRcdFx0XHQnZ2xfRnJhZ0NvbG9yID0gbWl4KCBnbF9GcmFnQ29sb3IsIHZlYzQoIGZvZ0NvbG9yLCBnbF9GcmFnQ29sb3IudyApLCBmb2dGYWN0b3IgKTsnLFxuXG5cdFx0XHRcdCd9JyxcblxuXHRcdFx0J30nXG5cblx0XHRdLmpvaW4oICdcXG4nICkgKTtcblxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcblxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cblx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUgKCBhLCBiICkge1xuXG5cdFx0aWYgKCBhLnogIT09IGIueiApIHtcblxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBiLmlkIC0gYS5pZDtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL1RocmVlLkxlZ2FjeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkJveDIucHJvdG90eXBlLCB7XG5cdGVtcHR5OiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cdFx0fVxuXHR9LFxuXHRpc0ludGVyc2VjdGlvbkJveDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkJveDMucHJvdG90eXBlLCB7XG5cdGVtcHR5OiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5lbXB0eSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmlzRW1wdHkoKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG5cdFx0fVxuXHR9LFxuXHRpc0ludGVyc2VjdGlvbkJveDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvbkJveCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNCb3goKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcblx0XHR9XG5cdH0sXG5cdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uU3BoZXJlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1NwaGVyZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuTWF0cml4My5wcm90b3R5cGUsIHtcblx0bXVsdGlwbHlWZWN0b3IzOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cdFx0fVxuXHR9LFxuXHRtdWx0aXBseVZlY3RvcjNBcnJheToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5NYXRyaXg0LnByb3RvdHlwZSwge1xuXHRleHRyYWN0UG9zaXRpb246IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuXHRcdH1cblx0fSxcblx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHEgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblx0XHR9XG5cdH0sXG5cdG11bHRpcGx5VmVjdG9yMzoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgb3IgdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuXHRcdH1cblx0fSxcblx0bXVsdGlwbHlWZWN0b3I0OiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cdFx0fVxuXHR9LFxuXHRtdWx0aXBseVZlY3RvcjNBcnJheToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cdFx0fVxuXHR9LFxuXHRyb3RhdGVBeGlzOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggdiApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XG5cdFx0fVxuXHR9LFxuXHRjcm9zc1ZlY3Rvcjoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5jcm9zc1ZlY3RvcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG5cdFx0fVxuXHR9LFxuXHR0cmFuc2xhdGU6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCB2ICkge1xuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblx0XHR9XG5cdH0sXG5cdHJvdGF0ZVg6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBhbmdsZSApIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH1cblx0fSxcblx0cm90YXRlWToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGFuZ2xlICkge1xuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cdFx0fVxuXHR9LFxuXHRyb3RhdGVaOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZVooKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblx0XHR9XG5cdH0sXG5cdHJvdGF0ZUJ5QXhpczoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLlBsYW5lLnByb3RvdHlwZSwge1xuXHRpc0ludGVyc2VjdGlvbkxpbmU6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBsaW5lICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGxhbmU6IC5pc0ludGVyc2VjdGlvbkxpbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzTGluZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xuXHRtdWx0aXBseVZlY3RvcjM6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggdGhpcyApO1xuXHRcdH1cblx0fVxufSApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuUmF5LnByb3RvdHlwZSwge1xuXHRpc0ludGVyc2VjdGlvbkJveDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGJveCApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xuXHRcdH1cblx0fSxcblx0aXNJbnRlcnNlY3Rpb25QbGFuZToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNQbGFuZSggcGxhbmUgKTtcblx0XHR9XG5cdH0sXG5cdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5WZWN0b3IzLnByb3RvdHlwZSwge1xuXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXHRcdH1cblx0fSxcblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcblx0XHR9XG5cdH0sXG5cdGdldFBvc2l0aW9uRnJvbU1hdHJpeDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIG0gKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cdFx0fVxuXHR9LFxuXHRnZXRTY2FsZUZyb21NYXRyaXg6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBtICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhTY2FsZSggbSApO1xuXHRcdH1cblx0fSxcblx0Z2V0Q29sdW1uRnJvbU1hdHJpeDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUsIHtcblx0ZXVsZXJPcmRlcjoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRpb24ub3JkZXI7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XG5cdFx0XHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRnZXRDaGlsZEJ5TmFtZToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmdldENoaWxkQnlOYW1lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0T2JqZWN0QnlOYW1lKCkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XG5cdFx0fVxuXHR9LFxuXHRyZW5kZXJEZXB0aDoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XG5cdFx0fVxuXHR9LFxuXHR0cmFuc2xhdGU6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XG5cdFx0fVxuXHR9LFxuXHR1c2VRdWF0ZXJuaW9uOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRSwge1xuXHRQb2ludENsb3VkOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdFx0fVxuXHR9LFxuXHRQYXJ0aWNsZVN5c3RlbToge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy9cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSwge1xuXHRvbmx5U2hhZG93OiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhRm92OiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhTGVmdDoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5sZWZ0ID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFSaWdodDoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhVG9wOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhQm90dG9tOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93Q2FtZXJhTmVhcjoge1xuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFGYXI6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dDYW1lcmFWaXNpYmxlOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dCaWFzOiB7XG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93RGFya25lc3M6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5kYXJrbmVzcyA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwV2lkdGg6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLndpZHRoID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dNYXBIZWlnaHQ6IHtcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xuXHRcdH1cblx0fVxufSApO1xuXG4vL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xuXHRsZW5ndGg6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5jb3VudC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cdFx0fVxuXHR9XG59ICk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcblx0ZHJhd2NhbGxzOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmdyb3Vwcztcblx0XHR9XG5cdH0sXG5cdG9mZnNldHM6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuXHRcdH1cblx0fSxcblx0YWRkSW5kZXg6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBpbmRleCApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkSW5kZXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRJbmRleCgpLicgKTtcblx0XHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XG5cdFx0fVxuXHR9LFxuXHRhZGREcmF3Q2FsbDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XG5cdFx0XHRpZiAoIGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XG5cdFx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcblx0XHR9XG5cdH0sXG5cdGNsZWFyRHJhd0NhbGxzOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY2xlYXJEcmF3Q2FsbHMoKSBpcyBub3cgLmNsZWFyR3JvdXBzKCkuJyApO1xuXHRcdFx0dGhpcy5jbGVhckdyb3VwcygpO1xuXHRcdH1cblx0fSxcblx0Y29tcHV0ZVRhbmdlbnRzOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cdFx0fVxuXHR9LFxuXHRjb21wdXRlT2Zmc2V0czoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVPZmZzZXRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUsIHtcblx0d3JhcEFyb3VuZDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH1cblx0fSxcblx0d3JhcFJHQjoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC53cmFwUkdCIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdFx0cmV0dXJuIG5ldyBUSFJFRS5Db2xvcigpO1xuXHRcdH1cblx0fVxufSApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUsIHtcblx0UG9pbnRDbG91ZE1hdGVyaWFsOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblx0XHR9XG5cdH0sXG5cdFBhcnRpY2xlQmFzaWNNYXRlcmlhbDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG5cdFx0fVxuXHR9LFxuXHRQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsOntcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcblx0XHRcdHJldHVybiBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSwge1xuXHRtZXRhbDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZC4nICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkJyApO1xuXHRcdH1cblx0fVxufSApO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLCB7XG5cdGRlcml2YXRpdmVzOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXM7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4gU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XG5cdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy9cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFRIUkVFLldlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XG5cdHN1cHBvcnRzRmxvYXRUZXh0dXJlczoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfZmxvYXRcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuXHRcdH1cblx0fSxcblx0c3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlczoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cdFx0fVxuXHR9LFxuXHRzdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXM6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcJyApLicgKTtcblx0XHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xuXHRcdH1cblx0fSxcblx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEM6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXHRcdH1cblx0fSxcblx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGNcXCcgKS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblx0XHR9XG5cdH0sXG5cdHN1cHBvcnRzQmxlbmRNaW5NYXg6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQmxlbmRNaW5NYXgoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdFWFRfYmxlbmRfbWlubWF4XFwnICkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xuXHRcdH1cblx0fSxcblx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXM7XG5cdFx0fVxuXHR9LFxuXHRzdXBwb3J0c0luc3RhbmNlZEFycmF5czoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXHRcdH1cblx0fSxcblx0ZW5hYmxlU2Npc3NvclRlc3Q6IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCBib29sZWFuICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcblx0XHRcdHRoaXMuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcblx0XHR9XG5cdH0sXG5cdGluaXRNYXRlcmlhbDoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cdFx0fVxuXHR9LFxuXHRhZGRQcmVQbHVnaW46IHtcblx0XHR2YWx1ZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH1cblx0fSxcblx0YWRkUG9zdFBsdWdpbjoge1xuXHRcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXHRcdH1cblx0fSxcblx0dXBkYXRlU2hhZG93TWFwOiB7XG5cdFx0dmFsdWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblx0XHR9XG5cdH0sXG5cdHNoYWRvd01hcEVuYWJsZWQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC5lbmFibGVkO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XG5cdFx0XHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRzaGFkb3dNYXBUeXBlOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAudHlwZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBUeXBlIGlzIG5vdyAuc2hhZG93TWFwLnR5cGUuJyApO1xuXHRcdFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC5jdWxsRmFjZTtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XG5cdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0c2hhZG93TWFwRGVidWc6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC5kZWJ1Zztcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBEZWJ1ZyBpcyBub3cgLnNoYWRvd01hcC5kZWJ1Zy4nICk7XG5cdFx0XHR0aGlzLnNoYWRvd01hcC5kZWJ1ZyA9IHZhbHVlO1xuXHRcdH1cblx0fVxufSApO1xuXG4vL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG5cdHdyYXBTOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHR3cmFwVDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS53cmFwVCA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0bWFnRmlsdGVyOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUubWFnRmlsdGVyO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XG5cdFx0XHR0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRtaW5GaWx0ZXI6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdGFuaXNvdHJvcHk6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHk7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmFuaXNvdHJvcHkgPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdG9mZnNldDoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLm9mZnNldDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLm9mZnNldCA9IHZhbHVlO1xuXHRcdH1cblx0fSxcblx0cmVwZWF0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcblx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XG5cdFx0XHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XG5cdFx0fVxuXHR9LFxuXHRmb3JtYXQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xuXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcblx0XHRcdHRoaXMudGV4dHVyZS5mb3JtYXQgPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdHR5cGU6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLnR5cGU7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB2YWx1ZTtcblx0XHR9XG5cdH0sXG5cdGdlbmVyYXRlTWlwbWFwczoge1xuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xuXHRcdFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xuXHRcdH1cblx0fVxufSApO1xuXG4vL1xuXG5USFJFRS5HZW9tZXRyeVV0aWxzID0ge1xuXG5cdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5MSwgZ2VvbWV0cnkyLCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcblxuXHRcdHZhciBtYXRyaXg7XG5cblx0XHRpZiAoIGdlb21ldHJ5MiBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cblx0XHRcdGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuXHRcdFx0bWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcblx0XHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcblxuXHR9LFxuXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xuXHRcdHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkltYWdlVXRpbHMgPSB7XG5cblx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcblxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG5cdFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXG5cdH0sXG5cblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIHVybHMsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xuXHRcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG5cdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJscywgb25Mb2FkLCB1bmRlZmluZWQsIG9uRXJyb3IgKTtcblxuXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cblx0XHRyZXR1cm4gdGV4dHVyZTtcblxuXHR9LFxuXG5cdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nIClcblxuXHR9LFxuXG5cdGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG5cdH1cblxufTtcblxuLy9cblxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xuXG5cdHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xuXHRcdHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHR9O1xuXG5cdHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xuXHRcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG5cdH07XG5cblx0dGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xuXG5cdH07XG5cbn07XG5cbi8vXG5cblRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xuXG5cdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG59O1xuXG4vL1xuXG5USFJFRS5UZXh0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeSBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvZ2VvbWV0cmllcy9UZXh0R2VvbWV0cnkuanMnICk7XG5cdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Gb250VXRpbHMgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3V0aWxzL0ZvbnRVdGlscy5qcycgKTtcblxufTtcblxuLy9cblxuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCA9IFRIUkVFLk11bHRpTWF0ZXJpYWw7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9DdXJ2ZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLkN1cnZlVXRpbHMgPSB7XG5cblx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XG5cblx0fSxcblxuXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuXHR0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0XHRyZXR1cm4gLSAzICogcDAgKiAoIDEgLSB0ICkgKiAoIDEgLSB0ICkgICtcblx0XHRcdDMgKiBwMSAqICggMSAtIHQgKSAqICggMSAtIHQgKSAtIDYgKiB0ICogcDEgKiAoIDEgLSB0ICkgK1xuXHRcdFx0NiAqIHQgKiAgcDIgKiAoIDEgLSB0ICkgLSAzICogdCAqIHQgKiBwMiArXG5cdFx0XHQzICogdCAqIHQgKiBwMztcblxuXHR9LFxuXG5cdHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XG5cblx0XHQvLyBUbyBjaGVjayBpZiBteSBmb3JtdWxhcyBhcmUgY29ycmVjdFxuXG5cdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuXHRcdHZhciBoMTAgPSAzICogdCAqIHQgLSA0ICogdCArIDE7IC8vIHReMyDiiJIgMnReMiArIHRcblx0XHR2YXIgaDAxID0gLSA2ICogdCAqIHQgKyA2ICogdDsgXHQvLyDiiJIgMnQzICsgM3QyXG5cdFx0dmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMg4oiSIHQyXG5cblx0XHRyZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xuXG5cdH0sXG5cblx0Ly8gQ2F0bXVsbC1Sb21cblxuXHRpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xuXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XG5cdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cdFx0dmFyIHQyID0gdCAqIHQ7XG5cdFx0dmFyIHQzID0gdCAqIHQyO1xuXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL1NjZW5lVXRpbHMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNjZW5lVXRpbHMgPSB7XG5cblx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xuXG5cdFx0dmFyIGdyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Z3JvdXAuYWRkKCBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBncm91cDtcblxuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcblxuXHRcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xuXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcblxuXHR9LFxuXG5cdGF0dGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcblxuXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXHRcdG1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKTtcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XG5cblx0XHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcblxuXHR9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9TaGFwZVV0aWxzLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICovXG5cblRIUkVFLlNoYXBlVXRpbHMgPSB7XG5cblx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG5cdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcblxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cdFx0dmFyIGEgPSAwLjA7XG5cblx0XHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xuXG5cdFx0XHRhICs9IGNvbnRvdXJbIHAgXS54ICogY29udG91clsgcSBdLnkgLSBjb250b3VyWyBxIF0ueCAqIGNvbnRvdXJbIHAgXS55O1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGEgKiAwLjU7XG5cblx0fSxcblxuXHR0cmlhbmd1bGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xuXHRcdCAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXG5cdFx0ICogU2VlIG9yaWdpbmFsIGNvZGUgYW5kIG1vcmUgaW5mb3JtYXRpb24gaGVyZTpcblx0XHQgKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXG5cdFx0ICpcblx0XHQgKiBwb3J0ZWQgdG8gYWN0aW9uc2NyaXB0IGJ5IFpldmFuIFJvc3NlclxuXHRcdCAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxuXHRcdCAqXG5cdFx0ICogcG9ydGVkIHRvIGphdmFzY3JpcHQgYnkgSm9zaHVhIEtvb1xuXHRcdCAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcblx0XHQgKlxuXHRcdCAqL1xuXG5cdFx0ZnVuY3Rpb24gc25pcCggY29udG91ciwgdSwgdiwgdywgbiwgdmVydHMgKSB7XG5cblx0XHRcdHZhciBwO1xuXHRcdFx0dmFyIGF4LCBheSwgYngsIGJ5O1xuXHRcdFx0dmFyIGN4LCBjeSwgcHgsIHB5O1xuXG5cdFx0XHRheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xuXHRcdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuXHRcdFx0YnggPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueDtcblx0XHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XG5cblx0XHRcdGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG5cdFx0XHRjeSA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS55O1xuXG5cdFx0XHRpZiAoIE51bWJlci5FUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdHZhciBhWCwgYVksIGJYLCBiWSwgY1gsIGNZO1xuXHRcdFx0dmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG5cdFx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuXHRcdFx0YVggPSBjeCAtIGJ4OyAgYVkgPSBjeSAtIGJ5O1xuXHRcdFx0YlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xuXHRcdFx0Y1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xuXG5cdFx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHAgKysgKSB7XG5cblx0XHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueDtcblx0XHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuXHRcdFx0XHRpZiAoICggKCBweCA9PT0gYXggKSAmJiAoIHB5ID09PSBheSApICkgfHxcblx0XHRcdFx0XHQgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxuXHRcdFx0XHRcdCAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApIClcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdGFweCA9IHB4IC0gYXg7ICBhcHkgPSBweSAtIGF5O1xuXHRcdFx0XHRicHggPSBweCAtIGJ4OyAgYnB5ID0gcHkgLSBieTtcblx0XHRcdFx0Y3B4ID0gcHggLSBjeDsgIGNweSA9IHB5IC0gY3k7XG5cblx0XHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xuXG5cdFx0XHRcdGFDUk9TU2JwID0gYVggKiBicHkgLSBhWSAqIGJweDtcblx0XHRcdFx0Y0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xuXHRcdFx0XHRiQ1JPU1NjcCA9IGJYICogY3B5IC0gYlkgKiBjcHg7XG5cblx0XHRcdFx0aWYgKCAoIGFDUk9TU2JwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGJDUk9TU2NwID49IC0gTnVtYmVyLkVQU0lMT04gKSAmJiAoIGNDUk9TU2FwID49IC0gTnVtYmVyLkVQU0lMT04gKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cblx0XHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XG5cblx0XHRcdGlmICggbiA8IDMgKSByZXR1cm4gbnVsbDtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHR2ZXJ0cyA9IFtdLFxuXHRcdFx0XHR2ZXJ0SW5kaWNlcyA9IFtdO1xuXG5cdFx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG5cdFx0XHR2YXIgdSwgdiwgdztcblxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZVV0aWxzLmFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcblxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gdjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbnYgPSBuO1xuXG5cdFx0XHQvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXG5cblx0XHRcdHZhciBjb3VudCA9IDIgKiBudjsgICAvKiBlcnJvciBkZXRlY3Rpb24gKi9cblxuXHRcdFx0Zm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcblxuXHRcdFx0XHQvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xuXG5cdFx0XHRcdGlmICggKCBjb3VudCAtLSApIDw9IDAgKSB7XG5cblx0XHRcdFx0XHQvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxuXG5cdFx0XHRcdFx0Ly90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcblx0XHRcdFx0XHQvL3JldHVybiBudWxsO1xuXHRcdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlVXRpbHM6IFVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uISBpbiB0cmlhbmd1bGF0ZSgpJyApO1xuXG5cdFx0XHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIHRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PiAqL1xuXG5cdFx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cblx0XHRcdFx0diA9IHUgKyAxOyAgaWYgKCBudiA8PSB2ICkgdiA9IDA7ICAgICAvKiBuZXcgdiAgICAqL1xuXHRcdFx0XHR3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXG5cblx0XHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuXHRcdFx0XHRcdHZhciBhLCBiLCBjLCBzLCB0O1xuXG5cdFx0XHRcdFx0LyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cblxuXHRcdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xuXHRcdFx0XHRcdGIgPSB2ZXJ0c1sgdiBdO1xuXHRcdFx0XHRcdGMgPSB2ZXJ0c1sgdyBdO1xuXG5cdFx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXG5cblx0XHRcdFx0XHRyZXN1bHQucHVzaCggWyBjb250b3VyWyBhIF0sXG5cdFx0XHRcdFx0XHRjb250b3VyWyBiIF0sXG5cdFx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xuXG5cblx0XHRcdFx0XHR2ZXJ0SW5kaWNlcy5wdXNoKCBbIHZlcnRzWyB1IF0sIHZlcnRzWyB2IF0sIHZlcnRzWyB3IF0gXSApO1xuXG5cdFx0XHRcdFx0LyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cblxuXHRcdFx0XHRcdGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcyArKywgdCArKyApIHtcblxuXHRcdFx0XHRcdFx0dmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRudiAtLTtcblxuXHRcdFx0XHRcdC8qIHJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyICovXG5cblx0XHRcdFx0XHRjb3VudCA9IDIgKiBudjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuXHRcdH1cblxuXHR9ICkoKSxcblxuXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xuXG5cdFx0ZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XG5cblx0XHRcdC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xsaW5lYXIgdG8gdGhlIGluU2VnbWVudFxuXHRcdFx0aWYgKCBpblNlZ1B0MS54ICE9PSBpblNlZ1B0Mi54ICkge1xuXG5cdFx0XHRcdGlmICggaW5TZWdQdDEueCA8IGluU2VnUHQyLnggKSB7XG5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS54IDw9IGluT3RoZXJQdC54ICkgJiYgKCBpbk90aGVyUHQueCA8PSBpblNlZ1B0Mi54ICkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XG5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBpblNlZ1B0MS55IDw9IGluT3RoZXJQdC55ICkgJiYgKCBpbk90aGVyUHQueSA8PSBpblNlZ1B0Mi55ICkgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDIueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDEueSApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuXG5cdFx0XHR2YXIgc2VnMWR4ID0gaW5TZWcxUHQyLnggLSBpblNlZzFQdDEueCwgICBzZWcxZHkgPSBpblNlZzFQdDIueSAtIGluU2VnMVB0MS55O1xuXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcblxuXHRcdFx0dmFyIHNlZzFzZWcyZHggPSBpblNlZzFQdDEueCAtIGluU2VnMlB0MS54O1xuXHRcdFx0dmFyIHNlZzFzZWcyZHkgPSBpblNlZzFQdDEueSAtIGluU2VnMlB0MS55O1xuXG5cdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG5cdFx0XHR2YXIgcGVycFNlZzFcdD0gc2VnMWR5ICogc2VnMXNlZzJkeCAtIHNlZzFkeCAqIHNlZzFzZWcyZHk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIGxpbWl0ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHQvLyBub3QgcGFyYWxsZWxcblxuXHRcdFx0XHR2YXIgcGVycFNlZzI7XG5cdFx0XHRcdGlmICggbGltaXQgPiAwICkge1xuXG5cdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxIDwgMCApIHx8ICggcGVycFNlZzEgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMiA8IDAgKSB8fCAoIHBlcnBTZWcyID4gbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggKCBwZXJwU2VnMSA+IDAgKSB8fCAoIHBlcnBTZWcxIDwgbGltaXQgKSApIFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcblx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpLmUuIHRvIHJlZHVjZSByb3VuZGluZyBlcnJvcnNcblx0XHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMT9cblx0XHRcdFx0aWYgKCBwZXJwU2VnMiA9PT0gMCApIHtcblxuXHRcdFx0XHRcdGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG5cdFx0XHRcdFx0XHQgKCAoIHBlcnBTZWcxID09PSAwICkgfHwgKCBwZXJwU2VnMSA9PT0gbGltaXQgKSApIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MiBdO1xuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMj9cblx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PT0gMCApXHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xuXHRcdFx0XHRpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApXHRyZXR1cm4gWyBpblNlZzJQdDIgXTtcblxuXHRcdFx0XHQvLyByZXR1cm4gcmVhbCBpbnRlcnNlY3Rpb24gcG9pbnRcblx0XHRcdFx0dmFyIGZhY3RvclNlZzEgPSBwZXJwU2VnMiAvIGxpbWl0O1xuXHRcdFx0XHRyZXR1cm5cdFsgeyB4OiBpblNlZzFQdDEueCArIGZhY3RvclNlZzEgKiBzZWcxZHgsXG5cdFx0XHRcdFx0XHRcdHk6IGluU2VnMVB0MS55ICsgZmFjdG9yU2VnMSAqIHNlZzFkeSB9IF07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG5cdFx0XHRcdGlmICggKCBwZXJwU2VnMSAhPT0gMCApIHx8XG5cdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xuXG5cdFx0XHRcdC8vIHRoZXkgYXJlIGNvbGxpbmVhciBvciBkZWdlbmVyYXRlXG5cdFx0XHRcdHZhciBzZWcxUHQgPSAoICggc2VnMWR4ID09PSAwICkgJiYgKCBzZWcxZHkgPT09IDAgKSApO1x0Ly8gc2VnbWVudDEgaXMganVzdCBhIHBvaW50P1xuXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoIHNlZzJkeCA9PT0gMCApICYmICggc2VnMmR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQyIGlzIGp1c3QgYSBwb2ludD9cblx0XHRcdFx0Ly8gYm90aCBzZWdtZW50cyBhcmUgcG9pbnRzXG5cdFx0XHRcdGlmICggc2VnMVB0ICYmIHNlZzJQdCApIHtcblxuXHRcdFx0XHRcdGlmICggKCBpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLnggKSB8fFxuXHRcdFx0XHRcdFx0ICggaW5TZWcxUHQxLnkgIT09IGluU2VnMlB0MS55ICkgKVx0XHRyZXR1cm4gW107XHQvLyB0aGV5IGFyZSBkaXN0aW5jdCAgcG9pbnRzXG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07ICAgICAgICAgICAgICAgICBcdFx0XHRcdFx0XHQvLyB0aGV5IGFyZSB0aGUgc2FtZSBwb2ludFxuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc2VnbWVudCMxICBpcyBhIHNpbmdsZSBwb2ludFxuXHRcdFx0XHRpZiAoIHNlZzFQdCApIHtcblxuXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5TZWcxUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMyXG5cdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZWdtZW50IzIgIGlzIGEgc2luZ2xlIHBvaW50XG5cdFx0XHRcdGlmICggc2VnMlB0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCAhIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEgKSApXHRcdHJldHVybiBbXTtcdFx0Ly8gYnV0IG5vdCBpbiBzZWdtZW50IzFcblx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdGhleSBhcmUgY29sbGluZWFyIHNlZ21lbnRzLCB3aGljaCBtaWdodCBvdmVybGFwXG5cdFx0XHRcdHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuXHRcdFx0XHR2YXIgc2VnMm1pbiwgc2VnMm1heCwgc2VnMm1pblZhbCwgc2VnMm1heFZhbDtcblx0XHRcdFx0aWYgKCBzZWcxZHggIT09IDAgKSB7XG5cblx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcblx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XG5cblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueDtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueDtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS54IDwgaW5TZWcyUHQyLnggKSB7XG5cblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueDtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueDtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcblx0XHRcdFx0XHRpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XG5cblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcblx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG5cblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueTtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDI7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDIueTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueTtcblx0XHRcdFx0XHRcdHNlZzJtYXggPSBpblNlZzJQdDE7IHNlZzJtYXhWYWwgPSBpblNlZzJQdDEueTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xuXG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDwgIHNlZzJtaW5WYWwgKVx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApXHR7XG5cblx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzJtaW4sIHNlZzFtYXggXTtcblx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMm1pbiwgc2VnMm1heCBdO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZiAoIHNlZzFtaW5WYWwgPiAgc2VnMm1heFZhbCApXHRyZXR1cm4gW107XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsIClcdHtcblxuXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBzZWcxbWluIF07XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuXHRcdFx0XHRcdHJldHVyblx0WyBzZWcxbWluLCBzZWcybWF4IF07XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XG5cblx0XHRcdC8vIFRoZSBvcmRlciBvZiBsZWdzIGlzIGltcG9ydGFudFxuXG5cdFx0XHQvLyB0cmFuc2xhdGlvbiBvZiBhbGwgcG9pbnRzLCBzbyB0aGF0IFZlcnRleCBpcyBhdCAoMCwwKVxuXHRcdFx0dmFyIGxlZ0Zyb21QdFhcdD0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsICBsZWdGcm9tUHRZXHQ9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuXHRcdFx0dmFyIGxlZ1RvUHRYXHQ9IGluTGVnVG9QdC54XHQtIGluVmVydGV4LngsICBsZWdUb1B0WVx0XHQ9IGluTGVnVG9QdC55XHQtIGluVmVydGV4Lnk7XG5cdFx0XHR2YXIgb3RoZXJQdFhcdD0gaW5PdGhlclB0LnhcdC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZXHRcdD0gaW5PdGhlclB0LnlcdC0gaW5WZXJ0ZXgueTtcblxuXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG5cdFx0XHR2YXIgZnJvbTJ0b0FuZ2xlXHQ9IGxlZ0Zyb21QdFggKiBsZWdUb1B0WSAtIGxlZ0Zyb21QdFkgKiBsZWdUb1B0WDtcblx0XHRcdHZhciBmcm9tMm90aGVyQW5nbGVcdD0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xuXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBmcm9tMnRvQW5nbGUgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdC8vIGFuZ2xlICE9IDE4MCBkZWcuXG5cblx0XHRcdFx0dmFyIG90aGVyMnRvQW5nbGVcdFx0PSBvdGhlclB0WCAqIGxlZ1RvUHRZIC0gb3RoZXJQdFkgKiBsZWdUb1B0WDtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG5cdFx0XHRcdGlmICggZnJvbTJ0b0FuZ2xlID4gMCApIHtcblxuXHRcdFx0XHRcdC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cblx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gYW5nbGUgPT0gMTgwIGRlZy5cblx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogMTgwIGRlZy4sIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICApO1xuXHRcdFx0XHRyZXR1cm5cdCggZnJvbTJvdGhlckFuZ2xlID4gMCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG5cdFx0XHR2YXIgaG9sZTtcblxuXHRcdFx0ZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcblx0XHRcdFx0dmFyIGxhc3RTaGFwZUlkeCA9IHNoYXBlLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0dmFyIHByZXZTaGFwZUlkeCA9IGluU2hhcGVJZHggLSAxO1xuXHRcdFx0XHRpZiAoIHByZXZTaGFwZUlkeCA8IDAgKVx0XHRcdHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcblxuXHRcdFx0XHR2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XG5cdFx0XHRcdGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4IClcdG5leHRTaGFwZUlkeCA9IDA7XG5cblx0XHRcdFx0dmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVsgaW5TaGFwZUlkeCBdLCBzaGFwZVsgcHJldlNoYXBlSWR4IF0sIHNoYXBlWyBuZXh0U2hhcGVJZHggXSwgaG9sZVsgaW5Ib2xlSWR4IF0gKTtcblx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChTaGFwZSk6IFwiICsgaW5TaGFwZUlkeCArIFwiLCBQb2ludDogXCIgKyBob2xlW2luSG9sZUlkeF0ueCArIFwiL1wiICsgaG9sZVtpbkhvbGVJZHhdLnkgKTtcblx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxuXHRcdFx0XHR2YXIgbGFzdEhvbGVJZHggPSBob2xlLmxlbmd0aCAtIDE7XG5cblx0XHRcdFx0dmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcblx0XHRcdFx0aWYgKCBwcmV2SG9sZUlkeCA8IDAgKVx0XHRcdHByZXZIb2xlSWR4ID0gbGFzdEhvbGVJZHg7XG5cblx0XHRcdFx0dmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcblx0XHRcdFx0aWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4IClcdG5leHRIb2xlSWR4ID0gMDtcblxuXHRcdFx0XHRpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVsgaW5Ib2xlSWR4IF0sIGhvbGVbIHByZXZIb2xlSWR4IF0sIGhvbGVbIG5leHRIb2xlSWR4IF0sIHNoYXBlWyBpblNoYXBlSWR4IF0gKTtcblx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiVmVydGV4IChIb2xlKTogXCIgKyBpbkhvbGVJZHggKyBcIiwgUG9pbnQ6IFwiICsgc2hhcGVbaW5TaGFwZUlkeF0ueCArIFwiL1wiICsgc2hhcGVbaW5TaGFwZUlkeF0ueSApO1xuXHRcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVyblx0dHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG5cdFx0XHRcdC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIHNoYXBlIGVkZ2VzXG5cdFx0XHRcdHZhciBzSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGZvciAoIHNJZHggPSAwOyBzSWR4IDwgc2hhcGUubGVuZ3RoOyBzSWR4ICsrICkge1xuXG5cdFx0XHRcdFx0bmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcblx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIHNoYXBlWyBzSWR4IF0sIHNoYXBlWyBuZXh0SWR4IF0sIHRydWUgKTtcblx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpbmRlcEhvbGVzID0gW107XG5cblx0XHRcdGZ1bmN0aW9uIGludGVyc2VjdHNIb2xlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcblxuXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXG5cdFx0XHRcdHZhciBpaElkeCwgY2hrSG9sZSxcblx0XHRcdFx0XHRoSWR4LCBuZXh0SWR4LCBpbnRlcnNlY3Rpb247XG5cdFx0XHRcdGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHggKysgKSB7XG5cblx0XHRcdFx0XHRjaGtIb2xlID0gaG9sZXNbIGluZGVwSG9sZXNbIGloSWR4IF1dO1xuXHRcdFx0XHRcdGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHggKysgKSB7XG5cblx0XHRcdFx0XHRcdG5leHRJZHggPSBoSWR4ICsgMTsgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcblx0XHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgY2hrSG9sZVsgaElkeCBdLCBjaGtIb2xlWyBuZXh0SWR4IF0sIHRydWUgKTtcblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKVx0XHRyZXR1cm5cdHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG5cdFx0XHRcdHNoYXBlUHQsIGhvbGVQdCxcblx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG5cdFx0XHRcdHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuXHRcdFx0XHR0bXBIb2xlMSwgdG1wSG9sZTI7XG5cblx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0XHRpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWluU2hhcGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcblx0XHRcdHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGNvdW50ZXIgLS07XG5cdFx0XHRcdGlmICggY291bnRlciA8IDAgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggXCJJbmZpbml0ZSBMb29wISBIb2xlcyBsZWZ0OlwiICsgaW5kZXBIb2xlcy5sZW5ndGggKyBcIiwgUHJvYmFibHkgSG9sZSBvdXRzaWRlIFNoYXBlIVwiICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcblx0XHRcdFx0Ly8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcblx0XHRcdFx0Zm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cblx0XHRcdFx0XHRzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcblx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xuXG5cdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBob2xlIHdoaWNoIGNhbiBiZSByZWFjaGVkIHdpdGhvdXQgaW50ZXJzZWN0aW9uc1xuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGluZGVwSG9sZXMubGVuZ3RoOyBoICsrICkge1xuXG5cdFx0XHRcdFx0XHRob2xlSWR4ID0gaW5kZXBIb2xlc1sgaCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG11bHRpcGxlIGNoZWNrc1xuXHRcdFx0XHRcdFx0Y3V0S2V5ID0gc2hhcGVQdC54ICsgXCI6XCIgKyBzaGFwZVB0LnkgKyBcIjpcIiArIGhvbGVJZHg7XG5cdFx0XHRcdFx0XHRpZiAoIGZhaWxlZEN1dHNbIGN1dEtleSBdICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHRcdFx0XHRob2xlID0gaG9sZXNbIGhvbGVJZHggXTtcblx0XHRcdFx0XHRcdGZvciAoIHZhciBoMiA9IDA7IGgyIDwgaG9sZS5sZW5ndGg7IGgyICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGhvbGVQdCA9IGhvbGVbIGgyIF07XG5cdFx0XHRcdFx0XHRcdGlmICggISBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIHNoYXBlSW5kZXgsIGgyICkgKVx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3RzU2hhcGVFZGdlKCBzaGFwZVB0LCBob2xlUHQgKSApXHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNIb2xlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRcdFx0XHRob2xlSW5kZXggPSBoMjtcblx0XHRcdFx0XHRcdFx0aW5kZXBIb2xlcy5zcGxpY2UoIGgsIDEgKTtcblxuXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcblx0XHRcdFx0XHRcdFx0dG1wU2hhcGUyID0gc2hhcGUuc2xpY2UoIHNoYXBlSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTEgPSBob2xlLnNsaWNlKCBob2xlSW5kZXggKTtcblx0XHRcdFx0XHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XG5cblx0XHRcdFx0XHRcdFx0c2hhcGUgPSB0bXBTaGFwZTEuY29uY2F0KCB0bXBIb2xlMSApLmNvbmNhdCggdG1wSG9sZTIgKS5jb25jYXQoIHRtcFNoYXBlMiApO1xuXG5cdFx0XHRcdFx0XHRcdG1pblNoYXBlSW5kZXggPSBzaGFwZUluZGV4O1xuXG5cdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcblx0XHRcdFx0XHRcdFx0Ly8gZ2xvYl9DdXRMaW5lcy5wdXNoKCBbIHNoYXBlUHQsIGhvbGVQdCBdICk7XG5cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cblx0XHRcdFx0XHRcdGZhaWxlZEN1dHNbIGN1dEtleSBdID0gdHJ1ZTtcdFx0XHQvLyByZW1lbWJlciBmYWlsdXJlXG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBob2xlSW5kZXggPj0gMCApXHRicmVhaztcdFx0Ly8gaG9sZS12ZXJ0ZXggZm91bmRcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNoYXBlOyBcdFx0XHQvKiBzaGFwZSB3aXRoIG5vIGhvbGVzICovXG5cblx0XHR9XG5cblxuXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcblx0XHRcdGtleSwgaW5kZXgsXG5cdFx0XHRhbGxQb2ludHNNYXAgPSB7fTtcblxuXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuXHRcdHZhciBhbGxwb2ludHMgPSBjb250b3VyLmNvbmNhdCgpO1xuXG5cdFx0Zm9yICggdmFyIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XG5cblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xuXG5cdFx0Ly8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xuXG5cdFx0XHRpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcblxuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcblx0XHR2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcblxuXHRcdHZhciB0cmlhbmdsZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlKCBzaGFwZVdpdGhvdXRIb2xlcywgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJ0cmlhbmdsZXNcIix0cmlhbmdsZXMsIHRyaWFuZ2xlcy5sZW5ndGggKTtcblxuXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcblxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0ZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xuXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XG5cblx0XHRcdFx0a2V5ID0gZmFjZVsgZiBdLnggKyBcIjpcIiArIGZhY2VbIGYgXS55O1xuXG5cdFx0XHRcdGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcblxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRmYWNlWyBmIF0gPSBpbmRleDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cmlhbmdsZXMuY29uY2F0KCk7XG5cblx0fSxcblxuXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XG5cblx0XHRyZXR1cm4gVEhSRUUuU2hhcGVVdGlscy5hcmVhKCBwdHMgKSA8IDA7XG5cblx0fSxcblxuXHQvLyBCZXppZXIgQ3VydmVzIGZvcm11bGFzIG9idGFpbmVkIGZyb21cblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxuXG5cdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG5cdGIyOiAoIGZ1bmN0aW9uICgpIHtcblxuXHRcdGZ1bmN0aW9uIGIycDAoIHQsIHAgKSB7XG5cblx0XHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0XHRyZXR1cm4gayAqIGsgKiBwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYjJwMSggdCwgcCApIHtcblxuXHRcdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGIycDIoIHQsIHAgKSB7XG5cblx0XHRcdHJldHVybiB0ICogdCAqIHA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG5cdFx0XHRyZXR1cm4gYjJwMCggdCwgcDAgKSArIGIycDEoIHQsIHAxICkgKyBiMnAyKCB0LCBwMiApO1xuXG5cdFx0fTtcblxuXHR9ICkoKSxcblxuXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cblx0YjM6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0ZnVuY3Rpb24gYjNwMCggdCwgcCApIHtcblxuXHRcdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRcdHJldHVybiBrICogayAqIGsgKiBwO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcblxuXHRcdFx0dmFyIGsgPSAxIC0gdDtcblx0XHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGIzcDIoIHQsIHAgKSB7XG5cblx0XHRcdHZhciBrID0gMSAtIHQ7XG5cdFx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBiM3AzKCB0LCBwICkge1xuXG5cdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG5cdFx0XHRyZXR1cm4gYjNwMCggdCwgcDAgKSArIGIzcDEoIHQsIHAxICkgKyBiM3AyKCB0LCBwMiApICsgYjNwMyggdCwgcDMgKTtcblxuXHRcdH07XG5cblx0fSApKClcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxuICpcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxuICogLmdldFBvaW50QXQodSksIGdldFRhZ2VudEF0KHUpXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxuICpcbiAqIC0tIDJkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gKlxuICogLS0gM2QgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuU3BsaW5lQ3VydmUzXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcbiAqXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUgPSB7XG5cblx0Y29uc3RydWN0b3I6IFRIUkVFLkN1cnZlLFxuXG5cdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xuXHQvL1x0LSB0IFswIC4uIDFdXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9LFxuXG5cdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuXHQvLyAtIHUgWzAgLi4gMV1cblxuXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG5cdH0sXG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXG5cblx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG5cdFx0dmFyIGQsIHB0cyA9IFtdO1xuXG5cdFx0Zm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG5cdFx0XHRwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcHRzO1xuXG5cdH0sXG5cblx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcblxuXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9IDU7XG5cblx0XHR2YXIgZCwgcHRzID0gW107XG5cblx0XHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cblx0XHRcdHB0cy5wdXNoKCB0aGlzLmdldFBvaW50QXQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHB0cztcblxuXHR9LFxuXG5cdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgbGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcblxuXHR9LFxuXG5cdC8vIEdldCBsaXN0IG9mIGN1bXVsYXRpdmUgc2VnbWVudCBsZW5ndGhzXG5cblx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cblx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgPyAoIHRoaXMuX19hcmNMZW5ndGhEaXZpc2lvbnMgKSA6IDIwMDtcblxuXHRcdGlmICggdGhpcy5jYWNoZUFyY0xlbmd0aHNcblx0XHRcdCYmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxIClcblx0XHRcdCYmICEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0Ly9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcblx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuXHRcdH1cblxuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdHZhciBjYWNoZSA9IFtdO1xuXHRcdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuXHRcdHZhciBwLCBzdW0gPSAwO1xuXG5cdFx0Y2FjaGUucHVzaCggMCApO1xuXG5cdFx0Zm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG5cdFx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCAoIHAgLyBkaXZpc2lvbnMgKTtcblx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcblx0XHRcdGNhY2hlLnB1c2goIHN1bSApO1xuXHRcdFx0bGFzdCA9IGN1cnJlbnQ7XG5cblx0XHR9XG5cblx0XHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG5cdFx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxuXG5cdH0sXG5cblx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24oKSB7XG5cblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLmdldExlbmd0aHMoKTtcblxuXHR9LFxuXG5cdC8vIEdpdmVuIHUgKCAwIC4uIDEgKSwgZ2V0IGEgdCB0byBmaW5kIHAuIFRoaXMgZ2l2ZXMgeW91IHBvaW50cyB3aGljaCBhcmUgZXF1aWRpc3RhbnRcblxuXHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcblxuXHRcdHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG5cblx0XHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XG5cblx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuXHRcdGlmICggZGlzdGFuY2UgKSB7XG5cblx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gdSAqIGFyY0xlbmd0aHNbIGlsIC0gMSBdO1xuXG5cdFx0fVxuXG5cdFx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XG5cblx0XHQvLyBiaW5hcnkgc2VhcmNoIGZvciB0aGUgaW5kZXggd2l0aCBsYXJnZXN0IHZhbHVlIHNtYWxsZXIgdGhhbiB0YXJnZXQgdSBkaXN0YW5jZVxuXG5cdFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XG5cblx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG5cdFx0XHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcblxuXHRcdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcblxuXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuXHRcdFx0XHRsb3cgPSBpICsgMTtcblxuXHRcdFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XG5cblx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGhpZ2ggPSBpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBET05FXG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGkgPSBoaWdoO1xuXG5cdFx0Ly9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xuXG5cdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuXHRcdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcblx0XHRcdHJldHVybiB0O1xuXG5cdFx0fVxuXG5cdFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuXHRcdHZhciBsZW5ndGhCZWZvcmUgPSBhcmNMZW5ndGhzWyBpIF07XG5cdFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcblxuXHRcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cblx0XHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG5cdFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG5cdFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxuXG5cdFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XG5cblx0XHRyZXR1cm4gdDtcblxuXHR9LFxuXG5cdC8vIFJldHVybnMgYSB1bml0IHZlY3RvciB0YW5nZW50IGF0IHRcblx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxuXHQvLyB3aGljaCBzZWVtcyB0byBnaXZlIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uXG5cblx0Z2V0VGFuZ2VudDogZnVuY3Rpb24oIHQgKSB7XG5cblx0XHR2YXIgZGVsdGEgPSAwLjAwMDE7XG5cdFx0dmFyIHQxID0gdCAtIGRlbHRhO1xuXHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcblxuXHRcdC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuXHRcdGlmICggdDEgPCAwICkgdDEgPSAwO1xuXHRcdGlmICggdDIgPiAxICkgdDIgPSAxO1xuXG5cdFx0dmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XG5cdFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XG5cblx0XHR2YXIgdmVjID0gcHQyLmNsb25lKCkuc3ViKCBwdDEgKTtcblx0XHRyZXR1cm4gdmVjLm5vcm1hbGl6ZSgpO1xuXG5cdH0sXG5cblx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cblx0XHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cblx0fVxuXG59XG5cblRIUkVFLkN1cnZlLlV0aWxzID0gVEhSRUUuQ3VydmVVdGlsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuLy8gVE9ETzogVHJhbnNmb3JtYXRpb24gZm9yIEN1cnZlcz9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0M0QgQ3VydmVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vIEEgRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBjdXJ2ZSBzdWJjbGFzc2VzXG5cblRIUkVFLkN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcblxuXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jb3JlL0N1cnZlUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmN1cnZlcyA9IFtdO1xuXG5cdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdXJ2ZVBhdGg7XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jaGVja0Nvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0Ly8gVE9ET1xuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXG5cdC8vIG9yIHRoZSBuZXh0IGN1cnZlLCB0aGVuLCB0aGlzIGlzIG5vdCBhIHJlYWwgcGF0aFxufTtcbiovXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gVE9ETyBUZXN0XG5cdC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXG5cdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxuXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcblx0dmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbIHRoaXMuY3VydmVzLmxlbmd0aCAtIDEgXS5nZXRQb2ludCggMSApO1xuXG5cdGlmICggISBzdGFydFBvaW50LmVxdWFscyggZW5kUG9pbnQgKSApIHtcblxuXHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcblxuXHR9XG5cbn07XG5cbi8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xuLy8gZW50aXJlIHBhdGggZGlzdGFuY2UgYXQgdGltZSB0LFxuLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxuXG4vLyAxLiBMZW5ndGggb2YgZWFjaCBzdWIgcGF0aCBoYXZlIHRvIGJlIGtub3duXG4vLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcbi8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcbi8vIDQuIFJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KHQnKVxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cblx0dmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcblx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XG5cdHZhciBpID0gMDtcblxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cblxuXHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xuXG5cdFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xuXG5cdFx0XHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cblx0XHRcdHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuXHRcdFx0cmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdH1cblxuXHRcdGkgKys7XG5cblx0fVxuXG5cdHJldHVybiBudWxsO1xuXG5cdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59O1xuKi9cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cblx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuXHRyZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuXHQvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cblx0aWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcblxuXHRcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuXHR9XG5cblx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcblx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XG5cblx0dmFyIGxlbmd0aHMgPSBbXSwgc3VtcyA9IDA7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcblx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcblxuXHR9XG5cblx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xuXG5cdHJldHVybiBsZW5ndGhzO1xuXG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUG9pbnRzIG9iamVjdHMpXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xuXG5cdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxufTtcblxuLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xuXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XG5cdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XG5cblx0fVxuXG5cdHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvUGF0aC5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxuICpcbiAqKi9cblxuVEhSRUUuUGF0aCA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG5cdFRIUkVFLkN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5hY3Rpb25zID0gW107XG5cblx0aWYgKCBwb2ludHMgKSB7XG5cblx0XHR0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG5cdH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5USFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XG5cbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuXHR0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cblx0Zm9yICggdmFyIGkgPSAxLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIGkgXS54LCB2ZWN0b3JzWyBpIF0ueSApO1xuXG5cdH1cblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAnbW92ZVRvJywgYXJnczogWyB4LCB5IF0gfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdsaW5lVG8nLCBhcmdzOiBbIHgsIHkgXSB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKVxuXHQpO1xuXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiAncXVhZHJhdGljQ3VydmVUbycsIGFyZ3M6IFsgYUNQeCwgYUNQeSwgYVgsIGFZIF0gfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZShcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuXHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYVgsIGFZIClcblx0KTtcblxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogJ2JlemllckN1cnZlVG8nLCBhcmdzOiBbIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgXSB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnNwbGluZVRocnUgPSBmdW5jdGlvbiggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XG5cblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuXHR2YXIgbnB0cyA9IFsgbmV3IFRIUkVFLlZlY3RvcjIoIHgwLCB5MCApIF07XG5cdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBucHRzLCBwdHMgKTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuU3BsaW5lQ3VydmUoIG5wdHMgKTtcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdzcGxpbmVUaHJ1JywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cbi8vIEZVVFVSRTogQ2hhbmdlIHRoZSBBUEkgb3IgZm9sbG93IGNhbnZhcyBBUEk/XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmFyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG5cdHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuXHRcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuIH07XG5cbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuXHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gfTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cblx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcblxuIH07XG5cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0dmFyIGFyZ3MgPSBbXG5cdFx0YVgsIGFZLFxuXHRcdHhSYWRpdXMsIHlSYWRpdXMsXG5cdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSxcblx0XHRhQ2xvY2t3aXNlLFxuXHRcdGFSb3RhdGlvbiB8fCAwIC8vIGFSb3RhdGlvbiBpcyBvcHRpb25hbC5cblx0XTtcblxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG5cdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xuXHRhcmdzLnB1c2goIGxhc3RQb2ludC54ICk7XG5cdGFyZ3MucHVzaCggbGFzdFBvaW50LnkgKTtcblxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246ICdlbGxpcHNlJywgYXJnczogYXJncyB9ICk7XG5cbiB9O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XG5cblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IGRpdmlzaW9uczsgaSArKyApIHtcblxuXHRcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKTtcblxuXHRcdC8vaWYgKCAhdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICkgdGhyb3cgXCJESUVcIjtcblxuXHR9XG5cblx0aWYgKCB0aGlzLmF1dG9DbG9zZSApIHtcblxuXHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG5cdH1cblxuXHRyZXR1cm4gcG9pbnRzO1xuXG59O1xuXG4vKiBSZXR1cm4gYW4gYXJyYXkgb2YgdmVjdG9ycyBiYXNlZCBvbiBjb250b3VyIG9mIHRoZSBwYXRoICovXG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cblx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEyO1xuXG5cdHZhciBiMiA9IFRIUkVFLlNoYXBlVXRpbHMuYjI7XG5cdHZhciBiMyA9IFRIUkVFLlNoYXBlVXRpbHMuYjM7XG5cblx0dmFyIHBvaW50cyA9IFtdO1xuXG5cdHZhciBjcHgsIGNweSwgY3B4MiwgY3B5MiwgY3B4MSwgY3B5MSwgY3B4MCwgY3B5MCxcblx0XHRsYXN0ZSwgdHgsIHR5O1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuYWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcblxuXHRcdHZhciBhY3Rpb24gPSBpdGVtLmFjdGlvbjtcblx0XHR2YXIgYXJncyA9IGl0ZW0uYXJncztcblxuXHRcdHN3aXRjaCAoIGFjdGlvbiApIHtcblxuXHRcdGNhc2UgJ21vdmVUbyc6XG5cblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2xpbmVUbyc6XG5cblx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggYXJnc1sgMCBdLCBhcmdzWyAxIF0gKSApO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ3F1YWRyYXRpY0N1cnZlVG8nOlxuXG5cdFx0XHRjcHggID0gYXJnc1sgMiBdO1xuXHRcdFx0Y3B5ICA9IGFyZ3NbIDMgXTtcblxuXHRcdFx0Y3B4MSA9IGFyZ3NbIDAgXTtcblx0XHRcdGNweTEgPSBhcmdzWyAxIF07XG5cblx0XHRcdGlmICggcG9pbnRzLmxlbmd0aCA+IDAgKSB7XG5cblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XG5cdFx0XHRcdGNweTAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMSBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIHQgPSBqIC8gZGl2aXNpb25zO1xuXG5cdFx0XHRcdHR4ID0gYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xuXHRcdFx0XHR0eSA9IGIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdiZXppZXJDdXJ2ZVRvJzpcblxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDQgXTtcblx0XHRcdGNweSAgPSBhcmdzWyA1IF07XG5cblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XG5cdFx0XHRjcHkxID0gYXJnc1sgMSBdO1xuXG5cdFx0XHRjcHgyID0gYXJnc1sgMiBdO1xuXHRcdFx0Y3B5MiA9IGFyZ3NbIDMgXTtcblxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcblxuXHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcblxuXHRcdFx0XHRjcHgwID0gbGFzdGUueDtcblx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcblxuXHRcdFx0XHRjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcblx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XG5cblx0XHRcdH1cblxuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB0ID0gaiAvIGRpdmlzaW9ucztcblxuXHRcdFx0XHR0eCA9IGIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcblx0XHRcdFx0dHkgPSBiMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnc3BsaW5lVGhydSc6XG5cblx0XHRcdGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cblx0XHRcdHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcblx0XHRcdHZhciBzcHRzID0gWyBsYXN0IF07XG5cblx0XHRcdHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcblxuXHRcdFx0c3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcblxuXHRcdFx0dmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gbjsgaiArKyApIHtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggc3BsaW5lLmdldFBvaW50QXQoIGogLyBuICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2FyYyc6XG5cblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXG5cdFx0XHRcdGFSYWRpdXMgPSBhcmdzWyAyIF0sXG5cdFx0XHRcdGFTdGFydEFuZ2xlID0gYXJnc1sgMyBdLCBhRW5kQW5nbGUgPSBhcmdzWyA0IF0sXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhISBhcmdzWyA1IF07XG5cblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG5cdFx0XHR2YXIgYW5nbGU7XG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG5cdFx0XHRcdHZhciB0ID0gaiAvIHRkaXZpc2lvbnM7XG5cblx0XHRcdFx0aWYgKCAhIGFDbG9ja3dpc2UgKSB7XG5cblx0XHRcdFx0XHR0ID0gMSAtIHQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFuZ2xlID0gYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcblxuXHRcdFx0XHR0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHRcdFx0XHR0eSA9IGFZICsgYVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcblxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgJ2VsbGlwc2UnOlxuXG5cdFx0XHR2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuXHRcdFx0XHR4UmFkaXVzID0gYXJnc1sgMiBdLFxuXHRcdFx0XHR5UmFkaXVzID0gYXJnc1sgMyBdLFxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISEgYXJnc1sgNiBdLFxuXHRcdFx0XHRhUm90YXRpb24gPSBhcmdzWyA3IF07XG5cblxuXHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcblx0XHRcdHZhciBhbmdsZTtcblx0XHRcdHZhciB0ZGl2aXNpb25zID0gZGl2aXNpb25zICogMjtcblxuXHRcdFx0dmFyIGNvcywgc2luO1xuXHRcdFx0aWYgKCBhUm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdFx0Y29zID0gTWF0aC5jb3MoIGFSb3RhdGlvbiApO1xuXHRcdFx0XHRzaW4gPSBNYXRoLnNpbiggYVJvdGF0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggdmFyIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIHQgPSBqIC8gdGRpdmlzaW9ucztcblxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcblxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdFx0XHRcdHR4ID0gYVggKyB4UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG5cdFx0XHRcdHR5ID0gYVkgKyB5UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cblx0XHRcdFx0aWYgKCBhUm90YXRpb24gIT09IDAgKSB7XG5cblx0XHRcdFx0XHR2YXIgeCA9IHR4LCB5ID0gdHk7XG5cblx0XHRcdFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG5cdFx0XHRcdFx0dHggPSAoIHggLSBhWCApICogY29zIC0gKCB5IC0gYVkgKSAqIHNpbiArIGFYO1xuXHRcdFx0XHRcdHR5ID0gKCB4IC0gYVggKSAqIHNpbiArICggeSAtIGFZICkgKiBjb3MgKyBhWTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0fSAvLyBlbmQgc3dpdGNoXG5cblx0fVxuXG5cblxuXHQvLyBOb3JtYWxpemUgdG8gcmVtb3ZlIHRoZSBjbG9zaW5nIHBvaW50IGJ5IGRlZmF1bHQuXG5cdHZhciBsYXN0UG9pbnQgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XG5cdGlmICggTWF0aC5hYnMoIGxhc3RQb2ludC54IC0gcG9pbnRzWyAwIF0ueCApIDwgTnVtYmVyLkVQU0lMT04gJiZcblx0XHRcdCBNYXRoLmFicyggbGFzdFBvaW50LnkgLSBwb2ludHNbIDAgXS55ICkgPCBOdW1iZXIuRVBTSUxPTiApXG5cdFx0cG9pbnRzLnNwbGljZSggcG9pbnRzLmxlbmd0aCAtIDEsIDEgKTtcblxuXHRpZiAoIHRoaXMuYXV0b0Nsb3NlICkge1xuXG5cdFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cblx0fVxuXG5cdHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8vXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xuLy9cbi8vXHRBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG4vL1x0LSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcbi8vXHQtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcbi8vXG4vL1x0SWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuLy9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XG5cblx0ZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cblx0XHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5BY3Rpb25zLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpdGVtID0gaW5BY3Rpb25zWyBpIF07XG5cblx0XHRcdHZhciBhcmdzID0gaXRlbS5hcmdzO1xuXHRcdFx0dmFyIGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG5cdFx0XHRpZiAoIGFjdGlvbiA9PT0gJ21vdmVUbycgKSB7XG5cblx0XHRcdFx0aWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cdFx0XHRcdFx0bGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRsYXN0UGF0aFsgYWN0aW9uIF0uYXBwbHkoIGxhc3RQYXRoLCBhcmdzICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gY29uc29sZS5sb2coc3ViUGF0aHMpO1xuXG5cdFx0cmV0dXJuXHRzdWJQYXRocztcblxuXHR9XG5cblx0ZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG5cdFx0dmFyIHNoYXBlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcblxuXHRcdFx0dmFyIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG5cdFx0XHR0bXBTaGFwZS5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuXHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0XHRyZXR1cm4gc2hhcGVzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xuXG5cdFx0dmFyIHBvbHlMZW4gPSBpblBvbHlnb24ubGVuZ3RoO1xuXG5cdFx0Ly8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3Jcblx0XHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXG5cdFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxuXHRcdC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlO1xuXHRcdGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XG5cblx0XHRcdHZhciBlZGdlTG93UHQgID0gaW5Qb2x5Z29uWyBwIF07XG5cdFx0XHR2YXIgZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcSBdO1xuXG5cdFx0XHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XG5cdFx0XHR2YXIgZWRnZUR5ID0gZWRnZUhpZ2hQdC55IC0gZWRnZUxvd1B0Lnk7XG5cblx0XHRcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0Ly8gbm90IHBhcmFsbGVsXG5cdFx0XHRcdGlmICggZWRnZUR5IDwgMCApIHtcblxuXHRcdFx0XHRcdGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XG5cdFx0XHRcdFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSBcdFx0Y29udGludWU7XG5cblx0XHRcdFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54IClcdFx0cmV0dXJuXHR0cnVlO1x0XHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xuXHRcdFx0XHRcdC8vIGNvbnRpbnVlO1x0XHRcdFx0Ly8gbm8gaW50ZXJzZWN0aW9uIG9yIGVkZ2VMb3dQdCA9PiBkb2Vzbid0IGNvdW50ICEhIVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XG5cdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA9PT0gMCApXHRcdFx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG5cdFx0XHRcdFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGluc2lkZSA9ICEgaW5zaWRlO1x0XHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXG5cdFx0XHRcdGlmICggaW5QdC55ICE9PSBlZGdlTG93UHQueSApIFx0XHRjb250aW51ZTtcdFx0XHQvLyBwYXJhbGxlbFxuXHRcdFx0XHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcblx0XHRcdFx0aWYgKCAoICggZWRnZUhpZ2hQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VMb3dQdC54ICkgKSB8fFxuXHRcdFx0XHRcdCAoICggZWRnZUxvd1B0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUhpZ2hQdC54ICkgKSApXHRcdHJldHVyblx0dHJ1ZTtcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxuXHRcdFx0XHQvLyBjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuXHRpbnNpZGU7XG5cblx0fVxuXG5cdHZhciBpc0Nsb2NrV2lzZSA9IFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XG5cblx0dmFyIHN1YlBhdGhzID0gZXh0cmFjdFN1YnBhdGhzKCB0aGlzLmFjdGlvbnMgKTtcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cblx0aWYgKCBub0hvbGVzID09PSB0cnVlIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XG5cblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XG5cblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcblx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xuXHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG5cdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG5cdFx0cmV0dXJuIHNoYXBlcztcblxuXHR9XG5cblx0dmFyIGhvbGVzRmlyc3QgPSAhIGlzQ2xvY2tXaXNlKCBzdWJQYXRoc1sgMCBdLmdldFBvaW50cygpICk7XG5cdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XG5cblx0Ly8gY29uc29sZS5sb2coXCJIb2xlcyBmaXJzdFwiLCBob2xlc0ZpcnN0KTtcblxuXHR2YXIgYmV0dGVyU2hhcGVIb2xlcyA9IFtdO1xuXHR2YXIgbmV3U2hhcGVzID0gW107XG5cdHZhciBuZXdTaGFwZUhvbGVzID0gW107XG5cdHZhciBtYWluSWR4ID0gMDtcblx0dmFyIHRtcFBvaW50cztcblxuXHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcblx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuXHRcdHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG5cdFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG5cdFx0c29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcblxuXHRcdGlmICggc29saWQgKSB7XG5cblx0XHRcdGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKVx0bWFpbklkeCArKztcblxuXHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB7IHM6IG5ldyBUSFJFRS5TaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcblx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcblx0XHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cblx0XHRcdGlmICggaG9sZXNGaXJzdCApXHRtYWluSWR4ICsrO1xuXHRcdFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0ucHVzaCggeyBoOiB0bXBQYXRoLCBwOiB0bXBQb2ludHNbIDAgXSB9ICk7XG5cblx0XHRcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBvbmx5IEhvbGVzPyAtPiBwcm9iYWJseSBhbGwgU2hhcGVzIHdpdGggd3Jvbmcgb3JpZW50YXRpb25cblx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcdHJldHVyblx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xuXG5cblx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcblxuXHRcdHZhciBhbWJpZ3VvdXMgPSBmYWxzZTtcblx0XHR2YXIgdG9DaGFuZ2UgPSBbXTtcblxuXHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0gPSBbXTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xuXG5cdFx0XHR2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1sgc0lkeCBdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaElkeCA9IDA7IGhJZHggPCBzaG8ubGVuZ3RoOyBoSWR4ICsrICkge1xuXG5cdFx0XHRcdHZhciBobyA9IHNob1sgaElkeCBdO1xuXHRcdFx0XHR2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xuXG5cdFx0XHRcdFx0aWYgKCBpc1BvaW50SW5zaWRlUG9seWdvbiggaG8ucCwgbmV3U2hhcGVzWyBzMklkeCBdLnAgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXHR0b0NoYW5nZS5wdXNoKCB7IGZyb21zOiBzSWR4LCB0b3M6IHMySWR4LCBob2xlOiBoSWR4IH0gKTtcblx0XHRcdFx0XHRcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzMklkeCBdLnB1c2goIGhvICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0YW1iaWd1b3VzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cblx0XHRcdFx0XHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblx0XHQvLyBjb25zb2xlLmxvZyhcImFtYmlndW91czogXCIsIGFtYmlndW91cyk7XG5cdFx0aWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcInRvIGNoYW5nZTogXCIsIHRvQ2hhbmdlKTtcblx0XHRcdGlmICggISBhbWJpZ3VvdXMgKVx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciB0bXBIb2xlcztcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbmV3U2hhcGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xuXHRcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cblx0cmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xuXG5cdFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXG5cdHRoaXMuaG9sZXMgPSBbXTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUGF0aC5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNoYXBlO1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIEV4dHJ1ZGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cnVkZSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuXG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIFNoYXBlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLm1ha2VHZW9tZXRyeSA9IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLlNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHR2YXIgaG9sZXNQdHMgPSBbXTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFBvaW50cyggZGl2aXNpb25zICk7XG5cblx0fVxuXG5cdHJldHVybiBob2xlc1B0cztcblxufTtcblxuXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuXHRyZXR1cm4ge1xuXG5cdFx0c2hhcGU6IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKSxcblx0XHRob2xlczogdGhpcy5nZXRQb2ludHNIb2xlcyggZGl2aXNpb25zIClcblxuXHR9O1xuXG59O1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG5cdHJldHVybiB0aGlzLmV4dHJhY3RBbGxQb2ludHMoIGRpdmlzaW9ucyApO1xuXG59O1xuXG5USFJFRS5TaGFwZS5VdGlscyA9IFRIUkVFLlNoYXBlVXRpbHM7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdExpbmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaW5lQ3VydmU7XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHBvaW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG5cdHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcblxuXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cblx0dGhpcy52MCA9IHYwO1xuXHR0aGlzLnYxID0gdjE7XG5cdHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblxuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIGIyID0gVEhSRUUuU2hhcGVVdGlscy5iMjtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXG5cdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcblx0XHRiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApXG5cdCk7XG5cbn07XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuXHR2YXIgdGFuZ2VudFF1YWRyYXRpY0JlemllciA9IFRIUkVFLkN1cnZlVXRpbHMudGFuZ2VudFF1YWRyYXRpY0JlemllcjtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoXG5cdFx0dGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxuXHRcdHRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxuXHQpLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1YmljQmV6aWVyQ3VydmUgPSBmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdHRoaXMudjAgPSB2MDtcblx0dGhpcy52MSA9IHYxO1xuXHR0aGlzLnYyID0gdjI7XG5cdHRoaXMudjMgPSB2MztcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcblxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIFxuXHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcblx0XHRiMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55IClcblx0KTtcblxufTtcblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdHZhciB0YW5nZW50Q3ViaWNCZXppZXIgPSBUSFJFRS5DdXJ2ZVV0aWxzLnRhbmdlbnRDdWJpY0JlemllcjtcblxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIFxuXHRcdHRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXG5cdFx0dGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxuXHQpLm5vcm1hbGl6ZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdFNwbGluZSBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5TcGxpbmVDdXJ2ZSA9IGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XG5cblx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG59O1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwbGluZUN1cnZlO1xuXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG5cdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG5cdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0dmFyIHBvaW50MSA9IHBvaW50c1sgaW50UG9pbnQgXTtcblx0dmFyIHBvaW50MiA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMiA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxIF07XG5cdHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdHZhciBpbnRlcnBvbGF0ZSA9IFRIUkVFLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XG5cblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxuXHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXG5cdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKVxuXHQpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRFbGxpcHNlIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cblx0dGhpcy5hWCA9IGFYO1xuXHR0aGlzLmFZID0gYVk7XG5cblx0dGhpcy54UmFkaXVzID0geFJhZGl1cztcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcblxuXHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGU7XG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG5cdHRoaXMuYUNsb2Nrd2lzZSA9IGFDbG9ja3dpc2U7XG5cdFxuXHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xuXG59O1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG5cdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG5cdGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xuXHRpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XG5cblx0dmFyIGFuZ2xlO1xuXG5cdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xuXG5cdFx0YW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG5cdH1cblx0XG5cdHZhciB4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xuXHR2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG5cdFx0dmFyIGNvcyA9IE1hdGguY29zKCB0aGlzLmFSb3RhdGlvbiApO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbiggdGhpcy5hUm90YXRpb24gKTtcblxuXHRcdHZhciB0eCA9IHgsIHR5ID0geTtcblxuXHRcdC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cblx0XHR4ID0gKCB0eCAtIHRoaXMuYVggKSAqIGNvcyAtICggdHkgLSB0aGlzLmFZICkgKiBzaW4gKyB0aGlzLmFYO1xuXHRcdHkgPSAoIHR4IC0gdGhpcy5hWCApICogc2luICsgKCB0eSAtIHRoaXMuYVkgKSAqIGNvcyArIHRoaXMuYVk7XG5cblx0fVxuXG5cdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggeCwgeSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0FyY0N1cnZlLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEFyYyBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG5cdFRIUkVFLkVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxufTtcblxuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJjQ3VydmU7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvTGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRMaW5lM0RcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuTGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cblx0fSxcblxuXHRmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHRcdHZlY3Rvci5zdWJWZWN0b3JzKCB0aGlzLnYyLCB0aGlzLnYxICk7IC8vIGRpZmZcblx0XHR2ZWN0b3IubXVsdGlwbHlTY2FsYXIoIHQgKTtcblx0XHR2ZWN0b3IuYWRkKCB0aGlzLnYxICk7XG5cblx0XHRyZXR1cm4gdmVjdG9yO1xuXG5cdH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9RdWFkcmF0aWNCZXppZXJDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlx0UXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cblx0fSxcblxuXHRmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHR2YXIgYjIgPSBUSFJFRS5TaGFwZVV0aWxzLmIyO1x0XHRcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdGIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICksXG5cdFx0XHRiMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApLFxuXHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxuXHRcdCk7XG5cblx0fVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0N1YmljQmV6aWVyQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xuXG5cdFx0dGhpcy52MCA9IHYwO1xuXHRcdHRoaXMudjEgPSB2MTtcblx0XHR0aGlzLnYyID0gdjI7XG5cdFx0dGhpcy52MyA9IHYzO1xuXG5cdH0sXG5cblx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0dmFyIGIzID0gVEhSRUUuU2hhcGVVdGlscy5iMztcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdGIzKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54LCB0aGlzLnYzLnggKSxcblx0XHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKSxcblx0XHRcdGIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKVxuXHRcdCk7XG5cblx0fVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1NwbGluZUN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXHRTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5TcGxpbmVDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyB3aWxsIGJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMycgKTtcblx0XHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cblx0fSxcblxuXHRmdW5jdGlvbiAoIHQgKSB7XG5cblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0dmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG5cdFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHR2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcblx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuXHRcdHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuXHRcdHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG5cdFx0dmFyIGludGVycG9sYXRlID0gVEhSRUUuQ3VydmVVdGlscy5pbnRlcnBvbGF0ZTtcblxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdGludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICksXG5cdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApLFxuXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxuXHRcdCk7XG5cblx0fVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0NhdG11bGxSb21DdXJ2ZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cblRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgPSAoIGZ1bmN0aW9uKCkge1xuXG5cdHZhclxuXHRcdHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cdFx0cHggPSBuZXcgQ3ViaWNQb2x5KCksXG5cdFx0cHkgPSBuZXcgQ3ViaWNQb2x5KCksXG5cdFx0cHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cblx0Lypcblx0QmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuXHQgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cblxuXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG5cdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuXHR3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXG5cdCovXG5cblx0ZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG5cdH1cblxuXHQvKlxuXHQgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG5cdCAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xuXHQgKiBzdWNoIHRoYXRcblx0ICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuXHQgKiAgYW5kXG5cdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cblx0ICovXG5cdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCB4MCwgeDEsIHQwLCB0MSApIHtcblxuXHRcdHRoaXMuYzAgPSB4MDtcblx0XHR0aGlzLmMxID0gdDA7XG5cdFx0dGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG5cdFx0dGhpcy5jMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cblx0fTtcblxuXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcblxuXHRcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cblx0XHR2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuXHRcdHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XG5cblx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cblx0XHR0MSAqPSBkdDE7XG5cdFx0dDIgKj0gZHQxO1xuXG5cdFx0Ly8gaW5pdEN1YmljUG9seVxuXHRcdHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuXHR9O1xuXG5cdC8vIHN0YW5kYXJkIENhdG11bGwtUm9tIHNwbGluZTogaW50ZXJwb2xhdGUgYmV0d2VlbiB4MSBhbmQgeDIgd2l0aCBwcmV2aW91cy9mb2xsb3dpbmcgcG9pbnRzIHgxL3g0XG5cdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cblx0XHR0aGlzLmluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuXHR9O1xuXG5cdEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xuXG5cdFx0dmFyIHQyID0gdCAqIHQ7XG5cdFx0dmFyIHQzID0gdDIgKiB0O1xuXHRcdHJldHVybiB0aGlzLmMwICsgdGhpcy5jMSAqIHQgKyB0aGlzLmMyICogdDIgKyB0aGlzLmMzICogdDM7XG5cblx0fTtcblxuXHQvLyBTdWJjbGFzcyBUaHJlZS5qcyBjdXJ2ZVxuXHRyZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG5cdFx0ZnVuY3Rpb24gKCBwIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cblx0XHRcdHRoaXMucG9pbnRzID0gcCB8fCBbXTtcblx0XHRcdHRoaXMuY2xvc2VkID0gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0ZnVuY3Rpb24gKCB0ICkge1xuXG5cdFx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMsXG5cdFx0XHRcdHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCBsO1xuXG5cdFx0XHRsID0gcG9pbnRzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBsIDwgMiApIGNvbnNvbGUubG9nKCAnZHVoLCB5b3UgbmVlZCBhdCBsZWFzdCAyIHBvaW50cycgKTtcblxuXHRcdFx0cG9pbnQgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcblx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblx0XHRcdHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cblx0XHRcdGlmICggdGhpcy5jbG9zZWQgKSB7XG5cblx0XHRcdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xuXG5cdFx0XHRcdGludFBvaW50ID0gbCAtIDI7XG5cdFx0XHRcdHdlaWdodCA9IDE7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xuXG5cdFx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCApIHtcblxuXHRcdFx0XHRwMCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuXHRcdFx0XHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xuXHRcdFx0XHRwMCA9IHRtcDtcblxuXHRcdFx0fVxuXG5cdFx0XHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XG5cdFx0XHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcblxuXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsICkge1xuXG5cdFx0XHRcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcblx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAyIF0gKTtcblx0XHRcdFx0cDMgPSB0bXA7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy50eXBlID09PSAnY2hvcmRhbCcgKSB7XG5cblx0XHRcdFx0Ly8gaW5pdCBDZW50cmlwZXRhbCAvIENob3JkYWwgQ2F0bXVsbC1Sb21cblx0XHRcdFx0dmFyIHBvdyA9IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcblx0XHRcdFx0dmFyIGR0MCA9IE1hdGgucG93KCBwMC5kaXN0YW5jZVRvU3F1YXJlZCggcDEgKSwgcG93ICk7XG5cdFx0XHRcdHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xuXHRcdFx0XHR2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcblxuXHRcdFx0XHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xuXHRcdFx0XHRpZiAoIGR0MSA8IDFlLTQgKSBkdDEgPSAxLjA7XG5cdFx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcblx0XHRcdFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xuXG5cdFx0XHRcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xuXHRcdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcblx0XHRcdFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudHlwZSA9PT0gJ2NhdG11bGxyb20nICkge1xuXG5cdFx0XHRcdHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XG5cdFx0XHRcdHB4LmluaXRDYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCB0ZW5zaW9uICk7XG5cdFx0XHRcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0ZW5zaW9uICk7XG5cdFx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMyhcblx0XHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXG5cdFx0XHRcdHB5LmNhbGMoIHdlaWdodCApLFxuXHRcdFx0XHRwei5jYWxjKCB3ZWlnaHQgKVxuXHRcdFx0KTtcblxuXHRcdFx0cmV0dXJuIHY7XG5cblx0XHR9XG5cblx0KTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ2xvc2VkU3BsaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5USFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLicgKTtcblxuXHRUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xuXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XG5cdHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxufTtcblxuVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0JveEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG4gKi9cblxuVEhSRUUuQm94R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdGRlcHRoOiBkZXB0aCxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXG5cdH07XG5cblx0dGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcblx0dGhpcy5kZXB0aFNlZ21lbnRzID0gZGVwdGhTZWdtZW50cyB8fCAxO1xuXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cdHZhciBkZXB0aF9oYWxmID0gZGVwdGggLyAyO1xuXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAtIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxuXHRidWlsZFBsYW5lKCAneicsICd5JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGhfaGFsZiwgMSApOyAvLyBueFxuXHRidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAgIDEsIHdpZHRoLCBkZXB0aCwgaGVpZ2h0X2hhbGYsIDIgKTsgLy8gcHlcblx0YnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgLSAxLCB3aWR0aCwgZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcblx0YnVpbGRQbGFuZSggJ3gnLCAneScsICAgMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aF9oYWxmLCA0ICk7IC8vIHB6XG5cdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAtIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgLSBkZXB0aF9oYWxmLCA1ICk7IC8vIG56XG5cblx0ZnVuY3Rpb24gYnVpbGRQbGFuZSggdSwgdiwgdWRpciwgdmRpciwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgdywgaXgsIGl5LFxuXHRcdGdyaWRYID0gc2NvcGUud2lkdGhTZWdtZW50cyxcblx0XHRncmlkWSA9IHNjb3BlLmhlaWdodFNlZ21lbnRzLFxuXHRcdHdpZHRoX2hhbGYgPSB3aWR0aCAvIDIsXG5cdFx0aGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyLFxuXHRcdG9mZnNldCA9IHNjb3BlLnZlcnRpY2VzLmxlbmd0aDtcblxuXHRcdGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3knICkgfHwgKCB1ID09PSAneScgJiYgdiA9PT0gJ3gnICkgKSB7XG5cblx0XHRcdHcgPSAneic7XG5cblx0XHR9IGVsc2UgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneicgKSB8fCAoIHUgPT09ICd6JyAmJiB2ID09PSAneCcgKSApIHtcblxuXHRcdFx0dyA9ICd5Jztcblx0XHRcdGdyaWRZID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuXHRcdH0gZWxzZSBpZiAoICggdSA9PT0gJ3onICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd6JyApICkge1xuXG5cdFx0XHR3ID0gJ3gnO1xuXHRcdFx0Z3JpZFggPSBzY29wZS5kZXB0aFNlZ21lbnRzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcblx0XHRncmlkWTEgPSBncmlkWSArIDEsXG5cdFx0c2VnbWVudF93aWR0aCA9IHdpZHRoIC8gZ3JpZFgsXG5cdFx0c2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcblx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdFx0bm9ybWFsWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xuXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZMTsgaXkgKysgKSB7XG5cblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdFx0XHR2ZWN0b3JbIHUgXSA9ICggaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZiApICogdWRpcjtcblx0XHRcdFx0dmVjdG9yWyB2IF0gPSAoIGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZiApICogdmRpcjtcblx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aDtcblxuXHRcdFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuXHRcdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuXHRcdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG5cdFx0XHRcdHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggaXggLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuXHRcdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXkgKyAxICkgLyBncmlkWSApO1xuXHRcdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtIGl5IC8gZ3JpZFkgKTtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggYSArIG9mZnNldCwgYiArIG9mZnNldCwgZCArIG9mZnNldCApO1xuXHRcdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCkgKTtcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuXHRcdFx0XHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG5cdFx0XHRcdGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIgKyBvZmZzZXQsIGMgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG5cdFx0XHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuXHRcdFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbn07XG5cblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQm94R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94R2VvbWV0cnk7XG5cblRIUkVFLkN1YmVHZW9tZXRyeSA9IFRIUkVFLkJveEdlb21ldHJ5OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgaHVnaGVzXG4gKi9cblxuVEhSRUUuQ2lyY2xlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbn07XG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0NpcmNsZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHRyYWRpdXMgPSByYWRpdXMgfHwgNTA7XG5cdHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcblxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0dmFyIHZlcnRpY2VzID0gc2VnbWVudHMgKyAyO1xuXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcblx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcblx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMiApO1xuXG5cdC8vIGNlbnRlciBkYXRhIGlzIGFscmVhZHkgemVybywgYnV0IG5lZWQgdG8gc2V0IGEgZmV3IGV4dHJhc1xuXHRub3JtYWxzWyAyIF0gPSAxLjA7XG5cdHV2c1sgMCBdID0gMC41O1xuXHR1dnNbIDEgXSA9IDAuNTtcblxuXHRmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XG5cblx0XHR2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuXHRcdHBvc2l0aW9uc1sgaSBdID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcblx0XHRwb3NpdGlvbnNbIGkgKyAxIF0gPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG5cdFx0bm9ybWFsc1sgaSArIDIgXSA9IDE7IC8vIG5vcm1hbCB6XG5cblx0XHR1dnNbIGlpIF0gPSAoIHBvc2l0aW9uc1sgaSBdIC8gcmFkaXVzICsgMSApIC8gMjtcblx0XHR1dnNbIGlpICsgMSBdID0gKCBwb3NpdGlvbnNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG5cdH1cblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuXHRcdGluZGljZXMucHVzaCggaSwgaSArIDEsIDAgKTtcblxuXHR9XG5cblx0dGhpcy5zZXRJbmRleCggbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5DaXJjbGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DeWxpbmRlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXG5cdFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXG5cdFx0aGVpZ2h0OiBoZWlnaHQsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMjA7XG5cdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XG5cdGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xuXG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0aGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xuXG5cdG9wZW5FbmRlZCA9IG9wZW5FbmRlZCAhPT0gdW5kZWZpbmVkID8gb3BlbkVuZGVkIDogZmFsc2U7XG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiAyICogTWF0aC5QSTtcblxuXHR2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG5cblx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xuXG5cdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XG5cdFx0dmFyIHV2c1JvdyA9IFtdO1xuXG5cdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcblx0XHRcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGVpZ2h0SGFsZjtcblx0XHRcdHZlcnRleC56ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQgKTtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XG5cdFx0XHR1dnNSb3cucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICkgKTtcblxuXHRcdH1cblxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cdFx0dXZzLnB1c2goIHV2c1JvdyApO1xuXG5cdH1cblxuXHR2YXIgdGFuVGhldGEgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xuXHR2YXIgbmEsIG5iO1xuXG5cdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRpZiAoIHJhZGl1c1RvcCAhPT0gMCApIHtcblxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4IF0gXS5jbG9uZSgpO1xuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCBdIF0uY2xvbmUoKTtcblx0XHRcdG5iID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDEgXVsgeCArIDEgXSBdLmNsb25lKCk7XG5cblx0XHR9XG5cblx0XHRuYS5zZXRZKCBNYXRoLnNxcnQoIG5hLnggKiBuYS54ICsgbmEueiAqIG5hLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cdFx0bmIuc2V0WSggTWF0aC5zcXJ0KCBuYi54ICogbmIueCArIG5iLnogKiBuYi56ICkgKiB0YW5UaGV0YSApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCBdO1xuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgKyAxIF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xuXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblxuXHRcdFx0dmFyIG4xID0gbmEuY2xvbmUoKTtcblx0XHRcdHZhciBuMiA9IG5hLmNsb25lKCk7XG5cdFx0XHR2YXIgbjMgPSBuYi5jbG9uZSgpO1xuXHRcdFx0dmFyIG40ID0gbmIuY2xvbmUoKTtcblxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgeSBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MyA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2NCA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHY0LCBbIG4xLCBuMiwgbjQgXSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djQgXSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYyLmNsb25lKCksIHV2MywgdXY0LmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyB0b3AgY2FwXG5cblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c1RvcCA+IDAgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCBoZWlnaHRIYWxmLCAwICkgKTtcblxuXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cblx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyAwIF1bIHggXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyAwIF1bIHggKyAxIF07XG5cdFx0XHR2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG5cblx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcblxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgMCBdWyB4IF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIDAgXVsgeCArIDEgXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMCApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMSApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBib3R0b20gY2FwXG5cblx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xuXG5cdFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XG5cdFx0XHR2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xuXHRcdFx0dmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG5cdFx0XHR2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cdFx0XHR2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cdFx0XHR2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cblx0XHRcdHZhciB1djEgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF0uY2xvbmUoKTtcblx0XHRcdHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xuXHRcdFx0dmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMSApO1xuXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0sIHVuZGVmaW5lZCwgMiApICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DeWxpbmRlckdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9FZGdlc0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuRWRnZXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICkge1xuXG5cdFRIUkVFLkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG5cdHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggVEhSRUUuTWF0aC5kZWdUb1JhZCggdGhyZXNob2xkQW5nbGUgKSApO1xuXG5cdHZhciBlZGdlID0gWyAwLCAwIF0sIGhhc2ggPSB7fTtcblxuXHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHRyZXR1cm4gYSAtIGI7XG5cblx0fVxuXG5cdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cblx0dmFyIGdlb21ldHJ5MjtcblxuXHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cblx0XHRnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0XHRnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xuXG5cdH1cblxuXHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xuXHRnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xuXHR2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuXHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuXHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG5cdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG5cdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG5cdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aGFzaFsga2V5IF0gPSB7IHZlcnQxOiBlZGdlWyAwIF0sIHZlcnQyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHZhciBjb29yZHMgPSBbXTtcblxuXHRmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cblx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG5cdFx0aWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnggKTtcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cblx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG5cdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnggKTtcblx0XHRcdGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XG5cbn07XG5cblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gRGVwdGggdG8gZXh0cnVkZSB0aGUgc2hhcGVcbiAqXG4gKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0aGUgb3JpZ2luYWwgc2hhcGUgYmV2ZWwgZ29lc1xuICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcbiAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICpcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXG4gKiAgZnJhbWVzOiA8VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcz4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xuICpcbiAqICB1dkdlbmVyYXRvcjogPE9iamVjdD4gLy8gb2JqZWN0IHRoYXQgcHJvdmlkZXMgVVYgZ2VuZXJhdG9yIGZ1bmN0aW9uc1xuICpcbiAqIH1cbiAqKi9cblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cblx0aWYgKCB0eXBlb2YoIHNoYXBlcyApID09PSBcInVuZGVmaW5lZFwiICkge1xuXG5cdFx0c2hhcGVzID0gW107XG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cblx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG5cdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG5cdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG5cdC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xuXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXG5cblx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cblx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cblx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblxuXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcblxuXHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xuXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuXHR2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xuXG5cdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxuXHR2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XG5cdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xuXG5cdHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxuXG5cdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcblxuXHR2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xuXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXG5cdC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxuXHR2YXIgdXZnZW4gPSBvcHRpb25zLlVWR2VuZXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLlVWR2VuZXJhdG9yIDogVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3I7XG5cblx0dmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcblx0aWYgKCBleHRydWRlUGF0aCApIHtcblxuXHRcdGV4dHJ1ZGVQdHMgPSBleHRydWRlUGF0aC5nZXRTcGFjZWRQb2ludHMoIHN0ZXBzICk7XG5cblx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcblx0XHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXG5cblx0XHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXG5cblx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxuXHRcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XG5cblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UgKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0cG9zaXRpb24yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuXHR9XG5cblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXG5cblx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuXHRcdGJldmVsU2VnbWVudHMgPSAwO1xuXHRcdGJldmVsVGhpY2tuZXNzID0gMDtcblx0XHRiZXZlbFNpemUgPSAwO1xuXG5cdH1cblxuXHQvLyBWYXJpYWJsZXMgaW5pdGlhbGl6YXRpb25cblxuXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG5cdHZhciBzY29wZSA9IHRoaXM7XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XG5cblx0dmFyIHJldmVyc2UgPSAhIFRIUkVFLlNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XG5cblx0aWYgKCByZXZlcnNlICkge1xuXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xuXG5cdFx0XHRcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldmVyc2UgPSBmYWxzZTsgLy8gSWYgdmVydGljZXMgYXJlIGluIG9yZGVyIG5vdywgd2Ugc2hvdWxkbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlbSBhZ2FpbiAoaG9wZWZ1bGx5KSFcblxuXHR9XG5cblxuXHR2YXIgZmFjZXMgPSBUSFJFRS5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG5cdC8qIFZlcnRpY2VzICovXG5cblx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcblxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG5cdH1cblxuXG5cdGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcblxuXHRcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuXHRcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuXHR9XG5cblx0dmFyIGIsIGJzLCB0LCB6LFxuXHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG5cdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG5cdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG5cdGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuXHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcblx0XHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XG5cdFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXG5cdFx0Ly9cblx0XHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xuXHRcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXG5cblx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcblx0XHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxuXG5cdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG5cdFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsIHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XG5cblx0XHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xuXG5cdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuXHRcdHZhciBjb2xsaW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuXHRcdFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cblx0XHRcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG5cdFx0XHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cblx0XHRcdHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cblx0XHRcdHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuXHRcdFx0dmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cblx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cblx0XHRcdHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cblx0XHRcdFx0XHRcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuXHRcdFx0XHRcdCAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG5cdFx0XHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG5cdFx0XHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG5cdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cblx0XHRcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG5cdFx0XHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG5cdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG5cdFx0XHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3gsIHZfdHJhbnNfeSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcblxuXHRcdFx0dmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlO1x0XHQvLyBhc3N1bWVzOiBvcHBvc2l0ZVxuXHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuXHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggTWF0aC5zaWduKCB2X3ByZXZfeSApID09PSBNYXRoLnNpZ24oIHZfbmV4dF95ICkgKSB7XG5cblx0XHRcdFx0XHRcdGRpcmVjdGlvbl9lcSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xuXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiV2FybmluZzogbGluZXMgYXJlIGEgc3RyYWlnaHQgc2VxdWVuY2VcIik7XG5cdFx0XHRcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XG5cdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcblx0XHRcdFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuXHRcdFx0XHR2X3RyYW5zX3ggPSB2X3ByZXZfeDtcblx0XHRcdFx0dl90cmFuc195ID0gdl9wcmV2X3k7XG5cdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm5cdG5ldyBUSFJFRS5WZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG5cdH1cblxuXG5cdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XG5cblx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXG5cblx0XHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xuXG5cdH1cblxuXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xuXG5cdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG5cdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xuXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuXHRcdFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG5cdFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG5cdFx0fVxuXG5cdFx0aG9sZXNNb3ZlbWVudHMucHVzaCggb25lSG9sZU1vdmVtZW50cyApO1xuXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cblx0fVxuXG5cblx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXG5cblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG5cdFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXG5cdFx0Ly96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xuXHRcdGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApICk7IC8vIGN1cnZlZFxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiB0OyAvLyBsaW5lYXJcblxuXHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIC0geiApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gZXhwYW5kIGhvbGVzXG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHRcdHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG5cdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0YnMgPSBiZXZlbFNpemU7XG5cblx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcblxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cblx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIDAgXS55LCBleHRydWRlUHRzWyAwIF0ueCApO1xuXG5cdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG5cdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG5cdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cblx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG5cdHZhciBzO1xuXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG5cdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cblx0XHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cblx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG5cdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcblx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cblx0XHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XG5cdFx0eiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xuXHRcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuXHRcdC8vIGNvbnRyYWN0IHNoYXBlXG5cblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XG5cblx0XHR9XG5cblx0XHQvLyBleHBhbmQgaG9sZXNcblxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cblx0XHRcdFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XG5cblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKiBGYWNlcyAqL1xuXG5cdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXG5cblx0YnVpbGRMaWRGYWNlcygpO1xuXG5cdC8vIFNpZGVzIGZhY2VzXG5cblx0YnVpbGRTaWRlRmFjZXMoKTtcblxuXG5cdC8vLy8vICBJbnRlcm5hbCBmdW5jdGlvbnNcblxuXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG5cdFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XG5cblx0XHRcdHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxuXHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG5cdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XG5cblx0XHRcdC8vIFRvcCBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cdFx0XHRcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gVG9wIGZhY2VzXG5cblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcblx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG5cdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXG5cdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcblx0XHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XG5cdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cblx0XHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuXHRcdFx0Ly8sIHRydWVcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuXHRcdHZhciBqLCBrO1xuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcblxuXHRcdHdoaWxlICggLS0gaSA+PSAwICkge1xuXG5cdFx0XHRqID0gaTtcblx0XHRcdGsgPSBpIC0gMTtcblx0XHRcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xuXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuXHRcdFx0dmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xuXG5cdFx0XHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG5cdFx0XHRcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xuXHRcdFx0XHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG5cdFx0XHRcdHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG5cdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuXHRcdFx0XHRcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcblx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cblx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xuXG5cdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcblxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xuXG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCAwICkgKTtcblxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG5cdFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIHV2cyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XG5cblx0XHRhICs9IHNoYXBlc09mZnNldDtcblx0XHRiICs9IHNoYXBlc09mZnNldDtcblx0XHRjICs9IHNoYXBlc09mZnNldDtcblx0XHRkICs9IHNoYXBlc09mZnNldDtcblxuXHRcdHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCwgbnVsbCwgbnVsbCwgMSApICk7XG5cdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBudWxsLCBudWxsLCAxICkgKTtcblxuXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBhLCBiLCBjLCBkICk7XG5cblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDAgXSwgdXZzWyAxIF0sIHV2c1sgMyBdIF0gKTtcblx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcblxuXHR9XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xuXG5cdGdlbmVyYXRlVG9wVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuXHRcdHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuXG5cdFx0cmV0dXJuIFtcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIGEueSApLFxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgYi55ICksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy54LCBjLnkgKVxuXHRcdF07XG5cblx0fSxcblxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG5cdFx0dmFyIGEgPSB2ZXJ0aWNlc1sgaW5kZXhBIF07XG5cdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG5cdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cdFx0dmFyIGQgPSB2ZXJ0aWNlc1sgaW5kZXhEIF07XG5cblx0XHRpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLngsIDEgLSBhLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGIueCwgMSAtIGIueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy54LCAxIC0gYy56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBkLngsIDEgLSBkLnogKVxuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGIueSwgMSAtIGIueiApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYy55LCAxIC0gYy56ICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBkLnksIDEgLSBkLnogKVxuXHRcdFx0XTtcblxuXHRcdH1cblxuXHR9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG4gKlxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICpcbiAqXHRtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGVHZW9tZXRyeTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG5cdGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cblx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG5cdC8vXG5cblx0dmFyIGksIGwsIGhvbGU7XG5cblx0dmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXHR2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG5cdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG5cdHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xuXG5cdGlmICggcmV2ZXJzZSApIHtcblxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG5cdFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZS4uLlxuXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBob2xlICkgKSB7XG5cblx0XHRcdFx0aG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXZlcnNlID0gZmFsc2U7XG5cblx0fVxuXG5cdHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cblx0Ly8gVmVydGljZXNcblxuXHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRob2xlID0gaG9sZXNbIGkgXTtcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggaG9sZSApO1xuXG5cdH1cblxuXHQvL1xuXG5cdHZhciB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoO1xuXHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cblx0XHR2ZXJ0ID0gdmVydGljZXNbIGkgXTtcblxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnQueCwgdmVydC55LCAwICkgKTtcblxuXHR9XG5cblx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG5cdFx0ZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHR2YXIgYSA9IGZhY2VbIDAgXSArIHNoYXBlc09mZnNldDtcblx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcblx0XHR2YXIgYyA9IGZhY2VbIDIgXSArIHNoYXBlc09mZnNldDtcblxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XG5cdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZnZW4uZ2VuZXJhdGVUb3BVViggdGhpcywgYSwgYiwgYyApICk7XG5cblx0fVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9MYXRoZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gKi9cblxuLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzIFxuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4vLyAgICAyKnBpIGlzIGEgY2xvc2VkIGxhdGhlLCBsZXNzIHRoYW4gMlBJIGlzIGEgcG9ydGlvbi5cblxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRwb2ludHM6IHBvaW50cyxcblx0XHRzZWdtZW50czogc2VnbWVudHMsXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXG5cdH07XG5cblx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcblx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XG5cblx0dmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSArKyApIHtcblxuXHRcdHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cblx0XHR2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcblx0XHRcdHMgPSBNYXRoLnNpbiggcGhpICk7XG5cblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgcHQgPSBwb2ludHNbIGogXTtcblxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0XHRcdHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcblx0XHRcdHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcblx0XHRcdHZlcnRleC56ID0gcHQuejtcblxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHR2YXIgYmFzZSA9IGogKyBucCAqIGk7XG5cdFx0XHR2YXIgYSA9IGJhc2U7XG5cdFx0XHR2YXIgYiA9IGJhc2UgKyBucDtcblx0XHRcdHZhciBjID0gYmFzZSArIDEgKyBucDtcblx0XHRcdHZhciBkID0gYmFzZSArIDE7XG5cblx0XHRcdHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XG5cdFx0XHR2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xuXHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XG5cdFx0XHR2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG5cdFx0XHRdICk7XG5cblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuXHRcdFx0XSApO1xuXG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdH07XG5cblx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XG5cbn07XG5cblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBsYW5lR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lQnVmZmVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cblx0VEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0d2lkdGg6IHdpZHRoLFxuXHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG5cdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG5cdH07XG5cblx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XG5cdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cblx0dmFyIGdyaWRYID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XG5cdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcblxuXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xuXG5cdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcblx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cblx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcblx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcblxuXHR2YXIgb2Zmc2V0ID0gMDtcblx0dmFyIG9mZnNldDIgPSAwO1xuXG5cdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuXHRcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xuXG5cdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cblx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgXSA9IHg7XG5cdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLSB5O1xuXG5cdFx0XHRub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xuXG5cdFx0XHR1dnNbIG9mZnNldDIgXSA9IGl4IC8gZ3JpZFg7XG5cdFx0XHR1dnNbIG9mZnNldDIgKyAxIF0gPSAxIC0gKCBpeSAvIGdyaWRZICk7XG5cblx0XHRcdG9mZnNldCArPSAzO1xuXHRcdFx0b2Zmc2V0MiArPSAyO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRvZmZzZXQgPSAwO1xuXG5cdHZhciBpbmRpY2VzID0gbmV3ICggKCB2ZXJ0aWNlcy5sZW5ndGggLyAzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggZ3JpZFggKiBncmlkWSAqIDYgKTtcblxuXHRmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuXHRcdGZvciAoIHZhciBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xuXG5cdFx0XHR2YXIgYSA9IGl4ICsgZ3JpZFgxICogaXk7XG5cdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcblx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XG5cdFx0XHR2YXIgZCA9ICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcblxuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0IF0gPSBhO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMSBdID0gYjtcblx0XHRcdGluZGljZXNbIG9mZnNldCArIDIgXSA9IGQ7XG5cblx0XHRcdGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XG5cdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA0IF0gPSBjO1xuXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNSBdID0gZDtcblxuXHRcdFx0b2Zmc2V0ICs9IDY7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxufTtcblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBLYWxlYiBNdXJwaHlcbiAqL1xuXG5USFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuXHRcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcblx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuXHRcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcblx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuXHR9O1xuXG5cdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMDtcblx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcblxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG5cdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cblx0dGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xuXHRwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDg7XG5cblx0dmFyIGksIG8sIHV2cyA9IFtdLCByYWRpdXMgPSBpbm5lclJhZGl1cywgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkge1xuXG5cdFx0Ly8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHRmb3IgKCBvID0gMDsgbyA8IHRoZXRhU2VnbWVudHMgKyAxOyBvICsrICkge1xuXG5cdFx0XHQvLyBudW1iZXIgb2Ygc2VnbWVudHMgcGVyIGNpcmNsZVxuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIG8gLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG5cdFx0XHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cdFx0XHR1dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDIgKSApO1xuXG5cdFx0fVxuXG5cdFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cblx0fVxuXG5cdHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0Ly8gY29uY2VudHJpYyBjaXJjbGVzIGluc2lkZSByaW5nXG5cblx0XHR2YXIgdGhldGFTZWdtZW50ID0gaSAqICggdGhldGFTZWdtZW50cyArIDEgKTtcblxuXHRcdGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyA7IG8gKysgKSB7XG5cblx0XHRcdC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cblx0XHRcdHZhciBzZWdtZW50ID0gbyArIHRoZXRhU2VnbWVudDtcblxuXHRcdFx0dmFyIHYxID0gc2VnbWVudDtcblx0XHRcdHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcblx0XHRcdHZhciB2MyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XG5cblx0XHRcdHYxID0gc2VnbWVudDtcblx0XHRcdHYyID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xuXHRcdFx0djMgPSBzZWdtZW50ICsgMTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5SaW5nR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUmluZ0dlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TcGhlcmVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuU3BoZXJlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuXHR0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcblx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG5cdFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXG5cdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcblx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcblx0fTtcblxuXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxuICovXG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcblx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG5cdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG5cdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG5cdH07XG5cblx0cmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXG5cdHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMywgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcblx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XG5cblx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG5cdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG5cdHZhciB0aGV0YUVuZCA9IHRoZXRhU3RhcnQgKyB0aGV0YUxlbmd0aDtcblxuXHR2YXIgdmVydGV4Q291bnQgPSAoICggd2lkdGhTZWdtZW50cyArIDEgKSAqICggaGVpZ2h0U2VnbWVudHMgKyAxICkgKTtcblxuXHR2YXIgcG9zaXRpb25zID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcblx0dmFyIG5vcm1hbHMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuXHR2YXIgdXZzID0gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuXHR2YXIgaW5kZXggPSAwLCB2ZXJ0aWNlcyA9IFtdLCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG5cdFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cblx0XHRmb3IgKCB2YXIgeCA9IDA7IHggPD0gd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcblxuXHRcdFx0dmFyIHB4ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXHRcdFx0dmFyIHB5ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcblx0XHRcdHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cblx0XHRcdG5vcm1hbC5zZXQoIHB4LCBweSwgcHogKS5ub3JtYWxpemUoKTtcblxuXHRcdFx0cG9zaXRpb25zLnNldFhZWiggaW5kZXgsIHB4LCBweSwgcHogKTtcblx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdSwgMSAtIHYgKTtcblxuXHRcdFx0dmVydGljZXNSb3cucHVzaCggaW5kZXggKTtcblxuXHRcdFx0aW5kZXggKys7XG5cblx0XHR9XG5cblx0XHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG5cdH1cblxuXHR2YXIgaW5kaWNlcyA9IFtdO1xuXG5cdGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG5cdFx0Zm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuXHRcdFx0aWYgKCB5ICE9PSAwIHx8IHRoZXRhU3RhcnQgPiAwICkgaW5kaWNlcy5wdXNoKCB2MSwgdjIsIHY0ICk7XG5cdFx0XHRpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0dGhpcy5zZXRJbmRleCggbmV3ICggcG9zaXRpb25zLmNvdW50ID4gNjU1MzUgPyBUSFJFRS5VaW50MzJBdHRyaWJ1dGUgOiBUSFJFRS5VaW50MTZBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG5cdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRExpdGUvc3JjL2F3YXkzZGxpdGUvcHJpbWl0aXZlcy9Ub3J1cy5hcz9yPTI4ODhcbiAqL1xuXG5USFJFRS5Ub3J1c0dlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcblxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHR0dWJlOiB0dWJlLFxuXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcblx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcblx0XHRhcmM6IGFyY1xuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG5cdHR1YmUgPSB0dWJlIHx8IDQwO1xuXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XG5cdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xuXHRhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XG5cblx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcblxuXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuXHRcdFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuXHRcdFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xuXHRcdFx0Y2VudGVyLnkgPSByYWRpdXMgKiBNYXRoLnNpbiggdSApO1xuXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcblx0XHRcdHZlcnRleC55ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5zaW4oIHUgKTtcblx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cblx0XHRcdHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHR1YnVsYXJTZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICkgKTtcblx0XHRcdG5vcm1hbHMucHVzaCggdmVydGV4LmNsb25lKCkuc3ViKCBjZW50ZXIgKS5ub3JtYWxpemUoKSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmb3IgKCB2YXIgaiA9IDE7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG5cdFx0XHR2YXIgYSA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGkgLSAxO1xuXHRcdFx0dmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xuXHRcdFx0dmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG5cdFx0XHR2YXIgZCA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogaiArIGk7XG5cblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBkLCBbIG5vcm1hbHNbIGEgXS5jbG9uZSgpLCBub3JtYWxzWyBiIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYSBdLmNsb25lKCksIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xuXG5cdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkLCBbIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBjIF0uY2xvbmUoKSwgbm9ybWFsc1sgZCBdLmNsb25lKCkgXSApO1xuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlICk7XG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgYiBdLmNsb25lKCksIHV2c1sgYyBdLmNsb25lKCksIHV2c1sgZCBdLmNsb25lKCkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG59O1xuXG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ub3J1c0dlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Ub3J1c0tub3RHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0Qvc3JjL2F3YXkzZC9wcmltaXRpdmVzL1RvcnVzS25vdC5hcz9zcGVjPXN2bjI0NzMmcj0yNDczXG4gKi9cblxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdHR1YmU6IHR1YmUsXG5cdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuXHRcdHA6IHAsXG5cdFx0cTogcSxcblx0XHRoZWlnaHRTY2FsZTogaGVpZ2h0U2NhbGVcblx0fTtcblxuXHRyYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuXHR0dWJlID0gdHViZSB8fCA0MDtcblx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA2NDtcblx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDg7XG5cdHAgPSBwIHx8IDI7XG5cdHEgPSBxIHx8IDM7XG5cdGhlaWdodFNjYWxlID0gaGVpZ2h0U2NhbGUgfHwgMTtcblxuXHR2YXIgZ3JpZCA9IG5ldyBBcnJheSggcmFkaWFsU2VnbWVudHMgKTtcblx0dmFyIHRhbmcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBiaXRhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XG5cblx0XHRncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHR1YnVsYXJTZWdtZW50cyApO1xuXHRcdHZhciB1ID0gaSAvIHJhZGlhbFNlZ21lbnRzICogMiAqIHAgKiBNYXRoLlBJO1xuXHRcdHZhciBwMSA9IGdldFBvcyggdSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuXHRcdHZhciBwMiA9IGdldFBvcyggdSArIDAuMDEsIHEsIHAsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKTtcblx0XHR0YW5nLnN1YlZlY3RvcnMoIHAyLCBwMSApO1xuXHRcdG4uYWRkVmVjdG9ycyggcDIsIHAxICk7XG5cblx0XHRiaXRhbi5jcm9zc1ZlY3RvcnMoIHRhbmcsIG4gKTtcblx0XHRuLmNyb3NzVmVjdG9ycyggYml0YW4sIHRhbmcgKTtcblx0XHRiaXRhbi5ub3JtYWxpemUoKTtcblx0XHRuLm5vcm1hbGl6ZSgpO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xuXG5cdFx0XHR2YXIgdiA9IGogLyB0dWJ1bGFyU2VnbWVudHMgKiAyICogTWF0aC5QSTtcblx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG5cdFx0XHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuXHRcdFx0dmFyIHBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0XHRwb3MueCA9IHAxLnggKyBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcblx0XHRcdHBvcy55ID0gcDEueSArIGN4ICogbi55ICsgY3kgKiBiaXRhbi55O1xuXHRcdFx0cG9zLnogPSBwMS56ICsgY3ggKiBuLnogKyBjeSAqIGJpdGFuLno7XG5cblx0XHRcdGdyaWRbIGkgXVsgaiBdID0gdGhpcy52ZXJ0aWNlcy5wdXNoKCBwb3MgKSAtIDE7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHJhZGlhbFNlZ21lbnRzOyArKyBpICkge1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdHVidWxhclNlZ21lbnRzOyArKyBqICkge1xuXG5cdFx0XHR2YXIgaXAgPSAoIGkgKyAxICkgJSByYWRpYWxTZWdtZW50cztcblx0XHRcdHZhciBqcCA9ICggaiArIDEgKSAlIHR1YnVsYXJTZWdtZW50cztcblxuXHRcdFx0dmFyIGEgPSBncmlkWyBpIF1bIGogXTtcblx0XHRcdHZhciBiID0gZ3JpZFsgaXAgXVsgaiBdO1xuXHRcdFx0dmFyIGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuXHRcdFx0dmFyIGQgPSBncmlkWyBpIF1bIGpwIF07XG5cblx0XHRcdHZhciB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCBqIC8gdHVidWxhclNlZ21lbnRzICk7XG5cdFx0XHR2YXIgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblx0XHRcdHZhciB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRmdW5jdGlvbiBnZXRQb3MoIHUsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XG5cblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xuXHRcdHZhciBzdSA9IE1hdGguc2luKCB1ICk7XG5cdFx0dmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XG5cdFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcblxuXHRcdHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcblx0XHR2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG5cdFx0dmFyIHR6ID0gaGVpZ2h0U2NhbGUgKiByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxuICpcbiAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcbiAqXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxuICpcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cbiAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxuICovXG5cblRIUkVFLlR1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRwYXRoOiBwYXRoLFxuXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG5cdFx0Y2xvc2VkOiBjbG9zZWQsXG5cdFx0dGFwZXI6IHRhcGVyXG5cdH07XG5cblx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcblx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XG5cdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcblx0Y2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuXHR0YXBlciA9IHRhcGVyIHx8IFRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyO1xuXG5cdHZhciBncmlkID0gW107XG5cblx0dmFyIHNjb3BlID0gdGhpcyxcblxuXHRcdHRhbmdlbnQsXG5cdFx0bm9ybWFsLFxuXHRcdGJpbm9ybWFsLFxuXG5cdFx0bnVtcG9pbnRzID0gc2VnbWVudHMgKyAxLFxuXG5cdFx0dSwgdiwgcixcblxuXHRcdGN4LCBjeSxcblx0XHRwb3MsIHBvczIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdGksIGosXG5cdFx0aXAsIGpwLFxuXHRcdGEsIGIsIGMsIGQsXG5cdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xuXG5cdHZhciBmcmFtZXMgPSBuZXcgVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApLFxuXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxuXHRcdG5vcm1hbHMgPSBmcmFtZXMubm9ybWFscyxcblx0XHRiaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG5cdC8vIHByb3h5IGludGVybmFsc1xuXHR0aGlzLnRhbmdlbnRzID0gdGFuZ2VudHM7XG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG5cdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XG5cblx0XHRyZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcblxuXHR9XG5cblx0Ly8gY29uc3RydWN0IHRoZSBncmlkXG5cblx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cblx0XHRncmlkWyBpIF0gPSBbXTtcblxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xuXHRcdG5vcm1hbCA9IG5vcm1hbHNbIGkgXTtcblx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG5cdFx0ciA9IHJhZGl1cyAqIHRhcGVyKCB1ICk7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHR2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cblx0XHRcdGN4ID0gLSByICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cblx0XHRcdGN5ID0gciAqIE1hdGguc2luKCB2ICk7XG5cblx0XHRcdHBvczIuY29weSggcG9zICk7XG5cdFx0XHRwb3MyLnggKz0gY3ggKiBub3JtYWwueCArIGN5ICogYmlub3JtYWwueDtcblx0XHRcdHBvczIueSArPSBjeCAqIG5vcm1hbC55ICsgY3kgKiBiaW5vcm1hbC55O1xuXHRcdFx0cG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XG5cblx0XHRcdGdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXG5cdC8vIGNvbnN0cnVjdCB0aGUgbWVzaFxuXG5cdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG5cdFx0XHRpcCA9ICggY2xvc2VkICkgPyAoIGkgKyAxICkgJSBzZWdtZW50cyA6IGkgKyAxO1xuXHRcdFx0anAgPSAoIGogKyAxICkgJSByYWRpYWxTZWdtZW50cztcblxuXHRcdFx0YSA9IGdyaWRbIGkgXVsgaiBdO1x0XHQvLyAqKiogTk9UIE5FQ0VTU0FSSUxZIFBMQU5BUiAhICoqKlxuXHRcdFx0YiA9IGdyaWRbIGlwIF1bIGogXTtcblx0XHRcdGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuXHRcdFx0ZCA9IGdyaWRbIGkgXVsganAgXTtcblxuXHRcdFx0dXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuXHRcdFx0dXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVHViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlR1YmVHZW9tZXRyeTtcblxuVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0cmV0dXJuIDE7XG5cbn07XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cblx0cmV0dXJuIE1hdGguc2luKCBNYXRoLlBJICogdSApO1xuXG59O1xuXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcblRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMgPSBmdW5jdGlvbiAoIHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQgKSB7XG5cblx0dmFyXHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG5cdFx0dGFuZ2VudHMgPSBbXSxcblx0XHRub3JtYWxzID0gW10sXG5cdFx0Ymlub3JtYWxzID0gW10sXG5cblx0XHR2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXHRcdG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cblx0XHRudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG5cdFx0dGhldGEsXG5cdFx0c21hbGxlc3QsXG5cblx0XHR0eCwgdHksIHR6LFxuXHRcdGksIHU7XG5cblxuXHQvLyBleHBvc2UgaW50ZXJuYWxzXG5cdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcblx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cblx0Ly8gY29tcHV0ZSB0aGUgdGFuZ2VudCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcblxuXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XG5cblx0XHR0YW5nZW50c1sgaSBdID0gcGF0aC5nZXRUYW5nZW50QXQoIHUgKTtcblx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xuXG5cdH1cblxuXHRpbml0aWFsTm9ybWFsMygpO1xuXG5cdC8qXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xuXHRcdC8vIGZpeGVkIHN0YXJ0IGJpbm9ybWFsLiBIYXMgZGFuZ2VycyBvZiAwIHZlY3RvcnNcblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRpZiAobGFzdEJpbm9ybWFsPT09dW5kZWZpbmVkKSBsYXN0Qmlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcblxuXHRcdC8vIFRoaXMgdXNlcyB0aGUgRnJlbmV0LVNlcnJldCBmb3JtdWxhIGZvciBkZXJpdmluZyBiaW5vcm1hbFxuXHRcdHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBiaW5vcm1hbHNbIDAgXSwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpOyAvLyBsYXN0IGJpbm9ybWFsIHggdGFuZ2VudFxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cblx0fVxuXHQqL1xuXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xuXG5cdFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3Rvcixcblx0XHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlc3QgdGFuZ2VudCB4eXogY29tcG9uZW50XG5cblx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0XHRzbWFsbGVzdCA9IE51bWJlci5NQVhfVkFMVUU7XG5cdFx0dHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG5cdFx0dHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XG5cdFx0dHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XG5cblx0XHRpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xuXG5cdFx0XHRzbWFsbGVzdCA9IHR4O1xuXHRcdFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcblxuXHRcdFx0c21hbGxlc3QgPSB0eTtcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdHogPD0gc21hbGxlc3QgKSB7XG5cblx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblxuXHRcdH1cblxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbCApLm5vcm1hbGl6ZSgpO1xuXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XG5cdFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuXHR9XG5cblxuXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG5cdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0bm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG5cdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cblx0XHRpZiAoIHZlYy5sZW5ndGgoKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG5cdFx0XHR2ZWMubm9ybWFsaXplKCk7XG5cblx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG5cdFx0XHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XG5cblx0XHR9XG5cblx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdH1cblxuXG5cdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcblxuXHRpZiAoIGNsb3NlZCApIHtcblxuXHRcdHRoZXRhID0gTWF0aC5hY29zKCBUSFJFRS5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSwgLSAxLCAxICkgKTtcblx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcblxuXHRcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgbnVtcG9pbnRzIC0gMSBdICkgKSA+IDAgKSB7XG5cblx0XHRcdHRoZXRhID0gLSB0aGV0YTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG5cdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XG5cdFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHR2ZXJ0aWNlczogdmVydGljZXMsXG5cdFx0aW5kaWNlczogaW5kaWNlcyxcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cblx0fVxuXG5cdHZhciBwID0gdGhpcy52ZXJ0aWNlcztcblxuXHR2YXIgZmFjZXMgPSBbXTtcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGogKysgKSB7XG5cblx0XHR2YXIgdjEgPSBwWyBpbmRpY2VzWyBpIF0gXTtcblx0XHR2YXIgdjIgPSBwWyBpbmRpY2VzWyBpICsgMSBdIF07XG5cdFx0dmFyIHYzID0gcFsgaW5kaWNlc1sgaSArIDIgXSBdO1xuXG5cdFx0ZmFjZXNbIGogXSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgaiApO1xuXG5cdH1cblxuXHR2YXIgY2VudHJvaWQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRzdWJkaXZpZGUoIGZhY2VzWyBpIF0sIGRldGFpbCApO1xuXG5cdH1cblxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gZmFjZSBzdHJhZGRsZXMgdGhlIHNlYW1cblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cblx0XHR2YXIgeDAgPSB1dnNbIDAgXS54O1xuXHRcdHZhciB4MSA9IHV2c1sgMSBdLng7XG5cdFx0dmFyIHgyID0gdXZzWyAyIF0ueDtcblxuXHRcdHZhciBtYXggPSBNYXRoLm1heCggeDAsIHgxLCB4MiApO1xuXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggeDAsIHgxLCB4MiApO1xuXG5cdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG5cdFx0XHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XG5cblx0XHRcdGlmICggeDAgPCAwLjIgKSB1dnNbIDAgXS54ICs9IDE7XG5cdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xuXHRcdFx0aWYgKCB4MiA8IDAuMiApIHV2c1sgMiBdLnggKz0gMTtcblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBcHBseSByYWRpdXNcblxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG5cdH1cblxuXG5cdC8vIE1lcmdlIHZlcnRpY2VzXG5cblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cblx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cblxuXHQvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcblxuXHRmdW5jdGlvbiBwcmVwYXJlKCB2ZWN0b3IgKSB7XG5cblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XG5cdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XG5cblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXG5cblx0XHR2YXIgdSA9IGF6aW11dGgoIHZlY3RvciApIC8gMiAvIE1hdGguUEkgKyAwLjU7XG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xuXHRcdHZlcnRleC51diA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApO1xuXG5cdFx0cmV0dXJuIHZlcnRleDtcblxuXHR9XG5cblxuXHQvLyBBcHByb3hpbWF0ZSBhIGN1cnZlZCBmYWNlIHdpdGggcmVjdXJzaXZlbHkgc3ViLWRpdmlkZWQgdHJpYW5nbGVzLlxuXG5cdGZ1bmN0aW9uIG1ha2UoIHYxLCB2MiwgdjMsIG1hdGVyaWFsSW5kZXggKSB7XG5cblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0sIHVuZGVmaW5lZCwgbWF0ZXJpYWxJbmRleCApO1xuXHRcdHRoYXQuZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0Y2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xuXG5cdFx0dmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cblx0XHR0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cdFx0XHRjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXG5cdFx0XHRjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXG5cdFx0XHRjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcblx0XHRdICk7XG5cblx0fVxuXG5cblx0Ly8gQW5hbHl0aWNhbGx5IHN1YmRpdmlkZSBhIGZhY2UgdG8gdGhlIHJlcXVpcmVkIGRldGFpbCBsZXZlbC5cblxuXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcblxuXHRcdHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xuXHRcdHZhciBhID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcblx0XHR2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XG5cdFx0dmFyIGMgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXHRcdHZhciB2ID0gW107XG5cblx0XHR2YXIgbWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcblxuXHRcdC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIHZlcnRpY2VzIGZvciB0aGlzIHN1YmRpdmlzaW9uLlxuXG5cdFx0Zm9yICggdmFyIGkgPSAwIDsgaSA8PSBjb2xzOyBpICsrICkge1xuXG5cdFx0XHR2WyBpIF0gPSBbXTtcblxuXHRcdFx0dmFyIGFqID0gcHJlcGFyZSggYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcblx0XHRcdHZhciBiaiA9IHByZXBhcmUoIGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XG5cdFx0XHR2YXIgcm93cyA9IGNvbHMgLSBpO1xuXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcblxuXHRcdFx0XHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcblxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gcHJlcGFyZSggYWouY2xvbmUoKS5sZXJwKCBiaiwgaiAvIHJvd3MgKSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb2xzIDsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG5cdFx0XHRcdGlmICggaiAlIDIgPT09IDAgKSB7XG5cblx0XHRcdFx0XHRtYWtlKFxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxuXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdLFxuXHRcdFx0XHRcdFx0dlsgaSBdWyBrIF0sXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWFrZShcblx0XHRcdFx0XHRcdHZbIGkgXVsgayArIDEgXSxcblx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgKyAxIF0sXG5cdFx0XHRcdFx0XHR2WyBpICsgMSBdWyBrIF0sXG5cdFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cblx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cblx0fVxuXG5cblx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG5cdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuXHR9XG5cblxuXHQvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG5cdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcblx0XHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcblx0XHRyZXR1cm4gdXYuY2xvbmUoKTtcblxuXHR9XG5cblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuICovXG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXHR2YXIgciA9IDEgLyB0O1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblxuXHRcdC8vICjCsTEsIMKxMSwgwrExKVxuXHRcdC0gMSwgLSAxLCAtIDEsICAgIC0gMSwgLSAxLCAgMSxcblx0XHQtIDEsICAxLCAtIDEsICAgIC0gMSwgIDEsICAxLFxuXHRcdCAxLCAtIDEsIC0gMSwgICAgIDEsIC0gMSwgIDEsXG5cdFx0IDEsICAxLCAtIDEsICAgICAxLCAgMSwgIDEsXG5cblx0XHQvLyAoMCwgwrExL8+GLCDCsc+GKVxuXHRcdCAwLCAtIHIsIC0gdCwgICAgIDAsIC0gciwgIHQsXG5cdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXG5cblx0XHQvLyAowrExL8+GLCDCsc+GLCAwKVxuXHRcdC0gciwgLSB0LCAgMCwgICAgLSByLCAgdCwgIDAsXG5cdFx0IHIsIC0gdCwgIDAsICAgICByLCAgdCwgIDAsXG5cblx0XHQvLyAowrHPhiwgMCwgwrExL8+GKVxuXHRcdC0gdCwgIDAsIC0gciwgICAgIHQsICAwLCAtIHIsXG5cdFx0LSB0LCAgMCwgIHIsICAgICB0LCAgMCwgIHJcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXG5cdFx0IDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxuXHRcdDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcblx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXG5cdFx0IDAsIDEyLCAgMSwgICAgICAwLCAgMSwgMTgsICAgICAgMCwgMTgsIDE2LFxuXHRcdCA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcblx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXG5cdFx0MTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxuXHRcdCA0LCAxNCwgMTIsICAgICAgNCwgMTIsICAwLCAgICAgIDQsICAwLCAgOCxcblx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXG5cdFx0MTksICA1LCAxNCwgICAgIDE5LCAxNCwgIDQsICAgICAxOSwgIDQsIDE3LFxuXHRcdCAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxuXHRdO1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRyYWRpdXM6IHJhZGl1cyxcblx0XHRkZXRhaWw6IGRldGFpbFxuXHR9O1xuXG59O1xuXG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG5cdHZhciB2ZXJ0aWNlcyA9IFtcblx0XHQtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcblx0XHQgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcblx0XHQgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuXHRdO1xuXG5cdHZhciBpbmRpY2VzID0gW1xuXHRcdCAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcblx0XHQgMSwgIDUsICA5LCAgICA1LCAxMSwgIDQsICAgMTEsIDEwLCAgMiwgICAxMCwgIDcsICA2LCAgICA3LCAgMSwgIDgsXG5cdFx0IDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxuXHRcdCA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuXHRdO1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cblx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuXHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdGRldGFpbDogZGV0YWlsXG5cdH07XG5cbn07XG5cblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuXHR2YXIgdmVydGljZXMgPSBbXG5cdFx0MSwgMCwgMCwgICAtIDEsIDAsIDAsICAgIDAsIDEsIDAsICAgIDAsIC0gMSwgMCwgICAgMCwgMCwgMSwgICAgMCwgMCwgLSAxXG5cdF07XG5cblx0dmFyIGluZGljZXMgPSBbXG5cdFx0MCwgMiwgNCwgICAgMCwgNCwgMywgICAgMCwgMywgNSwgICAgMCwgNSwgMiwgICAgMSwgMiwgNSwgICAgMSwgNSwgMywgICAgMSwgMywgNCwgICAgMSwgNCwgMlxuXHRdO1xuXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuXHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxufTtcblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLk9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PY3RhaGVkcm9uR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RldHJhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XG5cblx0dmFyIHZlcnRpY2VzID0gW1xuXHRcdCAxLCAgMSwgIDEsICAgLSAxLCAtIDEsICAxLCAgIC0gMSwgIDEsIC0gMSwgICAgMSwgLSAxLCAtIDFcblx0XTtcblxuXHR2YXIgaW5kaWNlcyA9IFtcblx0XHQgMiwgIDEsICAwLCAgICAwLCAgMywgIDIsICAgIDEsICAzLCAgMCwgICAgMiwgIDMsICAxXG5cdF07XG5cblx0VEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG5cdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcblxuXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG5cdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0ZGV0YWlsOiBkZXRhaWxcblx0fTtcblxufTtcblxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XG4gKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICpcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XG4gKlxuICovXG5cblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG5cdHRoaXMucGFyYW1ldGVycyA9IHtcblx0XHRmdW5jOiBmdW5jLFxuXHRcdHNsaWNlczogc2xpY2VzLFxuXHRcdHN0YWNrczogc3RhY2tzXG5cdH07XG5cblx0dmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcblx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcblx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG5cdHZhciBpLCBqLCBwO1xuXHR2YXIgdSwgdjtcblxuXHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cblx0Zm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xuXG5cdFx0diA9IGkgLyBzdGFja3M7XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XG5cblx0XHRcdHUgPSBqIC8gc2xpY2VzO1xuXG5cdFx0XHRwID0gZnVuYyggdSwgdiApO1xuXHRcdFx0dmVydHMucHVzaCggcCApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHR2YXIgYSwgYiwgYywgZDtcblx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcblxuXHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcblxuXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG5cdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xuXHRcdFx0YiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XG5cdFx0XHRjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuXHRcdFx0ZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xuXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuXHRcdFx0dXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuXHRcdFx0dXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG5cblx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG5cdFx0XHR1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuXHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblx0XHRcdHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gY29uc29sZS5sb2codGhpcyk7XG5cblx0Ly8gbWFnaWMgYnVsbGV0XG5cdC8vIHZhciBkaWZmID0gdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cdC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuXHRUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cblx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuXG5cdGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdHJldHVybiBhIC0gYjtcblxuXHR9XG5cblx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuXHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cblx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcblx0XHR2YXIgbnVtRWRnZXMgPSAwO1xuXG5cdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG5cdFx0dmFyIGVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KCA2ICogZmFjZXMubGVuZ3RoICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG5cdFx0XHRcdGVkZ2VbIDEgXSA9IGZhY2VbIGtleXNbICggaiArIDEgKSAlIDMgXSBdO1xuXHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG5cdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cblx0XHRcdFx0aWYgKCBoYXNoWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuXHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG5cdFx0XHRcdFx0aGFzaFsga2V5IF0gPSB0cnVlO1xuXHRcdFx0XHRcdG51bUVkZ2VzICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMjsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqIF0gXTtcblxuXHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuXHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGV4Lng7XG5cdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcblx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRleC56O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuXHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG5cdFx0XHR2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4LmFycmF5O1xuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cdFx0XHR2YXIgbnVtRWRnZXMgPSAwO1xuXG5cdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG5cdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG5cdFx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG5cdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgbyBdO1xuXG5cdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuXHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0ZWRnZVsgMCBdID0gaW5kaWNlc1sgaSArIGogXTtcblx0XHRcdFx0XHRcdGVkZ2VbIDEgXSA9IGluZGljZXNbIGkgKyAoIGogKyAxICkgJSAzIF07XG5cdFx0XHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG5cdFx0XHRcdFx0XHR2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzICsgMSBdID0gZWRnZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRoYXNoWyBrZXkgXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdG51bUVkZ2VzICsrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KCBudW1FZGdlcyAqIDIgKiAzICk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcblx0XHRcdFx0XHR2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xuXG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblx0XHRcdHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG5cdFx0XHR2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcblxuXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG5cdFx0XHRcdFx0dmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XG5cdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcblxuXHRcdFx0XHRcdHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcblx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xuXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuXHRcdH1cblxuXHR9XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG5cblx0c2l6ZSA9IHNpemUgfHwgMTtcblxuXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MCwgMCwgMCwgIHNpemUsIDAsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIHNpemUsIDAsXG5cdFx0MCwgMCwgMCwgIDAsIDAsIHNpemVcblx0XSApO1xuXG5cdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcblx0XHQwLCAxLCAwLCAgMC42LCAxLCAwLFxuXHRcdDAsIDAsIDEsICAwLCAwLjYsIDFcblx0XSApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcblx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAqXG4gKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXG4gKlxuICogUGFyYW1ldGVyczpcbiAqICBkaXIgLSBWZWN0b3IzXG4gKiAgb3JpZ2luIC0gVmVjdG9yM1xuICogIGxlbmd0aCAtIE51bWJlclxuICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXG4gKiAgaGVhZExlbmd0aCAtIE51bWJlclxuICogIGhlYWRXaWR0aCAtIE51bWJlclxuICovXG5cblRIUkVFLkFycm93SGVscGVyID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xuXG5cdHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XG5cdGNvbmVHZW9tZXRyeS50cmFuc2xhdGUoIDAsIC0gMC41LCAwICk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG5cdFx0Ly8gZGlyIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG5cdFx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcblx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcblx0XHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG5cdFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cblx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xuXHRcdFxuXHRcdHRoaXMubGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cdFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblx0XHR0aGlzLmFkZCggdGhpcy5saW5lICk7XG5cblx0XHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXHRcdHRoaXMuY29uZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG5cdFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuXHRcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xuXG5cdH1cblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXJyb3dIZWxwZXI7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciByYWRpYW5zO1xuXG5cdHJldHVybiBmdW5jdGlvbiBzZXREaXJlY3Rpb24oIGRpciApIHtcblxuXHRcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuXHRcdGlmICggZGlyLnkgPiAwLjk5OTk5ICkge1xuXG5cdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XG5cblx0XHR9IGVsc2UgaWYgKCBkaXIueSA8IC0gMC45OTk5OSApIHtcblxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XG5cblx0XHRcdHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XG5cblx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XG5cblx0XHR9XG5cblx0fTtcblxufSgpICk7XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG5cdGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcblx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cblx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApO1xuXHR0aGlzLmxpbmUudXBkYXRlTWF0cml4KCk7XG5cblx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XG5cdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcblxufTtcblxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcblxuXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCBjb2xvciApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Cb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkJveEhlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xuXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZjAwIH0gKSApO1xuXG5cdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHR0aGlzLnVwZGF0ZSggb2JqZWN0ICk7XG5cblx0fVxuXG59O1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEhlbHBlcjtcblxuVEhSRUUuQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0XHRib3guc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XG5cblx0XHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XG5cblx0XHR2YXIgbWluID0gYm94Lm1pbjtcblx0XHR2YXIgbWF4ID0gYm94Lm1heDtcblxuXHRcdC8qXG5cdFx0ICA1X19fXzRcblx0XHQxL19fXzAvfFxuXHRcdHwgNl9ffF83XG5cdFx0Mi9fX18zL1xuXG5cdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuXHRcdDE6IG1pbi54LCBtYXgueSwgbWF4Lnpcblx0XHQyOiBtaW4ueCwgbWluLnksIG1heC56XG5cdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuXHRcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcblx0XHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XG5cdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuXHRcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcblx0XHQqL1xuXG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdHZhciBhcnJheSA9IHBvc2l0aW9uLmFycmF5O1xuXG5cdFx0YXJyYXlbICAwIF0gPSBtYXgueDsgYXJyYXlbICAxIF0gPSBtYXgueTsgYXJyYXlbICAyIF0gPSBtYXguejtcblx0XHRhcnJheVsgIDMgXSA9IG1pbi54OyBhcnJheVsgIDQgXSA9IG1heC55OyBhcnJheVsgIDUgXSA9IG1heC56O1xuXHRcdGFycmF5WyAgNiBdID0gbWluLng7IGFycmF5WyAgNyBdID0gbWluLnk7IGFycmF5WyAgOCBdID0gbWF4Lno7XG5cdFx0YXJyYXlbICA5IF0gPSBtYXgueDsgYXJyYXlbIDEwIF0gPSBtaW4ueTsgYXJyYXlbIDExIF0gPSBtYXguejtcblx0XHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xuXHRcdGFycmF5WyAxNSBdID0gbWluLng7IGFycmF5WyAxNiBdID0gbWF4Lnk7IGFycmF5WyAxNyBdID0gbWluLno7XG5cdFx0YXJyYXlbIDE4IF0gPSBtaW4ueDsgYXJyYXlbIDE5IF0gPSBtaW4ueTsgYXJyYXlbIDIwIF0gPSBtaW4uejtcblx0XHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xuXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuXHR9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG5cdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG5cdHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cbn07XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xuXG5cdHRoaXMuYm94LnNpemUoIHRoaXMuc2NhbGUgKTtcblxuXHR0aGlzLmJveC5jZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gKlx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gKiBcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcbiAqXHRcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcbiAqL1xuXG5USFJFRS5DYW1lcmFIZWxwZXIgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzIH0gKTtcblxuXHR2YXIgcG9pbnRNYXAgPSB7fTtcblxuXHQvLyBjb2xvcnNcblxuXHR2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xuXHR2YXIgaGV4Q29uZSA9IDB4ZmYwMDAwO1xuXHR2YXIgaGV4VXAgPSAweDAwYWFmZjtcblx0dmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xuXHR2YXIgaGV4Q3Jvc3MgPSAweDMzMzMzMztcblxuXHQvLyBuZWFyXG5cblx0YWRkTGluZSggXCJuMVwiLCBcIm4yXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuM1wiLCBcIm4xXCIsIGhleEZydXN0dW0gKTtcblxuXHQvLyBmYXJcblxuXHRhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcImYyXCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcImY0XCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuXHRhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuXG5cdC8vIHNpZGVzXG5cblx0YWRkTGluZSggXCJuMVwiLCBcImYxXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcblx0YWRkTGluZSggXCJuNFwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcblxuXHQvLyBjb25lXG5cblx0YWRkTGluZSggXCJwXCIsIFwibjFcIiwgaGV4Q29uZSApO1xuXHRhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBoZXhDb25lICk7XG5cdGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcblx0YWRkTGluZSggXCJwXCIsIFwibjRcIiwgaGV4Q29uZSApO1xuXG5cdC8vIHVwXG5cblx0YWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XG5cdGFkZExpbmUoIFwidTJcIiwgXCJ1M1wiLCBoZXhVcCApO1xuXHRhZGRMaW5lKCBcInUzXCIsIFwidTFcIiwgaGV4VXAgKTtcblxuXHQvLyB0YXJnZXRcblxuXHRhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xuXHRhZGRMaW5lKCBcInBcIiwgXCJjXCIsIGhleENyb3NzICk7XG5cblx0Ly8gY3Jvc3NcblxuXHRhZGRMaW5lKCBcImNuMVwiLCBcImNuMlwiLCBoZXhDcm9zcyApO1xuXHRhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBoZXhDcm9zcyApO1xuXG5cdGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XG5cdGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XG5cblx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgaGV4ICkge1xuXG5cdFx0YWRkUG9pbnQoIGEsIGhleCApO1xuXHRcdGFkZFBvaW50KCBiLCBoZXggKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBoZXggKSB7XG5cblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG5cdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggaGV4ICkgKTtcblxuXHRcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cG9pbnRNYXBbIGlkIF0gPSBbXTtcblxuXHRcdH1cblxuXHRcdHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblxuXHR9XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuXHR0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cblx0dGhpcy5tYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5DYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYUhlbHBlcjtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcblxuXHR2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIGNhbWVyYSA9IG5ldyBUSFJFRS5DYW1lcmEoKTtcblxuXHRmdW5jdGlvbiBzZXRQb2ludCggcG9pbnQsIHgsIHksIHogKSB7XG5cblx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuXHRcdHZhciBwb2ludHMgPSBwb2ludE1hcFsgcG9pbnQgXTtcblxuXHRcdGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIHBvaW50c1sgaSBdIF0uY29weSggdmVjdG9yICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cblx0XHR2YXIgdyA9IDEsIGggPSAxO1xuXG5cdFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxuXHRcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cblx0XHRjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cblx0XHQvLyBjZW50ZXIgLyB0YXJnZXRcblxuXHRcdHNldFBvaW50KCBcImNcIiwgMCwgMCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwidFwiLCAwLCAwLCAgMSApO1xuXG5cdFx0Ly8gbmVhclxuXG5cdFx0c2V0UG9pbnQoIFwibjFcIiwgLSB3LCAtIGgsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcIm4yXCIsICAgdywgLSBoLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJuM1wiLCAtIHcsICAgaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwibjRcIiwgICB3LCAgIGgsIC0gMSApO1xuXG5cdFx0Ly8gZmFyXG5cblx0XHRzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCBcImYyXCIsICAgdywgLSBoLCAxICk7XG5cdFx0c2V0UG9pbnQoIFwiZjNcIiwgLSB3LCAgIGgsIDEgKTtcblx0XHRzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xuXG5cdFx0Ly8gdXBcblxuXHRcdHNldFBvaW50KCBcInUxXCIsICAgdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwidTJcIiwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJ1M1wiLCAgICAgICAgIDAsIGggKiAyLCAgIC0gMSApO1xuXG5cdFx0Ly8gY3Jvc3NcblxuXHRcdHNldFBvaW50KCBcImNmMVwiLCAtIHcsICAgMCwgMSApO1xuXHRcdHNldFBvaW50KCBcImNmMlwiLCAgIHcsICAgMCwgMSApO1xuXHRcdHNldFBvaW50KCBcImNmM1wiLCAgIDAsIC0gaCwgMSApO1xuXHRcdHNldFBvaW50KCBcImNmNFwiLCAgIDAsICAgaCwgMSApO1xuXG5cdFx0c2V0UG9pbnQoIFwiY24xXCIsIC0gdywgICAwLCAtIDEgKTtcblx0XHRzZXRQb2ludCggXCJjbjJcIiwgICB3LCAgIDAsIC0gMSApO1xuXHRcdHNldFBvaW50KCBcImNuM1wiLCAgIDAsIC0gaCwgLSAxICk7XG5cdFx0c2V0UG9pbnQoIFwiY240XCIsICAgMCwgICBoLCAtIDEgKTtcblxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0fTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc2l6ZSApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0c2l6ZSA9IHNpemUgfHwgMTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblx0Z2VvbWV0cnkudmVydGljZXMucHVzaChcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAgIHNpemUsIDAgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAtIHNpemUsIDAgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAtIHNpemUsIDAgKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKVxuXHQpO1xuXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdHRoaXMubGlnaHRQbGFuZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xuXG5cdGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSxcblx0XHRuZXcgVEhSRUUuVmVjdG9yMygpXG5cdCk7XG5cblx0bWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHR0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcblxuXHR0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdjMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cblx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcblx0XHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cdFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XG5cblx0XHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xuXHRcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB2MyApO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXHRcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IgKTtcblxuXHR9O1xuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0VkZ2VzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAcGFyYW0gb2JqZWN0IFRIUkVFLk1lc2ggd2hvc2UgZ2VvbWV0cnkgd2lsbCBiZSB1c2VkXG4gKiBAcGFyYW0gaGV4IGxpbmUgY29sb3JcbiAqIEBwYXJhbSB0aHJlc2hvbGRBbmdsZSB0aGUgbWluaW11bSBhbmdsZSAoaW4gZGVncmVlcyksXG4gKiBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgYWRqYWNlbnQgZmFjZXMsXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIHJlbmRlciBhbiBlZGdlLiBBIHZhbHVlIG9mIDEwIG1lYW5zXG4gKiBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIGlzIGF0IGxlYXN0IDEwIGRlZ3JlZXMuXG4gKi9cblxuVEhSRUUuRWRnZXNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmZmZjtcblxuXHRUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgbmV3IFRIUkVFLkVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSwgbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcblxuXHR0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkVkZ2VzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzSGVscGVyO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9GYWNlTm9ybWFsc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG5cdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcblxuXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cblx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cblx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuXHQvL1xuXG5cdHZhciBuTm9ybWFscyA9IDA7XG5cblx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0aWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xuXG5cdH1cblxuXHQvL1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG5cdC8vXG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuXHRcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cblx0XHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHQvL1xuXG5cdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cblx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuXHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0dmFyIGlkeCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuXHRcdFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcblx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYiBdIClcblx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcblx0XHRcdFx0LmRpdmlkZVNjYWxhciggMyApXG5cdFx0XHRcdC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cblx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuXHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdH1cblxuXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH1cblxufSgpICk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0dyaWRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdyaWRIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUsIHN0ZXAgKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cblx0dGhpcy5jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoIDB4NDQ0NDQ0ICk7XG5cdHRoaXMuY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCAweDg4ODg4OCApO1xuXG5cdGZvciAoIHZhciBpID0gLSBzaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcblxuXHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAwLCBpICksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAwLCBpICksXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLSBzaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcblx0XHQpO1xuXG5cdFx0dmFyIGNvbG9yID0gaSA9PT0gMCA/IHRoaXMuY29sb3IxIDogdGhpcy5jb2xvcjI7XG5cblx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuXHR9XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JpZEhlbHBlcjtcblxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xuXG5cdHRoaXMuY29sb3IxLnNldCggY29sb3JDZW50ZXJMaW5lICk7XG5cdHRoaXMuY29sb3IyLnNldCggY29sb3JHcmlkICk7XG5cblx0dGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5saWdodCA9IGxpZ2h0O1xuXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy5jb2xvcnMgPSBbIG5ldyBUSFJFRS5Db2xvcigpLCBuZXcgVEhSRUUuQ29sb3IoKSBdO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuXHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XG5cblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IDg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdGdlb21ldHJ5LmZhY2VzWyBpIF0uY29sb3IgPSB0aGlzLmNvbG9yc1sgaSA8IDQgPyAwIDogMSBdO1xuXG5cdH1cblxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzLCB3aXJlZnJhbWU6IHRydWUgfSApO1xuXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlcjtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdHRoaXMuY29sb3JzWyAwIF0uY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXHRcdHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdFx0dGhpcy5saWdodFNwaGVyZS5sb29rQXQoIHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKSApO1xuXHRcdHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XG5cblx0fVxuXG59KCk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1BvaW50TGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG5cdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDQsIDIgKTtcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG5cdHRoaXMubWF0cml4ID0gdGhpcy5saWdodC5tYXRyaXhXb3JsZDtcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0Lypcblx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xuXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xuXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xuXG5cdHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XG5cblx0aWYgKCBkID09PSAwLjAgKSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG5cdH0gZWxzZSB7XG5cblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcblx0Ki9cblxufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludExpZ2h0SGVscGVyO1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxufTtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdC8qXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcblxuXHRpZiAoIGQgPT09IDAuMCApIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XG5cblx0fVxuXHQqL1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Ta2VsZXRvbkhlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXG4gKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLlNrZWxldG9uSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cblx0dGhpcy5ib25lcyA9IHRoaXMuZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cblx0XHRpZiAoIGJvbmUucGFyZW50IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcblxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXHRcdFx0Z2VvbWV0cnkuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggMCwgMCwgMSApICk7XG5cdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAxLCAwICkgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VvbWV0cnkuZHluYW1pYyA9IHRydWU7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVEhSRUUuVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuXHR0aGlzLnJvb3QgPSBvYmplY3Q7XG5cblx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tlbGV0b25IZWxwZXI7XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cblx0dmFyIGJvbmVMaXN0ID0gW107XG5cblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cblx0fVxuXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG5cdH1cblxuXHRyZXR1cm4gYm9uZUxpc3Q7XG5cbn07XG5cblRIUkVFLlNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG5cdHZhciBib25lTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR2YXIgaiA9IDA7XG5cblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuXHRcdGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLm1hdHJpeFdvcmxkICk7XG5cdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG5cdFx0XHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNbIGogKyAxIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cblx0XHRcdGogKz0gMjtcblxuXHRcdH1cblxuXHR9XG5cblx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvU3BvdExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlNwb3RMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQgKSB7XG5cblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcblx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG5cdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAxLCAxLCA4LCAxLCB0cnVlICk7XG5cblx0Z2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xuXHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XG5cblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XG5cblx0dGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodEhlbHBlcjtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG5cdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG5cbn07XG5cblRIUkVFLlNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXHR2YXIgdmVjdG9yMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcblx0XHR2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCB0aGlzLmxpZ2h0LmFuZ2xlICk7XG5cblx0XHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xuXG5cdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuXHRcdHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuXG5cdFx0dGhpcy5jb25lLmxvb2tBdCggdmVjdG9yMi5zdWIoIHZlY3RvciApICk7XG5cblx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG5cdH07XG5cbn0oKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvVmVydGV4Tm9ybWFsc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XG5cblx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XG5cblx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmYwMDAwO1xuXG5cdHZhciB3aWR0aCA9ICggbGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSA/IGxpbmV3aWR0aCA6IDE7XG5cblx0Ly9cblxuXHR2YXIgbk5vcm1hbHMgPSAwO1xuXG5cdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG5cdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuXHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudFxuXG5cdH1cblxuXHQvL1xuXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG5cdHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG5cdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG5cblx0VEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG5cdC8vXG5cblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cblx0dGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXI7XG5cblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG5cdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuXHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cblx0XHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcblxuXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdC8vXG5cblx0XHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcblxuXHRcdGlmICggb2JqR2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XG5cblx0XHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG5cdFx0XHR2YXIgaWR4ID0gMDtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZmFjZVsga2V5c1sgaiBdIF0gXTtcblxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuXHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHRcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcblxuXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cblx0XHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcblxuXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdFx0dmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuXHRcdFx0dmFyIGlkeCA9IDA7XG5cblx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuXHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuXHRcdFx0XHR2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cblx0XHRcdFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcblxuXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG5cdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cblx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fVxuXG59KCkgKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG5cdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG5cdFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXG5cdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVIZWxwZXI7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxufTtcblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdDtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvTW9ycGhCbGVuZE1lc2guanNcblxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2ggPSBmdW5jdGlvbiggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXAgPSB7fTtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XHJcblxyXG5cdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuXHQvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXHJcblxyXG5cdHZhciBudW1GcmFtZXMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7XHJcblxyXG5cdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcblx0dmFyIHN0YXJ0RnJhbWUgPSAwO1xyXG5cdHZhciBlbmRGcmFtZSA9IG51bUZyYW1lcyAtIDE7XHJcblxyXG5cdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuXHR0aGlzLmNyZWF0ZUFuaW1hdGlvbiggbmFtZSwgc3RhcnRGcmFtZSwgZW5kRnJhbWUsIGZwcyApO1xyXG5cdHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTW9ycGhCbGVuZE1lc2g7XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY3JlYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBzdGFydCwgZW5kLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB7XHJcblxyXG5cdFx0c3RhcnQ6IHN0YXJ0LFxyXG5cdFx0ZW5kOiBlbmQsXHJcblxyXG5cdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG5cdFx0ZnBzOiBmcHMsXHJcblx0XHRkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxyXG5cclxuXHRcdGxhc3RGcmFtZTogMCxcclxuXHRcdGN1cnJlbnRGcmFtZTogMCxcclxuXHJcblx0XHRhY3RpdmU6IGZhbHNlLFxyXG5cclxuXHRcdHRpbWU6IDAsXHJcblx0XHRkaXJlY3Rpb246IDEsXHJcblx0XHR3ZWlnaHQ6IDEsXHJcblxyXG5cdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuXHRcdG1pcnJvcmVkTG9vcDogZmFsc2VcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcblx0dGhpcy5hbmltYXRpb25zTGlzdC5wdXNoKCBhbmltYXRpb24gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcblx0dmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS9pO1xyXG5cclxuXHR2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XHJcblx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuXHRcdGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0dmFyIG5hbWUgPSBjaHVua3NbIDEgXTtcclxuXHJcblx0XHRcdGlmICggISBmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG5cdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHRcdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0gMTtcclxuXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcblx0XHRhbmltYXRpb24uZHVyYXRpb24gPSAoIGFuaW1hdGlvbi5lbmQgLSBhbmltYXRpb24uc3RhcnQgKSAvIGFuaW1hdGlvbi5mcHM7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIGR1cmF0aW9uICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG5cdFx0YW5pbWF0aW9uLmZwcyA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbldlaWdodCA9IGZ1bmN0aW9uICggbmFtZSwgd2VpZ2h0ICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi53ZWlnaHQgPSB3ZWlnaHQ7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSwgdGltZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24udGltZSA9IHRpbWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uVGltZSA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIHRpbWUgPSAwO1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGltZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBkdXJhdGlvbiA9IC0gMTtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRkdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZHVyYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG5cdFx0YW5pbWF0aW9uLmFjdGl2ZSA9IHRydWU7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5hbmltYXRpb25zTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTGlzdFsgaSBdO1xyXG5cclxuXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XHJcblxyXG5cdFx0dmFyIGZyYW1lVGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbiAvIGFuaW1hdGlvbi5sZW5ndGg7XHJcblxyXG5cdFx0YW5pbWF0aW9uLnRpbWUgKz0gYW5pbWF0aW9uLmRpcmVjdGlvbiAqIGRlbHRhO1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcclxuXHJcblx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPiBhbmltYXRpb24uZHVyYXRpb24gfHwgYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRhbmltYXRpb24uZGlyZWN0aW9uICo9IC0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydCArIFRIUkVFLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcblx0XHR2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcclxuXHJcblx0XHRpZiAoIGtleWZyYW1lICE9PSBhbmltYXRpb24uY3VycmVudEZyYW1lICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSAxICogd2VpZ2h0O1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcblx0XHRcdGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgPSBrZXlmcmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgKSBtaXggPSAxIC0gbWl4O1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSAhPT0gYW5pbWF0aW9uLmxhc3RGcmFtZSApIHtcclxuXHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcblx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxuIiwiLyoqXG4gKiBAYXV0aG9yIGRtYXJjb3MgLyBodHRwczovL2dpdGh1Yi5jb20vZG1hcmNvc1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICovXG5cblRIUkVFLlZSQ29udHJvbHMgPSBmdW5jdGlvbiAoIG9iamVjdCwgb25FcnJvciApIHtcblxuXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdHZhciB2cklucHV0cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGZpbHRlckludmFsaWREZXZpY2VzKCBkZXZpY2VzICkge1xuXG5cdFx0Ly8gRXhjbHVkZSBDYXJkYm9hcmQgcG9zaXRpb24gc2Vuc29yIGlmIE9jdWx1cyBleGlzdHMuXG5cblx0XHR2YXIgb2N1bHVzRGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKCBmdW5jdGlvbiAoIGRldmljZSApIHtcblxuXHRcdFx0cmV0dXJuIGRldmljZS5kZXZpY2VOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZiggJ29jdWx1cycgKSAhPT0gLSAxO1xuXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvY3VsdXNEZXZpY2VzLmxlbmd0aCA+PSAxICkge1xuXG5cdFx0XHRyZXR1cm4gZGV2aWNlcy5maWx0ZXIoIGZ1bmN0aW9uICggZGV2aWNlICkge1xuXG5cdFx0XHRcdHJldHVybiBkZXZpY2UuZGV2aWNlTmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoICdjYXJkYm9hcmQnICkgPT09IC0gMTtcblxuXHRcdFx0fSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGRldmljZXM7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdvdFZSRGV2aWNlcyggZGV2aWNlcyApIHtcblxuXHRcdGRldmljZXMgPSBmaWx0ZXJJbnZhbGlkRGV2aWNlcyggZGV2aWNlcyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGV2aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZGV2aWNlc1sgaSBdIGluc3RhbmNlb2YgUG9zaXRpb25TZW5zb3JWUkRldmljZSApIHtcblxuXHRcdFx0XHR2cklucHV0cy5wdXNoKCBkZXZpY2VzWyBpIF0gKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggJ0hNRCBub3QgYXZhaWxhYmxlJyApO1xuXG5cdH1cblxuXHRpZiAoIG5hdmlnYXRvci5nZXRWUkRldmljZXMgKSB7XG5cblx0XHRuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbiggZ290VlJEZXZpY2VzICk7XG5cblx0fVxuXG5cdC8vIHRoZSBSaWZ0IFNESyByZXR1cm5zIHRoZSBwb3NpdGlvbiBpbiBtZXRlcnNcblx0Ly8gdGhpcyBzY2FsZSBmYWN0b3IgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSBob3cgbWV0ZXJzXG5cdC8vIGFyZSBjb252ZXJ0ZWQgdG8gc2NlbmUgdW5pdHMuXG5cblx0dGhpcy5zY2FsZSA9IDE7XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2cklucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciB2cklucHV0ID0gdnJJbnB1dHNbIGkgXTtcblxuXHRcdFx0dmFyIHN0YXRlID0gdnJJbnB1dC5nZXRTdGF0ZSgpO1xuXG5cdFx0XHRpZiAoIHN0YXRlLm9yaWVudGF0aW9uICE9PSBudWxsICkge1xuXG5cdFx0XHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHN0YXRlLm9yaWVudGF0aW9uICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzdGF0ZS5wb3NpdGlvbiAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRvYmplY3QucG9zaXRpb24uY29weSggc3RhdGUucG9zaXRpb24gKS5tdWx0aXBseVNjYWxhciggc2NvcGUuc2NhbGUgKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5yZXNldFNlbnNvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZySW5wdXRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHZySW5wdXQgPSB2cklucHV0c1sgaSBdO1xuXG5cdFx0XHRpZiAoIHZySW5wdXQucmVzZXRTZW5zb3IgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHR2cklucHV0LnJlc2V0U2Vuc29yKCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHZySW5wdXQuemVyb1NlbnNvciAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZySW5wdXQuemVyb1NlbnNvcigpO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHR0aGlzLnplcm9TZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkNvbnRyb2xzOiAuemVyb1NlbnNvcigpIGlzIG5vdyAucmVzZXRTZW5zb3IoKS4nICk7XG5cdFx0dGhpcy5yZXNldFNlbnNvcigpO1xuXG5cdH07XG5cblx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dnJJbnB1dHMgPSBbXTtcblxuXHR9O1xuXG59O1xuIiwiLyoqXG4gKiBAYXV0aG9yIGRtYXJjb3MgLyBodHRwczovL2dpdGh1Yi5jb20vZG1hcmNvc1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICpcbiAqIFdlYlZSIFNwZWM6IGh0dHA6Ly9tb3p2ci5naXRodWIuaW8vd2VidnItc3BlYy93ZWJ2ci5odG1sXG4gKlxuICogRmlyZWZveDogaHR0cDovL21venZyLmNvbS9kb3dubG9hZHMvXG4gKiBDaHJvbWl1bTogaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZvbGRlcnZpZXc/aWQ9MEJ6dWRMdDIyQnFHUmJXOVdUSE10T1dNek5qUSZ1c3A9c2hhcmluZyNsaXN0XG4gKlxuICovXG5cblRIUkVFLlZSRWZmZWN0ID0gZnVuY3Rpb24gKCByZW5kZXJlciwgb25FcnJvciApIHtcblxuXHR2YXIgdnJITUQ7XG5cdHZhciBleWVUcmFuc2xhdGlvbkwsIGV5ZUZPVkw7XG5cdHZhciBleWVUcmFuc2xhdGlvblIsIGV5ZUZPVlI7XG5cblx0ZnVuY3Rpb24gZ290VlJEZXZpY2VzKCBkZXZpY2VzICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGV2aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZGV2aWNlc1sgaSBdIGluc3RhbmNlb2YgSE1EVlJEZXZpY2UgKSB7XG5cblx0XHRcdFx0dnJITUQgPSBkZXZpY2VzWyBpIF07XG5cblx0XHRcdFx0YnJlYWs7IC8vIFdlIGtlZXAgdGhlIGZpcnN0IHdlIGVuY291bnRlclxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIHZySE1EID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoICdITUQgbm90IGF2YWlsYWJsZScgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzICkge1xuXG5cdFx0bmF2aWdhdG9yLmdldFZSRGV2aWNlcygpLnRoZW4oIGdvdFZSRGV2aWNlcyApO1xuXG5cdH1cblxuXHQvL1xuXG5cdHRoaXMuc2NhbGUgPSAxO1xuXG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG5cdFx0cmVuZGVyZXIuc2V0U2l6ZSggd2lkdGgsIGhlaWdodCApO1xuXG5cdH07XG5cblx0Ly8gZnVsbHNjcmVlblxuXG5cdHZhciBpc0Z1bGxzY3JlZW4gPSBmYWxzZTtcblxuXHR2YXIgY2FudmFzID0gcmVuZGVyZXIuZG9tRWxlbWVudDtcblx0dmFyIGZ1bGxzY3JlZW5jaGFuZ2UgPSBjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4gPyAnbW96ZnVsbHNjcmVlbmNoYW5nZScgOiAnd2Via2l0ZnVsbHNjcmVlbmNoYW5nZSc7XG5cblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggZnVsbHNjcmVlbmNoYW5nZSwgZnVuY3Rpb24gKCBldmVudCApIHtcblxuXHRcdGlzRnVsbHNjcmVlbiA9IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuXG5cdH0sIGZhbHNlICk7XG5cblx0dGhpcy5zZXRGdWxsU2NyZWVuID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xuXG5cdFx0aWYgKCB2ckhNRCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXHRcdGlmICggaXNGdWxsc2NyZWVuID09PSBib29sZWFuICkgcmV0dXJuO1xuXG5cdFx0aWYgKCBjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4gKSB7XG5cblx0XHRcdGNhbnZhcy5tb3pSZXF1ZXN0RnVsbFNjcmVlbiggeyB2ckRpc3BsYXk6IHZySE1EIH0gKTtcblxuXHRcdH0gZWxzZSBpZiAoIGNhbnZhcy53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApIHtcblxuXHRcdFx0Y2FudmFzLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCB7IHZyRGlzcGxheTogdnJITUQgfSApO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0Ly8gcmVuZGVyXG5cblx0dmFyIGNhbWVyYUwgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0Y2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XG5cblx0dmFyIGNhbWVyYVIgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcblx0Y2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XG5cblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cblx0XHRpZiAoIHZySE1EICkge1xuXG5cdFx0XHR2YXIgZXllUGFyYW1zTCA9IHZySE1ELmdldEV5ZVBhcmFtZXRlcnMoICdsZWZ0JyApO1xuXHRcdFx0dmFyIGV5ZVBhcmFtc1IgPSB2ckhNRC5nZXRFeWVQYXJhbWV0ZXJzKCAncmlnaHQnICk7XG5cblx0XHRcdGV5ZVRyYW5zbGF0aW9uTCA9IGV5ZVBhcmFtc0wuZXllVHJhbnNsYXRpb247XG5cdFx0XHRleWVUcmFuc2xhdGlvblIgPSBleWVQYXJhbXNSLmV5ZVRyYW5zbGF0aW9uO1xuXHRcdFx0ZXllRk9WTCA9IGV5ZVBhcmFtc0wucmVjb21tZW5kZWRGaWVsZE9mVmlldztcblx0XHRcdGV5ZUZPVlIgPSBleWVQYXJhbXNSLnJlY29tbWVuZGVkRmllbGRPZlZpZXc7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggc2NlbmUgKSApIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WUkVmZmVjdC5yZW5kZXIoKSBubyBsb25nZXIgc3VwcG9ydHMgYXJyYXlzLiBVc2Ugb2JqZWN0LmxheWVycyBpbnN0ZWFkLicgKTtcblx0XHRcdFx0c2NlbmUgPSBzY2VuZVsgMCBdO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBzaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSgpO1xuXHRcdFx0c2l6ZS53aWR0aCAvPSAyO1xuXG5cdFx0XHRyZW5kZXJlci5zZXRTY2lzc29yVGVzdCggdHJ1ZSApO1xuXHRcdFx0cmVuZGVyZXIuY2xlYXIoKTtcblxuXHRcdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cblx0XHRcdGNhbWVyYUwucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WTCwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcblx0XHRcdGNhbWVyYVIucHJvamVjdGlvbk1hdHJpeCA9IGZvdlRvUHJvamVjdGlvbiggZXllRk9WUiwgdHJ1ZSwgY2FtZXJhLm5lYXIsIGNhbWVyYS5mYXIgKTtcblxuXHRcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggY2FtZXJhTC5wb3NpdGlvbiwgY2FtZXJhTC5xdWF0ZXJuaW9uLCBjYW1lcmFMLnNjYWxlICk7XG5cdFx0XHRjYW1lcmEubWF0cml4V29ybGQuZGVjb21wb3NlKCBjYW1lcmFSLnBvc2l0aW9uLCBjYW1lcmFSLnF1YXRlcm5pb24sIGNhbWVyYVIuc2NhbGUgKTtcblxuXHRcdFx0Y2FtZXJhTC50cmFuc2xhdGVYKCBleWVUcmFuc2xhdGlvbkwueCAqIHRoaXMuc2NhbGUgKTtcblx0XHRcdGNhbWVyYVIudHJhbnNsYXRlWCggZXllVHJhbnNsYXRpb25SLnggKiB0aGlzLnNjYWxlICk7XG5cblx0XHRcdC8vIHJlbmRlciBsZWZ0IGV5ZVxuXHRcdFx0cmVuZGVyZXIuc2V0Vmlld3BvcnQoIDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG5cdFx0XHRyZW5kZXJlci5zZXRTY2lzc29yKCAwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCApO1xuXHRcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTCApO1xuXG5cdFx0XHQvLyByZW5kZXIgcmlnaHQgZXllXG5cdFx0XHRyZW5kZXJlci5zZXRWaWV3cG9ydCggc2l6ZS53aWR0aCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQgKTtcblx0XHRcdHJlbmRlcmVyLnNldFNjaXNzb3IoIHNpemUud2lkdGgsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0ICk7XG5cdFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFSICk7XG5cblx0XHRcdHJlbmRlcmVyLnNldFNjaXNzb3JUZXN0KCBmYWxzZSApO1xuXG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHQvLyBSZWd1bGFyIHJlbmRlciBtb2RlIGlmIG5vdCBITURcblxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXG5cdH07XG5cblx0Ly9cblxuXHRmdW5jdGlvbiBmb3ZUb05EQ1NjYWxlT2Zmc2V0KCBmb3YgKSB7XG5cblx0XHR2YXIgcHhzY2FsZSA9IDIuMCAvICggZm92LmxlZnRUYW4gKyBmb3YucmlnaHRUYW4gKTtcblx0XHR2YXIgcHhvZmZzZXQgPSAoIGZvdi5sZWZ0VGFuIC0gZm92LnJpZ2h0VGFuICkgKiBweHNjYWxlICogMC41O1xuXHRcdHZhciBweXNjYWxlID0gMi4wIC8gKCBmb3YudXBUYW4gKyBmb3YuZG93blRhbiApO1xuXHRcdHZhciBweW9mZnNldCA9ICggZm92LnVwVGFuIC0gZm92LmRvd25UYW4gKSAqIHB5c2NhbGUgKiAwLjU7XG5cdFx0cmV0dXJuIHsgc2NhbGU6IFsgcHhzY2FsZSwgcHlzY2FsZSBdLCBvZmZzZXQ6IFsgcHhvZmZzZXQsIHB5b2Zmc2V0IF0gfTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZm92UG9ydFRvUHJvamVjdGlvbiggZm92LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKSB7XG5cblx0XHRyaWdodEhhbmRlZCA9IHJpZ2h0SGFuZGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogcmlnaHRIYW5kZWQ7XG5cdFx0ek5lYXIgPSB6TmVhciA9PT0gdW5kZWZpbmVkID8gMC4wMSA6IHpOZWFyO1xuXHRcdHpGYXIgPSB6RmFyID09PSB1bmRlZmluZWQgPyAxMDAwMC4wIDogekZhcjtcblxuXHRcdHZhciBoYW5kZWRuZXNzU2NhbGUgPSByaWdodEhhbmRlZCA/IC0gMS4wIDogMS4wO1xuXG5cdFx0Ly8gc3RhcnQgd2l0aCBhbiBpZGVudGl0eSBtYXRyaXhcblx0XHR2YXIgbW9iaiA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0dmFyIG0gPSBtb2JqLmVsZW1lbnRzO1xuXG5cdFx0Ly8gYW5kIHdpdGggc2NhbGUvb2Zmc2V0IGluZm8gZm9yIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3Jkc1xuXHRcdHZhciBzY2FsZUFuZE9mZnNldCA9IGZvdlRvTkRDU2NhbGVPZmZzZXQoIGZvdiApO1xuXG5cdFx0Ly8gWCByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cblx0XHRtWyAwICogNCArIDAgXSA9IHNjYWxlQW5kT2Zmc2V0LnNjYWxlWyAwIF07XG5cdFx0bVsgMCAqIDQgKyAxIF0gPSAwLjA7XG5cdFx0bVsgMCAqIDQgKyAyIF0gPSBzY2FsZUFuZE9mZnNldC5vZmZzZXRbIDAgXSAqIGhhbmRlZG5lc3NTY2FsZTtcblx0XHRtWyAwICogNCArIDMgXSA9IDAuMDtcblxuXHRcdC8vIFkgcmVzdWx0LCBtYXAgY2xpcCBlZGdlcyB0byBbLXcsK3ddXG5cdFx0Ly8gWSBvZmZzZXQgaXMgbmVnYXRlZCBiZWNhdXNlIHRoaXMgcHJvaiBtYXRyaXggdHJhbnNmb3JtcyBmcm9tIHdvcmxkIGNvb3JkcyB3aXRoIFk9dXAsXG5cdFx0Ly8gYnV0IHRoZSBOREMgc2NhbGluZyBoYXMgWT1kb3duICh0aGFua3MgRDNEPylcblx0XHRtWyAxICogNCArIDAgXSA9IDAuMDtcblx0XHRtWyAxICogNCArIDEgXSA9IHNjYWxlQW5kT2Zmc2V0LnNjYWxlWyAxIF07XG5cdFx0bVsgMSAqIDQgKyAyIF0gPSAtIHNjYWxlQW5kT2Zmc2V0Lm9mZnNldFsgMSBdICogaGFuZGVkbmVzc1NjYWxlO1xuXHRcdG1bIDEgKiA0ICsgMyBdID0gMC4wO1xuXG5cdFx0Ly8gWiByZXN1bHQgKHVwIHRvIHRoZSBhcHApXG5cdFx0bVsgMiAqIDQgKyAwIF0gPSAwLjA7XG5cdFx0bVsgMiAqIDQgKyAxIF0gPSAwLjA7XG5cdFx0bVsgMiAqIDQgKyAyIF0gPSB6RmFyIC8gKCB6TmVhciAtIHpGYXIgKSAqIC0gaGFuZGVkbmVzc1NjYWxlO1xuXHRcdG1bIDIgKiA0ICsgMyBdID0gKCB6RmFyICogek5lYXIgKSAvICggek5lYXIgLSB6RmFyICk7XG5cblx0XHQvLyBXIHJlc3VsdCAoPSBaIGluKVxuXHRcdG1bIDMgKiA0ICsgMCBdID0gMC4wO1xuXHRcdG1bIDMgKiA0ICsgMSBdID0gMC4wO1xuXHRcdG1bIDMgKiA0ICsgMiBdID0gaGFuZGVkbmVzc1NjYWxlO1xuXHRcdG1bIDMgKiA0ICsgMyBdID0gMC4wO1xuXG5cdFx0bW9iai50cmFuc3Bvc2UoKTtcblxuXHRcdHJldHVybiBtb2JqO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBmb3ZUb1Byb2plY3Rpb24oIGZvdiwgcmlnaHRIYW5kZWQsIHpOZWFyLCB6RmFyICkge1xuXG5cdFx0dmFyIERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLjA7XG5cblx0XHR2YXIgZm92UG9ydCA9IHtcblx0XHRcdHVwVGFuOiBNYXRoLnRhbiggZm92LnVwRGVncmVlcyAqIERFRzJSQUQgKSxcblx0XHRcdGRvd25UYW46IE1hdGgudGFuKCBmb3YuZG93bkRlZ3JlZXMgKiBERUcyUkFEICksXG5cdFx0XHRsZWZ0VGFuOiBNYXRoLnRhbiggZm92LmxlZnREZWdyZWVzICogREVHMlJBRCApLFxuXHRcdFx0cmlnaHRUYW46IE1hdGgudGFuKCBmb3YucmlnaHREZWdyZWVzICogREVHMlJBRCApXG5cdFx0fTtcblxuXHRcdHJldHVybiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3ZQb3J0LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKTtcblxuXHR9XG5cbn07XG4iLCIvKipcbiogQGF1dGhvciBUaW0gS25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS8gLyB0aW0gYXQgZmxvb3JwbGFubmVyLmNvbVxuKiBAYXV0aG9yIFRvbnkgUGFyaXNpIC8gaHR0cDovL3d3dy50b255cGFyaXNpLmNvbS9cbiovXG5cblRIUkVFLkNvbGxhZGFMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0dmFyIENPTExBREEgPSBudWxsO1xuXHR2YXIgc2NlbmUgPSBudWxsO1xuXHR2YXIgdmlzdWFsU2NlbmU7XG5cdHZhciBraW5lbWF0aWNzTW9kZWw7XG5cblx0dmFyIHJlYWR5Q2FsbGJhY2tGdW5jID0gbnVsbDtcblxuXHR2YXIgc291cmNlcyA9IHt9O1xuXHR2YXIgaW1hZ2VzID0ge307XG5cdHZhciBhbmltYXRpb25zID0ge307XG5cdHZhciBjb250cm9sbGVycyA9IHt9O1xuXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xuXHR2YXIgbWF0ZXJpYWxzID0ge307XG5cdHZhciBlZmZlY3RzID0ge307XG5cdHZhciBjYW1lcmFzID0ge307XG5cdHZhciBsaWdodHMgPSB7fTtcblxuXHR2YXIgYW5pbURhdGE7XG5cdHZhciBraW5lbWF0aWNzO1xuXHR2YXIgdmlzdWFsU2NlbmVzO1xuXHR2YXIga2luZW1hdGljc01vZGVscztcblx0dmFyIGJhc2VVcmw7XG5cdHZhciBtb3JwaHM7XG5cdHZhciBza2lucztcblxuXHR2YXIgZmxpcF91diA9IHRydWU7XG5cdHZhciBwcmVmZXJyZWRTaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuXHR2YXIgb3B0aW9ucyA9IHtcblx0XHQvLyBGb3JjZSBHZW9tZXRyeSB0byBhbHdheXMgYmUgY2VudGVyZWQgYXQgdGhlIGxvY2FsIG9yaWdpbiBvZiB0aGVcblx0XHQvLyBjb250YWluaW5nIE1lc2guXG5cdFx0Y2VudGVyR2VvbWV0cnk6IGZhbHNlLFxuXG5cdFx0Ly8gQXhpcyBjb252ZXJzaW9uIGlzIGRvbmUgZm9yIGdlb21ldHJpZXMsIGFuaW1hdGlvbnMsIGFuZCBjb250cm9sbGVycy5cblx0XHQvLyBJZiB3ZSBldmVyIHB1bGwgY2FtZXJhcyBvciBsaWdodHMgb3V0IG9mIHRoZSBDT0xMQURBIGZpbGUsIHRoZXknbGxcblx0XHQvLyBuZWVkIGV4dHJhIHdvcmsuXG5cdFx0Y29udmVydFVwQXhpczogZmFsc2UsXG5cblx0XHRzdWJkaXZpZGVGYWNlczogdHJ1ZSxcblxuXHRcdHVwQXhpczogJ1knLFxuXG5cdFx0Ly8gRm9yIHJlZmxlY3RpdmUgb3IgcmVmcmFjdGl2ZSBtYXRlcmlhbHMgd2UnbGwgdXNlIHRoaXMgY3ViZW1hcFxuXHRcdGRlZmF1bHRFbnZNYXA6IG51bGxcblxuXHR9O1xuXG5cdHZhciBjb2xsYWRhVW5pdCA9IDEuMDtcblx0dmFyIGNvbGxhZGFVcCA9ICdZJztcblx0dmFyIHVwQ29udmVyc2lvbiA9IG51bGw7XG5cblx0ZnVuY3Rpb24gbG9hZCAoIHVybCwgcmVhZHlDYWxsYmFjaywgcHJvZ3Jlc3NDYWxsYmFjaywgZmFpbENhbGxiYWNrICkge1xuXG5cdFx0dmFyIGxlbmd0aCA9IDA7XG5cblx0XHRpZiAoIGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50ICkge1xuXG5cdFx0XHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG5cdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdGlmICggcmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0aWYgKCByZXF1ZXN0LnN0YXR1cyA9PT0gMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMjAwICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIHJlcXVlc3QucmVzcG9uc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVhZHlDYWxsYmFja0Z1bmMgPSByZWFkeUNhbGxiYWNrO1xuXHRcdFx0XHRcdFx0XHRwYXJzZSggcmVxdWVzdC5yZXNwb25zZSwgdW5kZWZpbmVkLCB1cmwgKTtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGZhaWxDYWxsYmFjayApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGZhaWxDYWxsYmFjaygpO1xuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkNvbGxhZGFMb2FkZXI6IEVtcHR5IG9yIG5vbi1leGlzdGluZyBmaWxlIChcIiArIHVybCArIFwiKVwiICk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIGlmICggcmVxdWVzdC5yZWFkeVN0YXRlID09PSAzICkge1xuXG5cdFx0XHRcdFx0aWYgKCBwcm9ncmVzc0NhbGxiYWNrICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSByZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtTGVuZ3RoXCIgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRwcm9ncmVzc0NhbGxiYWNrKCB7IHRvdGFsOiBsZW5ndGgsIGxvYWRlZDogcmVxdWVzdC5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH07XG5cblx0XHRcdHJlcXVlc3Qub3BlbiggXCJHRVRcIiwgdXJsLCB0cnVlICk7XG5cdFx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGFsZXJ0KCBcIkRvbid0IGtub3cgaG93IHRvIHBhcnNlIFhNTCFcIiApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZSggdGV4dCwgY2FsbEJhY2ssIHVybCApIHtcblxuXHRcdENPTExBREEgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKCB0ZXh0LCAndGV4dC94bWwnICk7XG5cdFx0Y2FsbEJhY2sgPSBjYWxsQmFjayB8fCByZWFkeUNhbGxiYWNrRnVuYztcblxuXHRcdGlmICggdXJsICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cdFx0XHRwYXJ0cy5wb3AoKTtcblx0XHRcdGJhc2VVcmwgPSAoIHBhcnRzLmxlbmd0aCA8IDEgPyAnLicgOiBwYXJ0cy5qb2luKCAnLycgKSApICsgJy8nO1xuXG5cdFx0fVxuXG5cdFx0cGFyc2VBc3NldCgpO1xuXHRcdHNldFVwQ29udmVyc2lvbigpO1xuXHRcdGltYWdlcyA9IHBhcnNlTGliKCBcImxpYnJhcnlfaW1hZ2VzIGltYWdlXCIsIF9JbWFnZSwgXCJpbWFnZVwiICk7XG5cdFx0bWF0ZXJpYWxzID0gcGFyc2VMaWIoIFwibGlicmFyeV9tYXRlcmlhbHMgbWF0ZXJpYWxcIiwgTWF0ZXJpYWwsIFwibWF0ZXJpYWxcIiApO1xuXHRcdGVmZmVjdHMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2VmZmVjdHMgZWZmZWN0XCIsIEVmZmVjdCwgXCJlZmZlY3RcIiApO1xuXHRcdGdlb21ldHJpZXMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2dlb21ldHJpZXMgZ2VvbWV0cnlcIiwgR2VvbWV0cnksIFwiZ2VvbWV0cnlcIiApO1xuXHRcdGNhbWVyYXMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2NhbWVyYXMgY2FtZXJhXCIsIENhbWVyYSwgXCJjYW1lcmFcIiApO1xuXHRcdGxpZ2h0cyA9IHBhcnNlTGliKCBcImxpYnJhcnlfbGlnaHRzIGxpZ2h0XCIsIExpZ2h0LCBcImxpZ2h0XCIgKTtcblx0XHRjb250cm9sbGVycyA9IHBhcnNlTGliKCBcImxpYnJhcnlfY29udHJvbGxlcnMgY29udHJvbGxlclwiLCBDb250cm9sbGVyLCBcImNvbnRyb2xsZXJcIiApO1xuXHRcdGFuaW1hdGlvbnMgPSBwYXJzZUxpYiggXCJsaWJyYXJ5X2FuaW1hdGlvbnMgYW5pbWF0aW9uXCIsIEFuaW1hdGlvbiwgXCJhbmltYXRpb25cIiApO1xuXHRcdHZpc3VhbFNjZW5lcyA9IHBhcnNlTGliKCBcImxpYnJhcnlfdmlzdWFsX3NjZW5lcyB2aXN1YWxfc2NlbmVcIiwgVmlzdWFsU2NlbmUsIFwidmlzdWFsX3NjZW5lXCIgKTtcblx0XHRraW5lbWF0aWNzTW9kZWxzID0gcGFyc2VMaWIoIFwibGlicmFyeV9raW5lbWF0aWNzX21vZGVscyBraW5lbWF0aWNzX21vZGVsXCIsIEtpbmVtYXRpY3NNb2RlbCwgXCJraW5lbWF0aWNzX21vZGVsXCIgKTtcblxuXHRcdG1vcnBocyA9IFtdO1xuXHRcdHNraW5zID0gW107XG5cblx0XHR2aXN1YWxTY2VuZSA9IHBhcnNlU2NlbmUoKTtcblx0XHRzY2VuZSA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmlzdWFsU2NlbmUubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRzY2VuZS5hZGQoIGNyZWF0ZVNjZW5lR3JhcGgoIHZpc3VhbFNjZW5lLm5vZGVzWyBpIF0gKSApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gdW5pdCBjb252ZXJzaW9uXG5cdFx0c2NlbmUuc2NhbGUubXVsdGlwbHlTY2FsYXIoIGNvbGxhZGFVbml0ICk7XG5cblx0XHRjcmVhdGVBbmltYXRpb25zKCk7XG5cblx0XHRraW5lbWF0aWNzTW9kZWwgPSBwYXJzZUtpbmVtYXRpY3NNb2RlbCgpO1xuXHRcdGNyZWF0ZUtpbmVtYXRpY3MoKTtcblxuXHRcdHZhciByZXN1bHQgPSB7XG5cblx0XHRcdHNjZW5lOiBzY2VuZSxcblx0XHRcdG1vcnBoczogbW9ycGhzLFxuXHRcdFx0c2tpbnM6IHNraW5zLFxuXHRcdFx0YW5pbWF0aW9uczogYW5pbURhdGEsXG5cdFx0XHRraW5lbWF0aWNzOiBraW5lbWF0aWNzLFxuXHRcdFx0ZGFlOiB7XG5cdFx0XHRcdGltYWdlczogaW1hZ2VzLFxuXHRcdFx0XHRtYXRlcmlhbHM6IG1hdGVyaWFscyxcblx0XHRcdFx0Y2FtZXJhczogY2FtZXJhcyxcblx0XHRcdFx0bGlnaHRzOiBsaWdodHMsXG5cdFx0XHRcdGVmZmVjdHM6IGVmZmVjdHMsXG5cdFx0XHRcdGdlb21ldHJpZXM6IGdlb21ldHJpZXMsXG5cdFx0XHRcdGNvbnRyb2xsZXJzOiBjb250cm9sbGVycyxcblx0XHRcdFx0YW5pbWF0aW9uczogYW5pbWF0aW9ucyxcblx0XHRcdFx0dmlzdWFsU2NlbmVzOiB2aXN1YWxTY2VuZXMsXG5cdFx0XHRcdHZpc3VhbFNjZW5lOiB2aXN1YWxTY2VuZSxcblx0XHRcdFx0c2NlbmU6IHZpc3VhbFNjZW5lLFxuXHRcdFx0XHRraW5lbWF0aWNzTW9kZWxzOiBraW5lbWF0aWNzTW9kZWxzLFxuXHRcdFx0XHRraW5lbWF0aWNzTW9kZWw6IGtpbmVtYXRpY3NNb2RlbFxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdGlmICggY2FsbEJhY2sgKSB7XG5cblx0XHRcdGNhbGxCYWNrKCByZXN1bHQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldFByZWZlcnJlZFNoYWRpbmcgKCBzaGFkaW5nICkge1xuXG5cdFx0cHJlZmVycmVkU2hhZGluZyA9IHNoYWRpbmc7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlQXNzZXQgKCkge1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdhc3NldCcpO1xuXG5cdFx0dmFyIGVsZW1lbnQgPSBlbGVtZW50c1swXTtcblxuXHRcdGlmICggZWxlbWVudCAmJiBlbGVtZW50LmNoaWxkTm9kZXMgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICd1bml0JzpcblxuXHRcdFx0XHRcdFx0dmFyIG1ldGVyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnbWV0ZXInICk7XG5cblx0XHRcdFx0XHRcdGlmICggbWV0ZXIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y29sbGFkYVVuaXQgPSBwYXJzZUZsb2F0KCBtZXRlciApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAndXBfYXhpcyc6XG5cblx0XHRcdFx0XHRcdGNvbGxhZGFVcCA9IGNoaWxkLnRleHRDb250ZW50LmNoYXJBdCgwKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUxpYiAoIHEsIGNsYXNzU3BlYywgcHJlZml4ICkge1xuXG5cdFx0dmFyIGVsZW1lbnRzID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKHEpO1xuXG5cdFx0dmFyIGxpYiA9IHt9O1xuXG5cdFx0dmFyIGkgPSAwO1xuXG5cdFx0dmFyIGVsZW1lbnRzTGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgZWxlbWVudHNMZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdHZhciBlbGVtZW50ID0gZWxlbWVudHNbal07XG5cdFx0XHR2YXIgZGFlRWxlbWVudCA9ICggbmV3IGNsYXNzU3BlYygpICkucGFyc2UoIGVsZW1lbnQgKTtcblxuXHRcdFx0aWYgKCAhZGFlRWxlbWVudC5pZCB8fCBkYWVFbGVtZW50LmlkLmxlbmd0aCA9PT0gMCApIGRhZUVsZW1lbnQuaWQgPSBwcmVmaXggKyAoIGkgKysgKTtcblx0XHRcdGxpYlsgZGFlRWxlbWVudC5pZCBdID0gZGFlRWxlbWVudDtcblxuXHRcdH1cblxuXHRcdHJldHVybiBsaWI7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlU2NlbmUoKSB7XG5cblx0XHR2YXIgc2NlbmVFbGVtZW50ID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdzY2VuZSBpbnN0YW5jZV92aXN1YWxfc2NlbmUnKVswXTtcblxuXHRcdGlmICggc2NlbmVFbGVtZW50ICkge1xuXG5cdFx0XHR2YXIgdXJsID0gc2NlbmVFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXHRcdFx0cmV0dXJuIHZpc3VhbFNjZW5lc1sgdXJsLmxlbmd0aCA+IDAgPyB1cmwgOiAndmlzdWFsX3NjZW5lMCcgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUtpbmVtYXRpY3NNb2RlbCgpIHtcblxuXHRcdHZhciBraW5lbWF0aWNzTW9kZWxFbGVtZW50ID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9raW5lbWF0aWNzX21vZGVsJylbMF07XG5cblx0XHRpZiAoIGtpbmVtYXRpY3NNb2RlbEVsZW1lbnQgKSB7XG5cblx0XHRcdHZhciB1cmwgPSBraW5lbWF0aWNzTW9kZWxFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKC9eIy8sICcnKTtcblx0XHRcdHJldHVybiBraW5lbWF0aWNzTW9kZWxzWyB1cmwubGVuZ3RoID4gMCA/IHVybCA6ICdraW5lbWF0aWNzX21vZGVsMCcgXTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVBbmltYXRpb25zKCkge1xuXG5cdFx0YW5pbURhdGEgPSBbXTtcblxuXHRcdC8vIGZpbGwgaW4gdGhlIGtleXNcblx0XHRyZWN1cnNlSGllcmFyY2h5KCBzY2VuZSApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiByZWN1cnNlSGllcmFyY2h5KCBub2RlICkge1xuXG5cdFx0dmFyIG4gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIG5vZGUuY29sbGFkYUlkLCB0cnVlICksXG5cdFx0XHRuZXdEYXRhID0gbnVsbDtcblxuXHRcdGlmICggbiAmJiBuLmtleXMgKSB7XG5cblx0XHRcdG5ld0RhdGEgPSB7XG5cdFx0XHRcdGZwczogNjAsXG5cdFx0XHRcdGhpZXJhcmNoeTogWyB7XG5cdFx0XHRcdFx0bm9kZTogbixcblx0XHRcdFx0XHRrZXlzOiBuLmtleXMsXG5cdFx0XHRcdFx0c2lkczogbi5zaWRzXG5cdFx0XHRcdH0gXSxcblx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0bmFtZTogJ2FuaW1hdGlvbl8nICsgbm9kZS5uYW1lLFxuXHRcdFx0XHRsZW5ndGg6IDBcblx0XHRcdH07XG5cblx0XHRcdGFuaW1EYXRhLnB1c2gobmV3RGF0YSk7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuLmtleXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cblx0XHRcdFx0bmV3RGF0YS5sZW5ndGggPSBNYXRoLm1heCggbmV3RGF0YS5sZW5ndGgsIG4ua2V5c1tpXS50aW1lICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdG5ld0RhdGEgPSB7XG5cdFx0XHRcdGhpZXJhcmNoeTogWyB7XG5cdFx0XHRcdFx0a2V5czogW10sXG5cdFx0XHRcdFx0c2lkczogW11cblx0XHRcdFx0fSBdXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGQgPSByZWN1cnNlSGllcmFyY2h5KCBub2RlLmNoaWxkcmVuW2ldICk7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBkLmhpZXJhcmNoeS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRuZXdEYXRhLmhpZXJhcmNoeS5wdXNoKCB7XG5cdFx0XHRcdFx0a2V5czogW10sXG5cdFx0XHRcdFx0c2lkczogW11cblx0XHRcdFx0fSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3RGF0YTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY0FuaW1hdGlvbkJvdW5kcyAoKSB7XG5cblx0XHR2YXIgc3RhcnQgPSAxMDAwMDAwO1xuXHRcdHZhciBlbmQgPSAtc3RhcnQ7XG5cdFx0dmFyIGZyYW1lcyA9IDA7XG5cdFx0dmFyIElEO1xuXHRcdGZvciAoIHZhciBpZCBpbiBhbmltYXRpb25zICkge1xuXG5cdFx0XHR2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1sgaWQgXTtcblx0XHRcdElEID0gSUQgfHwgYW5pbWF0aW9uLmlkO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uLnNhbXBsZXIubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBzYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJbIGkgXTtcblxuXHRcdFx0XHRzYW1wbGVyLmNyZWF0ZSgpO1xuXG5cdFx0XHRcdHN0YXJ0ID0gTWF0aC5taW4oIHN0YXJ0LCBzYW1wbGVyLnN0YXJ0VGltZSApO1xuXHRcdFx0XHRlbmQgPSBNYXRoLm1heCggZW5kLCBzYW1wbGVyLmVuZFRpbWUgKTtcblx0XHRcdFx0ZnJhbWVzID0gTWF0aC5tYXgoIGZyYW1lcywgc2FtcGxlci5pbnB1dC5sZW5ndGggKTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHsgc3RhcnQ6c3RhcnQsIGVuZDplbmQsIGZyYW1lczpmcmFtZXMsSUQ6SUQgfTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlTW9ycGggKCBnZW9tZXRyeSwgY3RybCApIHtcblxuXHRcdHZhciBtb3JwaEN0cmwgPSBjdHJsIGluc3RhbmNlb2YgSW5zdGFuY2VDb250cm9sbGVyID8gY29udHJvbGxlcnNbIGN0cmwudXJsIF0gOiBjdHJsO1xuXG5cdFx0aWYgKCAhbW9ycGhDdHJsIHx8ICFtb3JwaEN0cmwubW9ycGggKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgbW9ycGggY29udHJvbGxlciFcIik7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHR2YXIgbW9ycGggPSBtb3JwaEN0cmwubW9ycGg7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaC50YXJnZXRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHRhcmdldF9pZCA9IG1vcnBoLnRhcmdldHNbIGkgXTtcblx0XHRcdHZhciBkYWVHZW9tZXRyeSA9IGdlb21ldHJpZXNbIHRhcmdldF9pZCBdO1xuXG5cdFx0XHRpZiAoICFkYWVHZW9tZXRyeS5tZXNoIHx8XG5cdFx0XHRcdCAhZGFlR2VvbWV0cnkubWVzaC5wcmltaXRpdmVzIHx8XG5cdFx0XHRcdCAhZGFlR2VvbWV0cnkubWVzaC5wcmltaXRpdmVzLmxlbmd0aCApIHtcblx0XHRcdFx0IGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gZGFlR2VvbWV0cnkubWVzaC5wcmltaXRpdmVzWyAwIF0uZ2VvbWV0cnk7XG5cblx0XHRcdGlmICggdGFyZ2V0LnZlcnRpY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5wdXNoKCB7IG5hbWU6IFwidGFyZ2V0XzFcIiwgdmVydGljZXM6IHRhcmdldC52ZXJ0aWNlcyB9ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5wdXNoKCB7IG5hbWU6IFwidGFyZ2V0X1pcIiwgdmVydGljZXM6IGdlb21ldHJ5LnZlcnRpY2VzIH0gKTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlU2tpbiAoIGdlb21ldHJ5LCBjdHJsLCBhcHBseUJpbmRTaGFwZSApIHtcblxuXHRcdHZhciBza2luQ3RybCA9IGNvbnRyb2xsZXJzWyBjdHJsLnVybCBdO1xuXG5cdFx0aWYgKCAhc2tpbkN0cmwgfHwgIXNraW5DdHJsLnNraW4gKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHNraW4gY29udHJvbGxlciFcIiApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhY3RybC5za2VsZXRvbiB8fCAhY3RybC5za2VsZXRvbi5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCBcImNvdWxkIG5vdCBmaW5kIHRoZSBza2VsZXRvbiBmb3IgdGhlIHNraW4hXCIgKTtcblx0XHRcdHJldHVybjtcblxuXHRcdH1cblxuXHRcdHZhciBza2luID0gc2tpbkN0cmwuc2tpbjtcblx0XHR2YXIgc2tlbGV0b24gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIGN0cmwuc2tlbGV0b25bIDAgXSApO1xuXHRcdHZhciBoaWVyYXJjaHkgPSBbXTtcblxuXHRcdGFwcGx5QmluZFNoYXBlID0gYXBwbHlCaW5kU2hhcGUgIT09IHVuZGVmaW5lZCA/IGFwcGx5QmluZFNoYXBlIDogdHJ1ZTtcblxuXHRcdHZhciBib25lcyA9IFtdO1xuXHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzID0gW107XG5cdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMgPSBbXTtcblxuXHRcdC8vY3JlYXRlQm9uZXMoIGdlb21ldHJ5LmJvbmVzLCBza2luLCBoaWVyYXJjaHksIHNrZWxldG9uLCBudWxsLCAtMSApO1xuXHRcdC8vY3JlYXRlV2VpZ2h0cyggc2tpbiwgZ2VvbWV0cnkuYm9uZXMsIGdlb21ldHJ5LnNraW5JbmRpY2VzLCBnZW9tZXRyeS5za2luV2VpZ2h0cyApO1xuXG5cdFx0Lypcblx0XHRnZW9tZXRyeS5hbmltYXRpb24gPSB7XG5cdFx0XHRuYW1lOiAndGFrZV8wMDEnLFxuXHRcdFx0ZnBzOiAzMCxcblx0XHRcdGxlbmd0aDogMixcblx0XHRcdEpJVDogdHJ1ZSxcblx0XHRcdGhpZXJhcmNoeTogaGllcmFyY2h5XG5cdFx0fTtcblx0XHQqL1xuXG5cdFx0aWYgKCBhcHBseUJpbmRTaGFwZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBpIF0uYXBwbHlNYXRyaXg0KCBza2luLmJpbmRTaGFwZU1hdHJpeCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHNldHVwU2tlbGV0b24gKCBub2RlLCBib25lcywgZnJhbWUsIHBhcmVudCApIHtcblxuXHRcdG5vZGUud29ybGQgPSBub2RlLndvcmxkIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0bm9kZS5sb2NhbHdvcmxkID0gbm9kZS5sb2NhbHdvcmxkIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0bm9kZS53b3JsZC5jb3B5KCBub2RlLm1hdHJpeCApO1xuXHRcdG5vZGUubG9jYWx3b3JsZC5jb3B5KCBub2RlLm1hdHJpeCApO1xuXG5cdFx0aWYgKCBub2RlLmNoYW5uZWxzICYmIG5vZGUuY2hhbm5lbHMubGVuZ3RoICkge1xuXG5cdFx0XHR2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbIDAgXTtcblx0XHRcdHZhciBtID0gY2hhbm5lbC5zYW1wbGVyLm91dHB1dFsgZnJhbWUgXTtcblxuXHRcdFx0aWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCApIHtcblxuXHRcdFx0XHRub2RlLndvcmxkLmNvcHkoIG0gKTtcblx0XHRcdFx0bm9kZS5sb2NhbHdvcmxkLmNvcHkobSk7XG5cdFx0XHRcdGlmIChmcmFtZSA9PT0gMClcblx0XHRcdFx0XHRub2RlLm1hdHJpeC5jb3B5KG0pO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdG5vZGUud29ybGQubXVsdGlwbHlNYXRyaWNlcyggcGFyZW50LCBub2RlLndvcmxkICk7XG5cblx0XHR9XG5cblx0XHRib25lcy5wdXNoKCBub2RlICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0c2V0dXBTa2VsZXRvbiggbm9kZS5ub2Rlc1sgaSBdLCBib25lcywgZnJhbWUsIG5vZGUud29ybGQgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0dXBTa2lubmluZ01hdHJpY2VzICggYm9uZXMsIHNraW4gKSB7XG5cblx0XHQvLyBGSVhNRTogdGhpcyBpcyBkdW1iLi4uXG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBib25lID0gYm9uZXNbIGkgXTtcblx0XHRcdHZhciBmb3VuZCA9IC0xO1xuXG5cdFx0XHRpZiAoIGJvbmUudHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHNraW4uam9pbnRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRpZiAoIGJvbmUuc2lkID09PSBza2luLmpvaW50c1sgaiBdICkge1xuXG5cdFx0XHRcdFx0Zm91bmQgPSBqO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGZvdW5kID49IDAgKSB7XG5cblx0XHRcdFx0dmFyIGludiA9IHNraW4uaW52QmluZE1hdHJpY2VzWyBmb3VuZCBdO1xuXG5cdFx0XHRcdGJvbmUuaW52QmluZE1hdHJpeCA9IGludjtcblx0XHRcdFx0Ym9uZS5za2lubmluZ01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cdFx0XHRcdGJvbmUuc2tpbm5pbmdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhib25lLndvcmxkLCBpbnYpOyAvLyAoSUJNaSAqIEpNaSlcblx0XHRcdFx0Ym9uZS5hbmltYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdGJvbmUuYW5pbWF0cml4LmNvcHkoYm9uZS5sb2NhbHdvcmxkKTtcblx0XHRcdFx0Ym9uZS53ZWlnaHRzID0gW107XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgc2tpbi53ZWlnaHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgc2tpbi53ZWlnaHRzWyBqIF0ubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgdyA9IHNraW4ud2VpZ2h0c1sgaiBdWyBrIF07XG5cblx0XHRcdFx0XHRcdGlmICggdy5qb2ludCA9PT0gZm91bmQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ym9uZS53ZWlnaHRzLnB1c2goIHcgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgam9pbnQgJ1wiICsgYm9uZS5zaWQgKyBcIicuXCIgKTtcblxuXHRcdFx0XHRib25lLnNraW5uaW5nTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblx0XHRcdFx0Ym9uZS53ZWlnaHRzID0gW107XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdC8vV2FsayB0aGUgQ29sbGFkYSB0cmVlIGFuZCBmbGF0dGVuIHRoZSBib25lcyBpbnRvIGEgbGlzdCwgZXh0cmFjdCB0aGUgcG9zaXRpb24sIHF1YXQgYW5kIHNjYWxlIGZyb20gdGhlIG1hdHJpeFxuXHRmdW5jdGlvbiBmbGF0dGVuU2tlbGV0b24oc2tlbGV0b24pIHtcblxuXHRcdHZhciBsaXN0ID0gW107XG5cdFx0dmFyIHdhbGsgPSBmdW5jdGlvbihwYXJlbnRpZCwgbm9kZSwgbGlzdCkge1xuXG5cdFx0XHR2YXIgYm9uZSA9IHt9O1xuXHRcdFx0Ym9uZS5uYW1lID0gbm9kZS5zaWQ7XG5cdFx0XHRib25lLnBhcmVudCA9IHBhcmVudGlkO1xuXHRcdFx0Ym9uZS5tYXRyaXggPSBub2RlLm1hdHJpeDtcblx0XHRcdHZhciBkYXRhID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xuXHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0pO1xuXG5cdFx0XHRib25lLnBvcyA9IFsgZGF0YVswXS54LGRhdGFbMF0ueSxkYXRhWzBdLnogXTtcblxuXHRcdFx0Ym9uZS5zY2wgPSBbIGRhdGFbMl0ueCxkYXRhWzJdLnksZGF0YVsyXS56IF07XG5cdFx0XHRib25lLnJvdHEgPSBbIGRhdGFbMV0ueCxkYXRhWzFdLnksZGF0YVsxXS56LGRhdGFbMV0udyBdO1xuXHRcdFx0bGlzdC5wdXNoKGJvbmUpO1xuXG5cdFx0XHRmb3IgKHZhciBpIGluIG5vZGUubm9kZXMpIHtcblxuXHRcdFx0XHR3YWxrKG5vZGUuc2lkLCBub2RlLm5vZGVzW2ldLCBsaXN0KTtcblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHdhbGsoLTEsIHNrZWxldG9uLCBsaXN0KTtcblx0XHRyZXR1cm4gbGlzdDtcblxuXHR9XG5cblx0Ly9Nb3ZlIHRoZSB2ZXJ0aWNlcyBpbnRvIHRoZSBwb3NlIHRoYXQgaXMgcHJvcGVyIGZvciB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvblxuXHRmdW5jdGlvbiBza2luVG9CaW5kUG9zZShnZW9tZXRyeSxza2VsZXRvbixza2luQ29udHJvbGxlcikge1xuXG5cdFx0dmFyIGJvbmVzID0gW107XG5cdFx0c2V0dXBTa2VsZXRvbiggc2tlbGV0b24sIGJvbmVzLCAtMSApO1xuXHRcdHNldHVwU2tpbm5pbmdNYXRyaWNlcyggYm9uZXMsIHNraW5Db250cm9sbGVyLnNraW4gKTtcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dmFyIHNraW5uZWQgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrKSB7XG5cblx0XHRcdHNraW5uZWQucHVzaChuZXcgVEhSRUUuVmVjdG9yMygpKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGJvbmVzWyBpIF0udHlwZSAhPSAnSk9JTlQnICkgY29udGludWU7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGJvbmVzWyBpIF0ud2VpZ2h0cy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIHcgPSBib25lc1sgaSBdLndlaWdodHNbIGogXTtcblx0XHRcdFx0dmFyIHZpZHggPSB3LmluZGV4O1xuXHRcdFx0XHR2YXIgd2VpZ2h0ID0gdy53ZWlnaHQ7XG5cblx0XHRcdFx0dmFyIG8gPSBnZW9tZXRyeS52ZXJ0aWNlc1t2aWR4XTtcblx0XHRcdFx0dmFyIHMgPSBza2lubmVkW3ZpZHhdO1xuXG5cdFx0XHRcdHYueCA9IG8ueDtcblx0XHRcdFx0di55ID0gby55O1xuXHRcdFx0XHR2LnogPSBvLno7XG5cblx0XHRcdFx0di5hcHBseU1hdHJpeDQoIGJvbmVzW2ldLnNraW5uaW5nTWF0cml4ICk7XG5cblx0XHRcdFx0cy54ICs9ICh2LnggKiB3ZWlnaHQpO1xuXHRcdFx0XHRzLnkgKz0gKHYueSAqIHdlaWdodCk7XG5cdFx0XHRcdHMueiArPSAodi56ICogd2VpZ2h0KTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoOyBpICsrKSB7XG5cblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzW2ldID0gc2tpbm5lZFtpXTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlTa2luICggZ2VvbWV0cnksIGluc3RhbmNlQ3RybCwgZnJhbWUgKSB7XG5cblx0XHR2YXIgc2tpbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgaW5zdGFuY2VDdHJsLnVybCBdO1xuXG5cdFx0ZnJhbWUgPSBmcmFtZSAhPT0gdW5kZWZpbmVkID8gZnJhbWUgOiA0MDtcblxuXHRcdGlmICggIXNraW5Db250cm9sbGVyIHx8ICFza2luQ29udHJvbGxlci5za2luICkge1xuXG5cdFx0XHRjb25zb2xlLmxvZyggJ0NvbGxhZGFMb2FkZXI6IENvdWxkIG5vdCBmaW5kIHNraW4gY29udHJvbGxlci4nICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9XG5cblx0XHRpZiAoICFpbnN0YW5jZUN0cmwuc2tlbGV0b24gfHwgIWluc3RhbmNlQ3RybC5za2VsZXRvbi5sZW5ndGggKSB7XG5cblx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogQ291bGQgbm90IGZpbmQgdGhlIHNrZWxldG9uIGZvciB0aGUgc2tpbi4gJyApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGFuaW1hdGlvbkJvdW5kcyA9IGNhbGNBbmltYXRpb25Cb3VuZHMoKTtcblx0XHR2YXIgc2tlbGV0b24gPSB2aXN1YWxTY2VuZS5nZXRDaGlsZEJ5SWQoIGluc3RhbmNlQ3RybC5za2VsZXRvblswXSwgdHJ1ZSApIHx8IHZpc3VhbFNjZW5lLmdldENoaWxkQnlTaWQoIGluc3RhbmNlQ3RybC5za2VsZXRvblswXSwgdHJ1ZSApO1xuXG5cdFx0Ly9mbGF0dGVuIHRoZSBza2VsZXRvbiBpbnRvIGEgbGlzdCBvZiBib25lc1xuXHRcdHZhciBib25lbGlzdCA9IGZsYXR0ZW5Ta2VsZXRvbihza2VsZXRvbik7XG5cdFx0dmFyIGpvaW50cyA9IHNraW5Db250cm9sbGVyLnNraW4uam9pbnRzO1xuXG5cdFx0Ly9zb3J0IHRoYXQgbGlzdCBzbyB0aGF0IHRoZSBvcmRlciByZWZsZWN0cyB0aGUgb3JkZXIgaW4gdGhlIGpvaW50IGxpc3Rcblx0XHR2YXIgc29ydGVkYm9uZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGpvaW50cy5sZW5ndGg7IGkgKyspIHtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBib25lbGlzdC5sZW5ndGg7IGogKyspIHtcblxuXHRcdFx0XHRpZiAoYm9uZWxpc3Rbal0ubmFtZSA9PT0gam9pbnRzW2ldKSB7XG5cblx0XHRcdFx0XHRzb3J0ZWRib25lc1tpXSA9IGJvbmVsaXN0W2pdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly9ob29rIHVwIHRoZSBwYXJlbnRzIGJ5IGluZGV4IGluc3RlYWQgb2YgbmFtZVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc29ydGVkYm9uZXMubGVuZ3RoOyBpICsrKSB7XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgc29ydGVkYm9uZXMubGVuZ3RoOyBqICsrKSB7XG5cblx0XHRcdFx0aWYgKHNvcnRlZGJvbmVzW2ldLnBhcmVudCA9PT0gc29ydGVkYm9uZXNbal0ubmFtZSkge1xuXG5cdFx0XHRcdFx0c29ydGVkYm9uZXNbaV0ucGFyZW50ID0gajtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXG5cdFx0dmFyIGksIGosIHcsIHZpZHgsIHdlaWdodDtcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIG8sIHM7XG5cblx0XHQvLyBtb3ZlIHZlcnRpY2VzIHRvIGJpbmQgc2hhcGVcblx0XHRmb3IgKCBpID0gMDsgaSA8IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzW2ldLmFwcGx5TWF0cml4NCggc2tpbkNvbnRyb2xsZXIuc2tpbi5iaW5kU2hhcGVNYXRyaXggKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpbkluZGljZXMgPSBbXTtcblx0XHR2YXIgc2tpbldlaWdodHMgPSBbXTtcblx0XHR2YXIgd2VpZ2h0cyA9IHNraW5Db250cm9sbGVyLnNraW4ud2VpZ2h0cztcblxuXHRcdC8vIGhvb2sgdXAgdGhlIHNraW4gd2VpZ2h0c1xuXHRcdC8vIFRPRE8gLSB0aGlzIG1pZ2h0IGJlIGEgZ29vZCBwbGFjZSB0byBjaG9vc2UgZ3JlYXRlc3QgNCB3ZWlnaHRzXG5cdFx0Zm9yICggdmFyIGkgPTA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGluZGljaWVzID0gbmV3IFRIUkVFLlZlY3RvcjQod2VpZ2h0c1tpXVswXSA/IHdlaWdodHNbaV1bMF0uam9pbnQgOiAwLHdlaWdodHNbaV1bMV0gPyB3ZWlnaHRzW2ldWzFdLmpvaW50IDogMCx3ZWlnaHRzW2ldWzJdID8gd2VpZ2h0c1tpXVsyXS5qb2ludCA6IDAsd2VpZ2h0c1tpXVszXSA/IHdlaWdodHNbaV1bM10uam9pbnQgOiAwKTtcblx0XHRcdHZhciB3ZWlnaHQgPSBuZXcgVEhSRUUuVmVjdG9yNCh3ZWlnaHRzW2ldWzBdID8gd2VpZ2h0c1tpXVswXS53ZWlnaHQgOiAwLHdlaWdodHNbaV1bMV0gPyB3ZWlnaHRzW2ldWzFdLndlaWdodCA6IDAsd2VpZ2h0c1tpXVsyXSA/IHdlaWdodHNbaV1bMl0ud2VpZ2h0IDogMCx3ZWlnaHRzW2ldWzNdID8gd2VpZ2h0c1tpXVszXS53ZWlnaHQgOiAwKTtcblxuXHRcdFx0c2tpbkluZGljZXMucHVzaChpbmRpY2llcyk7XG5cdFx0XHRza2luV2VpZ2h0cy5wdXNoKHdlaWdodCk7XG5cblx0XHR9XG5cblx0XHRnZW9tZXRyeS5za2luSW5kaWNlcyA9IHNraW5JbmRpY2VzO1xuXHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzID0gc2tpbldlaWdodHM7XG5cdFx0Z2VvbWV0cnkuYm9uZXMgPSBzb3J0ZWRib25lcztcblx0XHQvLyBwcm9jZXNzIGFuaW1hdGlvbiwgb3Igc2ltcGx5IHBvc2UgdGhlIHJpZyBpZiBubyBhbmltYXRpb25cblxuXHRcdC8vY3JlYXRlIGFuIGFuaW1hdGlvbiBmb3IgdGhlIGFuaW1hdGVkIGJvbmVzXG5cdFx0Ly9OT1RFOiB0aGlzIGhhcyBubyBlZmZlY3Qgd2hlbiB1c2luZyBtb3JwaHRhcmdldHNcblx0XHR2YXIgYW5pbWF0aW9uZGF0YSA9IHsgXCJuYW1lXCI6YW5pbWF0aW9uQm91bmRzLklELFwiZnBzXCI6MzAsXCJsZW5ndGhcIjphbmltYXRpb25Cb3VuZHMuZnJhbWVzIC8gMzAsXCJoaWVyYXJjaHlcIjpbXSB9O1xuXG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBzb3J0ZWRib25lcy5sZW5ndGg7IGogKyspIHtcblxuXHRcdFx0YW5pbWF0aW9uZGF0YS5oaWVyYXJjaHkucHVzaCh7IHBhcmVudDpzb3J0ZWRib25lc1tqXS5wYXJlbnQsIG5hbWU6c29ydGVkYm9uZXNbal0ubmFtZSwga2V5czpbXSB9KTtcblxuXHRcdH1cblxuXHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjonLCBhbmltYXRpb25Cb3VuZHMuSUQgKyAnIGhhcyAnICsgc29ydGVkYm9uZXMubGVuZ3RoICsgJyBib25lcy4nICk7XG5cblxuXG5cdFx0c2tpblRvQmluZFBvc2UoZ2VvbWV0cnksIHNrZWxldG9uLCBza2luQ29udHJvbGxlcik7XG5cblxuXHRcdGZvciAoIGZyYW1lID0gMDsgZnJhbWUgPCBhbmltYXRpb25Cb3VuZHMuZnJhbWVzOyBmcmFtZSArKyApIHtcblxuXHRcdFx0dmFyIGJvbmVzID0gW107XG5cdFx0XHR2YXIgc2tpbm5lZCA9IFtdO1xuXHRcdFx0Ly8gcHJvY2VzcyB0aGUgZnJhbWUgYW5kIHNldHVwIHRoZSByaWcgd2l0aCBhIGZyZXNoXG5cdFx0XHQvLyB0cmFuc2Zvcm0sIHBvc3NpYmx5IGZyb20gdGhlIGJvbmUncyBhbmltYXRpb24gY2hhbm5lbChzKVxuXG5cdFx0XHRzZXR1cFNrZWxldG9uKCBza2VsZXRvbiwgYm9uZXMsIGZyYW1lICk7XG5cdFx0XHRzZXR1cFNraW5uaW5nTWF0cmljZXMoIGJvbmVzLCBza2luQ29udHJvbGxlci5za2luICk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyBpICsrKSB7XG5cblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBhbmltYXRpb25kYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGogKyspIHtcblxuXHRcdFx0XHRcdGlmIChhbmltYXRpb25kYXRhLmhpZXJhcmNoeVtqXS5uYW1lID09PSBib25lc1tpXS5zaWQpIHtcblxuXHRcdFx0XHRcdFx0dmFyIGtleSA9IHt9O1xuXHRcdFx0XHRcdFx0a2V5LnRpbWUgPSAoZnJhbWUgLyAzMCk7XG5cdFx0XHRcdFx0XHRrZXkubWF0cml4ID0gYm9uZXNbaV0uYW5pbWF0cml4O1xuXG5cdFx0XHRcdFx0XHRpZiAoZnJhbWUgPT09IDApXG5cdFx0XHRcdFx0XHRcdGJvbmVzW2ldLm1hdHJpeCA9IGtleS5tYXRyaXg7XG5cblx0XHRcdFx0XHRcdHZhciBkYXRhID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xuXHRcdFx0XHRcdFx0a2V5Lm1hdHJpeC5kZWNvbXBvc2UoZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSk7XG5cblx0XHRcdFx0XHRcdGtleS5wb3MgPSBbIGRhdGFbMF0ueCxkYXRhWzBdLnksZGF0YVswXS56IF07XG5cblx0XHRcdFx0XHRcdGtleS5zY2wgPSBbIGRhdGFbMl0ueCxkYXRhWzJdLnksZGF0YVsyXS56IF07XG5cdFx0XHRcdFx0XHRrZXkucm90ID0gZGF0YVsxXTtcblxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uZGF0YS5oaWVyYXJjaHlbal0ua2V5cy5wdXNoKGtleSk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGdlb21ldHJ5LmFuaW1hdGlvbiA9IGFuaW1hdGlvbmRhdGE7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUtpbmVtYXRpY3MoKSB7XG5cblx0XHRpZiAoIGtpbmVtYXRpY3NNb2RlbCAmJiBraW5lbWF0aWNzTW9kZWwuam9pbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdGtpbmVtYXRpY3MgPSB1bmRlZmluZWQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGpvaW50TWFwID0ge307XG5cblx0XHR2YXIgX2FkZFRvTWFwID0gZnVuY3Rpb24oIGpvaW50SW5kZXgsIHBhcmVudFZpc3VhbEVsZW1lbnQgKSB7XG5cblx0XHRcdHZhciBwYXJlbnRWaXN1YWxFbGVtZW50SWQgPSBwYXJlbnRWaXN1YWxFbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdFx0dmFyIGNvbGxhZGFOb2RlID0gdmlzdWFsU2NlbmUuZ2V0Q2hpbGRCeUlkKCBwYXJlbnRWaXN1YWxFbGVtZW50SWQsIHRydWUgKTtcblx0XHRcdHZhciBqb2ludCA9IGtpbmVtYXRpY3NNb2RlbC5qb2ludHNbIGpvaW50SW5kZXggXTtcblxuXHRcdFx0c2NlbmUudHJhdmVyc2UoZnVuY3Rpb24oIG5vZGUgKSB7XG5cblx0XHRcdFx0aWYgKCBub2RlLmNvbGxhZGFJZCA9PSBwYXJlbnRWaXN1YWxFbGVtZW50SWQgKSB7XG5cblx0XHRcdFx0XHRqb2ludE1hcFsgam9pbnRJbmRleCBdID0ge1xuXHRcdFx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXM6IGNvbGxhZGFOb2RlLnRyYW5zZm9ybXMsXG5cdFx0XHRcdFx0XHRqb2ludDogam9pbnQsXG5cdFx0XHRcdFx0XHRwb3NpdGlvbjogam9pbnQuemVyb1Bvc2l0aW9uXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0pO1xuXG5cdFx0fTtcblxuXHRcdGtpbmVtYXRpY3MgPSB7XG5cblx0XHRcdGpvaW50czoga2luZW1hdGljc01vZGVsICYmIGtpbmVtYXRpY3NNb2RlbC5qb2ludHMsXG5cblx0XHRcdGdldEpvaW50VmFsdWU6IGZ1bmN0aW9uKCBqb2ludEluZGV4ICkge1xuXG5cdFx0XHRcdHZhciBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdGlmICggam9pbnREYXRhICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpvaW50RGF0YS5wb3NpdGlvbjtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdnZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0JyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdFx0c2V0Sm9pbnRWYWx1ZTogZnVuY3Rpb24oIGpvaW50SW5kZXgsIHZhbHVlICkge1xuXG5cdFx0XHRcdHZhciBqb2ludERhdGEgPSBqb2ludE1hcFsgam9pbnRJbmRleCBdO1xuXG5cdFx0XHRcdGlmICggam9pbnREYXRhICkge1xuXG5cdFx0XHRcdFx0dmFyIGpvaW50ID0gam9pbnREYXRhLmpvaW50O1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA+IGpvaW50LmxpbWl0cy5tYXggfHwgdmFsdWUgPCBqb2ludC5saW1pdHMubWluICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ3NldEpvaW50VmFsdWU6IGpvaW50ICcgKyBqb2ludEluZGV4ICsgJyB2YWx1ZSAnICsgdmFsdWUgKyAnIG91dHNpZGUgb2YgbGltaXRzIChtaW46ICcgKyBqb2ludC5saW1pdHMubWluICsgJywgbWF4OiAnICsgam9pbnQubGltaXRzLm1heCArICcpJyApO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggam9pbnQuc3RhdGljICkge1xuXG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ3NldEpvaW50VmFsdWU6IGpvaW50ICcgKyBqb2ludEluZGV4ICsgJyBpcyBzdGF0aWMnICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHR2YXIgdGhyZWVqc05vZGUgPSBqb2ludERhdGEubm9kZTtcblx0XHRcdFx0XHRcdHZhciBheGlzID0gam9pbnQuYXhpcztcblx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm1zID0gam9pbnREYXRhLnRyYW5zZm9ybXM7XG5cblx0XHRcdFx0XHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbIGkgXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBraW5kYSBnaGV0dG8gam9pbnQgZGV0ZWN0aW9uXG5cdFx0XHRcdFx0XHRcdGlmICggdHJhbnNmb3JtLnNpZCAmJiB0cmFuc2Zvcm0uc2lkLmluZGV4T2YoICdqb2ludCcgKyBqb2ludEluZGV4ICkgIT09IC0xICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgYWN0dWFsIGpvaW50IHZhbHVlIGhlcmVcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBqb2ludC50eXBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdyZXZvbHV0ZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlUm90YXRpb25BeGlzKCBheGlzLCBUSFJFRS5NYXRoLmRlZ1RvUmFkKHZhbHVlKSApICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdwcmlzbWF0aWMnOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVRyYW5zbGF0aW9uKGF4aXMueCAqIHZhbHVlLCBheGlzLnkgKiB2YWx1ZSwgYXhpcy56ICogdmFsdWUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdzZXRKb2ludFZhbHVlOiB1bmtub3duIGpvaW50IHR5cGU6ICcgKyBqb2ludC50eXBlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICggdHJhbnNmb3JtLnR5cGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCB0cmFuc2Zvcm0ub2JqICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlVHJhbnNsYXRpb24oIHRyYW5zZm9ybS5vYmoueCwgdHJhbnNmb3JtLm9iai55LCB0cmFuc2Zvcm0ub2JqLnogKSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVJvdGF0aW9uQXhpcyggdHJhbnNmb3JtLm9iaiwgdHJhbnNmb3JtLmFuZ2xlICkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBhcHBseSB0aGUgbWF0cml4IHRvIHRoZSB0aHJlZWpzIG5vZGVcblx0XHRcdFx0XHRcdHZhciBlbGVtZW50c0Zsb2F0MzJBcnIgPSBtYXRyaXguZWxlbWVudHM7XG5cdFx0XHRcdFx0XHR2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggZWxlbWVudHNGbG9hdDMyQXJyICk7XG5cblx0XHRcdFx0XHRcdHZhciBlbGVtZW50c1Jvd01ham9yID0gW1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMCBdLFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgNCBdLFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgOCBdLFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMTIgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDEgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDUgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDkgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDEzIF0sXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyAyIF0sXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyA2IF0sXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyAxMCBdLFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50c1sgMTQgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDMgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDcgXSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHNbIDExIF0sXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzWyAxNSBdXG5cdFx0XHRcdFx0XHRdO1xuXG5cdFx0XHRcdFx0XHR0aHJlZWpzTm9kZS5tYXRyaXguc2V0LmFwcGx5KCB0aHJlZWpzTm9kZS5tYXRyaXgsIGVsZW1lbnRzUm93TWFqb3IgKTtcblx0XHRcdFx0XHRcdHRocmVlanNOb2RlLm1hdHJpeC5kZWNvbXBvc2UoIHRocmVlanNOb2RlLnBvc2l0aW9uLCB0aHJlZWpzTm9kZS5xdWF0ZXJuaW9uLCB0aHJlZWpzTm9kZS5zY2FsZSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coICdzZXRKb2ludFZhbHVlOiBqb2ludCAnICsgam9pbnRJbmRleCArICcgZG9lc25cXCd0IGV4aXN0JyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fTtcblxuXHRcdHZhciBlbGVtZW50ID0gQ09MTEFEQS5xdWVyeVNlbGVjdG9yKCdzY2VuZSBpbnN0YW5jZV9raW5lbWF0aWNzX3NjZW5lJyk7XG5cblx0XHRpZiAoIGVsZW1lbnQgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdiaW5kX2pvaW50X2F4aXMnOlxuXG5cdFx0XHRcdFx0XHR2YXIgdmlzdWFsVGFyZ2V0ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAndGFyZ2V0JyApLnNwbGl0KCAnLycgKS5wb3AoKTtcblx0XHRcdFx0XHRcdHZhciBheGlzID0gY2hpbGQucXVlcnlTZWxlY3RvcignYXhpcyBwYXJhbScpLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0dmFyIGpvaW50SW5kZXggPSBwYXJzZUludCggYXhpcy5zcGxpdCggJ2pvaW50JyApLnBvcCgpLnNwbGl0KCAnLicgKVswXSApO1xuXHRcdFx0XHRcdFx0dmFyIHZpc3VhbFRhcmdldEVsZW1lbnQgPSBDT0xMQURBLnF1ZXJ5U2VsZWN0b3IoICdbc2lkPVwiJyArIHZpc3VhbFRhcmdldCArICdcIl0nICk7XG5cblx0XHRcdFx0XHRcdGlmICggdmlzdWFsVGFyZ2V0RWxlbWVudCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHBhcmVudFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxUYXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdF9hZGRUb01hcChqb2ludEluZGV4LCBwYXJlbnRWaXN1YWxFbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVNjZW5lR3JhcGggKCBub2RlLCBwYXJlbnQgKSB7XG5cblx0XHR2YXIgb2JqID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG5cdFx0dmFyIHNraW5uZWQgPSBmYWxzZTtcblx0XHR2YXIgc2tpbkNvbnRyb2xsZXI7XG5cdFx0dmFyIG1vcnBoQ29udHJvbGxlcjtcblx0XHR2YXIgaSwgajtcblxuXHRcdC8vIEZJWE1FOiBjb250cm9sbGVyc1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLmNvbnRyb2xsZXJzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyc1sgbm9kZS5jb250cm9sbGVyc1sgaSBdLnVybCBdO1xuXG5cdFx0XHRzd2l0Y2ggKCBjb250cm9sbGVyLnR5cGUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJpZXNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXSApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluc3RfZ2VvbSA9IG5ldyBJbnN0YW5jZUdlb21ldHJ5KCk7XG5cblx0XHRcdFx0XHRcdGluc3RfZ2VvbS51cmwgPSBjb250cm9sbGVyLnNraW4uc291cmNlO1xuXHRcdFx0XHRcdFx0aW5zdF9nZW9tLmluc3RhbmNlX21hdGVyaWFsID0gbm9kZS5jb250cm9sbGVyc1sgaSBdLmluc3RhbmNlX21hdGVyaWFsO1xuXG5cdFx0XHRcdFx0XHRub2RlLmdlb21ldHJpZXMucHVzaCggaW5zdF9nZW9tICk7XG5cdFx0XHRcdFx0XHRza2lubmVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHNraW5Db250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY29udHJvbGxlcnNbIGNvbnRyb2xsZXIuc2tpbi5zb3VyY2UgXSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdXJnaDogY29udHJvbGxlciBjYW4gYmUgY2hhaW5lZFxuXHRcdFx0XHRcdFx0Ly8gaGFuZGxlIHRoZSBtb3N0IGJhc2ljIGNhc2UuLi5cblxuXHRcdFx0XHRcdFx0dmFyIHNlY29uZCA9IGNvbnRyb2xsZXJzWyBjb250cm9sbGVyLnNraW4uc291cmNlIF07XG5cdFx0XHRcdFx0XHRtb3JwaENvbnRyb2xsZXIgPSBzZWNvbmQ7XG5cdFx0XHRcdFx0Ly9cdHNraW5Db250cm9sbGVyID0gbm9kZS5jb250cm9sbGVyc1tpXTtcblxuXHRcdFx0XHRcdFx0aWYgKCBzZWNvbmQubW9ycGggJiYgZ2VvbWV0cmllc1sgc2Vjb25kLm1vcnBoLnNvdXJjZSBdICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBpbnN0X2dlb20gPSBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdFx0XHRcdGluc3RfZ2VvbS51cmwgPSBzZWNvbmQubW9ycGguc291cmNlO1xuXHRcdFx0XHRcdFx0XHRpbnN0X2dlb20uaW5zdGFuY2VfbWF0ZXJpYWwgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF0uaW5zdGFuY2VfbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdFx0bm9kZS5nZW9tZXRyaWVzLnB1c2goIGluc3RfZ2VvbSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtb3JwaCc6XG5cblx0XHRcdFx0XHRpZiAoIGdlb21ldHJpZXNbIGNvbnRyb2xsZXIubW9ycGguc291cmNlIF0gKSB7XG5cblx0XHRcdFx0XHRcdHZhciBpbnN0X2dlb20gPSBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpO1xuXG5cdFx0XHRcdFx0XHRpbnN0X2dlb20udXJsID0gY29udHJvbGxlci5tb3JwaC5zb3VyY2U7XG5cdFx0XHRcdFx0XHRpbnN0X2dlb20uaW5zdGFuY2VfbWF0ZXJpYWwgPSBub2RlLmNvbnRyb2xsZXJzWyBpIF0uaW5zdGFuY2VfbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdG5vZGUuZ2VvbWV0cmllcy5wdXNoKCBpbnN0X2dlb20gKTtcblx0XHRcdFx0XHRcdG1vcnBoQ29udHJvbGxlciA9IG5vZGUuY29udHJvbGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogTW9ycGgtY29udHJvbGxlciBwYXJ0aWFsbHkgc3VwcG9ydGVkLicgKTtcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW9tZXRyaWVzXG5cblx0XHR2YXIgZG91YmxlX3NpZGVkX21hdGVyaWFscyA9IHt9O1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLmdlb21ldHJpZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgaW5zdGFuY2VfZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJpZXNbaV07XG5cdFx0XHR2YXIgaW5zdGFuY2VfbWF0ZXJpYWxzID0gaW5zdGFuY2VfZ2VvbWV0cnkuaW5zdGFuY2VfbWF0ZXJpYWw7XG5cdFx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBpbnN0YW5jZV9nZW9tZXRyeS51cmwgXTtcblx0XHRcdHZhciB1c2VkX21hdGVyaWFscyA9IHt9O1xuXHRcdFx0dmFyIHVzZWRfbWF0ZXJpYWxzX2FycmF5ID0gW107XG5cdFx0XHR2YXIgbnVtX21hdGVyaWFscyA9IDA7XG5cdFx0XHR2YXIgZmlyc3RfbWF0ZXJpYWw7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkgKSB7XG5cblx0XHRcdFx0aWYgKCAhZ2VvbWV0cnkubWVzaCB8fCAhZ2VvbWV0cnkubWVzaC5wcmltaXRpdmVzIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHRpZiAoIG9iai5uYW1lLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdG9iai5uYW1lID0gZ2VvbWV0cnkuaWQ7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNvbGxlY3QgdXNlZCBmeCBmb3IgdGhpcyBnZW9tZXRyeS1pbnN0YW5jZVxuXG5cdFx0XHRcdGlmICggaW5zdGFuY2VfbWF0ZXJpYWxzICkge1xuXG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBpbnN0YW5jZV9tYXRlcmlhbHMubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR2YXIgaW5zdGFuY2VfbWF0ZXJpYWwgPSBpbnN0YW5jZV9tYXRlcmlhbHNbIGogXTtcblx0XHRcdFx0XHRcdHZhciBtYXQgPSBtYXRlcmlhbHNbIGluc3RhbmNlX21hdGVyaWFsLnRhcmdldCBdO1xuXHRcdFx0XHRcdFx0dmFyIGVmZmVjdF9pZCA9IG1hdC5pbnN0YW5jZV9lZmZlY3QudXJsO1xuXHRcdFx0XHRcdFx0dmFyIHNoYWRlciA9IGVmZmVjdHNbIGVmZmVjdF9pZCBdLnNoYWRlcjtcblx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbDNqcyA9IHNoYWRlci5tYXRlcmlhbDtcblxuXHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5kb3VibGVTaWRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoICEoIGluc3RhbmNlX21hdGVyaWFsLnN5bWJvbCBpbiBkb3VibGVfc2lkZWRfbWF0ZXJpYWxzICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgX2NvcGllZF9tYXRlcmlhbCA9IG1hdGVyaWFsM2pzLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdFx0X2NvcGllZF9tYXRlcmlhbC5zaWRlID0gVEhSRUUuRG91YmxlU2lkZTtcblx0XHRcdFx0XHRcdFx0XHRkb3VibGVfc2lkZWRfbWF0ZXJpYWxzWyBpbnN0YW5jZV9tYXRlcmlhbC5zeW1ib2wgXSA9IF9jb3BpZWRfbWF0ZXJpYWw7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdG1hdGVyaWFsM2pzID0gZG91YmxlX3NpZGVkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwzanMub3BhY2l0eSA9ICFtYXRlcmlhbDNqcy5vcGFjaXR5ID8gMSA6IG1hdGVyaWFsM2pzLm9wYWNpdHk7XG5cdFx0XHRcdFx0XHR1c2VkX21hdGVyaWFsc1sgaW5zdGFuY2VfbWF0ZXJpYWwuc3ltYm9sIF0gPSBudW1fbWF0ZXJpYWxzO1xuXHRcdFx0XHRcdFx0dXNlZF9tYXRlcmlhbHNfYXJyYXkucHVzaCggbWF0ZXJpYWwzanMgKTtcblx0XHRcdFx0XHRcdGZpcnN0X21hdGVyaWFsID0gbWF0ZXJpYWwzanM7XG5cdFx0XHRcdFx0XHRmaXJzdF9tYXRlcmlhbC5uYW1lID0gbWF0Lm5hbWUgPT09IG51bGwgfHwgbWF0Lm5hbWUgPT09ICcnID8gbWF0LmlkIDogbWF0Lm5hbWU7XG5cdFx0XHRcdFx0XHRudW1fbWF0ZXJpYWxzICsrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgbWVzaDtcblx0XHRcdFx0dmFyIG1hdGVyaWFsID0gZmlyc3RfbWF0ZXJpYWwgfHwgbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHsgY29sb3I6IDB4ZGRkZGRkLCBzaWRlOiBnZW9tZXRyeS5kb3VibGVTaWRlZCA/IFRIUkVFLkRvdWJsZVNpZGUgOiBUSFJFRS5Gcm9udFNpZGUgfSApO1xuXHRcdFx0XHR2YXIgZ2VvbSA9IGdlb21ldHJ5Lm1lc2guZ2VvbWV0cnkzanM7XG5cblx0XHRcdFx0aWYgKCBudW1fbWF0ZXJpYWxzID4gMSApIHtcblxuXHRcdFx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoIHVzZWRfbWF0ZXJpYWxzX2FycmF5ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2tpbkNvbnRyb2xsZXIgIT09IHVuZGVmaW5lZCApIHtcblxuXG5cdFx0XHRcdFx0YXBwbHlTa2luKCBnZW9tLCBza2luQ29udHJvbGxlciApO1xuXG5cdFx0XHRcdFx0aWYgKCBnZW9tLm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuc2tpbm5pbmcgPSBmYWxzZTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cblx0XHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCBnZW9tLCBtYXRlcmlhbCwgZmFsc2UgKTtcblxuXG5cdFx0XHRcdFx0Ly9tZXNoLnNrZWxldG9uID0gc2tpbkNvbnRyb2xsZXIuc2tlbGV0b247XG5cdFx0XHRcdFx0Ly9tZXNoLnNraW5Db250cm9sbGVyID0gY29udHJvbGxlcnNbIHNraW5Db250cm9sbGVyLnVybCBdO1xuXHRcdFx0XHRcdC8vbWVzaC5za2luSW5zdGFuY2VDb250cm9sbGVyID0gc2tpbkNvbnRyb2xsZXI7XG5cdFx0XHRcdFx0bWVzaC5uYW1lID0gJ3NraW5fJyArIHNraW5zLmxlbmd0aDtcblxuXG5cblx0XHRcdFx0XHQvL21lc2guYW5pbWF0aW9uSGFuZGxlLnNldEtleSgwKTtcblx0XHRcdFx0XHRza2lucy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbW9ycGhDb250cm9sbGVyICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRjcmVhdGVNb3JwaCggZ2VvbSwgbW9ycGhDb250cm9sbGVyICk7XG5cblx0XHRcdFx0XHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0cnVlO1xuXG5cdFx0XHRcdFx0bWVzaCA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tLCBtYXRlcmlhbCApO1xuXHRcdFx0XHRcdG1lc2gubmFtZSA9ICdtb3JwaF8nICsgbW9ycGhzLmxlbmd0aDtcblxuXHRcdFx0XHRcdG1vcnBocy5wdXNoKCBtZXNoICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGlmICggZ2VvbS5pc0xpbmVTdHJpcCA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdFx0bWVzaCA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRtZXNoID0gbmV3IFRIUkVFLk1lc2goIGdlb20sIG1hdGVyaWFsICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9iai5hZGQobWVzaCk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbm9kZS5jYW1lcmFzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGluc3RhbmNlX2NhbWVyYSA9IG5vZGUuY2FtZXJhc1tpXTtcblx0XHRcdHZhciBjcGFyYW1zID0gY2FtZXJhc1tpbnN0YW5jZV9jYW1lcmEudXJsXTtcblxuXHRcdFx0dmFyIGNhbSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYShjcGFyYW1zLnlmb3YsIHBhcnNlRmxvYXQoY3BhcmFtcy5hc3BlY3RfcmF0aW8pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY3BhcmFtcy56bmVhciksIHBhcnNlRmxvYXQoY3BhcmFtcy56ZmFyKSk7XG5cblx0XHRcdG9iai5hZGQoY2FtKTtcblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUubGlnaHRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGxpZ2h0ID0gbnVsbDtcblx0XHRcdHZhciBpbnN0YW5jZV9saWdodCA9IG5vZGUubGlnaHRzW2ldO1xuXHRcdFx0dmFyIGxwYXJhbXMgPSBsaWdodHNbaW5zdGFuY2VfbGlnaHQudXJsXTtcblxuXHRcdFx0aWYgKCBscGFyYW1zICYmIGxwYXJhbXMudGVjaG5pcXVlICkge1xuXG5cdFx0XHRcdHZhciBjb2xvciA9IGxwYXJhbXMuY29sb3IuZ2V0SGV4KCk7XG5cdFx0XHRcdHZhciBpbnRlbnNpdHkgPSBscGFyYW1zLmludGVuc2l0eTtcblx0XHRcdFx0dmFyIGRpc3RhbmNlID0gbHBhcmFtcy5kaXN0YW5jZTtcblx0XHRcdFx0dmFyIGFuZ2xlID0gbHBhcmFtcy5mYWxsb2ZmX2FuZ2xlO1xuXHRcdFx0XHR2YXIgZXhwb25lbnQ7IC8vIEludGVudGlvbmFsbHkgdW5kZWZpbmVkLCBkb24ndCBrbm93IHdoYXQgdGhpcyBpcyB5ZXRcblxuXHRcdFx0XHRzd2l0Y2ggKCBscGFyYW1zLnRlY2huaXF1ZSApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2RpcmVjdGlvbmFsJzpcblxuXHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UgKTtcblx0XHRcdFx0XHRcdGxpZ2h0LnBvc2l0aW9uLnNldCgwLCAwLCAxKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAncG9pbnQnOlxuXG5cdFx0XHRcdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdzcG90JzpcblxuXHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50ICk7XG5cdFx0XHRcdFx0XHRsaWdodC5wb3NpdGlvbi5zZXQoMCwgMCwgMSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXG5cdFx0XHRcdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGNvbG9yICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKGxpZ2h0KSB7XG5cdFx0XHRcdG9iai5hZGQobGlnaHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9iai5uYW1lID0gbm9kZS5uYW1lIHx8IG5vZGUuaWQgfHwgXCJcIjtcblx0XHRvYmouY29sbGFkYUlkID0gbm9kZS5pZCB8fCBcIlwiO1xuXHRcdG9iai5sYXllciA9IG5vZGUubGF5ZXIgfHwgXCJcIjtcblx0XHRvYmoubWF0cml4ID0gbm9kZS5tYXRyaXg7XG5cdFx0b2JqLm1hdHJpeC5kZWNvbXBvc2UoIG9iai5wb3NpdGlvbiwgb2JqLnF1YXRlcm5pb24sIG9iai5zY2FsZSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmNlbnRlckdlb21ldHJ5ICYmIG9iai5nZW9tZXRyeSApIHtcblxuXHRcdFx0dmFyIGRlbHRhID0gb2JqLmdlb21ldHJ5LmNlbnRlcigpO1xuXHRcdFx0ZGVsdGEubXVsdGlwbHkoIG9iai5zY2FsZSApO1xuXHRcdFx0ZGVsdGEuYXBwbHlRdWF0ZXJuaW9uKCBvYmoucXVhdGVybmlvbiApO1xuXG5cdFx0XHRvYmoucG9zaXRpb24uc3ViKCBkZWx0YSApO1xuXG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0b2JqLmFkZCggY3JlYXRlU2NlbmVHcmFwaCggbm9kZS5ub2Rlc1tpXSwgbm9kZSApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRKb2ludElkKCBza2luLCBpZCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHNraW4uam9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0aWYgKCBza2luLmpvaW50c1sgaSBdID09PSBpZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gaTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRMaWJyYXJ5Tm9kZSggaWQgKSB7XG5cblx0XHR2YXIgbm9kZXMgPSBDT0xMQURBLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpYnJhcnlfbm9kZXMgbm9kZScpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdHZhciBhdHRPYmogPSBub2Rlc1tpXS5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnaWQnKTtcblxuXHRcdFx0aWYgKCBhdHRPYmogJiYgYXR0T2JqLnZhbHVlID09PSBpZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gbm9kZXNbaV07XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENoYW5uZWxzRm9yTm9kZSAoIG5vZGUgKSB7XG5cblx0XHR2YXIgY2hhbm5lbHMgPSBbXTtcblx0XHR2YXIgc3RhcnRUaW1lID0gMTAwMDAwMDtcblx0XHR2YXIgZW5kVGltZSA9IC0xMDAwMDAwO1xuXG5cdFx0Zm9yICggdmFyIGlkIGluIGFuaW1hdGlvbnMgKSB7XG5cblx0XHRcdHZhciBhbmltYXRpb24gPSBhbmltYXRpb25zW2lkXTtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uLmNoYW5uZWwubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBjaGFubmVsID0gYW5pbWF0aW9uLmNoYW5uZWxbaV07XG5cdFx0XHRcdHZhciBzYW1wbGVyID0gYW5pbWF0aW9uLnNhbXBsZXJbaV07XG5cdFx0XHRcdHZhciBpZCA9IGNoYW5uZWwudGFyZ2V0LnNwbGl0KCcvJylbMF07XG5cblx0XHRcdFx0aWYgKCBpZCA9PSBub2RlLmlkICkge1xuXG5cdFx0XHRcdFx0c2FtcGxlci5jcmVhdGUoKTtcblx0XHRcdFx0XHRjaGFubmVsLnNhbXBsZXIgPSBzYW1wbGVyO1xuXHRcdFx0XHRcdHN0YXJ0VGltZSA9IE1hdGgubWluKHN0YXJ0VGltZSwgc2FtcGxlci5zdGFydFRpbWUpO1xuXHRcdFx0XHRcdGVuZFRpbWUgPSBNYXRoLm1heChlbmRUaW1lLCBzYW1wbGVyLmVuZFRpbWUpO1xuXHRcdFx0XHRcdGNoYW5uZWxzLnB1c2goY2hhbm5lbCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIGNoYW5uZWxzLmxlbmd0aCApIHtcblxuXHRcdFx0bm9kZS5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG5cdFx0XHRub2RlLmVuZFRpbWUgPSBlbmRUaW1lO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNoYW5uZWxzO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBjYWxjRnJhbWVEdXJhdGlvbiggbm9kZSApIHtcblxuXHRcdHZhciBtaW5UID0gMTAwMDAwMDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2RlLmNoYW5uZWxzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIHNhbXBsZXIgPSBub2RlLmNoYW5uZWxzW2ldLnNhbXBsZXI7XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHNhbXBsZXIuaW5wdXQubGVuZ3RoIC0gMTsgaiArKyApIHtcblxuXHRcdFx0XHR2YXIgdDAgPSBzYW1wbGVyLmlucHV0WyBqIF07XG5cdFx0XHRcdHZhciB0MSA9IHNhbXBsZXIuaW5wdXRbIGogKyAxIF07XG5cdFx0XHRcdG1pblQgPSBNYXRoLm1pbiggbWluVCwgdDEgLSB0MCApO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pblQ7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGNNYXRyaXhBdCggbm9kZSwgdCApIHtcblxuXHRcdHZhciBhbmltYXRlZCA9IHt9O1xuXG5cdFx0dmFyIGksIGo7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IG5vZGUuY2hhbm5lbHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbIGkgXTtcblx0XHRcdGFuaW1hdGVkWyBjaGFubmVsLnNpZCBdID0gY2hhbm5lbDtcblxuXHRcdH1cblxuXHRcdHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBub2RlLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gbm9kZS50cmFuc2Zvcm1zWyBpIF07XG5cdFx0XHR2YXIgY2hhbm5lbCA9IGFuaW1hdGVkWyB0cmFuc2Zvcm0uc2lkIF07XG5cblx0XHRcdGlmICggY2hhbm5lbCAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHZhciBzYW1wbGVyID0gY2hhbm5lbC5zYW1wbGVyO1xuXHRcdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBzYW1wbGVyLmlucHV0Lmxlbmd0aCAtIDE7IGogKysgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHNhbXBsZXIuaW5wdXRbIGogKyAxIF0gPiB0ICkge1xuXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHNhbXBsZXIub3V0cHV0WyBqIF07XG5cdFx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKHZhbHVlLmZsYXR0ZW4pXG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLk1hdHJpeDQgKSB7XG5cblx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHZhbHVlICk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBGSVhNRTogaGFuZGxlIG90aGVyIHR5cGVzXG5cblx0XHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRyYW5zZm9ybS5tYXRyaXggKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdHJhbnNmb3JtLm1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0cmFuc2Zvcm0ubWF0cml4ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRyaXg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGJha2VBbmltYXRpb25zICggbm9kZSApIHtcblxuXHRcdGlmICggbm9kZS5jaGFubmVscyAmJiBub2RlLmNoYW5uZWxzLmxlbmd0aCApIHtcblxuXHRcdFx0dmFyIGtleXMgPSBbXSxcblx0XHRcdFx0c2lkcyA9IFtdO1xuXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9kZS5jaGFubmVscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuXHRcdFx0XHR2YXIgY2hhbm5lbCA9IG5vZGUuY2hhbm5lbHNbaV0sXG5cdFx0XHRcdFx0ZnVsbFNpZCA9IGNoYW5uZWwuZnVsbFNpZCxcblx0XHRcdFx0XHRzYW1wbGVyID0gY2hhbm5lbC5zYW1wbGVyLFxuXHRcdFx0XHRcdGlucHV0ID0gc2FtcGxlci5pbnB1dCxcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBub2RlLmdldFRyYW5zZm9ybUJ5U2lkKCBjaGFubmVsLnNpZCApLFxuXHRcdFx0XHRcdG1lbWJlcjtcblxuXHRcdFx0XHRpZiAoIGNoYW5uZWwuYXJySW5kaWNlcyApIHtcblxuXHRcdFx0XHRcdG1lbWJlciA9IFtdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGNoYW5uZWwuYXJySW5kaWNlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0bWVtYmVyWyBqIF0gPSBnZXRDb252ZXJ0ZWRJbmRleCggY2hhbm5lbC5hcnJJbmRpY2VzWyBqIF0gKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0bWVtYmVyID0gZ2V0Q29udmVydGVkTWVtYmVyKCBjaGFubmVsLm1lbWJlciApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHRyYW5zZm9ybSApIHtcblxuXHRcdFx0XHRcdGlmICggc2lkcy5pbmRleE9mKCBmdWxsU2lkICkgPT09IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzaWRzLnB1c2goIGZ1bGxTaWQgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBpbnB1dC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIHRpbWUgPSBpbnB1dFtqXSxcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHNhbXBsZXIuZ2V0RGF0YSggdHJhbnNmb3JtLnR5cGUsIGosIG1lbWJlciApLFxuXHRcdFx0XHRcdFx0XHRrZXkgPSBmaW5kS2V5KCBrZXlzLCB0aW1lICk7XG5cblx0XHRcdFx0XHRcdGlmICggIWtleSApIHtcblxuXHRcdFx0XHRcdFx0XHRrZXkgPSBuZXcgS2V5KCB0aW1lICk7XG5cdFx0XHRcdFx0XHRcdHZhciB0aW1lTmR4ID0gZmluZFRpbWVOZHgoIGtleXMsIHRpbWUgKTtcblx0XHRcdFx0XHRcdFx0a2V5cy5zcGxpY2UoIHRpbWVOZHggPT09IC0xID8ga2V5cy5sZW5ndGggOiB0aW1lTmR4LCAwLCBrZXkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRrZXkuYWRkVGFyZ2V0KCBmdWxsU2lkLCB0cmFuc2Zvcm0sIG1lbWJlciwgZGF0YSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggJ0NvdWxkIG5vdCBmaW5kIHRyYW5zZm9ybSBcIicgKyBjaGFubmVsLnNpZCArICdcIiBpbiBub2RlICcgKyBub2RlLmlkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHBvc3QgcHJvY2Vzc1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2lkcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIHNpZCA9IHNpZHNbIGkgXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzWyBqIF07XG5cblx0XHRcdFx0XHRpZiAoICFrZXkuaGFzVGFyZ2V0KCBzaWQgKSApIHtcblxuXHRcdFx0XHRcdFx0aW50ZXJwb2xhdGVLZXlzKCBrZXlzLCBrZXksIGosIHNpZCApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0XHRub2RlLmtleXMgPSBrZXlzO1xuXHRcdFx0bm9kZS5zaWRzID0gc2lkcztcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZmluZEtleSAoIGtleXMsIHRpbWUpIHtcblxuXHRcdHZhciByZXRWYWwgPSBudWxsO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGtleXMubGVuZ3RoOyBpIDwgaWwgJiYgcmV0VmFsID09PSBudWxsOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblxuXHRcdFx0aWYgKCBrZXkudGltZSA9PT0gdGltZSApIHtcblxuXHRcdFx0XHRyZXRWYWwgPSBrZXk7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGtleS50aW1lID4gdGltZSApIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldFZhbDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZmluZFRpbWVOZHggKCBrZXlzLCB0aW1lKSB7XG5cblx0XHR2YXIgbmR4ID0gLTE7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbCAmJiBuZHggPT09IC0xOyBpICsrICkge1xuXG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblxuXHRcdFx0aWYgKCBrZXkudGltZSA+PSB0aW1lICkge1xuXG5cdFx0XHRcdG5keCA9IGk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBuZHg7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGludGVycG9sYXRlS2V5cyAoIGtleXMsIGtleSwgbmR4LCBmdWxsU2lkICkge1xuXG5cdFx0dmFyIHByZXZLZXkgPSBnZXRQcmV2S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ID8gbmR4IC0gMSA6IDAgKSxcblx0XHRcdG5leHRLZXkgPSBnZXROZXh0S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ICsgMSApO1xuXG5cdFx0aWYgKCBwcmV2S2V5ICYmIG5leHRLZXkgKSB7XG5cblx0XHRcdHZhciBzY2FsZSA9IChrZXkudGltZSAtIHByZXZLZXkudGltZSkgLyAobmV4dEtleS50aW1lIC0gcHJldktleS50aW1lKSxcblx0XHRcdFx0cHJldlRhcmdldCA9IHByZXZLZXkuZ2V0VGFyZ2V0KCBmdWxsU2lkICksXG5cdFx0XHRcdG5leHREYXRhID0gbmV4dEtleS5nZXRUYXJnZXQoIGZ1bGxTaWQgKS5kYXRhLFxuXHRcdFx0XHRwcmV2RGF0YSA9IHByZXZUYXJnZXQuZGF0YSxcblx0XHRcdFx0ZGF0YTtcblxuXHRcdFx0aWYgKCBwcmV2VGFyZ2V0LnR5cGUgPT09ICdtYXRyaXgnICkge1xuXG5cdFx0XHRcdGRhdGEgPSBwcmV2RGF0YTtcblxuXHRcdFx0fSBlbHNlIGlmICggcHJldkRhdGEubGVuZ3RoICkge1xuXG5cdFx0XHRcdGRhdGEgPSBbXTtcblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwcmV2RGF0YS5sZW5ndGg7ICsrIGkgKSB7XG5cblx0XHRcdFx0XHRkYXRhWyBpIF0gPSBwcmV2RGF0YVsgaSBdICsgKCBuZXh0RGF0YVsgaSBdIC0gcHJldkRhdGFbIGkgXSApICogc2NhbGU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGRhdGEgPSBwcmV2RGF0YSArICggbmV4dERhdGEgLSBwcmV2RGF0YSApICogc2NhbGU7XG5cblx0XHRcdH1cblxuXHRcdFx0a2V5LmFkZFRhcmdldCggZnVsbFNpZCwgcHJldlRhcmdldC50cmFuc2Zvcm0sIHByZXZUYXJnZXQubWVtYmVyLCBkYXRhICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIEdldCBuZXh0IGtleSB3aXRoIGdpdmVuIHNpZFxuXG5cdGZ1bmN0aW9uIGdldE5leHRLZXlXaXRoKCBrZXlzLCBmdWxsU2lkLCBuZHggKSB7XG5cblx0XHRmb3IgKCA7IG5keCA8IGtleXMubGVuZ3RoOyBuZHggKysgKSB7XG5cblx0XHRcdHZhciBrZXkgPSBrZXlzWyBuZHggXTtcblxuXHRcdFx0aWYgKCBrZXkuaGFzVGFyZ2V0KCBmdWxsU2lkICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGtleTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdC8vIEdldCBwcmV2aW91cyBrZXkgd2l0aCBnaXZlbiBzaWRcblxuXHRmdW5jdGlvbiBnZXRQcmV2S2V5V2l0aCgga2V5cywgZnVsbFNpZCwgbmR4ICkge1xuXG5cdFx0bmR4ID0gbmR4ID49IDAgPyBuZHggOiBuZHggKyBrZXlzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgbmR4ID49IDA7IG5keCAtLSApIHtcblxuXHRcdFx0dmFyIGtleSA9IGtleXNbIG5keCBdO1xuXG5cdFx0XHRpZiAoIGtleS5oYXNUYXJnZXQoIGZ1bGxTaWQgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4ga2V5O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX0ltYWdlKCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5pbml0X2Zyb20gPSBcIlwiO1xuXG5cdH1cblxuXHRfSW1hZ2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdpbml0X2Zyb20nICkge1xuXG5cdFx0XHRcdHRoaXMuaW5pdF9mcm9tID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gQ29udHJvbGxlcigpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy50eXBlID0gXCJcIjtcblx0XHR0aGlzLnNraW4gPSBudWxsO1xuXHRcdHRoaXMubW9ycGggPSBudWxsO1xuXG5cdH1cblxuXHRDb250cm9sbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdHRoaXMubmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG5cdFx0dGhpcy50eXBlID0gXCJub25lXCI7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc2tpbic6XG5cblx0XHRcdFx0XHR0aGlzLnNraW4gPSAobmV3IFNraW4oKSkucGFyc2UoY2hpbGQpO1xuXHRcdFx0XHRcdHRoaXMudHlwZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21vcnBoJzpcblxuXHRcdFx0XHRcdHRoaXMubW9ycGggPSAobmV3IE1vcnBoKCkpLnBhcnNlKGNoaWxkKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBNb3JwaCgpIHtcblxuXHRcdHRoaXMubWV0aG9kID0gbnVsbDtcblx0XHR0aGlzLnNvdXJjZSA9IG51bGw7XG5cdFx0dGhpcy50YXJnZXRzID0gbnVsbDtcblx0XHR0aGlzLndlaWdodHMgPSBudWxsO1xuXG5cdH1cblxuXHRNb3JwaC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdHZhciBzb3VyY2VzID0ge307XG5cdFx0dmFyIGlucHV0cyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0dGhpcy5tZXRob2QgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ21ldGhvZCcgKTtcblx0XHR0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cblx0XHRcdFx0XHR2YXIgc291cmNlID0gKCBuZXcgU291cmNlKCkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHRzb3VyY2VzWyBzb3VyY2UuaWQgXSA9IHNvdXJjZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0YXJnZXRzJzpcblxuXHRcdFx0XHRcdGlucHV0cyA9IHRoaXMucGFyc2VJbnB1dHMoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpbnB1dCA9IGlucHV0c1sgaSBdO1xuXHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXG5cdFx0XHRzd2l0Y2ggKCBpbnB1dC5zZW1hbnRpYyApIHtcblxuXHRcdFx0XHRjYXNlICdNT1JQSF9UQVJHRVQnOlxuXG5cdFx0XHRcdFx0dGhpcy50YXJnZXRzID0gc291cmNlLnJlYWQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdNT1JQSF9XRUlHSFQnOlxuXG5cdFx0XHRcdFx0dGhpcy53ZWlnaHRzID0gc291cmNlLnJlYWQoKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRNb3JwaC5wcm90b3R5cGUucGFyc2VJbnB1dHMgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cblx0XHR2YXIgaW5wdXRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEpIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHRpbnB1dHMucHVzaCggKG5ldyBJbnB1dCgpKS5wYXJzZShjaGlsZCkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbnB1dHM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBTa2luKCkge1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBcIlwiO1xuXHRcdHRoaXMuYmluZFNoYXBlTWF0cml4ID0gbnVsbDtcblx0XHR0aGlzLmludkJpbmRNYXRyaWNlcyA9IFtdO1xuXHRcdHRoaXMuam9pbnRzID0gW107XG5cdFx0dGhpcy53ZWlnaHRzID0gW107XG5cblx0fVxuXG5cdFNraW4ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR2YXIgc291cmNlcyA9IHt9O1xuXHRcdHZhciBqb2ludHMsIHdlaWdodHM7XG5cblx0XHR0aGlzLnNvdXJjZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnc291cmNlJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG5cdFx0dGhpcy5pbnZCaW5kTWF0cmljZXMgPSBbXTtcblx0XHR0aGlzLmpvaW50cyA9IFtdO1xuXHRcdHRoaXMud2VpZ2h0cyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2JpbmRfc2hhcGVfbWF0cml4JzpcblxuXHRcdFx0XHRcdHZhciBmID0gX2Zsb2F0cyhjaGlsZC50ZXh0Q29udGVudCk7XG5cdFx0XHRcdFx0dGhpcy5iaW5kU2hhcGVNYXRyaXggPSBnZXRDb252ZXJ0ZWRNYXQ0KCBmICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHZhciBzcmMgPSBuZXcgU291cmNlKCkucGFyc2UoY2hpbGQpO1xuXHRcdFx0XHRcdHNvdXJjZXNbIHNyYy5pZCBdID0gc3JjO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2pvaW50cyc6XG5cblx0XHRcdFx0XHRqb2ludHMgPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd2ZXJ0ZXhfd2VpZ2h0cyc6XG5cblx0XHRcdFx0XHR3ZWlnaHRzID0gY2hpbGQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5wYXJzZUpvaW50cyggam9pbnRzLCBzb3VyY2VzICk7XG5cdFx0dGhpcy5wYXJzZVdlaWdodHMoIHdlaWdodHMsIHNvdXJjZXMgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0U2tpbi5wcm90b3R5cGUucGFyc2VKb2ludHMgPSBmdW5jdGlvbiAoIGVsZW1lbnQsIHNvdXJjZXMgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHR2YXIgaW5wdXQgPSAoIG5ldyBJbnB1dCgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCBpbnB1dC5zZW1hbnRpYyA9PT0gJ0pPSU5UJyApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5qb2ludHMgPSBzb3VyY2UucmVhZCgpO1xuXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggaW5wdXQuc2VtYW50aWMgPT09ICdJTlZfQklORF9NQVRSSVgnICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmludkJpbmRNYXRyaWNlcyA9IHNvdXJjZS5yZWFkKCk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0U2tpbi5wcm90b3R5cGUucGFyc2VXZWlnaHRzID0gZnVuY3Rpb24gKCBlbGVtZW50LCBzb3VyY2VzICkge1xuXG5cdFx0dmFyIHYsIHZjb3VudCwgaW5wdXRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHRpbnB1dHMucHVzaCggKCBuZXcgSW5wdXQoKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndic6XG5cblx0XHRcdFx0XHR2ID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndmNvdW50JzpcblxuXHRcdFx0XHRcdHZjb3VudCA9IF9pbnRzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHZhciBpbmRleCA9IDA7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2Y291bnQubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbnVtQm9uZXMgPSB2Y291bnRbaV07XG5cdFx0XHR2YXIgdmVydGV4X3dlaWdodHMgPSBbXTtcblxuXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbnVtQm9uZXM7IGogKysgKSB7XG5cblx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IHt9O1xuXG5cdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5wdXQgPSBpbnB1dHNbIGsgXTtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2WyBpbmRleCArIGlucHV0Lm9mZnNldCBdO1xuXG5cdFx0XHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ0pPSU5UJzpcblxuXHRcdFx0XHRcdFx0XHRpbmZsdWVuY2Uuam9pbnQgPSB2YWx1ZTsvL3RoaXMuam9pbnRzW3ZhbHVlXTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdGNhc2UgJ1dFSUdIVCc6XG5cblx0XHRcdFx0XHRcdFx0aW5mbHVlbmNlLndlaWdodCA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdLmRhdGFbIHZhbHVlIF07XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmVydGV4X3dlaWdodHMucHVzaCggaW5mbHVlbmNlICk7XG5cdFx0XHRcdGluZGV4ICs9IGlucHV0cy5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHZlcnRleF93ZWlnaHRzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHR2ZXJ0ZXhfd2VpZ2h0c1sgaiBdLmluZGV4ID0gaTtcblxuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLndlaWdodHMucHVzaCggdmVydGV4X3dlaWdodHMgKTtcblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFZpc3VhbFNjZW5lICgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdHRoaXMuc2NlbmUgPSBuZXcgVEhSRUUuR3JvdXAoKTtcblxuXHR9XG5cblx0VmlzdWFsU2NlbmUucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uKCBpZCwgcmVjdXJzaXZlICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBub2RlID0gdGhpcy5ub2Rlc1sgaSBdLmdldENoaWxkQnlJZCggaWQsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRpZiAoIG5vZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH07XG5cblx0VmlzdWFsU2NlbmUucHJvdG90eXBlLmdldENoaWxkQnlTaWQgPSBmdW5jdGlvbiggc2lkLCByZWN1cnNpdmUgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIG5vZGUgPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeVNpZCggc2lkLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0aWYgKCBub2RlICkge1xuXG5cdFx0XHRcdHJldHVybiBub2RlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdFZpc3VhbFNjZW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdHRoaXMubm9kZXMgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ25vZGUnOlxuXG5cdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gTm9kZSgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy5zaWQgPSBcIlwiO1xuXHRcdHRoaXMubm9kZXMgPSBbXTtcblx0XHR0aGlzLmNvbnRyb2xsZXJzID0gW107XG5cdFx0dGhpcy50cmFuc2Zvcm1zID0gW107XG5cdFx0dGhpcy5nZW9tZXRyaWVzID0gW107XG5cdFx0dGhpcy5jaGFubmVscyA9IFtdO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHR9XG5cblx0Tm9kZS5wcm90b3R5cGUuZ2V0Q2hhbm5lbEZvclRyYW5zZm9ybSA9IGZ1bmN0aW9uKCB0cmFuc2Zvcm1TaWQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYW5uZWxzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuXHRcdFx0dmFyIHBhcnRzID0gY2hhbm5lbC50YXJnZXQuc3BsaXQoJy8nKTtcblx0XHRcdHZhciBpZCA9IHBhcnRzLnNoaWZ0KCk7XG5cdFx0XHR2YXIgc2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdHZhciBkb3RTeW50YXggPSAoc2lkLmluZGV4T2YoXCIuXCIpID49IDApO1xuXHRcdFx0dmFyIGFyclN5bnRheCA9IChzaWQuaW5kZXhPZihcIihcIikgPj0gMCk7XG5cdFx0XHR2YXIgYXJySW5kaWNlcztcblx0XHRcdHZhciBtZW1iZXI7XG5cblx0XHRcdGlmICggZG90U3ludGF4ICkge1xuXG5cdFx0XHRcdHBhcnRzID0gc2lkLnNwbGl0KFwiLlwiKTtcblx0XHRcdFx0c2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdFx0bWVtYmVyID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdFx0fSBlbHNlIGlmICggYXJyU3ludGF4ICkge1xuXG5cdFx0XHRcdGFyckluZGljZXMgPSBzaWQuc3BsaXQoXCIoXCIpO1xuXHRcdFx0XHRzaWQgPSBhcnJJbmRpY2VzLnNoaWZ0KCk7XG5cblx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgYXJySW5kaWNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRhcnJJbmRpY2VzWyBqIF0gPSBwYXJzZUludCggYXJySW5kaWNlc1sgaiBdLnJlcGxhY2UoIC9cXCkvLCAnJyApICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2lkID09PSB0cmFuc2Zvcm1TaWQgKSB7XG5cblx0XHRcdFx0Y2hhbm5lbC5pbmZvID0geyBzaWQ6IHNpZCwgZG90U3ludGF4OiBkb3RTeW50YXgsIGFyclN5bnRheDogYXJyU3ludGF4LCBhcnJJbmRpY2VzOiBhcnJJbmRpY2VzIH07XG5cdFx0XHRcdHJldHVybiBjaGFubmVsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdE5vZGUucHJvdG90eXBlLmdldENoaWxkQnlJZCA9IGZ1bmN0aW9uICggaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5pZCA9PT0gaWQgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCByZWN1cnNpdmUgKSB7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHZhciBuID0gdGhpcy5ub2Rlc1sgaSBdLmdldENoaWxkQnlJZCggaWQsIHJlY3Vyc2l2ZSApO1xuXG5cdFx0XHRcdGlmICggbiApIHtcblxuXHRcdFx0XHRcdHJldHVybiBuO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS5nZXRDaGlsZEJ5U2lkID0gZnVuY3Rpb24gKCBzaWQsIHJlY3Vyc2l2ZSApIHtcblxuXHRcdGlmICggdGhpcy5zaWQgPT09IHNpZCApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHR9XG5cblx0XHRpZiAoIHJlY3Vyc2l2ZSApIHtcblxuXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdFx0dmFyIG4gPSB0aGlzLm5vZGVzWyBpIF0uZ2V0Q2hpbGRCeVNpZCggc2lkLCByZWN1cnNpdmUgKTtcblxuXHRcdFx0XHRpZiAoIG4gKSB7XG5cblx0XHRcdFx0XHRyZXR1cm4gbjtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdE5vZGUucHJvdG90eXBlLmdldFRyYW5zZm9ybUJ5U2lkID0gZnVuY3Rpb24gKCBzaWQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRoaXMudHJhbnNmb3Jtc1sgaSBdLnNpZCA9PT0gc2lkICkgcmV0dXJuIHRoaXMudHJhbnNmb3Jtc1sgaSBdO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0dmFyIHVybDtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHR0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzaWQnKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXHRcdHRoaXMudHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cdFx0dGhpcy5sYXllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdsYXllcicpO1xuXG5cdFx0dGhpcy50eXBlID0gdGhpcy50eXBlID09PSAnSk9JTlQnID8gdGhpcy50eXBlIDogJ05PREUnO1xuXG5cdFx0dGhpcy5ub2RlcyA9IFtdO1xuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuXHRcdHRoaXMuZ2VvbWV0cmllcyA9IFtdO1xuXHRcdHRoaXMuY2FtZXJhcyA9IFtdO1xuXHRcdHRoaXMubGlnaHRzID0gW107XG5cdFx0dGhpcy5jb250cm9sbGVycyA9IFtdO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ25vZGUnOlxuXG5cdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX2NhbWVyYSc6XG5cblx0XHRcdFx0XHR0aGlzLmNhbWVyYXMucHVzaCggKCBuZXcgSW5zdGFuY2VDYW1lcmEoKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaW5zdGFuY2VfY29udHJvbGxlcic6XG5cblx0XHRcdFx0XHR0aGlzLmNvbnRyb2xsZXJzLnB1c2goICggbmV3IEluc3RhbmNlQ29udHJvbGxlcigpICkucGFyc2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnN0YW5jZV9nZW9tZXRyeSc6XG5cblx0XHRcdFx0XHR0aGlzLmdlb21ldHJpZXMucHVzaCggKCBuZXcgSW5zdGFuY2VHZW9tZXRyeSgpICkucGFyc2UoIGNoaWxkICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnN0YW5jZV9saWdodCc6XG5cblx0XHRcdFx0XHR0aGlzLmxpZ2h0cy5wdXNoKCAoIG5ldyBJbnN0YW5jZUxpZ2h0KCkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2luc3RhbmNlX25vZGUnOlxuXG5cdFx0XHRcdFx0dXJsID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAndXJsJyApLnJlcGxhY2UoIC9eIy8sICcnICk7XG5cdFx0XHRcdFx0dmFyIGlOb2RlID0gZ2V0TGlicmFyeU5vZGUoIHVybCApO1xuXG5cdFx0XHRcdFx0aWYgKCBpTm9kZSApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy5ub2Rlcy5wdXNoKCAoIG5ldyBOb2RlKCkgKS5wYXJzZSggaU5vZGUgKSkgO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRjYXNlICdsb29rYXQnOlxuXHRcdFx0XHRjYXNlICdza2V3JzpcblxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtcy5wdXNoKCAoIG5ldyBUcmFuc2Zvcm0oKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRjb25zb2xlLmxvZyggY2hpbGQubm9kZU5hbWUgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5jaGFubmVscyA9IGdldENoYW5uZWxzRm9yTm9kZSggdGhpcyApO1xuXHRcdGJha2VBbmltYXRpb25zKCB0aGlzICk7XG5cblx0XHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHROb2RlLnByb3RvdHlwZS51cGRhdGVNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR0aGlzLm1hdHJpeC5pZGVudGl0eSgpO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFuc2Zvcm1zLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dGhpcy50cmFuc2Zvcm1zWyBpIF0uYXBwbHkoIHRoaXMubWF0cml4ICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHRmdW5jdGlvbiBUcmFuc2Zvcm0gKCkge1xuXG5cdFx0dGhpcy5zaWQgPSBcIlwiO1xuXHRcdHRoaXMudHlwZSA9IFwiXCI7XG5cdFx0dGhpcy5kYXRhID0gW107XG5cdFx0dGhpcy5vYmogPSBudWxsO1xuXG5cdH1cblxuXHRUcmFuc2Zvcm0ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5zaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NpZCcgKTtcblx0XHR0aGlzLnR5cGUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXHRcdHRoaXMuZGF0YSA9IF9mbG9hdHMoIGVsZW1lbnQudGV4dENvbnRlbnQgKTtcblx0XHR0aGlzLmNvbnZlcnQoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0VHJhbnNmb3JtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0c3dpdGNoICggdGhpcy50eXBlICkge1xuXG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdHRoaXMub2JqID0gZ2V0Q29udmVydGVkTWF0NCggdGhpcy5kYXRhICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXG5cdFx0XHRcdHRoaXMuYW5nbGUgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmRhdGFbM10gKTtcblxuXHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblxuXHRcdFx0XHRmaXhDb29yZHMoIHRoaXMuZGF0YSwgLTEgKTtcblx0XHRcdFx0dGhpcy5vYmogPSBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy5kYXRhWyAwIF0sIHRoaXMuZGF0YVsgMSBdLCB0aGlzLmRhdGFbIDIgXSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnc2NhbGUnOlxuXG5cdFx0XHRcdGZpeENvb3JkcyggdGhpcy5kYXRhLCAxICk7XG5cdFx0XHRcdHRoaXMub2JqID0gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuZGF0YVsgMCBdLCB0aGlzLmRhdGFbIDEgXSwgdGhpcy5kYXRhWyAyIF0gKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnQ2FuIG5vdCBjb252ZXJ0IFRyYW5zZm9ybSBvZiB0eXBlICcgKyB0aGlzLnR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fTtcblxuXHRUcmFuc2Zvcm0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0dmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuXHRcdFx0c3dpdGNoICggdGhpcy50eXBlICkge1xuXG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0XHRtYXRyaXgubXVsdGlwbHkoIHRoaXMub2JqICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXG5cdFx0XHRcdFx0bWF0cml4Lm11bHRpcGx5KCBtMS5tYWtlVHJhbnNsYXRpb24oIHRoaXMub2JqLngsIHRoaXMub2JqLnksIHRoaXMub2JqLnogKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblxuXHRcdFx0XHRcdG1hdHJpeC5tdWx0aXBseSggbTEubWFrZVJvdGF0aW9uQXhpcyggdGhpcy5vYmosIHRoaXMuYW5nbGUgKSApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2NhbGUnOlxuXG5cdFx0XHRcdFx0bWF0cml4LnNjYWxlKCB0aGlzLm9iaiApO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH07XG5cblx0fSgpO1xuXG5cdFRyYW5zZm9ybS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkYXRhLCBtZW1iZXIgKSB7XG5cblx0XHR2YXIgbWVtYmVycyA9IFsgJ1gnLCAnWScsICdaJywgJ0FOR0xFJyBdO1xuXG5cdFx0c3dpdGNoICggdGhpcy50eXBlICkge1xuXG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdGlmICggISBtZW1iZXIgKSB7XG5cblx0XHRcdFx0XHR0aGlzLm9iai5jb3B5KCBkYXRhICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggbWVtYmVyLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdFx0XHRcdHN3aXRjaCAoIG1lbWJlclsgMCBdICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlIDA6XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjExID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMjEgPSBkYXRhWyAxIF07XG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4zMSA9IGRhdGFbIDIgXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQxID0gZGF0YVsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjEyID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMjIgPSBkYXRhWyAxIF07XG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4zMiA9IGRhdGFbIDIgXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQyID0gZGF0YVsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIDI6XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjEzID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMjMgPSBkYXRhWyAxIF07XG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4zMyA9IGRhdGFbIDIgXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQzID0gZGF0YVsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjYXNlIDM6XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjE0ID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0XHR0aGlzLm9iai5uMjQgPSBkYXRhWyAxIF07XG5cdFx0XHRcdFx0XHRcdHRoaXMub2JqLm4zNCA9IGRhdGFbIDIgXTtcblx0XHRcdFx0XHRcdFx0dGhpcy5vYmoubjQ0ID0gZGF0YVsgMyBdO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbWJlci5sZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0XHR2YXIgcHJvcE5hbWUgPSAnbicgKyAoIG1lbWJlclsgMCBdICsgMSApICsgKCBtZW1iZXJbIDEgXSArIDEgKTtcblx0XHRcdFx0XHR0aGlzLm9ialsgcHJvcE5hbWUgXSA9IGRhdGE7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdJbmNvcnJlY3QgYWRkcmVzc2luZyBvZiBtYXRyaXggaW4gdHJhbnNmb3JtLicpO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAndHJhbnNsYXRlJzpcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblxuXHRcdFx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggbWVtYmVyICkgPT09ICdbb2JqZWN0IEFycmF5XScgKSB7XG5cblx0XHRcdFx0XHRtZW1iZXIgPSBtZW1iZXJzWyBtZW1iZXJbIDAgXSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKCBtZW1iZXIgKSB7XG5cblx0XHRcdFx0XHRjYXNlICdYJzpcblxuXHRcdFx0XHRcdFx0dGhpcy5vYmoueCA9IGRhdGE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1knOlxuXG5cdFx0XHRcdFx0XHR0aGlzLm9iai55ID0gZGF0YTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnWic6XG5cblx0XHRcdFx0XHRcdHRoaXMub2JqLnogPSBkYXRhO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHR0aGlzLm9iai54ID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmoueSA9IGRhdGFbIDEgXTtcblx0XHRcdFx0XHRcdHRoaXMub2JqLnogPSBkYXRhWyAyIF07XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cblx0XHRcdFx0aWYgKCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoIG1lbWJlciApID09PSAnW29iamVjdCBBcnJheV0nICkge1xuXG5cdFx0XHRcdFx0bWVtYmVyID0gbWVtYmVyc1sgbWVtYmVyWyAwIF0gXTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3dpdGNoICggbWVtYmVyICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAnWCc6XG5cblx0XHRcdFx0XHRcdHRoaXMub2JqLnggPSBkYXRhO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdZJzpcblxuXHRcdFx0XHRcdFx0dGhpcy5vYmoueSA9IGRhdGE7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ1onOlxuXG5cdFx0XHRcdFx0XHR0aGlzLm9iai56ID0gZGF0YTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQU5HTEUnOlxuXG5cdFx0XHRcdFx0XHR0aGlzLmFuZ2xlID0gVEhSRUUuTWF0aC5kZWdUb1JhZCggZGF0YSApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHR0aGlzLm9iai54ID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmoueSA9IGRhdGFbIDEgXTtcblx0XHRcdFx0XHRcdHRoaXMub2JqLnogPSBkYXRhWyAyIF07XG5cdFx0XHRcdFx0XHR0aGlzLmFuZ2xlID0gVEhSRUUuTWF0aC5kZWdUb1JhZCggZGF0YVsgMyBdICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gSW5zdGFuY2VDb250cm9sbGVyKCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXHRcdHRoaXMuc2tlbGV0b24gPSBbXTtcblx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cblx0fVxuXG5cdEluc3RhbmNlQ29udHJvbGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcblx0XHR0aGlzLnNrZWxldG9uID0gW107XG5cdFx0dGhpcy5pbnN0YW5jZV9tYXRlcmlhbCA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9PSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NrZWxldG9uJzpcblxuXHRcdFx0XHRcdHRoaXMuc2tlbGV0b24ucHVzaCggY2hpbGQudGV4dENvbnRlbnQucmVwbGFjZSgvXiMvLCAnJykgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdiaW5kX21hdGVyaWFsJzpcblxuXHRcdFx0XHRcdHZhciBpbnN0YW5jZXMgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9tYXRlcmlhbCcpO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaW5zdGFuY2VzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdFx0dmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2pdO1xuXHRcdFx0XHRcdFx0dGhpcy5pbnN0YW5jZV9tYXRlcmlhbC5wdXNoKCAobmV3IEluc3RhbmNlTWF0ZXJpYWwoKSkucGFyc2UoaW5zdGFuY2UpICk7XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBJbnN0YW5jZU1hdGVyaWFsICgpIHtcblxuXHRcdHRoaXMuc3ltYm9sID0gXCJcIjtcblx0XHR0aGlzLnRhcmdldCA9IFwiXCI7XG5cblx0fVxuXG5cdEluc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5zeW1ib2wgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3ltYm9sJyk7XG5cdFx0dGhpcy50YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFyZ2V0JykucmVwbGFjZSgvXiMvLCAnJyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBJbnN0YW5jZUdlb21ldHJ5KCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXHRcdHRoaXMuaW5zdGFuY2VfbWF0ZXJpYWwgPSBbXTtcblxuXHR9XG5cblx0SW5zdGFuY2VHZW9tZXRyeS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcblx0XHR0aGlzLmluc3RhbmNlX21hdGVyaWFsID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlTmFtZSA9PT0gJ2JpbmRfbWF0ZXJpYWwnICkge1xuXG5cdFx0XHRcdHZhciBpbnN0YW5jZXMgPSBjaGlsZC5xdWVyeVNlbGVjdG9yQWxsKCdpbnN0YW5jZV9tYXRlcmlhbCcpO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IGluc3RhbmNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbal07XG5cdFx0XHRcdFx0dGhpcy5pbnN0YW5jZV9tYXRlcmlhbC5wdXNoKCAobmV3IEluc3RhbmNlTWF0ZXJpYWwoKSkucGFyc2UoaW5zdGFuY2UpICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5tZXNoID0gbnVsbDtcblxuXHR9XG5cblx0R2VvbWV0cnkucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG5cdFx0ZXh0cmFjdERvdWJsZVNpZGVkKCB0aGlzLCBlbGVtZW50ICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ21lc2gnOlxuXG5cdFx0XHRcdFx0dGhpcy5tZXNoID0gKG5ldyBNZXNoKHRoaXMpKS5wYXJzZShjaGlsZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIE1lc2goIGdlb21ldHJ5ICkge1xuXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5LmlkO1xuXHRcdHRoaXMucHJpbWl0aXZlcyA9IFtdO1xuXHRcdHRoaXMudmVydGljZXMgPSBudWxsO1xuXHRcdHRoaXMuZ2VvbWV0cnkzanMgPSBudWxsO1xuXG5cdH1cblxuXHRNZXNoLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMucHJpbWl0aXZlcyA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3NvdXJjZSc6XG5cblx0XHRcdFx0XHRfc291cmNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3ZlcnRpY2VzJzpcblxuXHRcdFx0XHRcdHRoaXMudmVydGljZXMgPSAoIG5ldyBWZXJ0aWNlcygpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGluZXN0cmlwcyc6XG5cblx0XHRcdFx0XHR0aGlzLnByaW1pdGl2ZXMucHVzaCggKCBuZXcgTGluZVN0cmlwcygpLnBhcnNlKCBjaGlsZCApICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICd0cmlhbmdsZXMnOlxuXG5cdFx0XHRcdFx0dGhpcy5wcmltaXRpdmVzLnB1c2goICggbmV3IFRyaWFuZ2xlcygpLnBhcnNlKCBjaGlsZCApICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwb2x5Z29ucyc6XG5cblx0XHRcdFx0XHR0aGlzLnByaW1pdGl2ZXMucHVzaCggKCBuZXcgUG9seWdvbnMoKS5wYXJzZSggY2hpbGQgKSApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncG9seWxpc3QnOlxuXG5cdFx0XHRcdFx0dGhpcy5wcmltaXRpdmVzLnB1c2goICggbmV3IFBvbHlsaXN0KCkucGFyc2UoIGNoaWxkICkgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuZ2VvbWV0cnkzanMgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuXHRcdGlmICggdGhpcy52ZXJ0aWNlcyA9PT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gVE9ETyAobXJkb29iKTogU3R1ZHkgY2FzZSB3aGVuIHRoaXMgaXMgbnVsbCAoY2Fycmllci5kYWUpXG5cblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0fVxuXG5cdFx0dmFyIHZlcnRleERhdGEgPSBzb3VyY2VzWyB0aGlzLnZlcnRpY2VzLmlucHV0WydQT1NJVElPTiddLnNvdXJjZSBdLmRhdGE7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSArPSAzICkge1xuXG5cdFx0XHR0aGlzLmdlb21ldHJ5M2pzLnZlcnRpY2VzLnB1c2goIGdldENvbnZlcnRlZFZlYzMoIHZlcnRleERhdGEsIGkgKS5jbG9uZSgpICk7XG5cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnByaW1pdGl2ZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgcHJpbWl0aXZlID0gdGhpcy5wcmltaXRpdmVzWyBpIF07XG5cdFx0XHRwcmltaXRpdmUuc2V0VmVydGljZXMoIHRoaXMudmVydGljZXMgKTtcblx0XHRcdHRoaXMuaGFuZGxlUHJpbWl0aXZlKCBwcmltaXRpdmUsIHRoaXMuZ2VvbWV0cnkzanMgKTtcblxuXHRcdH1cblxuXHRcdGlmICggdGhpcy5nZW9tZXRyeTNqcy5jYWxjTm9ybWFscyApIHtcblxuXHRcdFx0dGhpcy5nZW9tZXRyeTNqcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuZ2VvbWV0cnkzanMuY2FsY05vcm1hbHM7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdE1lc2gucHJvdG90eXBlLmhhbmRsZVByaW1pdGl2ZSA9IGZ1bmN0aW9uICggcHJpbWl0aXZlLCBnZW9tICkge1xuXG5cdFx0aWYgKCBwcmltaXRpdmUgaW5zdGFuY2VvZiBMaW5lU3RyaXBzICkge1xuXG5cdFx0XHQvLyBUT0RPOiBIYW5kbGUgaW5kaWNlcy4gTWF5YmUgZWFzaWVyIHdpdGggQnVmZmVyR2VvbWV0cnk/XG5cblx0XHRcdGdlb20uaXNMaW5lU3RyaXAgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0dmFyIGosIGssIHBMaXN0ID0gcHJpbWl0aXZlLnAsIGlucHV0cyA9IHByaW1pdGl2ZS5pbnB1dHM7XG5cdFx0dmFyIGlucHV0LCBpbmRleCwgaWR4MzI7XG5cdFx0dmFyIHNvdXJjZSwgbnVtUGFyYW1zO1xuXHRcdHZhciB2Y0luZGV4ID0gMCwgdmNvdW50ID0gMywgbWF4T2Zmc2V0ID0gMDtcblx0XHR2YXIgdGV4dHVyZV9zZXRzID0gW107XG5cblx0XHRmb3IgKCBqID0gMDsgaiA8IGlucHV0cy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdGlucHV0ID0gaW5wdXRzWyBqIF07XG5cblx0XHRcdHZhciBvZmZzZXQgPSBpbnB1dC5vZmZzZXQgKyAxO1xuXHRcdFx0bWF4T2Zmc2V0ID0gKG1heE9mZnNldCA8IG9mZnNldCkgPyBvZmZzZXQgOiBtYXhPZmZzZXQ7XG5cblx0XHRcdHN3aXRjaCAoIGlucHV0LnNlbWFudGljICkge1xuXG5cdFx0XHRcdGNhc2UgJ1RFWENPT1JEJzpcblx0XHRcdFx0XHR0ZXh0dXJlX3NldHMucHVzaCggaW5wdXQuc2V0ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBwQ291bnQgPSAwOyBwQ291bnQgPCBwTGlzdC5sZW5ndGg7ICsrIHBDb3VudCApIHtcblxuXHRcdFx0dmFyIHAgPSBwTGlzdFsgcENvdW50IF0sIGkgPSAwO1xuXG5cdFx0XHR3aGlsZSAoIGkgPCBwLmxlbmd0aCApIHtcblxuXHRcdFx0XHR2YXIgdnMgPSBbXTtcblx0XHRcdFx0dmFyIG5zID0gW107XG5cdFx0XHRcdHZhciB0cyA9IG51bGw7XG5cdFx0XHRcdHZhciBjcyA9IFtdO1xuXG5cdFx0XHRcdGlmICggcHJpbWl0aXZlLnZjb3VudCApIHtcblxuXHRcdFx0XHRcdHZjb3VudCA9IHByaW1pdGl2ZS52Y291bnQubGVuZ3RoID8gcHJpbWl0aXZlLnZjb3VudFsgdmNJbmRleCArKyBdIDogcHJpbWl0aXZlLnZjb3VudDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dmNvdW50ID0gcC5sZW5ndGggLyBtYXhPZmZzZXQ7XG5cblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCB2Y291bnQ7IGogKysgKSB7XG5cblx0XHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdGlucHV0ID0gaW5wdXRzWyBrIF07XG5cdFx0XHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcblxuXHRcdFx0XHRcdFx0aW5kZXggPSBwWyBpICsgKCBqICogbWF4T2Zmc2V0ICkgKyBpbnB1dC5vZmZzZXQgXTtcblx0XHRcdFx0XHRcdG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0aWR4MzIgPSBpbmRleCAqIG51bVBhcmFtcztcblxuXHRcdFx0XHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnVkVSVEVYJzpcblxuXHRcdFx0XHRcdFx0XHRcdHZzLnB1c2goIGluZGV4ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdOT1JNQUwnOlxuXG5cdFx0XHRcdFx0XHRcdFx0bnMucHVzaCggZ2V0Q29udmVydGVkVmVjMyggc291cmNlLmRhdGEsIGlkeDMyICkgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ1RFWENPT1JEJzpcblxuXHRcdFx0XHRcdFx0XHRcdHRzID0gdHMgfHwgeyB9O1xuXHRcdFx0XHRcdFx0XHRcdGlmICggdHNbIGlucHV0LnNldCBdID09PSB1bmRlZmluZWQgKSB0c1sgaW5wdXQuc2V0IF0gPSBbXTtcblx0XHRcdFx0XHRcdFx0XHQvLyBpbnZlcnQgdGhlIFZcblx0XHRcdFx0XHRcdFx0XHR0c1sgaW5wdXQuc2V0IF0ucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHNvdXJjZS5kYXRhWyBpZHgzMiBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAxIF0gKSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAnQ09MT1InOlxuXG5cdFx0XHRcdFx0XHRcdFx0Y3MucHVzaCggbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMSBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAyIF0gKSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbnMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIHZlcnRpY2VzIGlucHV0c1xuXHRcdFx0XHRcdGlucHV0ID0gdGhpcy52ZXJ0aWNlcy5pbnB1dC5OT1JNQUw7XG5cblx0XHRcdFx0XHRpZiAoIGlucHV0ICkge1xuXG5cdFx0XHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcblx0XHRcdFx0XHRcdG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbmR4ID0gMCwgbGVuID0gdnMubGVuZ3RoOyBuZHggPCBsZW47IG5keCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRucy5wdXNoKCBnZXRDb252ZXJ0ZWRWZWMzKCBzb3VyY2UuZGF0YSwgdnNbIG5keCBdICogbnVtUGFyYW1zICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Z2VvbS5jYWxjTm9ybWFscyA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggIXRzICkge1xuXG5cdFx0XHRcdFx0dHMgPSB7IH07XG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIHZlcnRpY2VzIGlucHV0c1xuXHRcdFx0XHRcdGlucHV0ID0gdGhpcy52ZXJ0aWNlcy5pbnB1dC5URVhDT09SRDtcblxuXHRcdFx0XHRcdGlmICggaW5wdXQgKSB7XG5cblx0XHRcdFx0XHRcdHRleHR1cmVfc2V0cy5wdXNoKCBpbnB1dC5zZXQgKTtcblx0XHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZXNbIGlucHV0LnNvdXJjZSBdO1xuXHRcdFx0XHRcdFx0bnVtUGFyYW1zID0gc291cmNlLmFjY2Vzc29yLnBhcmFtcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBuZHggPSAwLCBsZW4gPSB2cy5sZW5ndGg7IG5keCA8IGxlbjsgbmR4ICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdGlkeDMyID0gdnNbIG5keCBdICogbnVtUGFyYW1zO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRzWyBpbnB1dC5zZXQgXSA9PT0gdW5kZWZpbmVkICkgdHNbIGlucHV0LnNldCBdID0gWyBdO1xuXHRcdFx0XHRcdFx0XHQvLyBpbnZlcnQgdGhlIFZcblx0XHRcdFx0XHRcdFx0dHNbIGlucHV0LnNldCBdLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgMS4wIC0gc291cmNlLmRhdGFbIGlkeDMyICsgMSBdICkgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIHRoZSB2ZXJ0aWNlcyBpbnB1dHNcblx0XHRcdFx0XHRpbnB1dCA9IHRoaXMudmVydGljZXMuaW5wdXQuQ09MT1I7XG5cblx0XHRcdFx0XHRpZiAoIGlucHV0ICkge1xuXG5cdFx0XHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VzWyBpbnB1dC5zb3VyY2UgXTtcblx0XHRcdFx0XHRcdG51bVBhcmFtcyA9IHNvdXJjZS5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgbmR4ID0gMCwgbGVuID0gdnMubGVuZ3RoOyBuZHggPCBsZW47IG5keCArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRpZHgzMiA9IHZzWyBuZHggXSAqIG51bVBhcmFtcztcblx0XHRcdFx0XHRcdFx0Y3MucHVzaCggbmV3IFRIUkVFLkNvbG9yKCkuc2V0UkdCKCBzb3VyY2UuZGF0YVsgaWR4MzIgXSwgc291cmNlLmRhdGFbIGlkeDMyICsgMSBdLCBzb3VyY2UuZGF0YVsgaWR4MzIgKyAyIF0gKSApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBmYWNlID0gbnVsbCwgZmFjZXMgPSBbXSwgdXYsIHV2QXJyO1xuXG5cdFx0XHRcdGlmICggdmNvdW50ID09PSAzICkge1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1swXSwgdnNbMV0sIHZzWzJdLCBucywgY3MubGVuZ3RoID8gY3MgOiBuZXcgVEhSRUUuQ29sb3IoKSApICk7XG5cblx0XHRcdFx0fSBlbHNlIGlmICggdmNvdW50ID09PSA0ICkge1xuXG5cdFx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1swXSwgdnNbMV0sIHZzWzNdLCBbIG5zWzBdLmNsb25lKCksIG5zWzFdLmNsb25lKCksIG5zWzNdLmNsb25lKCkgXSwgY3MubGVuZ3RoID8gWyBjc1swXSwgY3NbMV0sIGNzWzNdIF0gOiBuZXcgVEhSRUUuQ29sb3IoKSApICk7XG5cblx0XHRcdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHZzWzFdLCB2c1syXSwgdnNbM10sIFsgbnNbMV0uY2xvbmUoKSwgbnNbMl0uY2xvbmUoKSwgbnNbM10uY2xvbmUoKSBdLCBjcy5sZW5ndGggPyBbIGNzWzFdLCBjc1syXSwgY3NbM10gXSA6IG5ldyBUSFJFRS5Db2xvcigpICkgKTtcblxuXHRcdFx0XHR9IGVsc2UgaWYgKCB2Y291bnQgPiA0ICYmIG9wdGlvbnMuc3ViZGl2aWRlRmFjZXMgKSB7XG5cblx0XHRcdFx0XHR2YXIgY2xyID0gY3MubGVuZ3RoID8gY3MgOiBuZXcgVEhSRUUuQ29sb3IoKSxcblx0XHRcdFx0XHRcdHZlYzEsIHZlYzIsIHZlYzMsIHYxLCB2Miwgbm9ybTtcblxuXHRcdFx0XHRcdC8vIHN1YmRpdmlkZSBpbnRvIG11bHRpcGxlIEZhY2Uzc1xuXG5cdFx0XHRcdFx0Zm9yICggayA9IDE7IGsgPCB2Y291bnQgLSAxOyApIHtcblxuXHRcdFx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2c1swXSwgdnNba10sIHZzW2sgKyAxXSwgWyBuc1swXS5jbG9uZSgpLCBuc1trICsrXS5jbG9uZSgpLCBuc1trXS5jbG9uZSgpIF0sIGNsciApICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggZmFjZXMubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIG5keCA9IDAsIGxlbiA9IGZhY2VzLmxlbmd0aDsgbmR4IDwgbGVuOyBuZHggKysgKSB7XG5cblx0XHRcdFx0XHRcdGZhY2UgPSBmYWNlc1tuZHhdO1xuXHRcdFx0XHRcdFx0ZmFjZS5kYWVNYXRlcmlhbCA9IHByaW1pdGl2ZS5tYXRlcmlhbDtcblx0XHRcdFx0XHRcdGdlb20uZmFjZXMucHVzaCggZmFjZSApO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBrID0gMDsgayA8IHRleHR1cmVfc2V0cy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dXYgPSB0c1sgdGV4dHVyZV9zZXRzW2tdIF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB2Y291bnQgPiA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gR3JhYiB0aGUgcmlnaHQgVVZzIGZvciB0aGUgdmVydGljZXMgaW4gdGhpcyBmYWNlXG5cdFx0XHRcdFx0XHRcdFx0dXZBcnIgPSBbIHV2WzBdLCB1dltuZHggKyAxXSwgdXZbbmR4ICsgMl0gXTtcblxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB2Y291bnQgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5keCA9PT0gMCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dXZBcnIgPSBbIHV2WzBdLCB1dlsxXSwgdXZbM10gXTtcblxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHV2QXJyID0gWyB1dlsxXS5jbG9uZSgpLCB1dlsyXSwgdXZbM10uY2xvbmUoKSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHR1dkFyciA9IFsgdXZbMF0sIHV2WzFdLCB1dlsyXSBdO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIGdlb20uZmFjZVZlcnRleFV2c1trXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbS5mYWNlVmVydGV4VXZzW2tdID0gW107XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGdlb20uZmFjZVZlcnRleFV2c1trXS5wdXNoKCB1dkFyciApO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCAnZHJvcHBlZCBmYWNlIHdpdGggdmNvdW50ICcgKyB2Y291bnQgKyAnIGZvciBnZW9tZXRyeSB3aXRoIGlkOiAnICsgZ2VvbS5pZCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IG1heE9mZnNldCAqIHZjb3VudDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0ZnVuY3Rpb24gUG9seWdvbnMgKCkge1xuXG5cdFx0dGhpcy5tYXRlcmlhbCA9IFwiXCI7XG5cdFx0dGhpcy5jb3VudCA9IDA7XG5cdFx0dGhpcy5pbnB1dHMgPSBbXTtcblx0XHR0aGlzLnZjb3VudCA9IG51bGw7XG5cdFx0dGhpcy5wID0gW107XG5cdFx0dGhpcy5nZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG5cdH1cblxuXHRQb2x5Z29ucy5wcm90b3R5cGUuc2V0VmVydGljZXMgPSBmdW5jdGlvbiAoIHZlcnRpY2VzICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIHRoaXMuaW5wdXRzWyBpIF0uc291cmNlID09PSB2ZXJ0aWNlcy5pZCApIHtcblxuXHRcdFx0XHR0aGlzLmlucHV0c1sgaSBdLnNvdXJjZSA9IHZlcnRpY2VzLmlucHV0WyAnUE9TSVRJT04nIF0uc291cmNlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fTtcblxuXHRQb2x5Z29ucy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtYXRlcmlhbCcgKTtcblx0XHR0aGlzLmNvdW50ID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnY291bnQnLCAwICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnaW5wdXQnOlxuXG5cdFx0XHRcdFx0dGhpcy5pbnB1dHMucHVzaCggKCBuZXcgSW5wdXQoKSApLnBhcnNlKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXSApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndmNvdW50JzpcblxuXHRcdFx0XHRcdHRoaXMudmNvdW50ID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAncCc6XG5cblx0XHRcdFx0XHR0aGlzLnAucHVzaCggX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdwaCc6XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdwb2x5Z29uIGhvbGVzIG5vdCB5ZXQgc3VwcG9ydGVkIScgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFBvbHlsaXN0ICgpIHtcblxuXHRcdFBvbHlnb25zLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudmNvdW50ID0gW107XG5cblx0fVxuXG5cdFBvbHlsaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHlnb25zLnByb3RvdHlwZSApO1xuXHRQb2x5bGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5bGlzdDtcblxuXHRmdW5jdGlvbiBMaW5lU3RyaXBzKCkge1xuXG5cdFx0UG9seWdvbnMuY2FsbCggdGhpcyApO1xuXG5cdFx0dGhpcy52Y291bnQgPSAxO1xuXG5cdH1cblxuXHRMaW5lU3RyaXBzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHlnb25zLnByb3RvdHlwZSApO1xuXHRMaW5lU3RyaXBzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVTdHJpcHM7XG5cblx0ZnVuY3Rpb24gVHJpYW5nbGVzICgpIHtcblxuXHRcdFBvbHlnb25zLmNhbGwoIHRoaXMgKTtcblxuXHRcdHRoaXMudmNvdW50ID0gMztcblxuXHR9XG5cblx0VHJpYW5nbGVzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHlnb25zLnByb3RvdHlwZSApO1xuXHRUcmlhbmdsZXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHJpYW5nbGVzO1xuXG5cdGZ1bmN0aW9uIEFjY2Vzc29yKCkge1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBcIlwiO1xuXHRcdHRoaXMuY291bnQgPSAwO1xuXHRcdHRoaXMuc3RyaWRlID0gMDtcblx0XHR0aGlzLnBhcmFtcyA9IFtdO1xuXG5cdH1cblxuXHRBY2Nlc3Nvci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnBhcmFtcyA9IFtdO1xuXHRcdHRoaXMuc291cmNlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzb3VyY2UnICk7XG5cdFx0dGhpcy5jb3VudCA9IF9hdHRyX2FzX2ludCggZWxlbWVudCwgJ2NvdW50JywgMCApO1xuXHRcdHRoaXMuc3RyaWRlID0gX2F0dHJfYXNfaW50KCBlbGVtZW50LCAnc3RyaWRlJywgMCApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdGlmICggY2hpbGQubm9kZU5hbWUgPT09ICdwYXJhbScgKSB7XG5cblx0XHRcdFx0dmFyIHBhcmFtID0ge307XG5cdFx0XHRcdHBhcmFtWyAnbmFtZScgXSA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHRcdHBhcmFtWyAndHlwZScgXSA9IGNoaWxkLmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdHRoaXMucGFyYW1zLnB1c2goIHBhcmFtICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gVmVydGljZXMoKSB7XG5cblx0XHR0aGlzLmlucHV0ID0ge307XG5cblx0fVxuXG5cdFZlcnRpY2VzLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdGlmICggZWxlbWVudC5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lID09PSAnaW5wdXQnICkge1xuXG5cdFx0XHRcdHZhciBpbnB1dCA9ICggbmV3IElucHV0KCkgKS5wYXJzZSggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0gKTtcblx0XHRcdFx0dGhpcy5pbnB1dFsgaW5wdXQuc2VtYW50aWMgXSA9IGlucHV0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIElucHV0ICgpIHtcblxuXHRcdHRoaXMuc2VtYW50aWMgPSBcIlwiO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHR0aGlzLnNvdXJjZSA9IFwiXCI7XG5cdFx0dGhpcy5zZXQgPSAwO1xuXG5cdH1cblxuXHRJbnB1dC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnNlbWFudGljID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3NlbWFudGljJyk7XG5cdFx0dGhpcy5zb3VyY2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc291cmNlJykucmVwbGFjZSgvXiMvLCAnJyk7XG5cdFx0dGhpcy5zZXQgPSBfYXR0cl9hc19pbnQoZWxlbWVudCwgJ3NldCcsIC0xKTtcblx0XHR0aGlzLm9mZnNldCA9IF9hdHRyX2FzX2ludChlbGVtZW50LCAnb2Zmc2V0JywgMCk7XG5cblx0XHRpZiAoIHRoaXMuc2VtYW50aWMgPT09ICdURVhDT09SRCcgJiYgdGhpcy5zZXQgPCAwICkge1xuXG5cdFx0XHR0aGlzLnNldCA9IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFNvdXJjZSAoIGlkICkge1xuXG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMudHlwZSA9IG51bGw7XG5cblx0fVxuXG5cdFNvdXJjZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnYm9vbF9hcnJheSc6XG5cblx0XHRcdFx0XHR0aGlzLmRhdGEgPSBfYm9vbHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0dGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnZmxvYXRfYXJyYXknOlxuXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHR0aGlzLnR5cGUgPSBjaGlsZC5ub2RlTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbnRfYXJyYXknOlxuXG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gX2ludHMoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0dGhpcy50eXBlID0gY2hpbGQubm9kZU5hbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSURSRUZfYXJyYXknOlxuXHRcdFx0XHRjYXNlICdOYW1lX2FycmF5JzpcblxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IF9zdHJpbmdzKCBjaGlsZC50ZXh0Q29udGVudCApO1xuXHRcdFx0XHRcdHRoaXMudHlwZSA9IGNoaWxkLm5vZGVOYW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RlY2huaXF1ZV9jb21tb24nOlxuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgY2hpbGQuY2hpbGROb2Rlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggY2hpbGQuY2hpbGROb2Rlc1sgaiBdLm5vZGVOYW1lID09PSAnYWNjZXNzb3InICkge1xuXG5cdFx0XHRcdFx0XHRcdHRoaXMuYWNjZXNzb3IgPSAoIG5ldyBBY2Nlc3NvcigpICkucGFyc2UoIGNoaWxkLmNoaWxkTm9kZXNbIGogXSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKGNoaWxkLm5vZGVOYW1lKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRTb3VyY2UucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHQvL2ZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY2Nlc3Nvci5wYXJhbXMubGVuZ3RoOyBpKyspIHtcblxuXHRcdHZhciBwYXJhbSA9IHRoaXMuYWNjZXNzb3IucGFyYW1zWyAwIF07XG5cblx0XHRcdC8vY29uc29sZS5sb2cocGFyYW0ubmFtZSArIFwiIFwiICsgcGFyYW0udHlwZSk7XG5cblx0XHRzd2l0Y2ggKCBwYXJhbS50eXBlICkge1xuXG5cdFx0XHRjYXNlICdJRFJFRic6XG5cdFx0XHRjYXNlICdOYW1lJzogY2FzZSAnbmFtZSc6XG5cdFx0XHRjYXNlICdmbG9hdCc6XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMuZGF0YTtcblxuXHRcdFx0Y2FzZSAnZmxvYXQ0eDQnOlxuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRoaXMuZGF0YS5sZW5ndGg7IGogKz0gMTYgKSB7XG5cblx0XHRcdFx0XHR2YXIgcyA9IHRoaXMuZGF0YS5zbGljZSggaiwgaiArIDE2ICk7XG5cdFx0XHRcdFx0dmFyIG0gPSBnZXRDb252ZXJ0ZWRNYXQ0KCBzICk7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIG0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdGNvbnNvbGUubG9nKCAnQ29sbGFkYUxvYWRlcjogU291cmNlOiBSZWFkIGRvbnQga25vdyBob3cgdG8gcmVhZCAnICsgcGFyYW0udHlwZSArICcuJyApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHRcdC8vfVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIE1hdGVyaWFsICgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy5pbnN0YW5jZV9lZmZlY3QgPSBudWxsO1xuXG5cdH1cblxuXHRNYXRlcmlhbC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lID09PSAnaW5zdGFuY2VfZWZmZWN0JyApIHtcblxuXHRcdFx0XHR0aGlzLmluc3RhbmNlX2VmZmVjdCA9ICggbmV3IEluc3RhbmNlRWZmZWN0KCkgKS5wYXJzZSggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0gKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gQ29sb3JPclRleHR1cmUgKCkge1xuXG5cdFx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvcigpO1xuXHRcdHRoaXMuY29sb3Iuc2V0UkdCKCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpICk7XG5cdFx0dGhpcy5jb2xvci5hID0gMS4wO1xuXG5cdFx0dGhpcy50ZXh0dXJlID0gbnVsbDtcblx0XHR0aGlzLnRleGNvb3JkID0gbnVsbDtcblx0XHR0aGlzLnRleE9wdHMgPSBudWxsO1xuXG5cdH1cblxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUuaXNDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMudGV4dHVyZSA9PT0gbnVsbCApO1xuXG5cdH07XG5cblx0Q29sb3JPclRleHR1cmUucHJvdG90eXBlLmlzVGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHJldHVybiAoIHRoaXMudGV4dHVyZSAhPSBudWxsICk7XG5cblx0fTtcblxuXHRDb2xvck9yVGV4dHVyZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHRpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ3RyYW5zcGFyZW50Jykge1xuXG5cdFx0XHR0aGlzLm9wYXF1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvcGFxdWUnKTtcblxuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblxuXHRcdFx0XHRcdHZhciByZ2JhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cdFx0XHRcdFx0dGhpcy5jb2xvci5zZXRSR0IoIHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl0gKTtcblx0XHRcdFx0XHR0aGlzLmNvbG9yLmEgPSByZ2JhWzNdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RleHR1cmUnOlxuXG5cdFx0XHRcdFx0dGhpcy50ZXh0dXJlID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd0ZXh0dXJlJyk7XG5cdFx0XHRcdFx0dGhpcy50ZXhjb29yZCA9IGNoaWxkLmdldEF0dHJpYnV0ZSgndGV4Y29vcmQnKTtcblx0XHRcdFx0XHQvLyBEZWZhdWx0cyBmcm9tOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vY29sbGFkYS5vcmcvbWVkaWF3aWtpL2luZGV4LnBocC9NYXlhX3RleHR1cmVfcGxhY2VtZW50X01BWUFfZXh0ZW5zaW9uXG5cdFx0XHRcdFx0dGhpcy50ZXhPcHRzID0ge1xuXHRcdFx0XHRcdFx0b2Zmc2V0VTogMCxcblx0XHRcdFx0XHRcdG9mZnNldFY6IDAsXG5cdFx0XHRcdFx0XHRyZXBlYXRVOiAxLFxuXHRcdFx0XHRcdFx0cmVwZWF0VjogMSxcblx0XHRcdFx0XHRcdHdyYXBVOiAxLFxuXHRcdFx0XHRcdFx0d3JhcFY6IDFcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHRoaXMucGFyc2VUZXh0dXJlKCBjaGlsZCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Q29sb3JPclRleHR1cmUucHJvdG90eXBlLnBhcnNlVGV4dHVyZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdGlmICggISBlbGVtZW50LmNoaWxkTm9kZXMgKSByZXR1cm4gdGhpcztcblxuXHRcdC8vIFRoaXMgc2hvdWxkIGJlIHN1cHBvcnRlZCBieSBNYXlhLCAzZHNNYXgsIGFuZCBNb3Rpb25CdWlsZGVyXG5cblx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sxXSAmJiBlbGVtZW50LmNoaWxkTm9kZXNbMV0ubm9kZU5hbWUgPT09ICdleHRyYScgKSB7XG5cblx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LmNoaWxkTm9kZXNbMV07XG5cblx0XHRcdGlmICggZWxlbWVudC5jaGlsZE5vZGVzWzFdICYmIGVsZW1lbnQuY2hpbGROb2Rlc1sxXS5ub2RlTmFtZSA9PT0gJ3RlY2huaXF1ZScgKSB7XG5cblx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sxXTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ29mZnNldFUnOlxuXHRcdFx0XHRjYXNlICdvZmZzZXRWJzpcblx0XHRcdFx0Y2FzZSAncmVwZWF0VSc6XG5cdFx0XHRcdGNhc2UgJ3JlcGVhdFYnOlxuXG5cdFx0XHRcdFx0dGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gcGFyc2VGbG9hdCggY2hpbGQudGV4dENvbnRlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3dyYXBVJzpcblx0XHRcdFx0Y2FzZSAnd3JhcFYnOlxuXG5cdFx0XHRcdFx0Ly8gc29tZSBkYWUgaGF2ZSBhIHZhbHVlIG9mIHRydWUgd2hpY2ggYmVjb21lcyBOYU4gdmlhIHBhcnNlSW50XG5cblx0XHRcdFx0XHRpZiAoIGNoaWxkLnRleHRDb250ZW50LnRvVXBwZXJDYXNlKCkgPT09ICdUUlVFJyApIHtcblxuXHRcdFx0XHRcdFx0dGhpcy50ZXhPcHRzWyBjaGlsZC5ub2RlTmFtZSBdID0gMTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdHRoaXMudGV4T3B0c1sgY2hpbGQubm9kZU5hbWUgXSA9IHBhcnNlSW50KCBjaGlsZC50ZXh0Q29udGVudCApO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHR0aGlzLnRleE9wdHNbIGNoaWxkLm5vZGVOYW1lIF0gPSBjaGlsZC50ZXh0Q29udGVudDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFNoYWRlciAoIHR5cGUsIGVmZmVjdCApIHtcblxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG5cdFx0dGhpcy5tYXRlcmlhbCA9IG51bGw7XG5cblx0fVxuXG5cdFNoYWRlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdlbWlzc2lvbic6XG5cdFx0XHRcdGNhc2UgJ2RpZmZ1c2UnOlxuXHRcdFx0XHRjYXNlICdzcGVjdWxhcic6XG5cdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW50JzpcblxuXHRcdFx0XHRcdHRoaXNbIGNoaWxkLm5vZGVOYW1lIF0gPSAoIG5ldyBDb2xvck9yVGV4dHVyZSgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cblx0XHRcdFx0XHQvLyBJZiAnYnVtcHR5cGUnIGlzICdoZWlnaHRmaWVsZCcsIGNyZWF0ZSBhICdidW1wJyBwcm9wZXJ0eVxuXHRcdFx0XHRcdC8vIEVsc2UgaWYgJ2J1bXB0eXBlJyBpcyAnbm9ybWFsbWFwJywgY3JlYXRlIGEgJ25vcm1hbCcgcHJvcGVydHlcblx0XHRcdFx0XHQvLyAoRGVmYXVsdCB0byAnYnVtcCcpXG5cdFx0XHRcdFx0dmFyIGJ1bXBUeXBlID0gY2hpbGQuZ2V0QXR0cmlidXRlKCAnYnVtcHR5cGUnICk7XG5cdFx0XHRcdFx0aWYgKCBidW1wVHlwZSApIHtcblx0XHRcdFx0XHRcdGlmICggYnVtcFR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJoZWlnaHRmaWVsZFwiICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzWyAnYnVtcCcgXSA9ICggbmV3IENvbG9yT3JUZXh0dXJlKCkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGJ1bXBUeXBlLnRvTG93ZXJDYXNlKCkgPT09IFwibm9ybWFsbWFwXCIgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXNbICdub3JtYWwnIF0gPSAoIG5ldyBDb2xvck9yVGV4dHVyZSgpICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIlNoYWRlci5wcm90b3R5cGUucGFyc2U6IEludmFsaWQgdmFsdWUgZm9yIGF0dHJpYnV0ZSAnYnVtcHR5cGUnIChcIiArIGJ1bXBUeXBlICsgXCIpIC0gdmFsaWQgYnVtcHR5cGVzIGFyZSAnSEVJR0hURklFTEQnIGFuZCAnTk9STUFMTUFQJyAtIGRlZmF1bHRpbmcgdG8gJ0hFSUdIVEZJRUxEJ1wiICk7XG5cdFx0XHRcdFx0XHRcdHRoaXNbICdidW1wJyBdID0gKCBuZXcgQ29sb3JPclRleHR1cmUoKSApLnBhcnNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiU2hhZGVyLnByb3RvdHlwZS5wYXJzZTogQXR0cmlidXRlICdidW1wdHlwZScgbWlzc2luZyBmcm9tIGJ1bXAgbm9kZSAtIGRlZmF1bHRpbmcgdG8gJ0hFSUdIVEZJRUxEJ1wiICk7XG5cdFx0XHRcdFx0XHR0aGlzWyAnYnVtcCcgXSA9ICggbmV3IENvbG9yT3JUZXh0dXJlKCkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXHRcdFx0XHRjYXNlICdyZWZsZWN0aXZpdHknOlxuXHRcdFx0XHRjYXNlICdpbmRleF9vZl9yZWZyYWN0aW9uJzpcblx0XHRcdFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcblxuXHRcdFx0XHRcdHZhciBmID0gY2hpbGQucXVlcnlTZWxlY3RvckFsbCgnZmxvYXQnKTtcblxuXHRcdFx0XHRcdGlmICggZi5sZW5ndGggPiAwIClcblx0XHRcdFx0XHRcdHRoaXNbIGNoaWxkLm5vZGVOYW1lIF0gPSBwYXJzZUZsb2F0KCBmWyAwIF0udGV4dENvbnRlbnQgKTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMuY3JlYXRlKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRTaGFkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHByb3BzID0ge307XG5cblx0XHR2YXIgdHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuXHRcdGlmICh0aGlzWyd0cmFuc3BhcmVuY3knXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNbJ3RyYW5zcGFyZW50J10gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gY29udmVydCB0cmFuc3BhcmVudCBjb2xvciBSQkcgdG8gYXZlcmFnZSB2YWx1ZVxuXHRcdFx0dmFyIHRyYW5zcGFyZW50Q29sb3IgPSB0aGlzWyd0cmFuc3BhcmVudCddO1xuXHRcdFx0dmFyIHRyYW5zcGFyZW5jeUxldmVsID0gKHRoaXMudHJhbnNwYXJlbnQuY29sb3IuciArIHRoaXMudHJhbnNwYXJlbnQuY29sb3IuZyArIHRoaXMudHJhbnNwYXJlbnQuY29sb3IuYikgLyAzICogdGhpcy50cmFuc3BhcmVuY3k7XG5cblx0XHRcdGlmICh0cmFuc3BhcmVuY3lMZXZlbCA+IDApIHtcblx0XHRcdFx0dHJhbnNwYXJlbnQgPSB0cnVlO1xuXHRcdFx0XHRwcm9wc1sgJ3RyYW5zcGFyZW50JyBdID0gdHJ1ZTtcblx0XHRcdFx0cHJvcHNbICdvcGFjaXR5JyBdID0gMSAtIHRyYW5zcGFyZW5jeUxldmVsO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIga2V5cyA9IHtcblx0XHRcdCdkaWZmdXNlJzonbWFwJyxcblx0XHRcdCdhbWJpZW50JzonbGlnaHRNYXAnLFxuXHRcdFx0J3NwZWN1bGFyJzonc3BlY3VsYXJNYXAnLFxuXHRcdFx0J2VtaXNzaW9uJzonZW1pc3Npb25NYXAnLFxuXHRcdFx0J2J1bXAnOididW1wTWFwJyxcblx0XHRcdCdub3JtYWwnOidub3JtYWxNYXAnXG5cdFx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gdGhpcyApIHtcblxuXHRcdFx0c3dpdGNoICggcHJvcCApIHtcblxuXHRcdFx0XHRjYXNlICdhbWJpZW50Jzpcblx0XHRcdFx0Y2FzZSAnZW1pc3Npb24nOlxuXHRcdFx0XHRjYXNlICdkaWZmdXNlJzpcblx0XHRcdFx0Y2FzZSAnc3BlY3VsYXInOlxuXHRcdFx0XHRjYXNlICdidW1wJzpcblx0XHRcdFx0Y2FzZSAnbm9ybWFsJzpcblxuXHRcdFx0XHRcdHZhciBjb3QgPSB0aGlzWyBwcm9wIF07XG5cblx0XHRcdFx0XHRpZiAoIGNvdCBpbnN0YW5jZW9mIENvbG9yT3JUZXh0dXJlICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNvdC5pc1RleHR1cmUoKSApIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgc2FtcGxlcklkID0gY290LnRleHR1cmU7XG5cdFx0XHRcdFx0XHRcdHZhciBzdXJmYWNlSWQgPSB0aGlzLmVmZmVjdC5zYW1wbGVyW3NhbXBsZXJJZF07XG5cblx0XHRcdFx0XHRcdFx0aWYgKCBzdXJmYWNlSWQgIT09IHVuZGVmaW5lZCAmJiBzdXJmYWNlSWQuc291cmNlICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR2YXIgc3VyZmFjZSA9IHRoaXMuZWZmZWN0LnN1cmZhY2Vbc3VyZmFjZUlkLnNvdXJjZV07XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHN1cmZhY2UgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGltYWdlID0gaW1hZ2VzWyBzdXJmYWNlLmluaXRfZnJvbSBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGltYWdlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB1cmwgPSBiYXNlVXJsICsgaW1hZ2UuaW5pdF9mcm9tO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0ZXh0dXJlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggdXJsICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBsb2FkZXIgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGxvYWRUZXh0dXJlSW1hZ2UoIHRleHR1cmUsIHVybCApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlLndyYXBTID0gY290LnRleE9wdHMud3JhcFUgPyBUSFJFRS5SZXBlYXRXcmFwcGluZyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHR1cmUud3JhcFQgPSBjb3QudGV4T3B0cy53cmFwViA/IFRIUkVFLlJlcGVhdFdyYXBwaW5nIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQueCA9IGNvdC50ZXhPcHRzLm9mZnNldFU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRleHR1cmUub2Zmc2V0LnkgPSBjb3QudGV4T3B0cy5vZmZzZXRWO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0dXJlLnJlcGVhdC54ID0gY290LnRleE9wdHMucmVwZWF0VTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQueSA9IGNvdC50ZXhPcHRzLnJlcGVhdFY7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BzW2tleXNbcHJvcF1dID0gdGV4dHVyZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUZXh0dXJlIHdpdGggYmFrZWQgbGlnaHRpbmc/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wID09PSAnZW1pc3Npb24nKSBwcm9wc1snZW1pc3NpdmUnXSA9IDB4ZmZmZmZmO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBwcm9wID09PSAnZGlmZnVzZScgfHwgIXRyYW5zcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggcHJvcCA9PT0gJ2VtaXNzaW9uJyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHByb3BzWyAnZW1pc3NpdmUnIF0gPSBjb3QuY29sb3IuZ2V0SGV4KCk7XG5cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdHByb3BzWyBwcm9wIF0gPSBjb3QuY29sb3IuZ2V0SGV4KCk7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzaGluaW5lc3MnOlxuXG5cdFx0XHRcdFx0cHJvcHNbIHByb3AgXSA9IHRoaXNbIHByb3AgXTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyZWZsZWN0aXZpdHknOlxuXG5cdFx0XHRcdFx0cHJvcHNbIHByb3AgXSA9IHRoaXNbIHByb3AgXTtcblx0XHRcdFx0XHRpZiAoIHByb3BzWyBwcm9wIF0gPiAwLjAgKSBwcm9wc1snZW52TWFwJ10gPSBvcHRpb25zLmRlZmF1bHRFbnZNYXA7XG5cdFx0XHRcdFx0cHJvcHNbJ2NvbWJpbmUnXSA9IFRIUkVFLk1peE9wZXJhdGlvbjtcdC8vbWl4IHJlZ3VsYXIgc2hhZGluZyB3aXRoIHJlZmxlY3RpdmUgY29tcG9uZW50XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnaW5kZXhfb2ZfcmVmcmFjdGlvbic6XG5cblx0XHRcdFx0XHRwcm9wc1sgJ3JlZnJhY3Rpb25SYXRpbycgXSA9IHRoaXNbIHByb3AgXTsgLy9UT0RPOiBcImluZGV4X29mX3JlZnJhY3Rpb25cIiBiZWNvbWVzIFwicmVmcmFjdGlvblJhdGlvXCIgaW4gc2hhZGVyLCBidXQgSSdtIG5vdCBzdXJlIGlmIHRoZSB0d28gYXJlIGFjdHVhbGx5IGNvbXBhcmFibGVcblx0XHRcdFx0XHRpZiAoIHRoaXNbIHByb3AgXSAhPT0gMS4wICkgcHJvcHNbJ2Vudk1hcCddID0gb3B0aW9ucy5kZWZhdWx0RW52TWFwO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG5cdFx0XHRcdFx0Ly8gZ2V0cyBmaWd1cmVkIG91dCB1cCB0b3Bcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRwcm9wc1sgJ3NoYWRpbmcnIF0gPSBwcmVmZXJyZWRTaGFkaW5nO1xuXHRcdHByb3BzWyAnc2lkZScgXSA9IHRoaXMuZWZmZWN0LmRvdWJsZVNpZGVkID8gVEhSRUUuRG91YmxlU2lkZSA6IFRIUkVFLkZyb250U2lkZTtcblxuXHRcdGlmICggcHJvcHMuZGlmZnVzZSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRwcm9wcy5jb2xvciA9IHByb3BzLmRpZmZ1c2U7XG5cdFx0XHRkZWxldGUgcHJvcHMuZGlmZnVzZTtcblxuXHRcdH1cblxuXHRcdHN3aXRjaCAoIHRoaXMudHlwZSApIHtcblxuXHRcdFx0Y2FzZSAnY29uc3RhbnQnOlxuXG5cdFx0XHRcdGlmIChwcm9wcy5lbWlzc2l2ZSAhPSB1bmRlZmluZWQpIHByb3BzLmNvbG9yID0gcHJvcHMuZW1pc3NpdmU7XG5cdFx0XHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHByb3BzICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdwaG9uZyc6XG5cdFx0XHRjYXNlICdibGlubic6XG5cblx0XHRcdFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCggcHJvcHMgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ2xhbWJlcnQnOlxuXHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHR0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHByb3BzICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWw7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBTdXJmYWNlICggZWZmZWN0ICkge1xuXG5cdFx0dGhpcy5lZmZlY3QgPSBlZmZlY3Q7XG5cdFx0dGhpcy5pbml0X2Zyb20gPSBudWxsO1xuXHRcdHRoaXMuZm9ybWF0ID0gbnVsbDtcblxuXHR9XG5cblx0U3VyZmFjZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbml0X2Zyb20nOlxuXG5cdFx0XHRcdFx0dGhpcy5pbml0X2Zyb20gPSBjaGlsZC50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdmb3JtYXQnOlxuXG5cdFx0XHRcdFx0dGhpcy5mb3JtYXQgPSBjaGlsZC50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIFwidW5oYW5kbGVkIFN1cmZhY2UgcHJvcDogXCIgKyBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIFNhbXBsZXIyRCAoIGVmZmVjdCApIHtcblxuXHRcdHRoaXMuZWZmZWN0ID0gZWZmZWN0O1xuXHRcdHRoaXMuc291cmNlID0gbnVsbDtcblx0XHR0aGlzLndyYXBfcyA9IG51bGw7XG5cdFx0dGhpcy53cmFwX3QgPSBudWxsO1xuXHRcdHRoaXMubWluZmlsdGVyID0gbnVsbDtcblx0XHR0aGlzLm1hZ2ZpbHRlciA9IG51bGw7XG5cdFx0dGhpcy5taXBmaWx0ZXIgPSBudWxsO1xuXG5cdH1cblxuXHRTYW1wbGVyMkQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHRoaXMuc291cmNlID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWluZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWluZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWFnZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWFnZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbWlwZmlsdGVyJzpcblxuXHRcdFx0XHRcdHRoaXMubWlwZmlsdGVyID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnd3JhcF9zJzpcblxuXHRcdFx0XHRcdHRoaXMud3JhcF9zID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnd3JhcF90JzpcblxuXHRcdFx0XHRcdHRoaXMud3JhcF90ID0gY2hpbGQudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcInVuaGFuZGxlZCBTYW1wbGVyMkQgcHJvcDogXCIgKyBjaGlsZC5ub2RlTmFtZSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEVmZmVjdCAoKSB7XG5cblx0XHR0aGlzLmlkID0gXCJcIjtcblx0XHR0aGlzLm5hbWUgPSBcIlwiO1xuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblx0XHR0aGlzLnN1cmZhY2UgPSB7fTtcblx0XHR0aGlzLnNhbXBsZXIgPSB7fTtcblxuXHR9XG5cblx0RWZmZWN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRpZiAoIHRoaXMuc2hhZGVyID09PSBudWxsICkge1xuXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdH1cblxuXHR9O1xuXG5cdEVmZmVjdC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cblx0XHRleHRyYWN0RG91YmxlU2lkZWQoIHRoaXMsIGVsZW1lbnQgKTtcblxuXHRcdHRoaXMuc2hhZGVyID0gbnVsbDtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ3Byb2ZpbGVfQ09NTU9OJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VUZWNobmlxdWUoIHRoaXMucGFyc2VQcm9maWxlQ09NTU9OKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlTmV3cGFyYW0gPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR2YXIgc2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdzaWQnICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdzdXJmYWNlJzpcblxuXHRcdFx0XHRcdHRoaXMuc3VyZmFjZVtzaWRdID0gKCBuZXcgU3VyZmFjZSggdGhpcyApICkucGFyc2UoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc2FtcGxlcjJEJzpcblxuXHRcdFx0XHRcdHRoaXMuc2FtcGxlcltzaWRdID0gKCBuZXcgU2FtcGxlcjJEKCB0aGlzICkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdleHRyYSc6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdEVmZmVjdC5wcm90b3R5cGUucGFyc2VQcm9maWxlQ09NTU9OID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dmFyIHRlY2huaXF1ZTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAncHJvZmlsZV9DT01NT04nOlxuXG5cdFx0XHRcdFx0dGhpcy5wYXJzZVByb2ZpbGVDT01NT04oIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblxuXHRcdFx0XHRcdHRlY2huaXF1ZSA9IGNoaWxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ25ld3BhcmFtJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VOZXdwYXJhbSggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpbWFnZSc6XG5cblx0XHRcdFx0XHR2YXIgX2ltYWdlID0gKCBuZXcgX0ltYWdlKCkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHRpbWFnZXNbIF9pbWFnZS5pZCBdID0gX2ltYWdlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2V4dHJhJzpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coIGNoaWxkLm5vZGVOYW1lICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0ZWNobmlxdWU7XG5cblx0fTtcblxuXHRFZmZlY3QucHJvdG90eXBlLnBhcnNlVGVjaG5pcXVlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2NvbnN0YW50Jzpcblx0XHRcdFx0Y2FzZSAnbGFtYmVydCc6XG5cdFx0XHRcdGNhc2UgJ2JsaW5uJzpcblx0XHRcdFx0Y2FzZSAncGhvbmcnOlxuXG5cdFx0XHRcdFx0dGhpcy5zaGFkZXIgPSAoIG5ldyBTaGFkZXIoIGNoaWxkLm5vZGVOYW1lLCB0aGlzICkgKS5wYXJzZSggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZXh0cmEnOlxuXHRcdFx0XHRcdHRoaXMucGFyc2VFeHRyYShjaGlsZCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdEVmZmVjdC5wcm90b3R5cGUucGFyc2VFeHRyYSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWUnOlxuXHRcdFx0XHRcdHRoaXMucGFyc2VFeHRyYVRlY2huaXF1ZSggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH07XG5cblx0RWZmZWN0LnByb3RvdHlwZS5wYXJzZUV4dHJhVGVjaG5pcXVlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2J1bXAnOlxuXHRcdFx0XHRcdHRoaXMuc2hhZGVyLnBhcnNlKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEluc3RhbmNlRWZmZWN0ICgpIHtcblxuXHRcdHRoaXMudXJsID0gXCJcIjtcblxuXHR9XG5cblx0SW5zdGFuY2VFZmZlY3QucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy51cmwgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3VybCcgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gQW5pbWF0aW9uKCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcblx0XHR0aGlzLnNvdXJjZSA9IHt9O1xuXHRcdHRoaXMuc2FtcGxlciA9IFtdO1xuXHRcdHRoaXMuY2hhbm5lbCA9IFtdO1xuXG5cdH1cblxuXHRBbmltYXRpb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICduYW1lJyApO1xuXHRcdHRoaXMuc291cmNlID0ge307XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblxuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2FuaW1hdGlvbic6XG5cblx0XHRcdFx0XHR2YXIgYW5pbSA9ICggbmV3IEFuaW1hdGlvbigpICkucGFyc2UoIGNoaWxkICk7XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgc3JjIGluIGFuaW0uc291cmNlICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLnNvdXJjZVsgc3JjIF0gPSBhbmltLnNvdXJjZVsgc3JjIF07XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBhbmltLmNoYW5uZWwubGVuZ3RoOyBqICsrICkge1xuXG5cdFx0XHRcdFx0XHR0aGlzLmNoYW5uZWwucHVzaCggYW5pbS5jaGFubmVsWyBqIF0gKTtcblx0XHRcdFx0XHRcdHRoaXMuc2FtcGxlci5wdXNoKCBhbmltLnNhbXBsZXJbIGogXSApO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnc291cmNlJzpcblxuXHRcdFx0XHRcdHZhciBzcmMgPSAoIG5ldyBTb3VyY2UoKSApLnBhcnNlKCBjaGlsZCApO1xuXHRcdFx0XHRcdHRoaXMuc291cmNlWyBzcmMuaWQgXSA9IHNyYztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdzYW1wbGVyJzpcblxuXHRcdFx0XHRcdHRoaXMuc2FtcGxlci5wdXNoKCAoIG5ldyBTYW1wbGVyKCB0aGlzICkgKS5wYXJzZSggY2hpbGQgKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2NoYW5uZWwnOlxuXG5cdFx0XHRcdFx0dGhpcy5jaGFubmVsLnB1c2goICggbmV3IENoYW5uZWwoIHRoaXMgKSApLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVsKCBhbmltYXRpb24gKSB7XG5cblx0XHR0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcblx0XHR0aGlzLnNvdXJjZSA9IFwiXCI7XG5cdFx0dGhpcy50YXJnZXQgPSBcIlwiO1xuXHRcdHRoaXMuZnVsbFNpZCA9IG51bGw7XG5cdFx0dGhpcy5zaWQgPSBudWxsO1xuXHRcdHRoaXMuZG90U3ludGF4ID0gbnVsbDtcblx0XHR0aGlzLmFyclN5bnRheCA9IG51bGw7XG5cdFx0dGhpcy5hcnJJbmRpY2VzID0gbnVsbDtcblx0XHR0aGlzLm1lbWJlciA9IG51bGw7XG5cblx0fVxuXG5cdENoYW5uZWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBlbGVtZW50ICkge1xuXG5cdFx0dGhpcy5zb3VyY2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3NvdXJjZScgKS5yZXBsYWNlKCAvXiMvLCAnJyApO1xuXHRcdHRoaXMudGFyZ2V0ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0YXJnZXQnICk7XG5cblx0XHR2YXIgcGFydHMgPSB0aGlzLnRhcmdldC5zcGxpdCggJy8nICk7XG5cblx0XHR2YXIgaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciBzaWQgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0dmFyIGRvdFN5bnRheCA9ICggc2lkLmluZGV4T2YoXCIuXCIpID49IDAgKTtcblx0XHR2YXIgYXJyU3ludGF4ID0gKCBzaWQuaW5kZXhPZihcIihcIikgPj0gMCApO1xuXG5cdFx0aWYgKCBkb3RTeW50YXggKSB7XG5cblx0XHRcdHBhcnRzID0gc2lkLnNwbGl0KFwiLlwiKTtcblx0XHRcdHRoaXMuc2lkID0gcGFydHMuc2hpZnQoKTtcblx0XHRcdHRoaXMubWVtYmVyID0gcGFydHMuc2hpZnQoKTtcblxuXHRcdH0gZWxzZSBpZiAoIGFyclN5bnRheCApIHtcblxuXHRcdFx0dmFyIGFyckluZGljZXMgPSBzaWQuc3BsaXQoXCIoXCIpO1xuXHRcdFx0dGhpcy5zaWQgPSBhcnJJbmRpY2VzLnNoaWZ0KCk7XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgYXJySW5kaWNlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0YXJySW5kaWNlc1tqXSA9IHBhcnNlSW50KCBhcnJJbmRpY2VzW2pdLnJlcGxhY2UoL1xcKS8sICcnKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuYXJySW5kaWNlcyA9IGFyckluZGljZXM7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHR0aGlzLnNpZCA9IHNpZDtcblxuXHRcdH1cblxuXHRcdHRoaXMuZnVsbFNpZCA9IHNpZDtcblx0XHR0aGlzLmRvdFN5bnRheCA9IGRvdFN5bnRheDtcblx0XHR0aGlzLmFyclN5bnRheCA9IGFyclN5bnRheDtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0ZnVuY3Rpb24gU2FtcGxlciAoIGFuaW1hdGlvbiApIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuXHRcdHRoaXMuaW5wdXRzID0gW107XG5cdFx0dGhpcy5pbnB1dCA9IG51bGw7XG5cdFx0dGhpcy5vdXRwdXQgPSBudWxsO1xuXHRcdHRoaXMuc3RyaWRlT3V0ID0gbnVsbDtcblx0XHR0aGlzLmludGVycG9sYXRpb24gPSBudWxsO1xuXHRcdHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcblx0XHR0aGlzLmVuZFRpbWUgPSBudWxsO1xuXHRcdHRoaXMuZHVyYXRpb24gPSAwO1xuXG5cdH1cblxuXHRTYW1wbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMuaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXHRcdHRoaXMuaW5wdXRzID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdFx0XHR0aGlzLmlucHV0cy5wdXNoKCAobmV3IElucHV0KCkpLnBhcnNlKCBjaGlsZCApICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRTYW1wbGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBpbnB1dCA9IHRoaXMuaW5wdXRzWyBpIF07XG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5hbmltYXRpb24uc291cmNlWyBpbnB1dC5zb3VyY2UgXTtcblxuXHRcdFx0c3dpdGNoICggaW5wdXQuc2VtYW50aWMgKSB7XG5cblx0XHRcdFx0Y2FzZSAnSU5QVVQnOlxuXG5cdFx0XHRcdFx0dGhpcy5pbnB1dCA9IHNvdXJjZS5yZWFkKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT1VUUFVUJzpcblxuXHRcdFx0XHRcdHRoaXMub3V0cHV0ID0gc291cmNlLnJlYWQoKTtcblx0XHRcdFx0XHR0aGlzLnN0cmlkZU91dCA9IHNvdXJjZS5hY2Nlc3Nvci5zdHJpZGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnSU5URVJQT0xBVElPTic6XG5cblx0XHRcdFx0XHR0aGlzLmludGVycG9sYXRpb24gPSBzb3VyY2UucmVhZCgpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ0lOX1RBTkdFTlQnOlxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnT1VUX1RBTkdFTlQnOlxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGlucHV0LnNlbWFudGljKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuXHRcdHRoaXMuZW5kVGltZSA9IDA7XG5cdFx0dGhpcy5kdXJhdGlvbiA9IDA7XG5cblx0XHRpZiAoIHRoaXMuaW5wdXQubGVuZ3RoICkge1xuXG5cdFx0XHR0aGlzLnN0YXJ0VGltZSA9IDEwMDAwMDAwMDtcblx0XHRcdHRoaXMuZW5kVGltZSA9IC0xMDAwMDAwMDA7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXQubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRcdHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4oIHRoaXMuc3RhcnRUaW1lLCB0aGlzLmlucHV0WyBpIF0gKTtcblx0XHRcdFx0dGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIHRoaXMuZW5kVGltZSwgdGhpcy5pbnB1dFsgaSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IHRoaXMuZW5kVGltZSAtIHRoaXMuc3RhcnRUaW1lO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0U2FtcGxlci5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICggdHlwZSwgbmR4LCBtZW1iZXIgKSB7XG5cblx0XHR2YXIgZGF0YTtcblxuXHRcdGlmICggdHlwZSA9PT0gJ21hdHJpeCcgJiYgdGhpcy5zdHJpZGVPdXQgPT09IDE2ICkge1xuXG5cdFx0XHRkYXRhID0gdGhpcy5vdXRwdXRbIG5keCBdO1xuXG5cdFx0fSBlbHNlIGlmICggdGhpcy5zdHJpZGVPdXQgPiAxICkge1xuXG5cdFx0XHRkYXRhID0gW107XG5cdFx0XHRuZHggKj0gdGhpcy5zdHJpZGVPdXQ7XG5cblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuc3RyaWRlT3V0OyArKyBpICkge1xuXG5cdFx0XHRcdGRhdGFbIGkgXSA9IHRoaXMub3V0cHV0WyBuZHggKyBpIF07XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0aGlzLnN0cmlkZU91dCA9PT0gMyApIHtcblxuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXG5cdFx0XHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXG5cdFx0XHRcdFx0XHRmaXhDb29yZHMoIGRhdGEsIC0xICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgJ3NjYWxlJzpcblxuXHRcdFx0XHRcdFx0Zml4Q29vcmRzKCBkYXRhLCAxICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuc3RyaWRlT3V0ID09PSA0ICYmIHR5cGUgPT09ICdtYXRyaXgnICkge1xuXG5cdFx0XHRcdGZpeENvb3JkcyggZGF0YSwgLTEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZGF0YSA9IHRoaXMub3V0cHV0WyBuZHggXTtcblxuXHRcdFx0aWYgKCBtZW1iZXIgJiYgdHlwZSA9PT0gJ3RyYW5zbGF0ZScgKSB7XG5cdFx0XHRcdGRhdGEgPSBnZXRDb252ZXJ0ZWRUcmFuc2xhdGlvbiggbWVtYmVyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEtleSAoIHRpbWUgKSB7XG5cblx0XHR0aGlzLnRhcmdldHMgPSBbXTtcblx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuXG5cdH1cblxuXHRLZXkucHJvdG90eXBlLmFkZFRhcmdldCA9IGZ1bmN0aW9uICggZnVsbFNpZCwgdHJhbnNmb3JtLCBtZW1iZXIsIGRhdGEgKSB7XG5cblx0XHR0aGlzLnRhcmdldHMucHVzaCgge1xuXHRcdFx0c2lkOiBmdWxsU2lkLFxuXHRcdFx0bWVtYmVyOiBtZW1iZXIsXG5cdFx0XHR0cmFuc2Zvcm06IHRyYW5zZm9ybSxcblx0XHRcdGRhdGE6IGRhdGFcblx0XHR9ICk7XG5cblx0fTtcblxuXHRLZXkucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKCBvcHRfc2lkICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50YXJnZXRzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0dmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHRpZiAoICFvcHRfc2lkIHx8IHRhcmdldC5zaWQgPT09IG9wdF9zaWQgKSB7XG5cblx0XHRcdFx0dGFyZ2V0LnRyYW5zZm9ybS51cGRhdGUoIHRhcmdldC5kYXRhLCB0YXJnZXQubWVtYmVyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG5cdEtleS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCBmdWxsU2lkICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50YXJnZXRzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnRhcmdldHNbIGkgXS5zaWQgPT09IGZ1bGxTaWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMudGFyZ2V0c1sgaSBdO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9O1xuXG5cdEtleS5wcm90b3R5cGUuaGFzVGFyZ2V0ID0gZnVuY3Rpb24gKCBmdWxsU2lkICkge1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50YXJnZXRzLmxlbmd0aDsgKysgaSApIHtcblxuXHRcdFx0aWYgKCB0aGlzLnRhcmdldHNbIGkgXS5zaWQgPT09IGZ1bGxTaWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9O1xuXG5cdC8vIFRPRE86IEN1cnJlbnRseSBvbmx5IGRvaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBTaG91bGQgc3VwcG9ydCBmdWxsIENPTExBREEgc3BlYy5cblx0S2V5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICggbmV4dEtleSwgdGltZSApIHtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXRzWyBpIF0sXG5cdFx0XHRcdG5leHRUYXJnZXQgPSBuZXh0S2V5LmdldFRhcmdldCggdGFyZ2V0LnNpZCApLFxuXHRcdFx0XHRkYXRhO1xuXG5cdFx0XHRpZiAoIHRhcmdldC50cmFuc2Zvcm0udHlwZSAhPT0gJ21hdHJpeCcgJiYgbmV4dFRhcmdldCApIHtcblxuXHRcdFx0XHR2YXIgc2NhbGUgPSAoIHRpbWUgLSB0aGlzLnRpbWUgKSAvICggbmV4dEtleS50aW1lIC0gdGhpcy50aW1lICksXG5cdFx0XHRcdFx0bmV4dERhdGEgPSBuZXh0VGFyZ2V0LmRhdGEsXG5cdFx0XHRcdFx0cHJldkRhdGEgPSB0YXJnZXQuZGF0YTtcblxuXHRcdFx0XHRpZiAoIHNjYWxlIDwgMCApIHNjYWxlID0gMDtcblx0XHRcdFx0aWYgKCBzY2FsZSA+IDEgKSBzY2FsZSA9IDE7XG5cblx0XHRcdFx0aWYgKCBwcmV2RGF0YS5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHRkYXRhID0gW107XG5cblx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCBwcmV2RGF0YS5sZW5ndGg7ICsrIGogKSB7XG5cblx0XHRcdFx0XHRcdGRhdGFbIGogXSA9IHByZXZEYXRhWyBqIF0gKyAoIG5leHREYXRhWyBqIF0gLSBwcmV2RGF0YVsgaiBdICkgKiBzY2FsZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0ZGF0YSA9IHByZXZEYXRhICsgKCBuZXh0RGF0YSAtIHByZXZEYXRhICkgKiBzY2FsZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0ZGF0YSA9IHRhcmdldC5kYXRhO1xuXG5cdFx0XHR9XG5cblx0XHRcdHRhcmdldC50cmFuc2Zvcm0udXBkYXRlKCBkYXRhLCB0YXJnZXQubWVtYmVyICk7XG5cblx0XHR9XG5cblx0fTtcblxuXHQvLyBDYW1lcmFcblx0ZnVuY3Rpb24gQ2FtZXJhKCkge1xuXG5cdFx0dGhpcy5pZCA9IFwiXCI7XG5cdFx0dGhpcy5uYW1lID0gXCJcIjtcblx0XHR0aGlzLnRlY2huaXF1ZSA9IFwiXCI7XG5cblx0fVxuXG5cdENhbWVyYS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdvcHRpY3MnOlxuXG5cdFx0XHRcdFx0dGhpcy5wYXJzZU9wdGljcyggY2hpbGQgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdENhbWVyYS5wcm90b3R5cGUucGFyc2VPcHRpY3MgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRpZiAoIGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdLm5vZGVOYW1lID09PSAndGVjaG5pcXVlX2NvbW1vbicgKSB7XG5cblx0XHRcdFx0dmFyIHRlY2huaXF1ZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHRlY2huaXF1ZS5jaGlsZE5vZGVzLmxlbmd0aDsgaiArKyApIHtcblxuXHRcdFx0XHRcdHRoaXMudGVjaG5pcXVlID0gdGVjaG5pcXVlLmNoaWxkTm9kZXNbIGogXS5ub2RlTmFtZTtcblxuXHRcdFx0XHRcdGlmICggdGhpcy50ZWNobmlxdWUgPT09ICdwZXJzcGVjdGl2ZScgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBwZXJzcGVjdGl2ZSA9IHRlY2huaXF1ZS5jaGlsZE5vZGVzWyBqIF07XG5cblx0XHRcdFx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IHBlcnNwZWN0aXZlLmNoaWxkTm9kZXMubGVuZ3RoOyBrICsrICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBwYXJhbSA9IHBlcnNwZWN0aXZlLmNoaWxkTm9kZXNbIGsgXTtcblxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBwYXJhbS5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3lmb3YnOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy55Zm92ID0gcGFyYW0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd4Zm92Jzpcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMueGZvdiA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnem5lYXInOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy56bmVhciA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnemZhcic6XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnpmYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2FzcGVjdF9yYXRpbyc6XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzcGVjdF9yYXRpbyA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnRlY2huaXF1ZSA9PT0gJ29ydGhvZ3JhcGhpYycgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBvcnRob2dyYXBoaWMgPSB0ZWNobmlxdWUuY2hpbGROb2Rlc1sgaiBdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBvcnRob2dyYXBoaWMuY2hpbGROb2Rlcy5sZW5ndGg7IGsgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0dmFyIHBhcmFtID0gb3J0aG9ncmFwaGljLmNoaWxkTm9kZXNbIGsgXTtcblxuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKCBwYXJhbS5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3htYWcnOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy54bWFnID0gcGFyYW0udGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRjYXNlICd5bWFnJzpcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMueW1hZyA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnem5lYXInOlxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy56bmVhciA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSAnemZhcic6XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnpmYXIgPSBwYXJhbS50ZXh0Q29udGVudDtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2FzcGVjdF9yYXRpbyc6XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmFzcGVjdF9yYXRpbyA9IHBhcmFtLnRleHRDb250ZW50O1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIEluc3RhbmNlQ2FtZXJhKCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXG5cdH1cblxuXHRJbnN0YW5jZUNhbWVyYS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnVybCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1cmwnKS5yZXBsYWNlKC9eIy8sICcnKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0Ly8gTGlnaHRcblxuXHRmdW5jdGlvbiBMaWdodCgpIHtcblxuXHRcdHRoaXMuaWQgPSBcIlwiO1xuXHRcdHRoaXMubmFtZSA9IFwiXCI7XG5cdFx0dGhpcy50ZWNobmlxdWUgPSBcIlwiO1xuXG5cdH1cblxuXHRMaWdodC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXTtcblx0XHRcdGlmICggY2hpbGQubm9kZVR5cGUgIT0gMSApIGNvbnRpbnVlO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICd0ZWNobmlxdWVfY29tbW9uJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VDb21tb24oIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlJzpcblxuXHRcdFx0XHRcdHRoaXMucGFyc2VUZWNobmlxdWUoIGNoaWxkICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRMaWdodC5wcm90b3R5cGUucGFyc2VDb21tb24gPSBmdW5jdGlvbiAoIGVsZW1lbnQgKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHRzd2l0Y2ggKCBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXS5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdkaXJlY3Rpb25hbCc6XG5cdFx0XHRcdGNhc2UgJ3BvaW50Jzpcblx0XHRcdFx0Y2FzZSAnc3BvdCc6XG5cdFx0XHRcdGNhc2UgJ2FtYmllbnQnOlxuXG5cdFx0XHRcdFx0dGhpcy50ZWNobmlxdWUgPSBlbGVtZW50LmNoaWxkTm9kZXNbIGkgXS5ub2RlTmFtZTtcblxuXHRcdFx0XHRcdHZhciBsaWdodCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbGlnaHQuY2hpbGROb2Rlcy5sZW5ndGg7IGogKysgKSB7XG5cblx0XHRcdFx0XHRcdHZhciBjaGlsZCA9IGxpZ2h0LmNoaWxkTm9kZXNbal07XG5cblx0XHRcdFx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdGNhc2UgJ2NvbG9yJzpcblxuXHRcdFx0XHRcdFx0XHRcdHZhciByZ2JhID0gX2Zsb2F0cyggY2hpbGQudGV4dENvbnRlbnQgKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDApO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuY29sb3Iuc2V0UkdCKCByZ2JhWzBdLCByZ2JhWzFdLCByZ2JhWzJdICk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5jb2xvci5hID0gcmdiYVszXTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRjYXNlICdmYWxsb2ZmX2FuZ2xlJzpcblxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmFsbG9mZl9hbmdsZSA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0Y2FzZSAncXVhZHJhdGljX2F0dGVudWF0aW9uJzpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZiA9IHBhcnNlRmxvYXQoIGNoaWxkLnRleHRDb250ZW50ICk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kaXN0YW5jZSA9IGYgPyBNYXRoLnNxcnQoIDEgLyBmICkgOiAwO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdExpZ2h0LnByb3RvdHlwZS5wYXJzZVRlY2huaXF1ZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMucHJvZmlsZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAncHJvZmlsZScgKTtcblxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXG5cdFx0XHRzd2l0Y2ggKCBjaGlsZC5ub2RlTmFtZSApIHtcblxuXHRcdFx0XHRjYXNlICdpbnRlbnNpdHknOlxuXG5cdFx0XHRcdFx0dGhpcy5pbnRlbnNpdHkgPSBwYXJzZUZsb2F0KGNoaWxkLnRleHRDb250ZW50KTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBJbnN0YW5jZUxpZ2h0KCkge1xuXG5cdFx0dGhpcy51cmwgPSBcIlwiO1xuXG5cdH1cblxuXHRJbnN0YW5jZUxpZ2h0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICggZWxlbWVudCApIHtcblxuXHRcdHRoaXMudXJsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VybCcpLnJlcGxhY2UoL14jLywgJycpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBLaW5lbWF0aWNzTW9kZWwoICkge1xuXG5cdFx0dGhpcy5pZCA9ICcnO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMuam9pbnRzID0gW107XG5cdFx0dGhpcy5saW5rcyA9IFtdO1xuXG5cdH1cblxuXHRLaW5lbWF0aWNzTW9kZWwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmlkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cdFx0dGhpcy5uYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcblx0XHR0aGlzLmpvaW50cyA9IFtdO1xuXHRcdHRoaXMubGlua3MgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAndGVjaG5pcXVlX2NvbW1vbic6XG5cblx0XHRcdFx0XHR0aGlzLnBhcnNlQ29tbW9uKGNoaWxkKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdEtpbmVtYXRpY3NNb2RlbC5wcm90b3R5cGUucGFyc2VDb21tb24gPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggZWxlbWVudC5jaGlsZE5vZGVzWyBpIF0ubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnam9pbnQnOlxuXHRcdFx0XHRcdHRoaXMuam9pbnRzLnB1c2goIChuZXcgSm9pbnQoKSkucGFyc2UoY2hpbGQpICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbGluayc6XG5cdFx0XHRcdFx0dGhpcy5saW5rcy5wdXNoKCAobmV3IExpbmsoKSkucGFyc2UoY2hpbGQpICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBKb2ludCggKSB7XG5cblx0XHR0aGlzLnNpZCA9ICcnO1xuXHRcdHRoaXMubmFtZSA9ICcnO1xuXHRcdHRoaXMuYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy5saW1pdHMgPSB7XG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IDBcblx0XHR9O1xuXHRcdHRoaXMudHlwZSA9ICcnO1xuXHRcdHRoaXMuc3RhdGljID0gZmFsc2U7XG5cdFx0dGhpcy56ZXJvUG9zaXRpb24gPSAwLjA7XG5cdFx0dGhpcy5taWRkbGVQb3NpdGlvbiA9IDAuMDtcblxuXHR9XG5cblx0Sm9pbnQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzaWQnKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXHRcdHRoaXMuYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cdFx0dGhpcy5saW1pdHMgPSB7XG5cdFx0XHRtaW46IDAsXG5cdFx0XHRtYXg6IDBcblx0XHR9O1xuXHRcdHRoaXMudHlwZSA9ICcnO1xuXHRcdHRoaXMuc3RhdGljID0gZmFsc2U7XG5cdFx0dGhpcy56ZXJvUG9zaXRpb24gPSAwLjA7XG5cdFx0dGhpcy5taWRkbGVQb3NpdGlvbiA9IDAuMDtcblxuXHRcdHZhciBheGlzRWxlbWVudCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXhpcycpO1xuXHRcdHZhciBfYXhpcyA9IF9mbG9hdHMoYXhpc0VsZW1lbnQudGV4dENvbnRlbnQpO1xuXHRcdHRoaXMuYXhpcyA9IGdldENvbnZlcnRlZFZlYzMoX2F4aXMsIDApO1xuXG5cdFx0dmFyIG1pbiA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignbGltaXRzIG1pbicpID8gcGFyc2VGbG9hdChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbWl0cyBtaW4nKS50ZXh0Q29udGVudCkgOiAtMzYwO1xuXHRcdHZhciBtYXggPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbWl0cyBtYXgnKSA/IHBhcnNlRmxvYXQoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsaW1pdHMgbWF4JykudGV4dENvbnRlbnQpIDogMzYwO1xuXG5cdFx0dGhpcy5saW1pdHMgPSB7XG5cdFx0XHRtaW46IG1pbixcblx0XHRcdG1heDogbWF4XG5cdFx0fTtcblxuXHRcdHZhciBqb2ludFR5cGVzID0gWyAncHJpc21hdGljJywgJ3Jldm9sdXRlJyBdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgam9pbnRUeXBlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciB0eXBlID0gam9pbnRUeXBlc1sgaSBdO1xuXG5cdFx0XHR2YXIgam9pbnRFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKHR5cGUpO1xuXG5cdFx0XHRpZiAoIGpvaW50RWxlbWVudCApIHtcblxuXHRcdFx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgbWluIGlzIGVxdWFsIHRvIG9yIHNvbWVob3cgZ3JlYXRlciB0aGFuIHRoZSBtYXgsIGNvbnNpZGVyIHRoZSBqb2ludCBzdGF0aWNcblx0XHRpZiAoIHRoaXMubGltaXRzLm1pbiA+PSB0aGlzLmxpbWl0cy5tYXggKSB7XG5cblx0XHRcdHRoaXMuc3RhdGljID0gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdHRoaXMubWlkZGxlUG9zaXRpb24gPSAodGhpcy5saW1pdHMubWluICsgdGhpcy5saW1pdHMubWF4KSAvIDIuMDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIExpbmsoICkge1xuXG5cdFx0dGhpcy5zaWQgPSAnJztcblx0XHR0aGlzLm5hbWUgPSAnJztcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSBbXTtcblx0XHR0aGlzLmF0dGFjaG1lbnRzID0gW107XG5cblx0fVxuXG5cdExpbmsucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLnNpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzaWQnKTtcblx0XHR0aGlzLm5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuXHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xuXHRcdHRoaXMuYXR0YWNobWVudHMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdFx0dmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzWyBpIF07XG5cdFx0XHRpZiAoIGNoaWxkLm5vZGVUeXBlICE9IDEgKSBjb250aW51ZTtcblxuXHRcdFx0c3dpdGNoICggY2hpbGQubm9kZU5hbWUgKSB7XG5cblx0XHRcdFx0Y2FzZSAnYXR0YWNobWVudF9mdWxsJzpcblx0XHRcdFx0XHR0aGlzLmF0dGFjaG1lbnRzLnB1c2goIChuZXcgQXR0YWNobWVudCgpKS5wYXJzZShjaGlsZCkgKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRjYXNlICdtYXRyaXgnOlxuXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zLnB1c2goIChuZXcgVHJhbnNmb3JtKCkpLnBhcnNlKGNoaWxkKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBBdHRhY2htZW50KCApIHtcblxuXHRcdHRoaXMuam9pbnQgPSAnJztcblx0XHR0aGlzLnRyYW5zZm9ybXMgPSBbXTtcblx0XHR0aGlzLmxpbmtzID0gW107XG5cblx0fVxuXG5cdEF0dGFjaG1lbnQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHR0aGlzLmpvaW50ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2pvaW50Jykuc3BsaXQoJy8nKS5wb3AoKTtcblx0XHR0aGlzLmxpbmtzID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1sgaSBdO1xuXHRcdFx0aWYgKCBjaGlsZC5ub2RlVHlwZSAhPSAxICkgY29udGludWU7XG5cblx0XHRcdHN3aXRjaCAoIGNoaWxkLm5vZGVOYW1lICkge1xuXG5cdFx0XHRcdGNhc2UgJ2xpbmsnOlxuXHRcdFx0XHRcdHRoaXMubGlua3MucHVzaCggKG5ldyBMaW5rKCkpLnBhcnNlKGNoaWxkKSApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ3JvdGF0ZSc6XG5cdFx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdGNhc2UgJ21hdHJpeCc6XG5cblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCggKG5ldyBUcmFuc2Zvcm0oKSkucGFyc2UoY2hpbGQpICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdGZ1bmN0aW9uIF9zb3VyY2UoIGVsZW1lbnQgKSB7XG5cblx0XHR2YXIgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2lkJyApO1xuXG5cdFx0aWYgKCBzb3VyY2VzWyBpZCBdICE9IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0cmV0dXJuIHNvdXJjZXNbIGlkIF07XG5cblx0XHR9XG5cblx0XHRzb3VyY2VzWyBpZCBdID0gKCBuZXcgU291cmNlKGlkICkpLnBhcnNlKCBlbGVtZW50ICk7XG5cdFx0cmV0dXJuIHNvdXJjZXNbIGlkIF07XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9uc1Jlc29sdmVyKCBuc1ByZWZpeCApIHtcblxuXHRcdGlmICggbnNQcmVmaXggPT09IFwiZGFlXCIgKSB7XG5cblx0XHRcdHJldHVybiBcImh0dHA6Ly93d3cuY29sbGFkYS5vcmcvMjAwNS8xMS9DT0xMQURBU2NoZW1hXCI7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX2Jvb2xzKCBzdHIgKSB7XG5cblx0XHR2YXIgcmF3ID0gX3N0cmluZ3MoIHN0ciApO1xuXHRcdHZhciBkYXRhID0gW107XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByYXcubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0ZGF0YS5wdXNoKCAocmF3W2ldID09PSAndHJ1ZScgfHwgcmF3W2ldID09PSAnMScpID8gdHJ1ZSA6IGZhbHNlICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX2Zsb2F0cyggc3RyICkge1xuXG5cdFx0dmFyIHJhdyA9IF9zdHJpbmdzKHN0cik7XG5cdFx0dmFyIGRhdGEgPSBbXTtcblxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHJhdy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRkYXRhLnB1c2goIHBhcnNlRmxvYXQoIHJhd1sgaSBdICkgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfaW50cyggc3RyICkge1xuXG5cdFx0dmFyIHJhdyA9IF9zdHJpbmdzKCBzdHIgKTtcblx0XHR2YXIgZGF0YSA9IFtdO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmF3Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGRhdGEucHVzaCggcGFyc2VJbnQoIHJhd1sgaSBdLCAxMCApICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YTtcblxuXHR9XG5cblx0ZnVuY3Rpb24gX3N0cmluZ3MoIHN0ciApIHtcblxuXHRcdHJldHVybiAoIHN0ci5sZW5ndGggPiAwICkgPyBfdHJpbVN0cmluZyggc3RyICkuc3BsaXQoIC9cXHMrLyApIDogW107XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF90cmltU3RyaW5nKCBzdHIgKSB7XG5cblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzKy8sIFwiXCIgKS5yZXBsYWNlKCAvXFxzKyQvLCBcIlwiICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIF9hdHRyX2FzX2Zsb2F0KCBlbGVtZW50LCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cblx0XHRcdHJldHVybiBwYXJzZUZsb2F0KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRmdW5jdGlvbiBfYXR0cl9hc19pbnQoIGVsZW1lbnQsIG5hbWUsIGRlZmF1bHRWYWx1ZSApIHtcblxuXHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIG5hbWUgKSApIHtcblxuXHRcdFx0cmV0dXJuIHBhcnNlSW50KCBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApLCAxMCkgO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gX2F0dHJfYXNfc3RyaW5nKCBlbGVtZW50LCBuYW1lLCBkZWZhdWx0VmFsdWUgKSB7XG5cblx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBuYW1lICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gX2Zvcm1hdF9mbG9hdCggZiwgbnVtICkge1xuXG5cdFx0aWYgKCBmID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdHZhciBzID0gJzAuJztcblxuXHRcdFx0d2hpbGUgKCBzLmxlbmd0aCA8IG51bSArIDIgKSB7XG5cblx0XHRcdFx0cyArPSAnMCc7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHM7XG5cblx0XHR9XG5cblx0XHRudW0gPSBudW0gfHwgMjtcblxuXHRcdHZhciBwYXJ0cyA9IGYudG9TdHJpbmcoKS5zcGxpdCggJy4nICk7XG5cdFx0cGFydHNbIDEgXSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sgMSBdLnN1YnN0ciggMCwgbnVtICkgOiBcIjBcIjtcblxuXHRcdHdoaWxlICggcGFydHNbIDEgXS5sZW5ndGggPCBudW0gKSB7XG5cblx0XHRcdHBhcnRzWyAxIF0gKz0gJzAnO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oICcuJyApO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkVGV4dHVyZUltYWdlICggdGV4dHVyZSwgdXJsICkge1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlcigpO1xuXG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR9ICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGV4dHJhY3REb3VibGVTaWRlZCggb2JqLCBlbGVtZW50ICkge1xuXG5cdFx0b2JqLmRvdWJsZVNpZGVkID0gZmFsc2U7XG5cblx0XHR2YXIgbm9kZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZXh0cmEgZG91YmxlX3NpZGVkJylbMF07XG5cblx0XHRpZiAoIG5vZGUgKSB7XG5cblx0XHRcdGlmICggbm9kZSAmJiBwYXJzZUludCggbm9kZS50ZXh0Q29udGVudCwgMTAgKSA9PT0gMSApIHtcblxuXHRcdFx0XHRvYmouZG91YmxlU2lkZWQgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdC8vIFVwIGF4aXMgY29udmVyc2lvblxuXG5cdGZ1bmN0aW9uIHNldFVwQ29udmVyc2lvbigpIHtcblxuXHRcdGlmICggb3B0aW9ucy5jb252ZXJ0VXBBeGlzICE9PSB0cnVlIHx8IGNvbGxhZGFVcCA9PT0gb3B0aW9ucy51cEF4aXMgKSB7XG5cblx0XHRcdHVwQ29udmVyc2lvbiA9IG51bGw7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRzd2l0Y2ggKCBjb2xsYWRhVXAgKSB7XG5cblx0XHRcdFx0Y2FzZSAnWCc6XG5cblx0XHRcdFx0XHR1cENvbnZlcnNpb24gPSBvcHRpb25zLnVwQXhpcyA9PT0gJ1knID8gJ1h0b1knIDogJ1h0b1onO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1knOlxuXG5cdFx0XHRcdFx0dXBDb252ZXJzaW9uID0gb3B0aW9ucy51cEF4aXMgPT09ICdYJyA/ICdZdG9YJyA6ICdZdG9aJztcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdaJzpcblxuXHRcdFx0XHRcdHVwQ29udmVyc2lvbiA9IG9wdGlvbnMudXBBeGlzID09PSAnWCcgPyAnWnRvWCcgOiAnWnRvWSc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9XG5cblx0ZnVuY3Rpb24gZml4Q29vcmRzKCBkYXRhLCBzaWduICkge1xuXG5cdFx0aWYgKCBvcHRpb25zLmNvbnZlcnRVcEF4aXMgIT09IHRydWUgfHwgY29sbGFkYVVwID09PSBvcHRpb25zLnVwQXhpcyApIHtcblxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fVxuXG5cdFx0c3dpdGNoICggdXBDb252ZXJzaW9uICkge1xuXG5cdFx0XHRjYXNlICdYdG9ZJzpcblxuXHRcdFx0XHR2YXIgdG1wID0gZGF0YVsgMCBdO1xuXHRcdFx0XHRkYXRhWyAwIF0gPSBzaWduICogZGF0YVsgMSBdO1xuXHRcdFx0XHRkYXRhWyAxIF0gPSB0bXA7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdYdG9aJzpcblxuXHRcdFx0XHR2YXIgdG1wID0gZGF0YVsgMiBdO1xuXHRcdFx0XHRkYXRhWyAyIF0gPSBkYXRhWyAxIF07XG5cdFx0XHRcdGRhdGFbIDEgXSA9IGRhdGFbIDAgXTtcblx0XHRcdFx0ZGF0YVsgMCBdID0gdG1wO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWXRvWCc6XG5cblx0XHRcdFx0dmFyIHRtcCA9IGRhdGFbIDAgXTtcblx0XHRcdFx0ZGF0YVsgMCBdID0gZGF0YVsgMSBdO1xuXHRcdFx0XHRkYXRhWyAxIF0gPSBzaWduICogdG1wO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWXRvWic6XG5cblx0XHRcdFx0dmFyIHRtcCA9IGRhdGFbIDEgXTtcblx0XHRcdFx0ZGF0YVsgMSBdID0gc2lnbiAqIGRhdGFbIDIgXTtcblx0XHRcdFx0ZGF0YVsgMiBdID0gdG1wO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSAnWnRvWCc6XG5cblx0XHRcdFx0dmFyIHRtcCA9IGRhdGFbIDAgXTtcblx0XHRcdFx0ZGF0YVsgMCBdID0gZGF0YVsgMSBdO1xuXHRcdFx0XHRkYXRhWyAxIF0gPSBkYXRhWyAyIF07XG5cdFx0XHRcdGRhdGFbIDIgXSA9IHRtcDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ1p0b1knOlxuXG5cdFx0XHRcdHZhciB0bXAgPSBkYXRhWyAxIF07XG5cdFx0XHRcdGRhdGFbIDEgXSA9IGRhdGFbIDIgXTtcblx0XHRcdFx0ZGF0YVsgMiBdID0gc2lnbiAqIHRtcDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZlcnRlZFRyYW5zbGF0aW9uKCBheGlzLCBkYXRhICkge1xuXG5cdFx0aWYgKCBvcHRpb25zLmNvbnZlcnRVcEF4aXMgIT09IHRydWUgfHwgY29sbGFkYVVwID09PSBvcHRpb25zLnVwQXhpcyApIHtcblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBheGlzICkge1xuXHRcdFx0Y2FzZSAnWCc6XG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdYdG9ZJyA/IGRhdGEgKiAtMSA6IGRhdGE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWSc6XG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdZdG9aJyB8fCB1cENvbnZlcnNpb24gPT09ICdZdG9YJyA/IGRhdGEgKiAtMSA6IGRhdGE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnWic6XG5cdFx0XHRcdGRhdGEgPSB1cENvbnZlcnNpb24gPT09ICdadG9ZJyA/IGRhdGEgKiAtMSA6IGRhdGEgO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmVydGVkVmVjMyggZGF0YSwgb2Zmc2V0ICkge1xuXG5cdFx0dmFyIGFyciA9IFsgZGF0YVsgb2Zmc2V0IF0sIGRhdGFbIG9mZnNldCArIDEgXSwgZGF0YVsgb2Zmc2V0ICsgMiBdIF07XG5cdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCBhcnJbIDAgXSwgYXJyWyAxIF0sIGFyclsgMiBdICk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZlcnRlZE1hdDQoIGRhdGEgKSB7XG5cblx0XHRpZiAoIG9wdGlvbnMuY29udmVydFVwQXhpcyApIHtcblxuXHRcdFx0Ly8gRmlyc3QgZml4IHJvdGF0aW9uIGFuZCBzY2FsZVxuXG5cdFx0XHQvLyBDb2x1bW5zIGZpcnN0XG5cdFx0XHR2YXIgYXJyID0gWyBkYXRhWyAwIF0sIGRhdGFbIDQgXSwgZGF0YVsgOCBdIF07XG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcblx0XHRcdGRhdGFbIDAgXSA9IGFyclsgMCBdO1xuXHRcdFx0ZGF0YVsgNCBdID0gYXJyWyAxIF07XG5cdFx0XHRkYXRhWyA4IF0gPSBhcnJbIDIgXTtcblx0XHRcdGFyciA9IFsgZGF0YVsgMSBdLCBkYXRhWyA1IF0sIGRhdGFbIDkgXSBdO1xuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XG5cdFx0XHRkYXRhWyAxIF0gPSBhcnJbIDAgXTtcblx0XHRcdGRhdGFbIDUgXSA9IGFyclsgMSBdO1xuXHRcdFx0ZGF0YVsgOSBdID0gYXJyWyAyIF07XG5cdFx0XHRhcnIgPSBbIGRhdGFbIDIgXSwgZGF0YVsgNiBdLCBkYXRhWyAxMCBdIF07XG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcblx0XHRcdGRhdGFbIDIgXSA9IGFyclsgMCBdO1xuXHRcdFx0ZGF0YVsgNiBdID0gYXJyWyAxIF07XG5cdFx0XHRkYXRhWyAxMCBdID0gYXJyWyAyIF07XG5cdFx0XHQvLyBSb3dzIHNlY29uZFxuXHRcdFx0YXJyID0gWyBkYXRhWyAwIF0sIGRhdGFbIDEgXSwgZGF0YVsgMiBdIF07XG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcblx0XHRcdGRhdGFbIDAgXSA9IGFyclsgMCBdO1xuXHRcdFx0ZGF0YVsgMSBdID0gYXJyWyAxIF07XG5cdFx0XHRkYXRhWyAyIF0gPSBhcnJbIDIgXTtcblx0XHRcdGFyciA9IFsgZGF0YVsgNCBdLCBkYXRhWyA1IF0sIGRhdGFbIDYgXSBdO1xuXHRcdFx0Zml4Q29vcmRzKCBhcnIsIC0xICk7XG5cdFx0XHRkYXRhWyA0IF0gPSBhcnJbIDAgXTtcblx0XHRcdGRhdGFbIDUgXSA9IGFyclsgMSBdO1xuXHRcdFx0ZGF0YVsgNiBdID0gYXJyWyAyIF07XG5cdFx0XHRhcnIgPSBbIGRhdGFbIDggXSwgZGF0YVsgOSBdLCBkYXRhWyAxMCBdIF07XG5cdFx0XHRmaXhDb29yZHMoIGFyciwgLTEgKTtcblx0XHRcdGRhdGFbIDggXSA9IGFyclsgMCBdO1xuXHRcdFx0ZGF0YVsgOSBdID0gYXJyWyAxIF07XG5cdFx0XHRkYXRhWyAxMCBdID0gYXJyWyAyIF07XG5cblx0XHRcdC8vIE5vdyBmaXggdHJhbnNsYXRpb25cblx0XHRcdGFyciA9IFsgZGF0YVsgMyBdLCBkYXRhWyA3IF0sIGRhdGFbIDExIF0gXTtcblx0XHRcdGZpeENvb3JkcyggYXJyLCAtMSApO1xuXHRcdFx0ZGF0YVsgMyBdID0gYXJyWyAwIF07XG5cdFx0XHRkYXRhWyA3IF0gPSBhcnJbIDEgXTtcblx0XHRcdGRhdGFbIDExIF0gPSBhcnJbIDIgXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgVEhSRUUuTWF0cml4NCgpLnNldChcblx0XHRcdGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10sXG5cdFx0XHRkYXRhWzRdLCBkYXRhWzVdLCBkYXRhWzZdLCBkYXRhWzddLFxuXHRcdFx0ZGF0YVs4XSwgZGF0YVs5XSwgZGF0YVsxMF0sIGRhdGFbMTFdLFxuXHRcdFx0ZGF0YVsxMl0sIGRhdGFbMTNdLCBkYXRhWzE0XSwgZGF0YVsxNV1cblx0XHRcdCk7XG5cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZlcnRlZEluZGV4KCBpbmRleCApIHtcblxuXHRcdGlmICggaW5kZXggPiAtMSAmJiBpbmRleCA8IDMgKSB7XG5cblx0XHRcdHZhciBtZW1iZXJzID0gWyAnWCcsICdZJywgJ1onIF0sXG5cdFx0XHRcdGluZGljZXMgPSB7IFg6IDAsIFk6IDEsIFo6IDIgfTtcblxuXHRcdFx0aW5kZXggPSBnZXRDb252ZXJ0ZWRNZW1iZXIoIG1lbWJlcnNbIGluZGV4IF0gKTtcblx0XHRcdGluZGV4ID0gaW5kaWNlc1sgaW5kZXggXTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmVydGVkTWVtYmVyKCBtZW1iZXIgKSB7XG5cblx0XHRpZiAoIG9wdGlvbnMuY29udmVydFVwQXhpcyApIHtcblxuXHRcdFx0c3dpdGNoICggbWVtYmVyICkge1xuXG5cdFx0XHRcdGNhc2UgJ1gnOlxuXG5cdFx0XHRcdFx0c3dpdGNoICggdXBDb252ZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9ZJzpcblx0XHRcdFx0XHRcdGNhc2UgJ1h0b1onOlxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWCc6XG5cblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1knO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnWnRvWCc6XG5cblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1onO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ1knOlxuXG5cdFx0XHRcdFx0c3dpdGNoICggdXBDb252ZXJzaW9uICkge1xuXG5cdFx0XHRcdFx0XHRjYXNlICdYdG9ZJzpcblx0XHRcdFx0XHRcdGNhc2UgJ1l0b1gnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnWnRvWCc6XG5cblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1gnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnWHRvWic6XG5cdFx0XHRcdFx0XHRjYXNlICdZdG9aJzpcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1knOlxuXG5cdFx0XHRcdFx0XHRcdG1lbWJlciA9ICdaJztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdaJzpcblxuXHRcdFx0XHRcdHN3aXRjaCAoIHVwQ29udmVyc2lvbiApIHtcblxuXHRcdFx0XHRcdFx0Y2FzZSAnWHRvWic6XG5cblx0XHRcdFx0XHRcdFx0bWVtYmVyID0gJ1gnO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y2FzZSAnWXRvWic6XG5cdFx0XHRcdFx0XHRjYXNlICdadG9YJzpcblx0XHRcdFx0XHRcdGNhc2UgJ1p0b1knOlxuXG5cdFx0XHRcdFx0XHRcdG1lbWJlciA9ICdZJztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbWJlcjtcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlLFxuXHRcdHNldFByZWZlcnJlZFNoYWRpbmc6IHNldFByZWZlcnJlZFNoYWRpbmcsXG5cdFx0YXBwbHlTa2luOiBhcHBseVNraW4sXG5cdFx0Z2VvbWV0cmllcyA6IGdlb21ldHJpZXMsXG5cdFx0b3B0aW9uczogb3B0aW9uc1xuXG5cdH07XG5cbn07XG4iLCIvKipcbiAqIExvYWRzIGEgV2F2ZWZyb250IC5tdGwgZmlsZSBzcGVjaWZ5aW5nIG1hdGVyaWFsc1xuICpcbiAqIEBhdXRob3IgYW5nZWx4dWFuY2hhbmdcbiAqL1xuXG5USFJFRS5NVExMb2FkZXIgPSBmdW5jdGlvbiggbWFuYWdlciApIHtcblxuXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuTVRMTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTVRMTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcblx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIHRleHQgKSApO1xuXG5cdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdH0sXG5cblx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0QmFzZVVybDogZnVuY3Rpb24oIHZhbHVlICkge1xuXG5cdFx0Ly8gVE9ETzogTWVyZ2Ugd2l0aCBzZXRQYXRoKCk/IE9yIHJlbmFtZSB0byBzZXRUZXh0dXJlUGF0aD9cblxuXHRcdHRoaXMuYmFzZVVybCA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cblx0fSxcblxuXHRzZXRNYXRlcmlhbE9wdGlvbnM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFsT3B0aW9ucyA9IHZhbHVlO1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFBhcnNlcyBsb2FkZWQgTVRMIGZpbGVcblx0ICogQHBhcmFtIHRleHQgLSBDb250ZW50IG9mIE1UTCBmaWxlXG5cdCAqIEByZXR1cm4ge1RIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3J9XG5cdCAqL1xuXHRwYXJzZTogZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0dmFyIGxpbmVzID0gdGV4dC5zcGxpdCggXCJcXG5cIiApO1xuXHRcdHZhciBpbmZvID0ge307XG5cdFx0dmFyIGRlbGltaXRlcl9wYXR0ZXJuID0gL1xccysvO1xuXHRcdHZhciBtYXRlcmlhbHNJbmZvID0ge307XG5cblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkgKysgKSB7XG5cblx0XHRcdHZhciBsaW5lID0gbGluZXNbIGkgXTtcblx0XHRcdGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBsaW5lLmxlbmd0aCA9PT0gMCB8fCBsaW5lLmNoYXJBdCggMCApID09PSAnIycgKSB7XG5cblx0XHRcdFx0Ly8gQmxhbmsgbGluZSBvciBjb21tZW50IGlnbm9yZVxuXHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcG9zID0gbGluZS5pbmRleE9mKCAnICcgKTtcblxuXHRcdFx0dmFyIGtleSA9ICggcG9zID49IDAgKSA/IGxpbmUuc3Vic3RyaW5nKCAwLCBwb3MgKSA6IGxpbmU7XG5cdFx0XHRrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dmFyIHZhbHVlID0gKCBwb3MgPj0gMCApID8gbGluZS5zdWJzdHJpbmcoIHBvcyArIDEgKSA6IFwiXCI7XG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcblxuXHRcdFx0aWYgKCBrZXkgPT09IFwibmV3bXRsXCIgKSB7XG5cblx0XHRcdFx0Ly8gTmV3IG1hdGVyaWFsXG5cblx0XHRcdFx0aW5mbyA9IHsgbmFtZTogdmFsdWUgfTtcblx0XHRcdFx0bWF0ZXJpYWxzSW5mb1sgdmFsdWUgXSA9IGluZm87XG5cblx0XHRcdH0gZWxzZSBpZiAoIGluZm8gKSB7XG5cblx0XHRcdFx0aWYgKCBrZXkgPT09IFwia2FcIiB8fCBrZXkgPT09IFwia2RcIiB8fCBrZXkgPT09IFwia3NcIiApIHtcblxuXHRcdFx0XHRcdHZhciBzcyA9IHZhbHVlLnNwbGl0KCBkZWxpbWl0ZXJfcGF0dGVybiwgMyApO1xuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gWyBwYXJzZUZsb2F0KCBzc1sgMCBdICksIHBhcnNlRmxvYXQoIHNzWyAxIF0gKSwgcGFyc2VGbG9hdCggc3NbIDIgXSApIF07XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGluZm9bIGtleSBdID0gdmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgbWF0ZXJpYWxDcmVhdG9yID0gbmV3IFRIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IoIHRoaXMuYmFzZVVybCwgdGhpcy5tYXRlcmlhbE9wdGlvbnMgKTtcblx0XHRtYXRlcmlhbENyZWF0b3Iuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblx0XHRtYXRlcmlhbENyZWF0b3Iuc2V0TWFuYWdlciggdGhpcy5tYW5hZ2VyICk7XG5cdFx0bWF0ZXJpYWxDcmVhdG9yLnNldE1hdGVyaWFscyggbWF0ZXJpYWxzSW5mbyApO1xuXHRcdHJldHVybiBtYXRlcmlhbENyZWF0b3I7XG5cblx0fVxuXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUSFJFRS1NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yXG4gKiBAcGFyYW0gYmFzZVVybCAtIFVybCByZWxhdGl2ZSB0byB3aGljaCB0ZXh0dXJlcyBhcmUgbG9hZGVkXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNldCBvZiBvcHRpb25zIG9uIGhvdyB0byBjb25zdHJ1Y3QgdGhlIG1hdGVyaWFsc1xuICogICAgICAgICAgICAgICAgICBzaWRlOiBXaGljaCBzaWRlIHRvIGFwcGx5IHRoZSBtYXRlcmlhbFxuICogICAgICAgICAgICAgICAgICAgICAgICBUSFJFRS5Gcm9udFNpZGUgKGRlZmF1bHQpLCBUSFJFRS5CYWNrU2lkZSwgVEhSRUUuRG91YmxlU2lkZVxuICogICAgICAgICAgICAgICAgICB3cmFwOiBXaGF0IHR5cGUgb2Ygd3JhcHBpbmcgdG8gYXBwbHkgZm9yIHRleHR1cmVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFRIUkVFLlJlcGVhdFdyYXBwaW5nIChkZWZhdWx0KSwgVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZywgVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuICogICAgICAgICAgICAgICAgICBub3JtYWxpemVSR0I6IFJHQnMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIDAtMSBmcm9tIDAtMjU1XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogZmFsc2UsIGFzc3VtZWQgdG8gYmUgYWxyZWFkeSBub3JtYWxpemVkXG4gKiAgICAgICAgICAgICAgICAgIGlnbm9yZVplcm9SR0JzOiBJZ25vcmUgdmFsdWVzIG9mIFJHQnMgKEthLEtkLEtzKSB0aGF0IGFyZSBhbGwgMCdzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWZhdWx0OiBmYWxzZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuVEhSRUUuTVRMTG9hZGVyLk1hdGVyaWFsQ3JlYXRvciA9IGZ1bmN0aW9uKCBiYXNlVXJsLCBvcHRpb25zICkge1xuXG5cdHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdHRoaXMubWF0ZXJpYWxzSW5mbyA9IHt9O1xuXHR0aGlzLm1hdGVyaWFscyA9IHt9O1xuXHR0aGlzLm1hdGVyaWFsc0FycmF5ID0gW107XG5cdHRoaXMubmFtZUxvb2t1cCA9IHt9O1xuXG5cdHRoaXMuc2lkZSA9ICggdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zaWRlICkgPyB0aGlzLm9wdGlvbnMuc2lkZSA6IFRIUkVFLkZyb250U2lkZTtcblx0dGhpcy53cmFwID0gKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndyYXAgKSA/IHRoaXMub3B0aW9ucy53cmFwIDogVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG5cbn07XG5cblRIUkVFLk1UTExvYWRlci5NYXRlcmlhbENyZWF0b3IucHJvdG90eXBlID0ge1xuXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5NVExMb2FkZXIuTWF0ZXJpYWxDcmVhdG9yLFxuXG5cdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0TWFuYWdlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuXHRcdHRoaXMubWFuYWdlciA9IHZhbHVlO1xuXG5cdH0sXG5cblx0c2V0TWF0ZXJpYWxzOiBmdW5jdGlvbiggbWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdHRoaXMubWF0ZXJpYWxzSW5mbyA9IHRoaXMuY29udmVydCggbWF0ZXJpYWxzSW5mbyApO1xuXHRcdHRoaXMubWF0ZXJpYWxzID0ge307XG5cdFx0dGhpcy5tYXRlcmlhbHNBcnJheSA9IFtdO1xuXHRcdHRoaXMubmFtZUxvb2t1cCA9IHt9O1xuXG5cdH0sXG5cblx0Y29udmVydDogZnVuY3Rpb24oIG1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRpZiAoICEgdGhpcy5vcHRpb25zICkgcmV0dXJuIG1hdGVyaWFsc0luZm87XG5cblx0XHR2YXIgY29udmVydGVkID0ge307XG5cblx0XHRmb3IgKCB2YXIgbW4gaW4gbWF0ZXJpYWxzSW5mbyApIHtcblxuXHRcdFx0Ly8gQ29udmVydCBtYXRlcmlhbHMgaW5mbyBpbnRvIG5vcm1hbGl6ZWQgZm9ybSBiYXNlZCBvbiBvcHRpb25zXG5cblx0XHRcdHZhciBtYXQgPSBtYXRlcmlhbHNJbmZvWyBtbiBdO1xuXG5cdFx0XHR2YXIgY292bWF0ID0ge307XG5cblx0XHRcdGNvbnZlcnRlZFsgbW4gXSA9IGNvdm1hdDtcblxuXHRcdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xuXG5cdFx0XHRcdHZhciBzYXZlID0gdHJ1ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0WyBwcm9wIF07XG5cdFx0XHRcdHZhciBscHJvcCA9IHByb3AudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRzd2l0Y2ggKCBscHJvcCApIHtcblxuXHRcdFx0XHRcdGNhc2UgJ2tkJzpcblx0XHRcdFx0XHRjYXNlICdrYSc6XG5cdFx0XHRcdFx0Y2FzZSAna3MnOlxuXG5cdFx0XHRcdFx0XHQvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xuXG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubm9ybWFsaXplUkdCICkge1xuXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gWyB2YWx1ZVsgMCBdIC8gMjU1LCB2YWx1ZVsgMSBdIC8gMjU1LCB2YWx1ZVsgMiBdIC8gMjU1IF07XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmlnbm9yZVplcm9SR0JzICkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdmFsdWVbIDAgXSA9PT0gMCAmJiB2YWx1ZVsgMSBdID09PSAwICYmIHZhbHVlWyAxIF0gPT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBpZ25vcmVcblxuXHRcdFx0XHRcdFx0XHRcdHNhdmUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2F2ZSApIHtcblxuXHRcdFx0XHRcdGNvdm1hdFsgbHByb3AgXSA9IHZhbHVlO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcblxuXHR9LFxuXG5cdHByZWxvYWQ6IGZ1bmN0aW9uICgpIHtcblxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRcdHRoaXMuY3JlYXRlKCBtbiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCBtYXRlcmlhbE5hbWUgKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5uYW1lTG9va3VwWyBtYXRlcmlhbE5hbWUgXTtcblxuXHR9LFxuXG5cdGdldEFzQXJyYXk6IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGluZGV4ID0gMDtcblxuXHRcdGZvciAoIHZhciBtbiBpbiB0aGlzLm1hdGVyaWFsc0luZm8gKSB7XG5cblx0XHRcdHRoaXMubWF0ZXJpYWxzQXJyYXlbIGluZGV4IF0gPSB0aGlzLmNyZWF0ZSggbW4gKTtcblx0XHRcdHRoaXMubmFtZUxvb2t1cFsgbW4gXSA9IGluZGV4O1xuXHRcdFx0aW5kZXggKys7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNBcnJheTtcblxuXHR9LFxuXG5cdGNyZWF0ZTogZnVuY3Rpb24gKCBtYXRlcmlhbE5hbWUgKSB7XG5cblx0XHRpZiAoIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHR0aGlzLmNyZWF0ZU1hdGVyaWFsXyggbWF0ZXJpYWxOYW1lICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5tYXRlcmlhbHNbIG1hdGVyaWFsTmFtZSBdO1xuXG5cdH0sXG5cblx0Y3JlYXRlTWF0ZXJpYWxfOiBmdW5jdGlvbiAoIG1hdGVyaWFsTmFtZSApIHtcblxuXHRcdC8vIENyZWF0ZSBtYXRlcmlhbFxuXG5cdFx0dmFyIG1hdCA9IHRoaXMubWF0ZXJpYWxzSW5mb1sgbWF0ZXJpYWxOYW1lIF07XG5cdFx0dmFyIHBhcmFtcyA9IHtcblxuXHRcdFx0bmFtZTogbWF0ZXJpYWxOYW1lLFxuXHRcdFx0c2lkZTogdGhpcy5zaWRlXG5cblx0XHR9O1xuXG5cdFx0Zm9yICggdmFyIHByb3AgaW4gbWF0ICkge1xuXG5cdFx0XHR2YXIgdmFsdWUgPSBtYXRbIHByb3AgXTtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gJycgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKCBwcm9wLnRvTG93ZXJDYXNlKCkgKSB7XG5cblx0XHRcdFx0Ly8gTnMgaXMgbWF0ZXJpYWwgc3BlY3VsYXIgZXhwb25lbnRcblxuXHRcdFx0XHRjYXNlICdrZCc6XG5cblx0XHRcdFx0XHQvLyBEaWZmdXNlIGNvbG9yIChjb2xvciB1bmRlciB3aGl0ZSBsaWdodCkgdXNpbmcgUkdCIHZhbHVlc1xuXG5cdFx0XHRcdFx0cGFyYW1zWyAnY29sb3InIF0gPSBuZXcgVEhSRUUuQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdrcyc6XG5cblx0XHRcdFx0XHQvLyBTcGVjdWxhciBjb2xvciAoY29sb3Igd2hlbiBsaWdodCBpcyByZWZsZWN0ZWQgZnJvbSBzaGlueSBzdXJmYWNlKSB1c2luZyBSR0IgdmFsdWVzXG5cdFx0XHRcdFx0cGFyYW1zWyAnc3BlY3VsYXInIF0gPSBuZXcgVEhSRUUuQ29sb3IoKS5mcm9tQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdtYXBfa2QnOlxuXG5cdFx0XHRcdFx0Ly8gRGlmZnVzZSB0ZXh0dXJlIG1hcFxuXG5cdFx0XHRcdFx0cGFyYW1zWyAnbWFwJyBdID0gdGhpcy5sb2FkVGV4dHVyZSggdGhpcy5iYXNlVXJsICsgdmFsdWUgKTtcblx0XHRcdFx0XHRwYXJhbXNbICdtYXAnIF0ud3JhcFMgPSB0aGlzLndyYXA7XG5cdFx0XHRcdFx0cGFyYW1zWyAnbWFwJyBdLndyYXBUID0gdGhpcy53cmFwO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSAnbnMnOlxuXG5cdFx0XHRcdFx0Ly8gVGhlIHNwZWN1bGFyIGV4cG9uZW50IChkZWZpbmVzIHRoZSBmb2N1cyBvZiB0aGUgc3BlY3VsYXIgaGlnaGxpZ2h0KVxuXHRcdFx0XHRcdC8vIEEgaGlnaCBleHBvbmVudCByZXN1bHRzIGluIGEgdGlnaHQsIGNvbmNlbnRyYXRlZCBoaWdobGlnaHQuIE5zIHZhbHVlcyBub3JtYWxseSByYW5nZSBmcm9tIDAgdG8gMTAwMC5cblxuXHRcdFx0XHRcdHBhcmFtc1sgJ3NoaW5pbmVzcycgXSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdkJzpcblxuXHRcdFx0XHRcdGlmICggdmFsdWUgPCAxICkge1xuXG5cdFx0XHRcdFx0XHRwYXJhbXNbICdvcGFjaXR5JyBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRwYXJhbXNbICd0cmFuc3BhcmVudCcgXSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdUcic6XG5cblx0XHRcdFx0XHRpZiAoIHZhbHVlID4gMCApIHtcblxuXHRcdFx0XHRcdFx0cGFyYW1zWyAnb3BhY2l0eScgXSA9IDEgLSB2YWx1ZTtcblx0XHRcdFx0XHRcdHBhcmFtc1sgJ3RyYW5zcGFyZW50JyBdID0gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ21hcF9idW1wJzpcblx0XHRcdFx0Y2FzZSAnYnVtcCc6XG5cblx0XHRcdFx0XHQvLyBCdW1wIHRleHR1cmUgbWFwXG5cblx0XHRcdFx0XHRpZiAoIHBhcmFtc1sgJ2J1bXBNYXAnIF0gKSBicmVhazsgLy8gQXZvaWQgbG9hZGluZyB0d2ljZS5cblxuXHRcdFx0XHRcdHBhcmFtc1sgJ2J1bXBNYXAnIF0gPSB0aGlzLmxvYWRUZXh0dXJlKCB0aGlzLmJhc2VVcmwgKyB2YWx1ZSApO1xuXHRcdFx0XHRcdHBhcmFtc1sgJ2J1bXBNYXAnIF0ud3JhcFMgPSB0aGlzLndyYXA7XG5cdFx0XHRcdFx0cGFyYW1zWyAnYnVtcE1hcCcgXS53cmFwVCA9IHRoaXMud3JhcDtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXSA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCggcGFyYW1zICk7XG5cdFx0cmV0dXJuIHRoaXMubWF0ZXJpYWxzWyBtYXRlcmlhbE5hbWUgXTtcblxuXHR9LFxuXG5cblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgdGV4dHVyZTtcblx0XHR2YXIgbG9hZGVyID0gVEhSRUUuTG9hZGVyLkhhbmRsZXJzLmdldCggdXJsICk7XG5cdFx0dmFyIG1hbmFnZXIgPSAoIHRoaXMubWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyB0aGlzLm1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cblx0XHRpZiAoIGxvYWRlciA9PT0gbnVsbCApIHtcblxuXHRcdFx0bG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcblxuXHRcdH1cblxuXHRcdGlmICggbG9hZGVyLnNldENyb3NzT3JpZ2luICkgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cdFx0dGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG5cdFx0aWYgKCBtYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cblx0fVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5NVExMb2FkZXIucHJvdG90eXBlICk7XG4iLCIvKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuT0JKTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG5cdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG5cdHRoaXMubWF0ZXJpYWxzID0gbnVsbDtcblxufTtcblxuVEhSRUUuT0JKTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuT0JKTG9hZGVyLFxuXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG5cdFx0dmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcblx0XHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XG5cdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG5cdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCB0ZXh0ICkgKTtcblxuXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXHR9LFxuXG5cdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cblx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcblxuXHR9LFxuXG5cdHNldE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XG5cblx0XHR0aGlzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcblxuXHR9LFxuXG5cdHBhcnNlOiBmdW5jdGlvbiAoIHRleHQgKSB7XG5cblx0XHRjb25zb2xlLnRpbWUoICdPQkpMb2FkZXInICk7XG5cblx0XHR2YXIgb2JqZWN0cyA9IFtdO1xuXHRcdHZhciBvYmplY3Q7XG5cdFx0dmFyIGZvdW5kT2JqZWN0cyA9IGZhbHNlO1xuXHRcdHZhciB2ZXJ0aWNlcyA9IFtdO1xuXHRcdHZhciBub3JtYWxzID0gW107XG5cdFx0dmFyIHV2cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkT2JqZWN0KG5hbWUpIHtcblxuXHRcdFx0dmFyIGdlb21ldHJ5ID0ge1xuXHRcdFx0XHR2ZXJ0aWNlczogW10sXG5cdFx0XHRcdG5vcm1hbHM6IFtdLFxuXHRcdFx0XHR1dnM6IFtdXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgbWF0ZXJpYWwgPSB7XG5cdFx0XHRcdG5hbWU6ICcnLFxuXHRcdFx0XHRzbW9vdGg6IHRydWVcblx0XHRcdH07XG5cblx0XHRcdG9iamVjdCA9IHtcblx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuXHRcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWxcblx0XHRcdH07XG5cblx0XHRcdG9iamVjdHMucHVzaCggb2JqZWN0ICk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVZlcnRleEluZGV4KCB2YWx1ZSApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlICk7XG5cblx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSAqIDM7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZU5vcm1hbEluZGV4KCB2YWx1ZSApIHtcblxuXHRcdFx0dmFyIGluZGV4ID0gcGFyc2VJbnQoIHZhbHVlICk7XG5cblx0XHRcdHJldHVybiAoIGluZGV4ID49IDAgPyBpbmRleCAtIDEgOiBpbmRleCArIG5vcm1hbHMubGVuZ3RoIC8gMyApICogMztcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlVVZJbmRleCggdmFsdWUgKSB7XG5cblx0XHRcdHZhciBpbmRleCA9IHBhcnNlSW50KCB2YWx1ZSApO1xuXG5cdFx0XHRyZXR1cm4gKCBpbmRleCA+PSAwID8gaW5kZXggLSAxIDogaW5kZXggKyB1dnMubGVuZ3RoIC8gMiApICogMjtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFZlcnRleCggYSwgYiwgYyApIHtcblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG5cdFx0XHRcdHZlcnRpY2VzWyBhIF0sIHZlcnRpY2VzWyBhICsgMSBdLCB2ZXJ0aWNlc1sgYSArIDIgXSxcblx0XHRcdFx0dmVydGljZXNbIGIgXSwgdmVydGljZXNbIGIgKyAxIF0sIHZlcnRpY2VzWyBiICsgMiBdLFxuXHRcdFx0XHR2ZXJ0aWNlc1sgYyBdLCB2ZXJ0aWNlc1sgYyArIDEgXSwgdmVydGljZXNbIGMgKyAyIF1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGROb3JtYWwoIGEsIGIsIGMgKSB7XG5cblx0XHRcdG9iamVjdC5nZW9tZXRyeS5ub3JtYWxzLnB1c2goXG5cdFx0XHRcdG5vcm1hbHNbIGEgXSwgbm9ybWFsc1sgYSArIDEgXSwgbm9ybWFsc1sgYSArIDIgXSxcblx0XHRcdFx0bm9ybWFsc1sgYiBdLCBub3JtYWxzWyBiICsgMSBdLCBub3JtYWxzWyBiICsgMiBdLFxuXHRcdFx0XHRub3JtYWxzWyBjIF0sIG5vcm1hbHNbIGMgKyAxIF0sIG5vcm1hbHNbIGMgKyAyIF1cblx0XHRcdCk7XG5cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRVViggYSwgYiwgYyApIHtcblxuXHRcdFx0b2JqZWN0Lmdlb21ldHJ5LnV2cy5wdXNoKFxuXHRcdFx0XHR1dnNbIGEgXSwgdXZzWyBhICsgMSBdLFxuXHRcdFx0XHR1dnNbIGIgXSwgdXZzWyBiICsgMSBdLFxuXHRcdFx0XHR1dnNbIGMgXSwgdXZzWyBjICsgMSBdXG5cdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYywgZCwgIHVhLCB1YiwgdWMsIHVkLCBuYSwgbmIsIG5jLCBuZCApIHtcblxuXHRcdFx0dmFyIGlhID0gcGFyc2VWZXJ0ZXhJbmRleCggYSApO1xuXHRcdFx0dmFyIGliID0gcGFyc2VWZXJ0ZXhJbmRleCggYiApO1xuXHRcdFx0dmFyIGljID0gcGFyc2VWZXJ0ZXhJbmRleCggYyApO1xuXHRcdFx0dmFyIGlkO1xuXG5cdFx0XHRpZiAoIGQgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpZCA9IHBhcnNlVmVydGV4SW5kZXgoIGQgKTtcblxuXHRcdFx0XHRhZGRWZXJ0ZXgoIGlhLCBpYiwgaWQgKTtcblx0XHRcdFx0YWRkVmVydGV4KCBpYiwgaWMsIGlkICk7XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB1YSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VVVkluZGV4KCB1YSApO1xuXHRcdFx0XHRpYiA9IHBhcnNlVVZJbmRleCggdWIgKTtcblx0XHRcdFx0aWMgPSBwYXJzZVVWSW5kZXgoIHVjICk7XG5cblx0XHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhZGRVViggaWEsIGliLCBpYyApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRpZCA9IHBhcnNlVVZJbmRleCggdWQgKTtcblxuXHRcdFx0XHRcdGFkZFVWKCBpYSwgaWIsIGlkICk7XG5cdFx0XHRcdFx0YWRkVVYoIGliLCBpYywgaWQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBuYSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlhID0gcGFyc2VOb3JtYWxJbmRleCggbmEgKTtcblx0XHRcdFx0aWIgPSBwYXJzZU5vcm1hbEluZGV4KCBuYiApO1xuXHRcdFx0XHRpYyA9IHBhcnNlTm9ybWFsSW5kZXgoIG5jICk7XG5cblx0XHRcdFx0aWYgKCBkID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0XHRhZGROb3JtYWwoIGlhLCBpYiwgaWMgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0aWQgPSBwYXJzZU5vcm1hbEluZGV4KCBuZCApO1xuXG5cdFx0XHRcdFx0YWRkTm9ybWFsKCBpYSwgaWIsIGlkICk7XG5cdFx0XHRcdFx0YWRkTm9ybWFsKCBpYiwgaWMsIGlkICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRhZGRPYmplY3QoXCJcIik7XG5cblx0XHQvLyB2IGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0dmFyIHZlcnRleF9wYXR0ZXJuID0gL152XFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKVxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKylcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIHZuIGZsb2F0IGZsb2F0IGZsb2F0XG5cdFx0dmFyIG5vcm1hbF9wYXR0ZXJuID0gL152blxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKylcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspXFxzKyhbXFxkfFxcLnxcXCt8XFwtfGV8RV0rKS87XG5cblx0XHQvLyB2dCBmbG9hdCBmbG9hdFxuXHRcdHZhciB1dl9wYXR0ZXJuID0gL152dFxccysoW1xcZHxcXC58XFwrfFxcLXxlfEVdKylcXHMrKFtcXGR8XFwufFxcK3xcXC18ZXxFXSspLztcblxuXHRcdC8vIGYgdmVydGV4IHZlcnRleCB2ZXJ0ZXggLi4uXG5cdFx0dmFyIGZhY2VfcGF0dGVybjEgPSAvXmZcXHMrKC0/XFxkKylcXHMrKC0/XFxkKylcXHMrKC0/XFxkKykoPzpcXHMrKC0/XFxkKykpPy87XG5cblx0XHQvLyBmIHZlcnRleC91diB2ZXJ0ZXgvdXYgdmVydGV4L3V2IC4uLlxuXHRcdHZhciBmYWNlX3BhdHRlcm4yID0gL15mXFxzKygoLT9cXGQrKVxcLygtP1xcZCspKVxccysoKC0/XFxkKylcXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvKC0/XFxkKykpKD86XFxzKygoLT9cXGQrKVxcLygtP1xcZCspKSk/LztcblxuXHRcdC8vIGYgdmVydGV4L3V2L25vcm1hbCB2ZXJ0ZXgvdXYvbm9ybWFsIHZlcnRleC91di9ub3JtYWwgLi4uXG5cdFx0dmFyIGZhY2VfcGF0dGVybjMgPSAvXmZcXHMrKCgtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkoPzpcXHMrKCgtP1xcZCspXFwvKC0/XFxkKylcXC8oLT9cXGQrKSkpPy87XG5cblx0XHQvLyBmIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIHZlcnRleC8vbm9ybWFsIC4uLlxuXHRcdHZhciBmYWNlX3BhdHRlcm40ID0gL15mXFxzKygoLT9cXGQrKVxcL1xcLygtP1xcZCspKVxccysoKC0/XFxkKylcXC9cXC8oLT9cXGQrKSlcXHMrKCgtP1xcZCspXFwvXFwvKC0/XFxkKykpKD86XFxzKygoLT9cXGQrKVxcL1xcLygtP1xcZCspKSk/LztcblxuXHRcdHZhciBvYmplY3RfcGF0dGVybiA9IC9eW29nXVxccysoLispLztcblxuXHRcdHZhciBzbW9vdGhpbmdfcGF0dGVybiA9IC9ec1xccysoWzAxXXxvbnxvZmYpLztcblxuXHRcdC8vXG5cblx0XHR2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KCAnXFxuJyApO1xuXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzWyBpIF07XG5cdFx0XHRsaW5lID0gbGluZS50cmltKCk7XG5cblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdGlmICggbGluZS5sZW5ndGggPT09IDAgfHwgbGluZS5jaGFyQXQoIDAgKSA9PT0gJyMnICkge1xuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCAoIHJlc3VsdCA9IHZlcnRleF9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcInYgMS4wIDIuMCAzLjBcIiwgXCIxLjBcIiwgXCIyLjBcIiwgXCIzLjBcIl1cblxuXHRcdFx0XHR2ZXJ0aWNlcy5wdXNoKFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMSBdICksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAyIF0gKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDMgXSApXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gbm9ybWFsX3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gW1widm4gMS4wIDIuMCAzLjBcIiwgXCIxLjBcIiwgXCIyLjBcIiwgXCIzLjBcIl1cblxuXHRcdFx0XHRub3JtYWxzLnB1c2goXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggcmVzdWx0WyAxIF0gKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDIgXSApLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMyBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSB1dl9wYXR0ZXJuLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcInZ0IDAuMSAwLjJcIiwgXCIwLjFcIiwgXCIwLjJcIl1cblxuXHRcdFx0XHR1dnMucHVzaChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KCByZXN1bHRbIDEgXSApLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHJlc3VsdFsgMiBdIClcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4xLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcImYgMSAyIDNcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgdW5kZWZpbmVkXVxuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WyAxIF0sIHJlc3VsdFsgMiBdLCByZXN1bHRbIDMgXSwgcmVzdWx0WyA0IF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4yLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcImYgMS8xIDIvMiAzLzNcIiwgXCIgMS8xXCIsIFwiMVwiLCBcIjFcIiwgXCIgMi8yXCIsIFwiMlwiLCBcIjJcIiwgXCIgMy8zXCIsIFwiM1wiLCBcIjNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cblxuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsgMiBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTEgXSxcblx0XHRcdFx0XHRyZXN1bHRbIDMgXSwgcmVzdWx0WyA2IF0sIHJlc3VsdFsgOSBdLCByZXN1bHRbIDEyIF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm4zLmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcImYgMS8xLzEgMi8yLzIgMy8zLzNcIiwgXCIgMS8xLzFcIiwgXCIxXCIsIFwiMVwiLCBcIjFcIiwgXCIgMi8yLzJcIiwgXCIyXCIsIFwiMlwiLCBcIjJcIiwgXCIgMy8zLzNcIiwgXCIzXCIsIFwiM1wiLCBcIjNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuXG5cdFx0XHRcdGFkZEZhY2UoXG5cdFx0XHRcdFx0cmVzdWx0WyAyIF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDEwIF0sIHJlc3VsdFsgMTQgXSxcblx0XHRcdFx0XHRyZXN1bHRbIDMgXSwgcmVzdWx0WyA3IF0sIHJlc3VsdFsgMTEgXSwgcmVzdWx0WyAxNSBdLFxuXHRcdFx0XHRcdHJlc3VsdFsgNCBdLCByZXN1bHRbIDggXSwgcmVzdWx0WyAxMiBdLCByZXN1bHRbIDE2IF1cblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBmYWNlX3BhdHRlcm40LmV4ZWMoIGxpbmUgKSApICE9PSBudWxsICkge1xuXG5cdFx0XHRcdC8vIFtcImYgMS8vMSAyLy8yIDMvLzNcIiwgXCIgMS8vMVwiLCBcIjFcIiwgXCIxXCIsIFwiIDIvLzJcIiwgXCIyXCIsIFwiMlwiLCBcIiAzLy8zXCIsIFwiM1wiLCBcIjNcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cblxuXHRcdFx0XHRhZGRGYWNlKFxuXHRcdFx0XHRcdHJlc3VsdFsgMiBdLCByZXN1bHRbIDUgXSwgcmVzdWx0WyA4IF0sIHJlc3VsdFsgMTEgXSxcblx0XHRcdFx0XHR1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0cmVzdWx0WyAzIF0sIHJlc3VsdFsgNiBdLCByZXN1bHRbIDkgXSwgcmVzdWx0WyAxMiBdXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSBpZiAoICggcmVzdWx0ID0gb2JqZWN0X3BhdHRlcm4uZXhlYyggbGluZSApICkgIT09IG51bGwgKSB7XG5cblx0XHRcdFx0Ly8gbyBvYmplY3RfbmFtZVxuXHRcdFx0XHQvLyBvclxuXHRcdFx0XHQvLyBnIGdyb3VwX25hbWVcblxuXHRcdFx0XHR2YXIgbmFtZSA9IHJlc3VsdFsxXS50cmltKCk7XG5cblx0XHRcdFx0aWYgKCBmb3VuZE9iamVjdHMgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0Zm91bmRPYmplY3RzID0gdHJ1ZTtcblx0XHRcdFx0XHRvYmplY3QubmFtZSA9IG5hbWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdGFkZE9iamVjdChuYW1lKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSBpZiAoIC9edXNlbXRsIC8udGVzdCggbGluZSApICkge1xuXG5cdFx0XHRcdC8vIG1hdGVyaWFsXG5cblx0XHRcdFx0b2JqZWN0Lm1hdGVyaWFsLm5hbWUgPSBsaW5lLnN1YnN0cmluZyggNyApLnRyaW0oKTtcblxuXHRcdFx0fSBlbHNlIGlmICggL15tdGxsaWIgLy50ZXN0KCBsaW5lICkgKSB7XG5cblx0XHRcdFx0Ly8gbXRsIGZpbGVcblxuXHRcdFx0fSBlbHNlIGlmICggKCByZXN1bHQgPSBzbW9vdGhpbmdfcGF0dGVybi5leGVjKCBsaW5lICkgKSAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHQvLyBzbW9vdGggc2hhZGluZ1xuXG5cdFx0XHRcdG9iamVjdC5tYXRlcmlhbC5zbW9vdGggPSByZXN1bHRbIDEgXSA9PT0gXCIxXCIgfHwgcmVzdWx0WyAxIF0gPT09IFwib25cIjtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJUSFJFRS5PQkpMb2FkZXI6IFVuaGFuZGxlZCBsaW5lIFwiICsgbGluZSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR2YXIgY29udGFpbmVyID0gbmV3IFRIUkVFLkdyb3VwKCk7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdG9iamVjdCA9IG9iamVjdHNbIGkgXTtcblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuXHRcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cblx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSwgMyApICk7XG5cblx0XHRcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSwgMyApICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YnVmZmVyZ2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xuXG5cdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzICksIDIgKSApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRlcmlhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm1hdGVyaWFscyAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWxzLmNyZWF0ZSggb2JqZWN0Lm1hdGVyaWFsLm5hbWUgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFtYXRlcmlhbCApIHtcblxuXHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCgpO1xuXHRcdFx0XHRtYXRlcmlhbC5uYW1lID0gb2JqZWN0Lm1hdGVyaWFsLm5hbWU7XG5cblx0XHRcdH1cblxuXHRcdFx0bWF0ZXJpYWwuc2hhZGluZyA9IG9iamVjdC5tYXRlcmlhbC5zbW9vdGggPyBUSFJFRS5TbW9vdGhTaGFkaW5nIDogVEhSRUUuRmxhdFNoYWRpbmc7XG5cblx0XHRcdHZhciBtZXNoID0gbmV3IFRIUkVFLk1lc2goIGJ1ZmZlcmdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXHRcdFx0bWVzaC5uYW1lID0gb2JqZWN0Lm5hbWU7XG5cblx0XHRcdGNvbnRhaW5lci5hZGQoIG1lc2ggKTtcblxuXHRcdH1cblxuXHRcdGNvbnNvbGUudGltZUVuZCggJ09CSkxvYWRlcicgKTtcblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cblx0fVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHBlcmYgPSB3aW5kb3cgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAocGVyZiAmJiBwZXJmLm5vdykge1xuICAgIHJldHVybiBwZXJmLm5vdy5iaW5kKHBlcmYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuICB9XG59KCkpO1xuIiwiLyoqXG4gKiBUd2Vlbi5qcyAtIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGUvdHdlZW4uanMvZ3JhcGhzL2NvbnRyaWJ1dG9ycyBmb3IgdGhlIGZ1bGwgbGlzdCBvZiBjb250cmlidXRvcnMuXG4gKiBUaGFuayB5b3UgYWxsLCB5b3UncmUgYXdlc29tZSFcbiAqL1xuXG4vLyBwZXJmb3JtYW5jZS5ub3cgcG9seWZpbGxcbiggZnVuY3Rpb24gKCByb290ICkge1xuXG5cdGlmICggJ3BlcmZvcm1hbmNlJyBpbiByb290ID09PSBmYWxzZSApIHtcblx0XHRyb290LnBlcmZvcm1hbmNlID0ge307XG5cdH1cblxuXHQvLyBJRSA4XG5cdERhdGUubm93ID0gKCBEYXRlLm5vdyB8fCBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9ICk7XG5cblx0aWYgKCAnbm93JyBpbiByb290LnBlcmZvcm1hbmNlID09PSBmYWxzZSApIHtcblx0XHR2YXIgb2Zmc2V0ID0gcm9vdC5wZXJmb3JtYW5jZS50aW1pbmcgJiYgcm9vdC5wZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID8gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydFxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEYXRlLm5vdygpO1xuXG5cdFx0cm9vdC5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gRGF0ZS5ub3coKSAtIG9mZnNldDtcblx0XHR9O1xuXHR9XG5cbn0gKSggdGhpcyApO1xuXG52YXIgVFdFRU4gPSBUV0VFTiB8fCAoIGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgX3R3ZWVucyA9IFtdO1xuXG5cdHJldHVybiB7XG5cblx0XHRSRVZJU0lPTjogJzE0JyxcblxuXHRcdGdldEFsbDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRyZXR1cm4gX3R3ZWVucztcblxuXHRcdH0sXG5cblx0XHRyZW1vdmVBbGw6IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0X3R3ZWVucyA9IFtdO1xuXG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24gKCB0d2VlbiApIHtcblxuXHRcdFx0X3R3ZWVucy5wdXNoKCB0d2VlbiApO1xuXG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24gKCB0d2VlbiApIHtcblxuXHRcdFx0dmFyIGkgPSBfdHdlZW5zLmluZGV4T2YoIHR3ZWVuICk7XG5cblx0XHRcdGlmICggaSAhPT0gLTEgKSB7XG5cblx0XHRcdFx0X3R3ZWVucy5zcGxpY2UoIGksIDEgKTtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCB0aW1lICkge1xuXG5cdFx0XHRpZiAoIF90d2VlbnMubGVuZ3RoID09PSAwICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR2YXIgaSA9IDA7XG5cblx0XHRcdHRpbWUgPSB0aW1lICE9PSB1bmRlZmluZWQgPyB0aW1lIDogd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0XHR3aGlsZSAoIGkgPCBfdHdlZW5zLmxlbmd0aCApIHtcblxuXHRcdFx0XHRpZiAoIF90d2VlbnNbIGkgXS51cGRhdGUoIHRpbWUgKSApIHtcblxuXHRcdFx0XHRcdGkrKztcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0X3R3ZWVucy5zcGxpY2UoIGksIDEgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHR9XG5cdH07XG5cbn0gKSgpO1xuXG5UV0VFTi5Ud2VlbiA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG5cdHZhciBfb2JqZWN0ID0gb2JqZWN0O1xuXHR2YXIgX3ZhbHVlc1N0YXJ0ID0ge307XG5cdHZhciBfdmFsdWVzRW5kID0ge307XG5cdHZhciBfdmFsdWVzU3RhcnRSZXBlYXQgPSB7fTtcblx0dmFyIF9kdXJhdGlvbiA9IDEwMDA7XG5cdHZhciBfcmVwZWF0ID0gMDtcblx0dmFyIF95b3lvID0gZmFsc2U7XG5cdHZhciBfaXNQbGF5aW5nID0gZmFsc2U7XG5cdHZhciBfcmV2ZXJzZWQgPSBmYWxzZTtcblx0dmFyIF9kZWxheVRpbWUgPSAwO1xuXHR2YXIgX3N0YXJ0VGltZSA9IG51bGw7XG5cdHZhciBfZWFzaW5nRnVuY3Rpb24gPSBUV0VFTi5FYXNpbmcuTGluZWFyLk5vbmU7XG5cdHZhciBfaW50ZXJwb2xhdGlvbkZ1bmN0aW9uID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5MaW5lYXI7XG5cdHZhciBfY2hhaW5lZFR3ZWVucyA9IFtdO1xuXHR2YXIgX29uU3RhcnRDYWxsYmFjayA9IG51bGw7XG5cdHZhciBfb25TdGFydENhbGxiYWNrRmlyZWQgPSBmYWxzZTtcblx0dmFyIF9vblVwZGF0ZUNhbGxiYWNrID0gbnVsbDtcblx0dmFyIF9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBudWxsO1xuXHR2YXIgX29uU3RvcENhbGxiYWNrID0gbnVsbDtcblxuXHQvLyBTZXQgYWxsIHN0YXJ0aW5nIHZhbHVlcyBwcmVzZW50IG9uIHRoZSB0YXJnZXQgb2JqZWN0XG5cdGZvciAoIHZhciBmaWVsZCBpbiBvYmplY3QgKSB7XG5cblx0XHRfdmFsdWVzU3RhcnRbIGZpZWxkIF0gPSBwYXJzZUZsb2F0KG9iamVjdFtmaWVsZF0sIDEwKTtcblxuXHR9XG5cblx0dGhpcy50byA9IGZ1bmN0aW9uICggcHJvcGVydGllcywgZHVyYXRpb24gKSB7XG5cblx0XHRpZiAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdF9kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG5cdFx0fVxuXG5cdFx0X3ZhbHVlc0VuZCA9IHByb3BlcnRpZXM7XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHRUV0VFTi5hZGQoIHRoaXMgKTtcblxuXHRcdF9pc1BsYXlpbmcgPSB0cnVlO1xuXG5cdFx0X29uU3RhcnRDYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cblx0XHRfc3RhcnRUaW1lID0gdGltZSAhPT0gdW5kZWZpbmVkID8gdGltZSA6IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRfc3RhcnRUaW1lICs9IF9kZWxheVRpbWU7XG5cblx0XHRmb3IgKCB2YXIgcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgYW4gQXJyYXkgd2FzIHByb3ZpZGVkIGFzIHByb3BlcnR5IHZhbHVlXG5cdFx0XHRpZiAoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0XHRpZiAoIF92YWx1ZXNFbmRbIHByb3BlcnR5IF0ubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgdGhlIEFycmF5IHdpdGggdGhlIHN0YXJ0IHZhbHVlIGF0IHRoZSBmcm9udFxuXHRcdFx0XHRfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdID0gWyBfb2JqZWN0WyBwcm9wZXJ0eSBdIF0uY29uY2F0KCBfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdICk7XG5cblx0XHRcdH1cblxuXHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdID0gX29iamVjdFsgcHJvcGVydHkgXTtcblxuXHRcdFx0aWYoICggX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIGluc3RhbmNlb2YgQXJyYXkgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdF92YWx1ZXNTdGFydFsgcHJvcGVydHkgXSAqPSAxLjA7IC8vIEVuc3VyZXMgd2UncmUgdXNpbmcgbnVtYmVycywgbm90IHN0cmluZ3Ncblx0XHRcdH1cblxuXHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIHx8IDA7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdGlmICggIV9pc1BsYXlpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRUV0VFTi5yZW1vdmUoIHRoaXMgKTtcblx0XHRfaXNQbGF5aW5nID0gZmFsc2U7XG5cblx0XHRpZiAoIF9vblN0b3BDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0X29uU3RvcENhbGxiYWNrLmNhbGwoIF9vYmplY3QgKTtcblxuXHRcdH1cblxuXHRcdHRoaXMuc3RvcENoYWluZWRUd2VlbnMoKTtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMuc3RvcENoYWluZWRUd2VlbnMgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRmb3IgKCB2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSBfY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKysgKSB7XG5cblx0XHRcdF9jaGFpbmVkVHdlZW5zWyBpIF0uc3RvcCgpO1xuXG5cdFx0fVxuXG5cdH07XG5cblx0dGhpcy5kZWxheSA9IGZ1bmN0aW9uICggYW1vdW50ICkge1xuXG5cdFx0X2RlbGF5VGltZSA9IGFtb3VudDtcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMucmVwZWF0ID0gZnVuY3Rpb24gKCB0aW1lcyApIHtcblxuXHRcdF9yZXBlYXQgPSB0aW1lcztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMueW95byA9IGZ1bmN0aW9uKCB5b3lvICkge1xuXG5cdFx0X3lveW8gPSB5b3lvO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblxuXHR0aGlzLmVhc2luZyA9IGZ1bmN0aW9uICggZWFzaW5nICkge1xuXG5cdFx0X2Vhc2luZ0Z1bmN0aW9uID0gZWFzaW5nO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5pbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24gKCBpbnRlcnBvbGF0aW9uICkge1xuXG5cdFx0X2ludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb247XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLmNoYWluID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0X2NoYWluZWRUd2VlbnMgPSBhcmd1bWVudHM7XG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fTtcblxuXHR0aGlzLm9uU3RhcnQgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG5cdFx0X29uU3RhcnRDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vblVwZGF0ZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cblx0XHRfb25VcGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy5vbkNvbXBsZXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRyZXR1cm4gdGhpcztcblxuXHR9O1xuXG5cdHRoaXMub25TdG9wID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuXHRcdF9vblN0b3BDYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiB0aGlzO1xuXG5cdH07XG5cblx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHRpbWUgKSB7XG5cblx0XHR2YXIgcHJvcGVydHk7XG5cblx0XHRpZiAoIHRpbWUgPCBfc3RhcnRUaW1lICkge1xuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH1cblxuXHRcdGlmICggX29uU3RhcnRDYWxsYmFja0ZpcmVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0aWYgKCBfb25TdGFydENhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRcdF9vblN0YXJ0Q2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0XHR9XG5cblx0XHRcdF9vblN0YXJ0Q2FsbGJhY2tGaXJlZCA9IHRydWU7XG5cblx0XHR9XG5cblx0XHR2YXIgZWxhcHNlZCA9ICggdGltZSAtIF9zdGFydFRpbWUgKSAvIF9kdXJhdGlvbjtcblx0XHRlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuXHRcdHZhciB2YWx1ZSA9IF9lYXNpbmdGdW5jdGlvbiggZWxhcHNlZCApO1xuXG5cdFx0Zm9yICggcHJvcGVydHkgaW4gX3ZhbHVlc0VuZCApIHtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gX3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdIHx8IDA7XG5cdFx0XHR2YXIgZW5kID0gX3ZhbHVlc0VuZFsgcHJvcGVydHkgXTtcblxuXHRcdFx0aWYgKCBlbmQgaW5zdGFuY2VvZiBBcnJheSApIHtcblxuXHRcdFx0XHRfb2JqZWN0WyBwcm9wZXJ0eSBdID0gX2ludGVycG9sYXRpb25GdW5jdGlvbiggZW5kLCB2YWx1ZSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnNlcyByZWxhdGl2ZSBlbmQgdmFsdWVzIHdpdGggc3RhcnQgYXMgYmFzZSAoZS5nLjogKzEwLCAtMylcblx0XHRcdFx0aWYgKCB0eXBlb2YoZW5kKSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRlbmQgPSBzdGFydCArIHBhcnNlRmxvYXQoZW5kLCAxMCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwcm90ZWN0IGFnYWluc3Qgbm9uIG51bWVyaWMgcHJvcGVydGllcy5cblx0XHRcdFx0aWYgKCB0eXBlb2YoZW5kKSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRfb2JqZWN0WyBwcm9wZXJ0eSBdID0gc3RhcnQgKyAoIGVuZCAtIHN0YXJ0ICkgKiB2YWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRpZiAoIF9vblVwZGF0ZUNhbGxiYWNrICE9PSBudWxsICkge1xuXG5cdFx0XHRfb25VcGRhdGVDYWxsYmFjay5jYWxsKCBfb2JqZWN0LCB2YWx1ZSApO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBlbGFwc2VkID09IDEgKSB7XG5cblx0XHRcdGlmICggX3JlcGVhdCA+IDAgKSB7XG5cblx0XHRcdFx0aWYoIGlzRmluaXRlKCBfcmVwZWF0ICkgKSB7XG5cdFx0XHRcdFx0X3JlcGVhdC0tO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gcmVhc3NpZ24gc3RhcnRpbmcgdmFsdWVzLCByZXN0YXJ0IGJ5IG1ha2luZyBzdGFydFRpbWUgPSBub3dcblx0XHRcdFx0Zm9yKCBwcm9wZXJ0eSBpbiBfdmFsdWVzU3RhcnRSZXBlYXQgKSB7XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiggX3ZhbHVlc0VuZFsgcHJvcGVydHkgXSApID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdICsgcGFyc2VGbG9hdChfdmFsdWVzRW5kWyBwcm9wZXJ0eSBdLCAxMCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKF95b3lvKSB7XG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdO1xuXHRcdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc0VuZFsgcHJvcGVydHkgXTtcblx0XHRcdFx0XHRcdF92YWx1ZXNFbmRbIHByb3BlcnR5IF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0X3ZhbHVlc1N0YXJ0WyBwcm9wZXJ0eSBdID0gX3ZhbHVlc1N0YXJ0UmVwZWF0WyBwcm9wZXJ0eSBdO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoX3lveW8pIHtcblx0XHRcdFx0XHRfcmV2ZXJzZWQgPSAhX3JldmVyc2VkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X3N0YXJ0VGltZSA9IHRpbWUgKyBfZGVsYXlUaW1lO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGlmICggX29uQ29tcGxldGVDYWxsYmFjayAhPT0gbnVsbCApIHtcblxuXHRcdFx0XHRcdF9vbkNvbXBsZXRlQ2FsbGJhY2suY2FsbCggX29iamVjdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG51bUNoYWluZWRUd2VlbnMgPSBfY2hhaW5lZFR3ZWVucy5sZW5ndGg7IGkgPCBudW1DaGFpbmVkVHdlZW5zOyBpKysgKSB7XG5cblx0XHRcdFx0XHRfY2hhaW5lZFR3ZWVuc1sgaSBdLnN0YXJ0KCB0aW1lICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxufTtcblxuXG5UV0VFTi5FYXNpbmcgPSB7XG5cblx0TGluZWFyOiB7XG5cblx0XHROb25lOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVhZHJhdGljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogKCAyIC0gayApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGs7XG5cdFx0XHRyZXR1cm4gLSAwLjUgKiAoIC0tayAqICggayAtIDIgKSAtIDEgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEN1YmljOiB7XG5cblx0XHRJbjogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayAqIGsgKiBrO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gLS1rICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiBrICsgMiApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0UXVhcnRpYzoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIGsgKiBrICogayAqIGs7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gKCAtLWsgKiBrICogayAqIGsgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxKSByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcblx0XHRcdHJldHVybiAtIDAuNSAqICggKCBrIC09IDIgKSAqIGsgKiBrICogayAtIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFF1aW50aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrICogayAqIGsgKiBrICogaztcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqIGsgKiBrICogayArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdFNpbnVzb2lkYWw6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAxIC0gTWF0aC5jb3MoIGsgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zaW4oIGsgKiBNYXRoLlBJIC8gMiApO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiAwLjUgKiAoIDEgLSBNYXRoLmNvcyggTWF0aC5QSSAqIGsgKSApO1xuXG5cdFx0fVxuXG5cdH0sXG5cblx0RXhwb25lbnRpYWw6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHJldHVybiBrID09PSAwID8gMCA6IE1hdGgucG93KCAxMDI0LCBrIC0gMSApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coIDIsIC0gMTAgKiBrICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gMC41ICogTWF0aC5wb3coIDEwMjQsIGsgLSAxICk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAtIE1hdGgucG93KCAyLCAtIDEwICogKCBrIC0gMSApICkgKyAyICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRDaXJjdWxhcjoge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBNYXRoLnNxcnQoIDEgLSBrICogayApO1xuXG5cdFx0fSxcblxuXHRcdE91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCAxIC0gKCAtLWsgKiBrICkgKTtcblxuXHRcdH0sXG5cblx0XHRJbk91dDogZnVuY3Rpb24gKCBrICkge1xuXG5cdFx0XHRpZiAoICggayAqPSAyICkgPCAxKSByZXR1cm4gLSAwLjUgKiAoIE1hdGguc3FydCggMSAtIGsgKiBrKSAtIDEpO1xuXHRcdFx0cmV0dXJuIDAuNSAqICggTWF0aC5zcXJ0KCAxIC0gKCBrIC09IDIpICogaykgKyAxKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEVsYXN0aWM6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cblx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRyZXR1cm4gLSAoIGEgKiBNYXRoLnBvdyggMiwgMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICk7XG5cblx0XHR9LFxuXG5cdFx0T3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzLCBhID0gMC4xLCBwID0gMC40O1xuXHRcdFx0aWYgKCBrID09PSAwICkgcmV0dXJuIDA7XG5cdFx0XHRpZiAoIGsgPT09IDEgKSByZXR1cm4gMTtcblx0XHRcdGlmICggIWEgfHwgYSA8IDEgKSB7IGEgPSAxOyBzID0gcCAvIDQ7IH1cblx0XHRcdGVsc2UgcyA9IHAgKiBNYXRoLmFzaW4oIDEgLyBhICkgLyAoIDIgKiBNYXRoLlBJICk7XG5cdFx0XHRyZXR1cm4gKCBhICogTWF0aC5wb3coIDIsIC0gMTAgKiBrKSAqIE1hdGguc2luKCAoIGsgLSBzICkgKiAoIDIgKiBNYXRoLlBJICkgLyBwICkgKyAxICk7XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMsIGEgPSAwLjEsIHAgPSAwLjQ7XG5cdFx0XHRpZiAoIGsgPT09IDAgKSByZXR1cm4gMDtcblx0XHRcdGlmICggayA9PT0gMSApIHJldHVybiAxO1xuXHRcdFx0aWYgKCAhYSB8fCBhIDwgMSApIHsgYSA9IDE7IHMgPSBwIC8gNDsgfVxuXHRcdFx0ZWxzZSBzID0gcCAqIE1hdGguYXNpbiggMSAvIGEgKSAvICggMiAqIE1hdGguUEkgKTtcblx0XHRcdGlmICggKCBrICo9IDIgKSA8IDEgKSByZXR1cm4gLSAwLjUgKiAoIGEgKiBNYXRoLnBvdyggMiwgMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICk7XG5cdFx0XHRyZXR1cm4gYSAqIE1hdGgucG93KCAyLCAtMTAgKiAoIGsgLT0gMSApICkgKiBNYXRoLnNpbiggKCBrIC0gcyApICogKCAyICogTWF0aC5QSSApIC8gcCApICogMC41ICsgMTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJhY2s6IHtcblxuXHRcdEluOiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1ODtcblx0XHRcdHJldHVybiBrICogayAqICggKCBzICsgMSApICogayAtIHMgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0dmFyIHMgPSAxLjcwMTU4O1xuXHRcdFx0cmV0dXJuIC0tayAqIGsgKiAoICggcyArIDEgKSAqIGsgKyBzICkgKyAxO1xuXG5cdFx0fSxcblxuXHRcdEluT3V0OiBmdW5jdGlvbiAoIGsgKSB7XG5cblx0XHRcdHZhciBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHRcdFx0aWYgKCAoIGsgKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiAoIGsgKiBrICogKCAoIHMgKyAxICkgKiBrIC0gcyApICk7XG5cdFx0XHRyZXR1cm4gMC41ICogKCAoIGsgLT0gMiApICogayAqICggKCBzICsgMSApICogayArIHMgKSArIDIgKTtcblxuXHRcdH1cblxuXHR9LFxuXG5cdEJvdW5jZToge1xuXG5cdFx0SW46IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0cmV0dXJuIDEgLSBUV0VFTi5FYXNpbmcuQm91bmNlLk91dCggMSAtIGsgKTtcblxuXHRcdH0sXG5cblx0XHRPdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrIDwgKCAxIC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiBrICogaztcblxuXHRcdFx0fSBlbHNlIGlmICggayA8ICggMiAvIDIuNzUgKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gNy41NjI1ICogKCBrIC09ICggMS41IC8gMi43NSApICkgKiBrICsgMC43NTtcblxuXHRcdFx0fSBlbHNlIGlmICggayA8ICggMi41IC8gMi43NSApICkge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjI1IC8gMi43NSApICkgKiBrICsgMC45Mzc1O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiA3LjU2MjUgKiAoIGsgLT0gKCAyLjYyNSAvIDIuNzUgKSApICogayArIDAuOTg0Mzc1O1xuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cdFx0SW5PdXQ6IGZ1bmN0aW9uICggayApIHtcblxuXHRcdFx0aWYgKCBrIDwgMC41ICkgcmV0dXJuIFRXRUVOLkVhc2luZy5Cb3VuY2UuSW4oIGsgKiAyICkgKiAwLjU7XG5cdFx0XHRyZXR1cm4gVFdFRU4uRWFzaW5nLkJvdW5jZS5PdXQoIGsgKiAyIC0gMSApICogMC41ICsgMC41O1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuVFdFRU4uSW50ZXJwb2xhdGlvbiA9IHtcblxuXHRMaW5lYXI6IGZ1bmN0aW9uICggdiwgayApIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxLCBmID0gbSAqIGssIGkgPSBNYXRoLmZsb29yKCBmICksIGZuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5MaW5lYXI7XG5cblx0XHRpZiAoIGsgPCAwICkgcmV0dXJuIGZuKCB2WyAwIF0sIHZbIDEgXSwgZiApO1xuXHRcdGlmICggayA+IDEgKSByZXR1cm4gZm4oIHZbIG0gXSwgdlsgbSAtIDEgXSwgbSAtIGYgKTtcblxuXHRcdHJldHVybiBmbiggdlsgaSBdLCB2WyBpICsgMSA+IG0gPyBtIDogaSArIDEgXSwgZiAtIGkgKTtcblxuXHR9LFxuXG5cdEJlemllcjogZnVuY3Rpb24gKCB2LCBrICkge1xuXG5cdFx0dmFyIGIgPSAwLCBuID0gdi5sZW5ndGggLSAxLCBwdyA9IE1hdGgucG93LCBibiA9IFRXRUVOLkludGVycG9sYXRpb24uVXRpbHMuQmVybnN0ZWluLCBpO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPD0gbjsgaSsrICkge1xuXHRcdFx0YiArPSBwdyggMSAtIGssIG4gLSBpICkgKiBwdyggaywgaSApICogdlsgaSBdICogYm4oIG4sIGkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYjtcblxuXHR9LFxuXG5cdENhdG11bGxSb206IGZ1bmN0aW9uICggdiwgayApIHtcblxuXHRcdHZhciBtID0gdi5sZW5ndGggLSAxLCBmID0gbSAqIGssIGkgPSBNYXRoLmZsb29yKCBmICksIGZuID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5DYXRtdWxsUm9tO1xuXG5cdFx0aWYgKCB2WyAwIF0gPT09IHZbIG0gXSApIHtcblxuXHRcdFx0aWYgKCBrIDwgMCApIGkgPSBNYXRoLmZsb29yKCBmID0gbSAqICggMSArIGsgKSApO1xuXG5cdFx0XHRyZXR1cm4gZm4oIHZbICggaSAtIDEgKyBtICkgJSBtIF0sIHZbIGkgXSwgdlsgKCBpICsgMSApICUgbSBdLCB2WyAoIGkgKyAyICkgJSBtIF0sIGYgLSBpICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpZiAoIGsgPCAwICkgcmV0dXJuIHZbIDAgXSAtICggZm4oIHZbIDAgXSwgdlsgMCBdLCB2WyAxIF0sIHZbIDEgXSwgLWYgKSAtIHZbIDAgXSApO1xuXHRcdFx0aWYgKCBrID4gMSApIHJldHVybiB2WyBtIF0gLSAoIGZuKCB2WyBtIF0sIHZbIG0gXSwgdlsgbSAtIDEgXSwgdlsgbSAtIDEgXSwgZiAtIG0gKSAtIHZbIG0gXSApO1xuXG5cdFx0XHRyZXR1cm4gZm4oIHZbIGkgPyBpIC0gMSA6IDAgXSwgdlsgaSBdLCB2WyBtIDwgaSArIDEgPyBtIDogaSArIDEgXSwgdlsgbSA8IGkgKyAyID8gbSA6IGkgKyAyIF0sIGYgLSBpICk7XG5cblx0XHR9XG5cblx0fSxcblxuXHRVdGlsczoge1xuXG5cdFx0TGluZWFyOiBmdW5jdGlvbiAoIHAwLCBwMSwgdCApIHtcblxuXHRcdFx0cmV0dXJuICggcDEgLSBwMCApICogdCArIHAwO1xuXG5cdFx0fSxcblxuXHRcdEJlcm5zdGVpbjogZnVuY3Rpb24gKCBuICwgaSApIHtcblxuXHRcdFx0dmFyIGZjID0gVFdFRU4uSW50ZXJwb2xhdGlvbi5VdGlscy5GYWN0b3JpYWw7XG5cdFx0XHRyZXR1cm4gZmMoIG4gKSAvIGZjKCBpICkgLyBmYyggbiAtIGkgKTtcblxuXHRcdH0sXG5cblx0XHRGYWN0b3JpYWw6ICggZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYSA9IFsgMSBdO1xuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCBuICkge1xuXG5cdFx0XHRcdHZhciBzID0gMSwgaTtcblx0XHRcdFx0aWYgKCBhWyBuIF0gKSByZXR1cm4gYVsgbiBdO1xuXHRcdFx0XHRmb3IgKCBpID0gbjsgaSA+IDE7IGktLSApIHMgKj0gaTtcblx0XHRcdFx0cmV0dXJuIGFbIG4gXSA9IHM7XG5cblx0XHRcdH07XG5cblx0XHR9ICkoKSxcblxuXHRcdENhdG11bGxSb206IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XG5cblx0XHRcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LCB2MSA9ICggcDMgLSBwMSApICogMC41LCB0MiA9IHQgKiB0LCB0MyA9IHQgKiB0Mjtcblx0XHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxuLy8gVU1EIChVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24pXG4oIGZ1bmN0aW9uICggcm9vdCApIHtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBUV0VFTjtcblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVFdFRU47XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIEdsb2JhbCB2YXJpYWJsZVxuXHRcdHJvb3QuVFdFRU4gPSBUV0VFTjtcblxuXHR9XG5cbn0gKSggdGhpcyApO1xuIiwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBWUiBkZXZpY2VzLlxyXG4gKi9cclxuZnVuY3Rpb24gVlJEZXZpY2UoKSB7XHJcbiAgdGhpcy5oYXJkd2FyZVVuaXRJZCA9ICd3ZWJ2ci1wb2x5ZmlsbCBoYXJkd2FyZVVuaXRJZCc7XHJcbiAgdGhpcy5kZXZpY2VJZCA9ICd3ZWJ2ci1wb2x5ZmlsbCBkZXZpY2VJZCc7XHJcbiAgdGhpcy5kZXZpY2VOYW1lID0gJ3dlYnZyLXBvbHlmaWxsIGRldmljZU5hbWUnO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBWUiBITUQgZGV2aWNlcy5cclxuICovXHJcbmZ1bmN0aW9uIEhNRFZSRGV2aWNlKCkge1xyXG59XHJcbkhNRFZSRGV2aWNlLnByb3RvdHlwZSA9IG5ldyBWUkRldmljZSgpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBiYXNlIGNsYXNzIGZvciBhbGwgVlIgcG9zaXRpb24gc2Vuc29yIGRldmljZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBQb3NpdGlvblNlbnNvclZSRGV2aWNlKCkge1xyXG59XHJcblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlID0gbmV3IFZSRGV2aWNlKCk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cy5WUkRldmljZSA9IFZSRGV2aWNlO1xyXG5tb2R1bGUuZXhwb3J0cy5ITURWUkRldmljZSA9IEhNRFZSRGV2aWNlO1xyXG5tb2R1bGUuZXhwb3J0cy5Qb3NpdGlvblNlbnNvclZSRGV2aWNlID0gUG9zaXRpb25TZW5zb3JWUkRldmljZTtcclxuXHJcbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBITURWUkRldmljZSA9IF9kZXJlcV8oJy4vYmFzZS5qcycpLkhNRFZSRGV2aWNlO1xyXG5cclxuLy8gQ29uc3RhbnRzIGZyb20gdnJ0b29sa2l0OiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlc2FtcGxlcy9jYXJkYm9hcmQtamF2YS5cclxudmFyIElOVEVSUFVQSUxMQVJZX0RJU1RBTkNFID0gMC4wNjtcclxudmFyIERFRkFVTFRfTUFYX0ZPVl9MRUZUX1JJR0hUID0gNDA7XHJcbnZhciBERUZBVUxUX01BWF9GT1ZfQk9UVE9NID0gNDA7XHJcbnZhciBERUZBVUxUX01BWF9GT1ZfVE9QID0gNDA7XHJcblxyXG4vKipcclxuICogVGhlIEhNRCBpdHNlbGYsIHByb3ZpZGluZyByZW5kZXJpbmcgcGFyYW1ldGVycy5cclxuICovXHJcbmZ1bmN0aW9uIENhcmRib2FyZEhNRFZSRGV2aWNlKCkge1xyXG4gIC8vIEZyb20gY29tL2dvb2dsZS92cnRvb2xraXQvY2FyZGJvYXJkL0ZpZWxkT2ZWaWV3LmphdmEuXHJcbiAgdGhpcy5mb3YgPSB7XHJcbiAgICB1cERlZ3JlZXM6IERFRkFVTFRfTUFYX0ZPVl9UT1AsXHJcbiAgICBkb3duRGVncmVlczogREVGQVVMVF9NQVhfRk9WX0JPVFRPTSxcclxuICAgIGxlZnREZWdyZWVzOiBERUZBVUxUX01BWF9GT1ZfTEVGVF9SSUdIVCxcclxuICAgIHJpZ2h0RGVncmVlczogREVGQVVMVF9NQVhfRk9WX0xFRlRfUklHSFRcclxuICB9O1xyXG4gIC8vIFNldCBkaXNwbGF5IGNvbnN0YW50cy5cclxuICB0aGlzLmV5ZVRyYW5zbGF0aW9uTGVmdCA9IHtcclxuICAgIHg6IElOVEVSUFVQSUxMQVJZX0RJU1RBTkNFICogLTAuNSxcclxuICAgIHk6IDAsXHJcbiAgICB6OiAwXHJcbiAgfTtcclxuICB0aGlzLmV5ZVRyYW5zbGF0aW9uUmlnaHQgPSB7XHJcbiAgICB4OiBJTlRFUlBVUElMTEFSWV9ESVNUQU5DRSAqIDAuNSxcclxuICAgIHk6IDAsXHJcbiAgICB6OiAwXHJcbiAgfTtcclxufVxyXG5DYXJkYm9hcmRITURWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgSE1EVlJEZXZpY2UoKTtcclxuXHJcbkNhcmRib2FyZEhNRFZSRGV2aWNlLnByb3RvdHlwZS5nZXRFeWVQYXJhbWV0ZXJzID0gZnVuY3Rpb24od2hpY2hFeWUpIHtcclxuICB2YXIgZXllVHJhbnNsYXRpb247XHJcbiAgaWYgKHdoaWNoRXllID09ICdsZWZ0Jykge1xyXG4gICAgZXllVHJhbnNsYXRpb24gPSB0aGlzLmV5ZVRyYW5zbGF0aW9uTGVmdDtcclxuICB9IGVsc2UgaWYgKHdoaWNoRXllID09ICdyaWdodCcpIHtcclxuICAgIGV5ZVRyYW5zbGF0aW9uID0gdGhpcy5leWVUcmFuc2xhdGlvblJpZ2h0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGV5ZSBwcm92aWRlZDogJXMnLCB3aGljaEV5ZSk7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgcmV0dXJuIHtcclxuICAgIHJlY29tbWVuZGVkRmllbGRPZlZpZXc6IHRoaXMuZm92LFxyXG4gICAgZXllVHJhbnNsYXRpb246IGV5ZVRyYW5zbGF0aW9uXHJcbiAgfTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2FyZGJvYXJkSE1EVlJEZXZpY2U7XHJcblxyXG59LHtcIi4vYmFzZS5qc1wiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRPRE86IEZpeCB1cCBhbGwgXCJuZXcgVEhSRUVcIiBpbnN0YW50aWF0aW9ucyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxyXG4gKi9cclxudmFyIFNlbnNvclNhbXBsZSA9IF9kZXJlcV8oJy4vc2Vuc29yLXNhbXBsZS5qcycpO1xyXG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuL3RocmVlLW1hdGguanMnKTtcclxudmFyIFV0aWwgPSBfZGVyZXFfKCcuL3V0aWwuanMnKTtcclxuXHJcbnZhciBERUJVRyA9IGZhbHNlO1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIGEgc2ltcGxlIGNvbXBsZW1lbnRhcnkgZmlsdGVyLCB3aGljaCBmdXNlcyBneXJvc2NvcGUgYW5kXHJcbiAqIGFjY2VsZXJvbWV0ZXIgZGF0YSBmcm9tIHRoZSAnZGV2aWNlbW90aW9uJyBldmVudC5cclxuICpcclxuICogQWNjZWxlcm9tZXRlciBkYXRhIGlzIHZlcnkgbm9pc3ksIGJ1dCBzdGFibGUgb3ZlciB0aGUgbG9uZyB0ZXJtLlxyXG4gKiBHeXJvc2NvcGUgZGF0YSBpcyBzbW9vdGgsIGJ1dCB0ZW5kcyB0byBkcmlmdCBvdmVyIHRoZSBsb25nIHRlcm0uXHJcbiAqXHJcbiAqIFRoaXMgZnVzaW9uIGlzIHJlbGF0aXZlbHkgc2ltcGxlOlxyXG4gKiAxLiBHZXQgb3JpZW50YXRpb24gZXN0aW1hdGVzIGZyb20gYWNjZWxlcm9tZXRlciBieSBhcHBseWluZyBhIGxvdy1wYXNzIGZpbHRlclxyXG4gKiAgICBvbiB0aGF0IGRhdGEuXHJcbiAqIDIuIEdldCBvcmllbnRhdGlvbiBlc3RpbWF0ZXMgZnJvbSBneXJvc2NvcGUgYnkgaW50ZWdyYXRpbmcgb3ZlciB0aW1lLlxyXG4gKiAzLiBDb21iaW5lIHRoZSB0d28gZXN0aW1hdGVzLCB3ZWlnaGluZyAoMSkgaW4gdGhlIGxvbmcgdGVybSwgYnV0ICgyKSBmb3IgdGhlXHJcbiAqICAgIHNob3J0IHRlcm0uXHJcbiAqL1xyXG5mdW5jdGlvbiBDb21wbGVtZW50YXJ5RmlsdGVyKGtGaWx0ZXIpIHtcclxuICB0aGlzLmtGaWx0ZXIgPSBrRmlsdGVyO1xyXG5cclxuICAvLyBSYXcgc2Vuc29yIG1lYXN1cmVtZW50cy5cclxuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xyXG4gIHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudCA9IG5ldyBTZW5zb3JTYW1wbGUoKTtcclxuICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xyXG5cclxuICAvLyBDdXJyZW50IGZpbHRlciBvcmllbnRhdGlvblxyXG4gIHRoaXMuZmlsdGVyUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAvLyBPcmllbnRhdGlvbiBiYXNlZCBvbiB0aGUgYWNjZWxlcm9tZXRlci5cclxuICB0aGlzLmFjY2VsUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgLy8gV2hldGhlciBvciBub3QgdGhlIG9yaWVudGF0aW9uIGhhcyBiZWVuIGluaXRpYWxpemVkLlxyXG4gIHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgLy8gUnVubmluZyBlc3RpbWF0ZSBvZiBncmF2aXR5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uLlxyXG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgLy8gTWVhc3VyZWQgZ3Jhdml0eSBiYXNlZCBvbiBhY2NlbGVyb21ldGVyLlxyXG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgLy8gRGVidWcgb25seSBxdWF0ZXJuaW9uIG9mIGd5cm8tYmFzZWQgb3JpZW50YXRpb24uXHJcbiAgdGhpcy5neXJvSW50ZWdyYWxRID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxufVxyXG5cclxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkQWNjZWxNZWFzdXJlbWVudCA9IGZ1bmN0aW9uKHZlY3RvciwgdGltZXN0YW1wUykge1xyXG4gIHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XHJcbn07XHJcblxyXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5hZGRHeXJvTWVhc3VyZW1lbnQgPSBmdW5jdGlvbih2ZWN0b3IsIHRpbWVzdGFtcFMpIHtcclxuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XHJcblxyXG4gIHZhciBkZWx0YVQgPSB0aW1lc3RhbXBTIC0gdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xyXG4gIGlmIChVdGlsLmlzVGltZXN0YW1wRGVsdGFWYWxpZChkZWx0YVQpKSB7XHJcbiAgICB0aGlzLnJ1bl8oKTtcclxuICB9XHJcbiAgXHJcbiAgdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC5jb3B5KHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudCk7XHJcbn07XHJcblxyXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5ydW5fID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gIGlmICghdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQpIHtcclxuICAgIHRoaXMuYWNjZWxRID0gdGhpcy5hY2NlbFRvUXVhdGVybmlvbl8odGhpcy5jdXJyZW50QWNjZWxNZWFzdXJlbWVudC5zYW1wbGUpO1xyXG4gICAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmFjY2VsUSk7XHJcbiAgICB0aGlzLmlzT3JpZW50YXRpb25Jbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIgZGVsdGFUID0gdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFMgLVxyXG4gICAgICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFM7XHJcblxyXG4gIC8vIENvbnZlcnQgZ3lybyByb3RhdGlvbiB2ZWN0b3IgdG8gYSBxdWF0ZXJuaW9uIGRlbHRhLlxyXG4gIHZhciBneXJvRGVsdGFRID0gdGhpcy5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfKHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zYW1wbGUsIGRlbHRhVCk7XHJcbiAgdGhpcy5neXJvSW50ZWdyYWxRLm11bHRpcGx5KGd5cm9EZWx0YVEpO1xyXG5cclxuICAvLyBmaWx0ZXJfMSA9IEsgKiAoZmlsdGVyXzAgKyBneXJvICogZFQpICsgKDEgLSBLKSAqIGFjY2VsLlxyXG4gIHRoaXMuZmlsdGVyUS5jb3B5KHRoaXMucHJldmlvdXNGaWx0ZXJRKTtcclxuICB0aGlzLmZpbHRlclEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XHJcblxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY3VycmVudCBlc3RpbWF0ZWQgZ3Jhdml0eSBhbmQgdGhlIHJlYWxcclxuICAvLyBncmF2aXR5IHZlY3RvciBmcm9tIGFjY2VsZXJvbWV0ZXIuXHJcbiAgdmFyIGludkZpbHRlclEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4gIGludkZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xyXG4gIGludkZpbHRlclEuaW52ZXJzZSgpO1xyXG5cclxuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuc2V0KDAsIDAsIC0xKTtcclxuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuYXBwbHlRdWF0ZXJuaW9uKGludkZpbHRlclEpO1xyXG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eS5ub3JtYWxpemUoKTtcclxuXHJcbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkuY29weSh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XHJcbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkubm9ybWFsaXplKCk7XHJcblxyXG4gIC8vIENvbXBhcmUgZXN0aW1hdGVkIGdyYXZpdHkgd2l0aCBtZWFzdXJlZCBncmF2aXR5LCBnZXQgdGhlIGRlbHRhIHF1YXRlcm5pb25cclxuICAvLyBiZXR3ZWVuIHRoZSB0d28uXHJcbiAgdmFyIGRlbHRhUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgZGVsdGFRLnNldEZyb21Vbml0VmVjdG9ycyh0aGlzLmVzdGltYXRlZEdyYXZpdHksIHRoaXMubWVhc3VyZWRHcmF2aXR5KTtcclxuICBkZWx0YVEuaW52ZXJzZSgpO1xyXG5cclxuICBpZiAoREVCVUcpIHtcclxuICAgIGNvbnNvbGUubG9nKCdEZWx0YTogJWQgZGVnLCBHX2VzdDogKCVzLCAlcywgJXMpLCBHX21lYXM6ICglcywgJXMsICVzKScsXHJcbiAgICAgICAgICAgICAgICBUSFJFRS5NYXRoLnJhZFRvRGVnKFV0aWwuZ2V0UXVhdGVybmlvbkFuZ2xlKGRlbHRhUSkpLFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS54KS50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS55KS50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuZXN0aW1hdGVkR3Jhdml0eS56KS50b0ZpeGVkKDEpLFxyXG4gICAgICAgICAgICAgICAgKHRoaXMubWVhc3VyZWRHcmF2aXR5LngpLnRvRml4ZWQoMSksXHJcbiAgICAgICAgICAgICAgICAodGhpcy5tZWFzdXJlZEdyYXZpdHkueSkudG9GaXhlZCgxKSxcclxuICAgICAgICAgICAgICAgICh0aGlzLm1lYXN1cmVkR3Jhdml0eS56KS50b0ZpeGVkKDEpKTtcclxuICB9XHJcblxyXG4gIC8vIENhbGN1bGF0ZSB0aGUgU0xFUlAgdGFyZ2V0OiBjdXJyZW50IG9yaWVudGF0aW9uIHBsdXMgdGhlIG1lYXN1cmVkLWVzdGltYXRlZFxyXG4gIC8vIHF1YXRlcm5pb24gZGVsdGEuXHJcbiAgdmFyIHRhcmdldFEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4gIHRhcmdldFEuY29weSh0aGlzLmZpbHRlclEpO1xyXG4gIHRhcmdldFEubXVsdGlwbHkoZGVsdGFRKTtcclxuXHJcbiAgLy8gU0xFUlAgZmFjdG9yOiAwIGlzIHB1cmUgZ3lybywgMSBpcyBwdXJlIGFjY2VsLlxyXG4gIHRoaXMuZmlsdGVyUS5zbGVycCh0YXJnZXRRLCAxIC0gdGhpcy5rRmlsdGVyKTtcclxuXHJcbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xyXG59O1xyXG5cclxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gdGhpcy5maWx0ZXJRO1xyXG59O1xyXG5cclxuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWNjZWxUb1F1YXRlcm5pb25fID0gZnVuY3Rpb24oYWNjZWwpIHtcclxuICB2YXIgbm9ybUFjY2VsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICBub3JtQWNjZWwuY29weShhY2NlbCk7XHJcbiAgbm9ybUFjY2VsLm5vcm1hbGl6ZSgpO1xyXG4gIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuICBxdWF0LnNldEZyb21Vbml0VmVjdG9ycyhuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAtMSksIG5vcm1BY2NlbCk7XHJcbiAgcXVhdC5pbnZlcnNlKCk7XHJcbiAgcmV0dXJuIHF1YXQ7XHJcbn07XHJcblxyXG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfID0gZnVuY3Rpb24oZ3lybywgZHQpIHtcclxuICAvLyBFeHRyYWN0IGF4aXMgYW5kIGFuZ2xlIGZyb20gdGhlIGd5cm9zY29wZSBkYXRhLlxyXG4gIHZhciBxdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuICB2YXIgYXhpcyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbiAgYXhpcy5jb3B5KGd5cm8pO1xyXG4gIGF4aXMubm9ybWFsaXplKCk7XHJcbiAgcXVhdC5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGd5cm8ubGVuZ3RoKCkgKiBkdCk7XHJcbiAgcmV0dXJuIHF1YXQ7XHJcbn07XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDb21wbGVtZW50YXJ5RmlsdGVyO1xyXG5cclxufSx7XCIuL3NlbnNvci1zYW1wbGUuanNcIjo4LFwiLi90aHJlZS1tYXRoLmpzXCI6OSxcIi4vdXRpbC5qc1wiOjExfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSBfZGVyZXFfKCcuL2Jhc2UuanMnKS5Qb3NpdGlvblNlbnNvclZSRGV2aWNlO1xyXG5cclxudmFyIENvbXBsZW1lbnRhcnlGaWx0ZXIgPSBfZGVyZXFfKCcuL2NvbXBsZW1lbnRhcnktZmlsdGVyLmpzJyk7XHJcbnZhciBQb3NlUHJlZGljdG9yID0gX2RlcmVxXygnLi9wb3NlLXByZWRpY3Rvci5qcycpO1xyXG52YXIgVG91Y2hQYW5uZXIgPSBfZGVyZXFfKCcuL3RvdWNoLXBhbm5lci5qcycpO1xyXG52YXIgVEhSRUUgPSBfZGVyZXFfKCcuL3RocmVlLW1hdGguanMnKTtcclxudmFyIFV0aWwgPSBfZGVyZXFfKCcuL3V0aWwuanMnKTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcG9zaXRpb25hbCBzZW5zb3IsIGltcGxlbWVudGVkIHVzaW5nIERldmljZU1vdGlvbiBBUElzLlxyXG4gKi9cclxuZnVuY3Rpb24gRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZSgpIHtcclxuICB0aGlzLmRldmljZUlkID0gJ3dlYnZyLXBvbHlmaWxsOmZ1c2VkJztcclxuICB0aGlzLmRldmljZU5hbWUgPSAnVlIgUG9zaXRpb24gRGV2aWNlICh3ZWJ2ci1wb2x5ZmlsbDpmdXNlZCknO1xyXG5cclxuICB0aGlzLmFjY2VsZXJvbWV0ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gIHRoaXMuZ3lyb3Njb3BlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW1vdGlvbicsIHRoaXMub25EZXZpY2VNb3Rpb25DaGFuZ2VfLmJpbmQodGhpcykpO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMub25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZV8uYmluZCh0aGlzKSk7XHJcblxyXG4gIHRoaXMuZmlsdGVyID0gbmV3IENvbXBsZW1lbnRhcnlGaWx0ZXIoV2ViVlJDb25maWcuS19GSUxURVIgfHwgMC45OCk7XHJcbiAgdGhpcy5wb3NlUHJlZGljdG9yID0gbmV3IFBvc2VQcmVkaWN0b3IoV2ViVlJDb25maWcuUFJFRElDVElPTl9USU1FX1MgfHwgMC4wNDApO1xyXG4gIHRoaXMudG91Y2hQYW5uZXIgPSBuZXcgVG91Y2hQYW5uZXIoKTtcclxuXHJcbiAgdGhpcy5maWx0ZXJUb1dvcmxkUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gIC8vIFNldCB0aGUgZmlsdGVyIHRvIHdvcmxkIHRyYW5zZm9ybSwgZGVwZW5kaW5nIG9uIE9TLlxyXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcclxuICAgIHRoaXMuZmlsdGVyVG9Xb3JsZFEuc2V0RnJvbUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygxLCAwLCAwKSwgTWF0aC5QSS8yKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhpcy5maWx0ZXJUb1dvcmxkUS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDEsIDAsIDApLCAtTWF0aC5QSS8yKTtcclxuICB9XHJcblxyXG4gIHRoaXMud29ybGRUb1NjcmVlblEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG4gIHRoaXMuc2V0U2NyZWVuVHJhbnNmb3JtXygpO1xyXG5cclxuICAvLyBLZWVwIHRyYWNrIG9mIGEgcmVzZXQgdHJhbnNmb3JtIGZvciByZXNldFNlbnNvci5cclxuICB0aGlzLnJlc2V0USA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG4gIHRoaXMuaXNGaXJlZm94QW5kcm9pZCA9IFV0aWwuaXNGaXJlZm94QW5kcm9pZCgpO1xyXG4gIHRoaXMuaXNJT1MgPSBVdGlsLmlzSU9TKCk7XHJcbn1cclxuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgUG9zaXRpb25TZW5zb3JWUkRldmljZSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMge29yaWVudGF0aW9uOiB7eCx5LHosd30sIHBvc2l0aW9uOiBudWxsfS5cclxuICogUG9zaXRpb24gaXMgbm90IHN1cHBvcnRlZCBzaW5jZSB3ZSBjYW4ndCBkbyA2RE9GLlxyXG4gKi9cclxuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4ge1xyXG4gICAgaGFzT3JpZW50YXRpb246IHRydWUsXHJcbiAgICBvcmllbnRhdGlvbjogdGhpcy5nZXRPcmllbnRhdGlvbigpLFxyXG4gICAgaGFzUG9zaXRpb246IGZhbHNlLFxyXG4gICAgcG9zaXRpb246IG51bGxcclxuICB9XHJcbn07XHJcblxyXG5GdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIENvbnZlcnQgZnJvbSBmaWx0ZXIgc3BhY2UgdG8gdGhlIHRoZSBzYW1lIHN5c3RlbSB1c2VkIGJ5IHRoZVxyXG4gIC8vIGRldmljZW9yaWVudGF0aW9uIGV2ZW50LlxyXG4gIHZhciBvcmllbnRhdGlvbiA9IHRoaXMuZmlsdGVyLmdldE9yaWVudGF0aW9uKCk7XHJcblxyXG4gIC8vIFByZWRpY3Qgb3JpZW50YXRpb24uXHJcbiAgdGhpcy5wcmVkaWN0ZWRRID0gdGhpcy5wb3NlUHJlZGljdG9yLmdldFByZWRpY3Rpb24ob3JpZW50YXRpb24sIHRoaXMuZ3lyb3Njb3BlLCB0aGlzLnByZXZpb3VzVGltZXN0YW1wUyk7XHJcblxyXG4gIC8vIENvbnZlcnQgdG8gVEhSRUUgY29vcmRpbmF0ZSBzeXN0ZW06IC1aIGZvcndhcmQsIFkgdXAsIFggcmlnaHQuXHJcbiAgdmFyIG91dCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgb3V0LmNvcHkodGhpcy5maWx0ZXJUb1dvcmxkUSk7XHJcbiAgb3V0Lm11bHRpcGx5KHRoaXMucmVzZXRRKTtcclxuICBpZiAoIVdlYlZSQ29uZmlnLlRPVUNIX1BBTk5FUl9ESVNBQkxFRCkge1xyXG4gICAgb3V0Lm11bHRpcGx5KHRoaXMudG91Y2hQYW5uZXIuZ2V0T3JpZW50YXRpb24oKSk7XHJcbiAgfVxyXG4gIG91dC5tdWx0aXBseSh0aGlzLnByZWRpY3RlZFEpO1xyXG4gIG91dC5tdWx0aXBseSh0aGlzLndvcmxkVG9TY3JlZW5RKTtcclxuXHJcbiAgLy8gSGFuZGxlIHRoZSB5YXctb25seSBjYXNlLlxyXG4gIGlmIChXZWJWUkNvbmZpZy5ZQVdfT05MWSkge1xyXG4gICAgLy8gTWFrZSBhIHF1YXRlcm5pb24gdGhhdCBvbmx5IHR1cm5zIGFyb3VuZCB0aGUgWS1heGlzLlxyXG4gICAgb3V0LnggPSAwO1xyXG4gICAgb3V0LnogPSAwO1xyXG4gICAgb3V0Lm5vcm1hbGl6ZSgpO1xyXG4gIH1cclxuICByZXR1cm4gb3V0O1xyXG59O1xyXG5cclxuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUucmVzZXRTZW5zb3IgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoKTtcclxuICBldWxlci5zZXRGcm9tUXVhdGVybmlvbih0aGlzLmZpbHRlci5nZXRPcmllbnRhdGlvbigpKTtcclxuICB2YXIgeWF3ID0gZXVsZXIueTtcclxuICBjb25zb2xlLmxvZygncmVzZXRTZW5zb3Igd2l0aCB5YXc6ICVmJywgeWF3KTtcclxuICB0aGlzLnJlc2V0US5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDEpLCAteWF3KTtcclxuICBpZiAoIVdlYlZSQ29uZmlnLlRPVUNIX1BBTk5FUl9ESVNBQkxFRCkge1xyXG4gICAgdGhpcy50b3VjaFBhbm5lci5yZXNldFNlbnNvcigpO1xyXG4gIH1cclxufTtcclxuXHJcbkZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLm9uRGV2aWNlTW90aW9uQ2hhbmdlXyA9IGZ1bmN0aW9uKGRldmljZU1vdGlvbikge1xyXG4gIHZhciBhY2NHcmF2aXR5ID0gZGV2aWNlTW90aW9uLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XHJcbiAgdmFyIHJvdFJhdGUgPSBkZXZpY2VNb3Rpb24ucm90YXRpb25SYXRlO1xyXG4gIHZhciB0aW1lc3RhbXBTID0gZGV2aWNlTW90aW9uLnRpbWVTdGFtcCAvIDEwMDA7XHJcblxyXG4gIC8vIEZpcmVmb3ggQW5kcm9pZCB0aW1lU3RhbXAgcmV0dXJucyBvbmUgdGhvdXNhbmR0aCBvZiBhIG1pbGxpc2Vjb25kLlxyXG4gIGlmICh0aGlzLmlzRmlyZWZveEFuZHJvaWQpIHtcclxuICAgIHRpbWVzdGFtcFMgLz0gMTAwMDtcclxuICB9XHJcblxyXG4gIHZhciBkZWx0YVMgPSB0aW1lc3RhbXBTIC0gdGhpcy5wcmV2aW91c1RpbWVzdGFtcFM7XHJcbiAgaWYgKGRlbHRhUyA8PSBVdGlsLk1JTl9USU1FU1RFUCB8fCBkZWx0YVMgPiBVdGlsLk1BWF9USU1FU1RFUCkge1xyXG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIHRpbWVzdGFtcHMgZGV0ZWN0ZWQuIFRpbWUgc3RlcCBiZXR3ZWVuIHN1Y2Nlc3NpdmUgJyArXHJcbiAgICAgICAgICAgICAgICAgJ2d5cm9zY29wZSBzZW5zb3Igc2FtcGxlcyBpcyB2ZXJ5IHNtYWxsIG9yIG5vdCBtb25vdG9uaWMnKTtcclxuICAgIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gdGltZXN0YW1wUztcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5hY2NlbGVyb21ldGVyLnNldCgtYWNjR3Jhdml0eS54LCAtYWNjR3Jhdml0eS55LCAtYWNjR3Jhdml0eS56KTtcclxuICB0aGlzLmd5cm9zY29wZS5zZXQocm90UmF0ZS5hbHBoYSwgcm90UmF0ZS5iZXRhLCByb3RSYXRlLmdhbW1hKTtcclxuXHJcbiAgLy8gV2l0aCBpT1MgYW5kIEZpcmVmb3ggQW5kcm9pZCwgcm90YXRpb25SYXRlIGlzIHJlcG9ydGVkIGluIGRlZ3JlZXMsXHJcbiAgLy8gc28gd2UgZmlyc3QgY29udmVydCB0byByYWRpYW5zLlxyXG4gIGlmICh0aGlzLmlzSU9TIHx8IHRoaXMuaXNGaXJlZm94QW5kcm9pZCkge1xyXG4gICAgdGhpcy5neXJvc2NvcGUubXVsdGlwbHlTY2FsYXIoTWF0aC5QSSAvIDE4MCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLmZpbHRlci5hZGRBY2NlbE1lYXN1cmVtZW50KHRoaXMuYWNjZWxlcm9tZXRlciwgdGltZXN0YW1wUyk7XHJcbiAgdGhpcy5maWx0ZXIuYWRkR3lyb01lYXN1cmVtZW50KHRoaXMuZ3lyb3Njb3BlLCB0aW1lc3RhbXBTKTtcclxuXHJcbiAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xyXG59O1xyXG5cclxuRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUub25TY3JlZW5PcmllbnRhdGlvbkNoYW5nZV8gPVxyXG4gICAgZnVuY3Rpb24oc2NyZWVuT3JpZW50YXRpb24pIHtcclxuICB0aGlzLnNldFNjcmVlblRyYW5zZm9ybV8oKTtcclxufTtcclxuXHJcbkZ1c2lvblBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLnNldFNjcmVlblRyYW5zZm9ybV8gPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLndvcmxkVG9TY3JlZW5RLnNldCgwLCAwLCAwLCAxKTtcclxuICBzd2l0Y2ggKHdpbmRvdy5vcmllbnRhdGlvbikge1xyXG4gICAgY2FzZSAwOlxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgOTA6XHJcbiAgICAgIHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSwgLU1hdGguUEkvMik7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAtOTA6XHJcbiAgICAgIHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAxKSwgTWF0aC5QSS8yKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDE4MDpcclxuICAgICAgLy8gVE9ETy5cclxuICAgICAgYnJlYWs7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRnVzaW9uUG9zaXRpb25TZW5zb3JWUkRldmljZTtcclxuXHJcbn0se1wiLi9iYXNlLmpzXCI6MSxcIi4vY29tcGxlbWVudGFyeS1maWx0ZXIuanNcIjozLFwiLi9wb3NlLXByZWRpY3Rvci5qc1wiOjcsXCIuL3RocmVlLW1hdGguanNcIjo5LFwiLi90b3VjaC1wYW5uZXIuanNcIjoxMCxcIi4vdXRpbC5qc1wiOjExfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIFdlYlZSUG9seWZpbGwgPSBfZGVyZXFfKCcuL3dlYnZyLXBvbHlmaWxsLmpzJyk7XHJcblxyXG4vLyBJbml0aWFsaXplIGEgV2ViVlJDb25maWcganVzdCBpbiBjYXNlLlxyXG53aW5kb3cuV2ViVlJDb25maWcgPSB3aW5kb3cuV2ViVlJDb25maWcgfHwge307XHJcbm5ldyBXZWJWUlBvbHlmaWxsKCk7XHJcblxyXG59LHtcIi4vd2VidnItcG9seWZpbGwuanNcIjoxMn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBQb3NpdGlvblNlbnNvclZSRGV2aWNlID0gX2RlcmVxXygnLi9iYXNlLmpzJykuUG9zaXRpb25TZW5zb3JWUkRldmljZTtcclxudmFyIFRIUkVFID0gX2RlcmVxXygnLi90aHJlZS1tYXRoLmpzJyk7XHJcbnZhciBVdGlsID0gX2RlcmVxXygnLi91dGlsLmpzJyk7XHJcblxyXG4vLyBIb3cgbXVjaCB0byByb3RhdGUgcGVyIGtleSBzdHJva2UuXHJcbnZhciBLRVlfU1BFRUQgPSAwLjE1O1xyXG52YXIgS0VZX0FOSU1BVElPTl9EVVJBVElPTiA9IDgwO1xyXG5cclxuLy8gSG93IG11Y2ggdG8gcm90YXRlIGZvciBtb3VzZSBldmVudHMuXHJcbnZhciBNT1VTRV9TUEVFRF9YID0gMC41O1xyXG52YXIgTU9VU0VfU1BFRURfWSA9IDAuMztcclxuXHJcbi8qKlxyXG4gKiBBIHZpcnR1YWwgcG9zaXRpb24gc2Vuc29yLCBpbXBsZW1lbnRlZCB1c2luZyBrZXlib2FyZCBhbmRcclxuICogbW91c2UgQVBJcy4gVGhpcyBpcyBkZXNpZ25lZCBhcyBmb3IgZGVza3RvcHMvbGFwdG9wcyB3aGVyZSBubyBEZXZpY2UqXHJcbiAqIGV2ZW50cyB3b3JrLlxyXG4gKi9cclxuZnVuY3Rpb24gTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UoKSB7XHJcbiAgdGhpcy5kZXZpY2VJZCA9ICd3ZWJ2ci1wb2x5ZmlsbDptb3VzZS1rZXlib2FyZCc7XHJcbiAgdGhpcy5kZXZpY2VOYW1lID0gJ1ZSIFBvc2l0aW9uIERldmljZSAod2VidnItcG9seWZpbGw6bW91c2Uta2V5Ym9hcmQpJztcclxuXHJcbiAgLy8gQXR0YWNoIHRvIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMuXHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLm9uS2V5RG93bl8uYmluZCh0aGlzKSk7XHJcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmVfLmJpbmQodGhpcykpO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duXy5iaW5kKHRoaXMpKTtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwXy5iaW5kKHRoaXMpKTtcclxuXHJcbiAgdGhpcy5waGkgPSAwO1xyXG4gIHRoaXMudGhldGEgPSAwO1xyXG5cclxuICAvLyBWYXJpYWJsZXMgZm9yIGtleWJvYXJkLWJhc2VkIHJvdGF0aW9uIGFuaW1hdGlvbi5cclxuICB0aGlzLnRhcmdldEFuZ2xlID0gbnVsbDtcclxuXHJcbiAgLy8gU3RhdGUgdmFyaWFibGVzIGZvciBjYWxjdWxhdGlvbnMuXHJcbiAgdGhpcy5ldWxlciA9IG5ldyBUSFJFRS5FdWxlcigpO1xyXG4gIHRoaXMub3JpZW50YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuICAvLyBWYXJpYWJsZXMgZm9yIG1vdXNlLWJhc2VkIHJvdGF0aW9uLlxyXG4gIHRoaXMucm90YXRlU3RhcnQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG4gIHRoaXMucm90YXRlRW5kID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICB0aGlzLnJvdGF0ZURlbHRhID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxufVxyXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUgPSBuZXcgUG9zaXRpb25TZW5zb3JWUkRldmljZSgpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMge29yaWVudGF0aW9uOiB7eCx5LHosd30sIHBvc2l0aW9uOiBudWxsfS5cclxuICogUG9zaXRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgcGFyaXR5IHdpdGggb3RoZXIgUG9zaXRpb25TZW5zb3JzLlxyXG4gKi9cclxuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy5ldWxlci5zZXQodGhpcy5waGksIHRoaXMudGhldGEsIDAsICdZWFonKTtcclxuICB0aGlzLm9yaWVudGF0aW9uLnNldEZyb21FdWxlcih0aGlzLmV1bGVyKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGhhc09yaWVudGF0aW9uOiB0cnVlLFxyXG4gICAgb3JpZW50YXRpb246IHRoaXMub3JpZW50YXRpb24sXHJcbiAgICBoYXNQb3NpdGlvbjogZmFsc2UsXHJcbiAgICBwb3NpdGlvbjogbnVsbFxyXG4gIH1cclxufTtcclxuXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vbktleURvd25fID0gZnVuY3Rpb24oZSkge1xyXG4gIC8vIFRyYWNrIFdBU0QgYW5kIGFycm93IGtleXMuXHJcbiAgaWYgKGUua2V5Q29kZSA9PSAzOCkgeyAvLyBVcCBrZXkuXHJcbiAgICB0aGlzLmFuaW1hdGVQaGlfKHRoaXMucGhpICsgS0VZX1NQRUVEKTtcclxuICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAzOSkgeyAvLyBSaWdodCBrZXkuXHJcbiAgICB0aGlzLmFuaW1hdGVUaGV0YV8odGhpcy50aGV0YSAtIEtFWV9TUEVFRCk7XHJcbiAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT0gNDApIHsgLy8gRG93biBrZXkuXHJcbiAgICB0aGlzLmFuaW1hdGVQaGlfKHRoaXMucGhpIC0gS0VZX1NQRUVEKTtcclxuICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PSAzNykgeyAvLyBMZWZ0IGtleS5cclxuICAgIHRoaXMuYW5pbWF0ZVRoZXRhXyh0aGlzLnRoZXRhICsgS0VZX1NQRUVEKTtcclxuICB9XHJcbn07XHJcblxyXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUuYW5pbWF0ZVRoZXRhXyA9IGZ1bmN0aW9uKHRhcmdldEFuZ2xlKSB7XHJcbiAgdGhpcy5hbmltYXRlS2V5VHJhbnNpdGlvbnNfKCd0aGV0YScsIHRhcmdldEFuZ2xlKTtcclxufTtcclxuXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5hbmltYXRlUGhpXyA9IGZ1bmN0aW9uKHRhcmdldEFuZ2xlKSB7XHJcbiAgLy8gUHJldmVudCBsb29raW5nIHRvbyBmYXIgdXAgb3IgZG93bi5cclxuICB0YXJnZXRBbmdsZSA9IFV0aWwuY2xhbXAodGFyZ2V0QW5nbGUsIC1NYXRoLlBJLzIsIE1hdGguUEkvMik7XHJcbiAgdGhpcy5hbmltYXRlS2V5VHJhbnNpdGlvbnNfKCdwaGknLCB0YXJnZXRBbmdsZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogU3RhcnQgYW4gYW5pbWF0aW9uIHRvIHRyYW5zaXRpb24gYW4gYW5nbGUgZnJvbSBvbmUgdmFsdWUgdG8gYW5vdGhlci5cclxuICovXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5hbmltYXRlS2V5VHJhbnNpdGlvbnNfID0gZnVuY3Rpb24oYW5nbGVOYW1lLCB0YXJnZXRBbmdsZSkge1xyXG4gIC8vIElmIGFuIGFuaW1hdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZywgY2FuY2VsIGl0LlxyXG4gIGlmICh0aGlzLmFuZ2xlQW5pbWF0aW9uKSB7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMuYW5nbGVBbmltYXRpb24pO1xyXG4gIH1cclxuICB2YXIgc3RhcnRBbmdsZSA9IHRoaXNbYW5nbGVOYW1lXTtcclxuICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAvLyBTZXQgdXAgYW4gaW50ZXJ2YWwgdGltZXIgdG8gcGVyZm9ybSB0aGUgYW5pbWF0aW9uLlxyXG4gIHRoaXMuYW5nbGVBbmltYXRpb24gPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgIC8vIE9uY2Ugd2UncmUgZmluaXNoZWQgdGhlIGFuaW1hdGlvbiwgd2UncmUgZG9uZS5cclxuICAgIHZhciBlbGFwc2VkID0gbmV3IERhdGUoKSAtIHN0YXJ0VGltZTtcclxuICAgIGlmIChlbGFwc2VkID49IEtFWV9BTklNQVRJT05fRFVSQVRJT04pIHtcclxuICAgICAgdGhpc1thbmdsZU5hbWVdID0gdGFyZ2V0QW5nbGU7XHJcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5hbmdsZUFuaW1hdGlvbik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIExpbmVhcmx5IGludGVycG9sYXRlIHRoZSBhbmdsZSBzb21lIGFtb3VudC5cclxuICAgIHZhciBwZXJjZW50ID0gZWxhcHNlZCAvIEtFWV9BTklNQVRJT05fRFVSQVRJT047XHJcbiAgICB0aGlzW2FuZ2xlTmFtZV0gPSBzdGFydEFuZ2xlICsgKHRhcmdldEFuZ2xlIC0gc3RhcnRBbmdsZSkgKiBwZXJjZW50O1xyXG4gIH0uYmluZCh0aGlzKSwgMTAwMC82MCk7XHJcbn07XHJcblxyXG5Nb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZS5wcm90b3R5cGUub25Nb3VzZURvd25fID0gZnVuY3Rpb24oZSkge1xyXG4gIHRoaXMucm90YXRlU3RhcnQuc2V0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG59O1xyXG5cclxuLy8gVmVyeSBzaW1pbGFyIHRvIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21yZmxpeC84MzUxMDIwXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vbk1vdXNlTW92ZV8gPSBmdW5jdGlvbihlKSB7XHJcbiAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcgJiYgIXRoaXMuaXNQb2ludGVyTG9ja2VkXygpKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIC8vIFN1cHBvcnQgcG9pbnRlciBsb2NrIEFQSS5cclxuICBpZiAodGhpcy5pc1BvaW50ZXJMb2NrZWRfKCkpIHtcclxuICAgIHZhciBtb3ZlbWVudFggPSBlLm1vdmVtZW50WCB8fCBlLm1vek1vdmVtZW50WCB8fCAwO1xyXG4gICAgdmFyIG1vdmVtZW50WSA9IGUubW92ZW1lbnRZIHx8IGUubW96TW92ZW1lbnRZIHx8IDA7XHJcbiAgICB0aGlzLnJvdGF0ZUVuZC5zZXQodGhpcy5yb3RhdGVTdGFydC54IC0gbW92ZW1lbnRYLCB0aGlzLnJvdGF0ZVN0YXJ0LnkgLSBtb3ZlbWVudFkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLnJvdGF0ZUVuZC5zZXQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gIH1cclxuICAvLyBDYWxjdWxhdGUgaG93IG11Y2ggd2UgbW92ZWQgaW4gbW91c2Ugc3BhY2UuXHJcbiAgdGhpcy5yb3RhdGVEZWx0YS5zdWJWZWN0b3JzKHRoaXMucm90YXRlRW5kLCB0aGlzLnJvdGF0ZVN0YXJ0KTtcclxuICB0aGlzLnJvdGF0ZVN0YXJ0LmNvcHkodGhpcy5yb3RhdGVFbmQpO1xyXG5cclxuICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdW11bGF0aXZlIGV1bGVyIGFuZ2xlcy5cclxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XHJcbiAgdGhpcy5waGkgKz0gMiAqIE1hdGguUEkgKiB0aGlzLnJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCAqIE1PVVNFX1NQRUVEX1k7XHJcbiAgdGhpcy50aGV0YSArPSAyICogTWF0aC5QSSAqIHRoaXMucm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50V2lkdGggKiBNT1VTRV9TUEVFRF9YO1xyXG5cclxuICAvLyBQcmV2ZW50IGxvb2tpbmcgdG9vIGZhciB1cCBvciBkb3duLlxyXG4gIHRoaXMucGhpID0gVXRpbC5jbGFtcCh0aGlzLnBoaSwgLU1hdGguUEkvMiwgTWF0aC5QSS8yKTtcclxufTtcclxuXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5vbk1vdXNlVXBfID0gZnVuY3Rpb24oZSkge1xyXG4gIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG59O1xyXG5cclxuTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UucHJvdG90eXBlLmlzUG9pbnRlckxvY2tlZF8gPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZWwgPSBkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgfHwgZG9jdW1lbnQubW96UG9pbnRlckxvY2tFbGVtZW50IHx8XHJcbiAgICAgIGRvY3VtZW50LndlYmtpdFBvaW50ZXJMb2NrRWxlbWVudDtcclxuICByZXR1cm4gZWwgIT09IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbk1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlLnByb3RvdHlwZS5yZXNldFNlbnNvciA9IGZ1bmN0aW9uKCkge1xyXG4gIGNvbnNvbGUuZXJyb3IoJ05vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdXNlS2V5Ym9hcmRQb3NpdGlvblNlbnNvclZSRGV2aWNlO1xyXG5cclxufSx7XCIuL2Jhc2UuanNcIjoxLFwiLi90aHJlZS1tYXRoLmpzXCI6OSxcIi4vdXRpbC5qc1wiOjExfV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIFRIUkVFID0gX2RlcmVxXygnLi90aHJlZS1tYXRoLmpzJyk7XHJcblxyXG52YXIgREVCVUcgPSBmYWxzZTtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBvcmllbnRhdGlvbiBhbmQgdGhlIGd5cm9zY29wZSBkYXRhLCBwcmVkaWN0cyB0aGUgZnV0dXJlIG9yaWVudGF0aW9uXHJcbiAqIG9mIHRoZSBoZWFkLiBUaGlzIG1ha2VzIHJlbmRlcmluZyBhcHBlYXIgZmFzdGVyLlxyXG4gKlxyXG4gKiBBbHNvIHNlZTogaHR0cDovL21zbC5jcy51aXVjLmVkdS9+bGF2YWxsZS9wYXBlcnMvTGF2WWVyS2F0QW50MTQucGRmXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVkaWN0aW9uVGltZVMgdGltZSBmcm9tIGhlYWQgbW92ZW1lbnQgdG8gdGhlIGFwcGVhcmFuY2Ugb2ZcclxuICogdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBQb3NlUHJlZGljdG9yKHByZWRpY3Rpb25UaW1lUykge1xyXG4gIHRoaXMucHJlZGljdGlvblRpbWVTID0gcHJlZGljdGlvblRpbWVTO1xyXG5cclxuICAvLyBUaGUgcXVhdGVybmlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cclxuICB0aGlzLnByZXZpb3VzUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgLy8gUHJldmlvdXMgdGltZSBhIHByZWRpY3Rpb24gb2NjdXJyZWQuXHJcbiAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSBudWxsO1xyXG5cclxuICAvLyBUaGUgZGVsdGEgcXVhdGVybmlvbiB0aGF0IGFkanVzdHMgdGhlIGN1cnJlbnQgcG9zZS5cclxuICB0aGlzLmRlbHRhUSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbiAgLy8gVGhlIG91dHB1dCBxdWF0ZXJuaW9uLlxyXG4gIHRoaXMub3V0USA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbn1cclxuXHJcblBvc2VQcmVkaWN0b3IucHJvdG90eXBlLmdldFByZWRpY3Rpb24gPSBmdW5jdGlvbihjdXJyZW50USwgZ3lybywgdGltZXN0YW1wUykge1xyXG4gIGlmICghdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMpIHtcclxuICAgIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xyXG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xyXG4gICAgcmV0dXJuIGN1cnJlbnRRO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGF4aXMgYW5kIGFuZ2xlIGJhc2VkIG9uIGd5cm9zY29wZSByb3RhdGlvbiByYXRlIGRhdGEuXHJcbiAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG4gIGF4aXMuY29weShneXJvKTtcclxuICBheGlzLm5vcm1hbGl6ZSgpO1xyXG5cclxuICB2YXIgYW5ndWxhclNwZWVkID0gZ3lyby5sZW5ndGgoKTtcclxuXHJcbiAgLy8gSWYgd2UncmUgcm90YXRpbmcgc2xvd2x5LCBkb24ndCBkbyBwcmVkaWN0aW9uLlxyXG4gIGlmIChhbmd1bGFyU3BlZWQgPCBUSFJFRS5NYXRoLmRlZ1RvUmFkKDIwKSkge1xyXG4gICAgaWYgKERFQlVHKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdNb3Zpbmcgc2xvd2x5LCBhdCAlcyBkZWcvczogbm8gcHJlZGljdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgIFRIUkVFLk1hdGgucmFkVG9EZWcoYW5ndWxhclNwZWVkKS50b0ZpeGVkKDEpKTtcclxuICAgIH1cclxuICAgIHRoaXMub3V0US5jb3B5KGN1cnJlbnRRKTtcclxuICAgIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xyXG4gICAgcmV0dXJuIHRoaXMub3V0UTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgcHJlZGljdGVkIGFuZ2xlIGJhc2VkIG9uIHRoZSB0aW1lIGRlbHRhIGFuZCBsYXRlbmN5LlxyXG4gIHZhciBkZWx0YVQgPSB0aW1lc3RhbXBTIC0gdGhpcy5wcmV2aW91c1RpbWVzdGFtcFM7XHJcbiAgdmFyIHByZWRpY3RBbmdsZSA9IGFuZ3VsYXJTcGVlZCAqIHRoaXMucHJlZGljdGlvblRpbWVTO1xyXG5cclxuICB0aGlzLmRlbHRhUS5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIHByZWRpY3RBbmdsZSk7XHJcbiAgdGhpcy5vdXRRLmNvcHkodGhpcy5wcmV2aW91c1EpO1xyXG4gIHRoaXMub3V0US5tdWx0aXBseSh0aGlzLmRlbHRhUSk7XHJcblxyXG4gIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xyXG5cclxuICByZXR1cm4gdGhpcy5vdXRRO1xyXG59O1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUG9zZVByZWRpY3RvcjtcclxuXHJcbn0se1wiLi90aHJlZS1tYXRoLmpzXCI6OX1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xyXG5mdW5jdGlvbiBTZW5zb3JTYW1wbGUoc2FtcGxlLCB0aW1lc3RhbXBTKSB7XHJcbiAgdGhpcy5zZXQoc2FtcGxlLCB0aW1lc3RhbXBTKTtcclxufTtcclxuXHJcblNlbnNvclNhbXBsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc2FtcGxlLCB0aW1lc3RhbXBTKSB7XHJcbiAgdGhpcy5zYW1wbGUgPSBzYW1wbGU7XHJcbiAgdGhpcy50aW1lc3RhbXBTID0gdGltZXN0YW1wUztcclxufTtcclxuXHJcblNlbnNvclNhbXBsZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNlbnNvclNhbXBsZSkge1xyXG4gIHRoaXMuc2V0KHNlbnNvclNhbXBsZS5zYW1wbGUsIHNlbnNvclNhbXBsZS50aW1lc3RhbXBTKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU2Vuc29yU2FtcGxlO1xyXG5cclxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIEEgc3Vic2V0IG9mIFRIUkVFLmpzLCBwcm92aWRpbmcgbW9zdGx5IHF1YXRlcm5pb24gYW5kIGV1bGVyLXJlbGF0ZWRcclxuICogb3BlcmF0aW9ucywgbWFudWFsbHkgbGlmdGVkIGZyb21cclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy90cmVlL21hc3Rlci9zcmMvbWF0aCwgYXMgb2YgOWMzMDI4NmIzOGRmMDM5ZmNhMzg5OTg5ZmYwNmVhMWMxNWQ2YmFkMVxyXG4gKi9cclxuXHJcbi8vIE9ubHkgdXNlIGlmIHRoZSByZWFsIFRIUkVFIGlzIG5vdCBwcm92aWRlZC5cclxudmFyIFRIUkVFID0gd2luZG93LlRIUkVFIHx8IHt9O1xyXG5cclxuLy8gSWYgc29tZSBwaWVjZSBvZiBUSFJFRSBpcyBtaXNzaW5nLCBmaWxsIGl0IGluIGhlcmUuXHJcbmlmICghVEhSRUUuUXVhdGVybmlvbiB8fCAhVEhSRUUuVmVjdG9yMyB8fCAhVEhSRUUuVmVjdG9yMiB8fCAhVEhSRUUuRXVsZXIgfHwgIVRIUkVFLk1hdGgpIHtcclxuY29uc29sZS5sb2coJ05vIFRIUkVFLmpzIGZvdW5kLicpO1xyXG5cclxuXHJcbi8qKiogU1RBUlQgUXVhdGVybmlvbiAqKiovXHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMuX3ggPSB4IHx8IDA7XHJcblx0dGhpcy5feSA9IHkgfHwgMDtcclxuXHR0aGlzLl96ID0geiB8fCAwO1xyXG5cdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5RdWF0ZXJuaW9uLFxyXG5cclxuXHRfeDogMCxfeTogMCwgX3o6IDAsIF93OiAwLFxyXG5cclxuXHRnZXQgeCAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3g7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB4ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCB5ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHkgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl95ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHogKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl96O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3ogPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgdyAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB3ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5fdyA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0dGhpcy5feSA9IHk7XHJcblx0XHR0aGlzLl96ID0gejtcclxuXHRcdHRoaXMuX3cgPSB3O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XHJcblxyXG5cdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcclxuXHRcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XHJcblx0XHR0aGlzLl96ID0gcXVhdGVybmlvbi56O1xyXG5cdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XHJcblxyXG5cdFx0aWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cclxuXHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXHJcblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXHJcblxyXG5cdFx0dmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xyXG5cdFx0dmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xyXG5cdFx0dmFyIGMzID0gTWF0aC5jb3MoIGV1bGVyLl96IC8gMiApO1xyXG5cdFx0dmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xyXG5cdFx0dmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xyXG5cdFx0dmFyIHMzID0gTWF0aC5zaW4oIGV1bGVyLl96IC8gMiApO1xyXG5cclxuXHRcdGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XHJcblx0XHR0aGlzLl95ID0gYXhpcy55ICogcztcclxuXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xyXG5cdFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxyXG5cdFx0XHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxyXG5cdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcclxuXHJcblx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxyXG5cdFx0XHRzO1xyXG5cclxuXHRcdGlmICggdHJhY2UgPiAwICkge1xyXG5cclxuXHRcdFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAwLjI1IC8gcztcclxuXHRcdFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xyXG5cdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XHJcblx0XHRcdHRoaXMuX3ogPSAoIG0yMSAtIG0xMiApICogcztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtMTEgPiBtMjIgJiYgbTExID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcclxuXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xyXG5cdFx0XHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9ICggbTIxIC0gbTEyICkgLyBzO1xyXG5cdFx0XHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcclxuXHRcdFx0dGhpcy5feiA9IDAuMjUgKiBzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gaHR0cDovL2xvbGVuZ2luZS5uZXQvYmxvZy8yMDE0LzAyLzI0L3F1YXRlcm5pb24tZnJvbS10d28tdmVjdG9ycy1maW5hbFxyXG5cclxuXHRcdC8vIGFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvcnMgdkZyb20gYW5kIHZUbyBhcmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciB2MSwgcjtcclxuXHJcblx0XHR2YXIgRVBTID0gMC4wMDAwMDE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdkZyb20sIHZUbyApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHIgPSB2RnJvbS5kb3QoIHZUbyApICsgMTtcclxuXHJcblx0XHRcdGlmICggciA8IEVQUyApIHtcclxuXHJcblx0XHRcdFx0ciA9IDA7XHJcblxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2MS5zZXQoIDAsIC0gdkZyb20ueiwgdkZyb20ueSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2MS5jcm9zc1ZlY3RvcnMoIHZGcm9tLCB2VG8gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuX3ggPSB2MS54O1xyXG5cdFx0XHR0aGlzLl95ID0gdjEueTtcclxuXHRcdFx0dGhpcy5feiA9IHYxLno7XHJcblx0XHRcdHRoaXMuX3cgPSByO1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5feCAqPSAtIDE7XHJcblx0XHR0aGlzLl95ICo9IC0gMTtcclxuXHRcdHRoaXMuX3ogKj0gLSAxO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feCAqIHYuX3ggKyB0aGlzLl95ICogdi5feSArIHRoaXMuX3ogKiB2Ll96ICsgdGhpcy5fdyAqIHYuX3c7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBsID09PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5feCA9IDA7XHJcblx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHR0aGlzLl96ID0gMDtcclxuXHRcdFx0dGhpcy5fdyA9IDE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGwgPSAxIC8gbDtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSB0aGlzLl94ICogbDtcclxuXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xyXG5cdFx0XHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XHJcblx0XHRcdHRoaXMuX3cgPSB0aGlzLl93ICogbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XHJcblxyXG5cdFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXHJcblxyXG5cdFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XHJcblx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcclxuXHJcblx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xyXG5cdFx0dGhpcy5feSA9IHFheSAqIHFidyArIHFhdyAqIHFieSArIHFheiAqIHFieCAtIHFheCAqIHFiejtcclxuXHRcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XHJcblx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xyXG5cclxuXHRcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xyXG5cdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcclxuXHJcblx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xyXG5cdFx0XHR0aGlzLl94ID0gLSBxYi5feDtcclxuXHRcdFx0dGhpcy5feSA9IC0gcWIuX3k7XHJcblx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xyXG5cclxuXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuY29weSggcWIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IHc7XHJcblx0XHRcdHRoaXMuX3ggPSB4O1xyXG5cdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0dGhpcy5feiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XHJcblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcclxuXHRcdFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcclxuXHRcdFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcclxuXHRcdFx0dGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxyXG5cdFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcclxuXHJcblx0XHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBxdWF0ZXJuaW9uLl94ID09PSB0aGlzLl94ICkgJiYgKCBxdWF0ZXJuaW9uLl95ID09PSB0aGlzLl95ICkgJiYgKCBxdWF0ZXJuaW9uLl96ID09PSB0aGlzLl96ICkgJiYgKCBxdWF0ZXJuaW9uLl93ID09PSB0aGlzLl93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHRcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMuX3ogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xyXG5cdFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XHJcblxyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcclxuXHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlF1YXRlcm5pb24oIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XHJcblxyXG5cdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xyXG5cclxufVxyXG5cclxuLyoqKiBFTkQgUXVhdGVybmlvbiAqKiovXHJcbi8qKiogU1RBUlQgVmVjdG9yMiAqKiovXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xyXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5WZWN0b3IyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzO1xyXG5cdFx0dGhpcy55ICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdGlmICggc2NhbGFyICE9PSAwICkge1xyXG5cclxuXHRcdFx0dmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XHJcblxyXG5cdFx0XHR0aGlzLnggKj0gaW52U2NhbGFyO1xyXG5cdFx0XHR0aGlzLnkgKj0gaW52U2NhbGFyO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPiB2LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55ID4gdi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCB2LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB2Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgdi55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gdi55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWluLng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgbWluLCBtYXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWluVmFsLCBtYXhWYWwgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0XHRcdG1heCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xyXG5cdFx0XHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2VpbDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gLSB0aGlzLng7XHJcblx0XHR0aGlzLnkgPSAtIHRoaXMueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcclxuXHJcblx0XHR2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xyXG5cclxuXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XHJcblx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XHJcblxyXG5cdCAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcclxuXHJcblx0ICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XHJcblxyXG5cdCAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XHJcblx0ICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XHJcblxyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHRoaXMueCwgdGhpcy55ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKiogRU5EIFZlY3RvcjIgKioqL1xyXG4vKioqIFNUQVJUIFZlY3RvcjMgKioqL1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjMgPSBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVmVjdG9yMyxcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xyXG5cclxuXHRcdHRoaXMueSA9IHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFo6IGZ1bmN0aW9uICggeiApIHtcclxuXHJcblx0XHR0aGlzLnogPSB6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHR0aGlzLnogKz0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gcztcclxuXHRcdHRoaXMueSArPSBzO1xyXG5cdFx0dGhpcy56ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cdFx0dGhpcy56ICo9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzY2FsYXI7XHJcblx0XHR0aGlzLnkgKj0gc2NhbGFyO1xyXG5cdFx0dGhpcy56ICo9IHNjYWxhcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54ICogYi54O1xyXG5cdFx0dGhpcy55ID0gYS55ICogYi55O1xyXG5cdFx0dGhpcy56ID0gYS56ICogYi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHF1YXRlcm5pb247XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZXVsZXIgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxdWF0ZXJuaW9uO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdFx0aWYgKCBxdWF0ZXJuaW9uID09PSB1bmRlZmluZWQgKSBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XHJcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDggXSAqIHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XHJcblx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6ICsgZVsgMTMgXTtcclxuXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXHJcblxyXG5cdFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6ICsgZVsgMTIgXSApICogZDtcclxuXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XHJcblx0XHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiBkO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueDtcclxuXHRcdHZhciB5ID0gdGhpcy55O1xyXG5cdFx0dmFyIHogPSB0aGlzLno7XHJcblxyXG5cdFx0dmFyIHF4ID0gcS54O1xyXG5cdFx0dmFyIHF5ID0gcS55O1xyXG5cdFx0dmFyIHF6ID0gcS56O1xyXG5cdFx0dmFyIHF3ID0gcS53O1xyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXHJcblxyXG5cdFx0dmFyIGl4ID0gIHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcclxuXHRcdHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XHJcblx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xyXG5cdFx0dmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxyXG5cclxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XHJcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xyXG5cdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtYXRyaXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcclxuXHJcblx0XHRpZiAoIHNjYWxhciAhPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xyXG5cclxuXHRcdFx0dGhpcy54ICo9IGludlNjYWxhcjtcclxuXHRcdFx0dGhpcy55ICo9IGludlNjYWxhcjtcclxuXHRcdFx0dGhpcy56ICo9IGludlNjYWxhcjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnogPiB2LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWluLng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgbWluLnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IG1heC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBTY2FsYXI6ICggZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcclxuXHJcblx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0bWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcclxuXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSApKCksXHJcblxyXG5cdGZsb29yOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKCB0aGlzLnkgKTtcclxuXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjZWlsOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRyb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XHJcblx0XHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcclxuXHRcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xyXG5cdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMueCA9IC0gdGhpcy54O1xyXG5cdFx0dGhpcy55ID0gLSB0aGlzLnk7XHJcblx0XHR0aGlzLnogPSAtIHRoaXMuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldExlbmd0aDogZnVuY3Rpb24gKCBsICkge1xyXG5cclxuXHRcdHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG5cclxuXHRcdGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR0aGlzLnggPSB5ICogdi56IC0geiAqIHYueTtcclxuXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xyXG5cdFx0dGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xyXG5cdFx0dmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XHJcblxyXG5cdFx0dGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XHJcblx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcclxuXHRcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEsIGRvdDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHR2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGRvdCA9IHRoaXMuZG90KCB2MSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuY29weSggdjEgKS5tdWx0aXBseVNjYWxhciggZG90ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRwcm9qZWN0T25QbGFuZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBwbGFuZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcclxuXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcclxuXHJcblx0XHR2YXIgdjE7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbm9ybWFsICkge1xyXG5cclxuXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9KCksXHJcblxyXG5cdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xyXG5cclxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYWNvcyggVEhSRUUuTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgZHggPSB0aGlzLnggLSB2Lng7XHJcblx0XHR2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHR2YXIgZHogPSB0aGlzLnogLSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcclxuXHJcblx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVF1YXRlcm5pb24oKSBpbnN0ZWFkLicgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIGluZGV4LCBtYXRyaXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gbS5lbGVtZW50c1sgMTIgXTtcclxuXHRcdHRoaXMueSA9IG0uZWxlbWVudHNbIDEzIF07XHJcblx0XHR0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHR2YXIgc3ggPSB0aGlzLnNldCggbS5lbGVtZW50c1sgMCBdLCBtLmVsZW1lbnRzWyAxIF0sIG0uZWxlbWVudHNbICAyIF0gKS5sZW5ndGgoKTtcclxuXHRcdHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgIDYgXSApLmxlbmd0aCgpO1xyXG5cdFx0dmFyIHN6ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbIDggXSwgbS5lbGVtZW50c1sgOSBdLCBtLmVsZW1lbnRzWyAxMCBdICkubGVuZ3RoKCk7XHJcblxyXG5cdFx0dGhpcy54ID0gc3g7XHJcblx0XHR0aGlzLnkgPSBzeTtcclxuXHRcdHRoaXMueiA9IHN6O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xyXG5cclxuXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBtZVsgb2Zmc2V0IF07XHJcblx0XHR0aGlzLnkgPSBtZVsgb2Zmc2V0ICsgMSBdO1xyXG5cdFx0dGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xyXG5cdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcclxuXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcclxuXHJcblx0ICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xyXG5cclxuXHQgICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcclxuXHJcblx0ICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcclxuXHQgICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcclxuXHQgICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcclxuXHJcblx0ICAgIHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdGhpcy54LCB0aGlzLnksIHRoaXMueiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKioqIEVORCBWZWN0b3IzICoqKi9cclxuLyoqKiBTVEFSVCBFdWxlciAqKiovXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xyXG5cclxuXHR0aGlzLl94ID0geCB8fCAwO1xyXG5cdHRoaXMuX3kgPSB5IHx8IDA7XHJcblx0dGhpcy5feiA9IHogfHwgMDtcclxuXHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IFRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlcjtcclxuXHJcbn07XHJcblxyXG5USFJFRS5FdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xyXG5cclxuVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XHJcblxyXG5USFJFRS5FdWxlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5FdWxlcixcclxuXHJcblx0X3g6IDAsIF95OiAwLCBfejogMCwgX29yZGVyOiBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXIsXHJcblxyXG5cdGdldCB4ICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5feDtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0IHggKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gdmFsdWU7XHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0IHkgKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl95O1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgeSAoIHZhbHVlICkge1xyXG5cclxuXHRcdHRoaXMuX3kgPSB2YWx1ZTtcclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXQgeiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3o7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldCB6ICggdmFsdWUgKSB7XHJcblxyXG5cdFx0dGhpcy5feiA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldCBvcmRlciAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXQgb3JkZXIgKCB2YWx1ZSApIHtcclxuXHJcblx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xyXG5cdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCBvcmRlciApIHtcclxuXHJcblx0XHR0aGlzLl94ID0geDtcclxuXHRcdHRoaXMuX3kgPSB5O1xyXG5cdFx0dGhpcy5feiA9IHo7XHJcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xyXG5cclxuXHRcdHRoaXMuX3ggPSBldWxlci5feDtcclxuXHRcdHRoaXMuX3kgPSBldWxlci5feTtcclxuXHRcdHRoaXMuX3ogPSBldWxlci5fejtcclxuXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHR2YXIgY2xhbXAgPSBUSFJFRS5NYXRoLmNsYW1wO1xyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdO1xyXG5cdFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XHJcblx0XHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XHJcblxyXG5cdFx0b3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XHJcblx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gMDtcclxuXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX3ggPSAwO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XHJcblx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMuX3kgPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xyXG5cclxuXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBtYXRyaXg7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcSwgb3JkZXIsIHVwZGF0ZSApIHtcclxuXHJcblx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXHJcblxyXG5cdFx0dmFyIHEgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIG5ld09yZGVyICkge1xyXG5cclxuXHRcdFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcclxuXHRcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xyXG5cdFx0dGhpcy5feiA9IGFycmF5WyAyIF07XHJcblx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcclxuXHJcblx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBbIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX29yZGVyIF07XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvVmVjdG9yMzogZnVuY3Rpb24gKCBvcHRpb25hbFJlc3VsdCApIHtcclxuXHJcblx0XHRpZiAoIG9wdGlvbmFsUmVzdWx0ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xyXG5cclxuXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkV1bGVyKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKioqIEVORCBFdWxlciAqKiovXHJcbi8qKiogU1RBUlQgTWF0aCAqKiovXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGggPSB7XHJcblxyXG5cdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXHJcblxyXG5cdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcclxuXHRcdHZhciB1dWlkID0gbmV3IEFycmF5KCAzNiApO1xyXG5cdFx0dmFyIHJuZCA9IDAsIHI7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDM2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGkgPT0gOCB8fCBpID09IDEzIHx8IGkgPT0gMTggfHwgaSA9PSAyMyApIHtcclxuXHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSAnLSc7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGkgPT0gMTQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XHJcblx0XHRcdFx0XHRyID0gcm5kICYgMHhmO1xyXG5cdFx0XHRcdFx0cm5kID0gcm5kID4+IDQ7XHJcblx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09IDE5ICkgPyAoIHIgJiAweDMgKSB8IDB4OCA6IHIgXTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdXVpZC5qb2luKCAnJyApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIHgsIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggeCA8IGEgKSA/IGEgOiAoICggeCA+IGIgKSA/IGIgOiB4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIENsYW1wIHZhbHVlIHRvIHJhbmdlIDxhLCBpbmYpXHJcblxyXG5cdGNsYW1wQm90dG9tOiBmdW5jdGlvbiAoIHgsIGEgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHggPCBhID8gYSA6IHg7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cclxuXHJcblx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xyXG5cclxuXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcclxuXHJcblx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcclxuXHJcblx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XHJcblx0XHRpZiAoIHggPj0gbWF4ICkgcmV0dXJuIDE7XHJcblxyXG5cdFx0eCA9ICggeCAtIG1pbiApIC8gKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XHJcblxyXG5cdFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xyXG5cdFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xyXG5cclxuXHRcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XHJcblxyXG5cdFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXHJcblx0Ly8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcclxuXHJcblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCA2NTI4MCAqIE1hdGgucmFuZG9tKCkgKyAyNTUgKiBNYXRoLnJhbmRvbSgpICkgLyA2NTUzNTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5mbG9vciggdGhpcy5yYW5kRmxvYXQoIGxvdywgaGlnaCApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXHJcblxyXG5cdHJhbmRGbG9hdDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHJhbmdlICogKCAwLjUgLSBNYXRoLnJhbmRvbSgpICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRlZ1RvUmFkOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcclxuXHJcblx0XHRcdHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmFkVG9EZWc6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgcmFkaWFuVG9EZWdyZWVzRmFjdG9yID0gMTgwIC8gTWF0aC5QSTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCByYWRpYW5zICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhZGlhbnMgKiByYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cclxuXHRcdHZhbHVlIC0tO1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDI7XHJcblx0XHR2YWx1ZSB8PSB2YWx1ZSA+PiA0O1xyXG5cdFx0dmFsdWUgfD0gdmFsdWUgPj4gODtcclxuXHRcdHZhbHVlIHw9IHZhbHVlID4+IDE2O1xyXG5cdFx0dmFsdWUgKys7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKioqIEVORCBNYXRoICoqKi9cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcblxyXG59LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIFRIUkVFID0gX2RlcmVxXygnLi90aHJlZS1tYXRoLmpzJyk7XHJcbnZhciBVdGlsID0gX2RlcmVxXygnLi91dGlsLmpzJyk7XHJcblxyXG52YXIgUk9UQVRFX1NQRUVEID0gMC41O1xyXG4vKipcclxuICogUHJvdmlkZXMgYSBxdWF0ZXJuaW9uIHJlc3BvbnNpYmxlIGZvciBwcmUtcGFubmluZyB0aGUgc2NlbmUgYmVmb3JlIGZ1cnRoZXJcclxuICogdHJhbnNmb3JtYXRpb25zIGR1ZSB0byBkZXZpY2Ugc2Vuc29ycy5cclxuICovXHJcbmZ1bmN0aW9uIFRvdWNoUGFubmVyKCkge1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnRfLmJpbmQodGhpcykpO1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlXy5iaW5kKHRoaXMpKTtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmRfLmJpbmQodGhpcykpO1xyXG5cclxuICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxuICB0aGlzLnJvdGF0ZVN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuICB0aGlzLnJvdGF0ZUVuZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcbiAgdGhpcy5yb3RhdGVEZWx0YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG4gIHRoaXMudGhldGEgPSAwO1xyXG4gIHRoaXMub3JpZW50YXRpb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG59XHJcblxyXG5Ub3VjaFBhbm5lci5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbigpIHtcclxuICB0aGlzLm9yaWVudGF0aW9uLnNldEZyb21FdWxlcihuZXcgVEhSRUUuRXVsZXIoMCwgMCwgdGhpcy50aGV0YSkpO1xyXG4gIHJldHVybiB0aGlzLm9yaWVudGF0aW9uO1xyXG59O1xyXG5cclxuVG91Y2hQYW5uZXIucHJvdG90eXBlLnJlc2V0U2Vuc29yID0gZnVuY3Rpb24oKSB7XHJcbiAgdGhpcy50aGV0YSA9IDA7XHJcbn07XHJcblxyXG5Ub3VjaFBhbm5lci5wcm90b3R5cGUub25Ub3VjaFN0YXJ0XyA9IGZ1bmN0aW9uKGUpIHtcclxuICAvLyBPbmx5IHJlc3BvbmQgaWYgdGhlcmUgaXMgZXhhY3RseSBvbmUgdG91Y2guXHJcbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB0aGlzLnJvdGF0ZVN0YXJ0LnNldChlLnRvdWNoZXNbMF0ucGFnZVgsIGUudG91Y2hlc1swXS5wYWdlWSk7XHJcbiAgdGhpcy5pc1RvdWNoaW5nID0gdHJ1ZTtcclxufTtcclxuXHJcblRvdWNoUGFubmVyLnByb3RvdHlwZS5vblRvdWNoTW92ZV8gPSBmdW5jdGlvbihlKSB7XHJcbiAgaWYgKCF0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgdGhpcy5yb3RhdGVFbmQuc2V0KGUudG91Y2hlc1swXS5wYWdlWCwgZS50b3VjaGVzWzBdLnBhZ2VZKTtcclxuICB0aGlzLnJvdGF0ZURlbHRhLnN1YlZlY3RvcnModGhpcy5yb3RhdGVFbmQsIHRoaXMucm90YXRlU3RhcnQpO1xyXG4gIHRoaXMucm90YXRlU3RhcnQuY29weSh0aGlzLnJvdGF0ZUVuZCk7XHJcblxyXG4gIC8vIE9uIGlPUywgZGlyZWN0aW9uIGlzIGludmVydGVkLlxyXG4gIGlmIChVdGlsLmlzSU9TKCkpIHtcclxuICAgIHRoaXMucm90YXRlRGVsdGEueCAqPSAtMTtcclxuICB9XHJcblxyXG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcclxuICB0aGlzLnRoZXRhICs9IDIgKiBNYXRoLlBJICogdGhpcy5yb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRXaWR0aCAqIFJPVEFURV9TUEVFRDtcclxufTtcclxuXHJcblRvdWNoUGFubmVyLnByb3RvdHlwZS5vblRvdWNoRW5kXyA9IGZ1bmN0aW9uKGUpIHtcclxuICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVG91Y2hQYW5uZXI7XHJcblxyXG59LHtcIi4vdGhyZWUtbWF0aC5qc1wiOjksXCIuL3V0aWwuanNcIjoxMX1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTUgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgVXRpbCA9IHdpbmRvdy5VdGlsIHx8IHt9O1xyXG5cclxuVXRpbC5NSU5fVElNRVNURVAgPSAwLjAwMTtcclxuVXRpbC5NQVhfVElNRVNURVAgPSAxO1xyXG5cclxuVXRpbC5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xyXG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcclxufTtcclxuXHJcblV0aWwuaXNJT1MgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcclxufTtcclxuXHJcblV0aWwuaXNGaXJlZm94QW5kcm9pZCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xO1xyXG59XHJcblxyXG4vLyBIZWxwZXIgbWV0aG9kIHRvIHZhbGlkYXRlIHRoZSB0aW1lIHN0ZXBzIG9mIHNlbnNvciB0aW1lc3RhbXBzLlxyXG5VdGlsLmlzVGltZXN0YW1wRGVsdGFWYWxpZCA9IGZ1bmN0aW9uKHRpbWVzdGFtcERlbHRhUykge1xyXG4gIGlmIChpc05hTih0aW1lc3RhbXBEZWx0YVMpKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPD0gVXRpbC5NSU5fVElNRVNURVApIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKHRpbWVzdGFtcERlbHRhUyA+IFV0aWwuTUFYX1RJTUVTVEVQKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XHJcblxyXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDE1IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuXHJcbnZhciBDYXJkYm9hcmRITURWUkRldmljZSA9IF9kZXJlcV8oJy4vY2FyZGJvYXJkLWhtZC12ci1kZXZpY2UuanMnKTtcclxuLy92YXIgT3JpZW50YXRpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlID0gcmVxdWlyZSgnLi9vcmllbnRhdGlvbi1wb3NpdGlvbi1zZW5zb3ItdnItZGV2aWNlLmpzJyk7XHJcbnZhciBGdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlID0gX2RlcmVxXygnLi9mdXNpb24tcG9zaXRpb24tc2Vuc29yLXZyLWRldmljZS5qcycpO1xyXG52YXIgTW91c2VLZXlib2FyZFBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSBfZGVyZXFfKCcuL21vdXNlLWtleWJvYXJkLXBvc2l0aW9uLXNlbnNvci12ci1kZXZpY2UuanMnKTtcclxuLy8gVW5jb21tZW50IHRvIGFkZCBwb3NpdGlvbmFsIHRyYWNraW5nIHZpYSB3ZWJjYW0uXHJcbi8vdmFyIFdlYmNhbVBvc2l0aW9uU2Vuc29yVlJEZXZpY2UgPSByZXF1aXJlKCcuL3dlYmNhbS1wb3NpdGlvbi1zZW5zb3ItdnItZGV2aWNlLmpzJyk7XHJcbnZhciBITURWUkRldmljZSA9IF9kZXJlcV8oJy4vYmFzZS5qcycpLkhNRFZSRGV2aWNlO1xyXG52YXIgUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IF9kZXJlcV8oJy4vYmFzZS5qcycpLlBvc2l0aW9uU2Vuc29yVlJEZXZpY2U7XHJcblxyXG5mdW5jdGlvbiBXZWJWUlBvbHlmaWxsKCkge1xyXG4gIHRoaXMuZGV2aWNlcyA9IFtdO1xyXG5cclxuICBpZiAoIXRoaXMuaXNXZWJWUkF2YWlsYWJsZSgpKSB7XHJcbiAgICB0aGlzLmVuYWJsZVBvbHlmaWxsKCk7XHJcbiAgfVxyXG59XHJcblxyXG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5pc1dlYlZSQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuICgnZ2V0VlJEZXZpY2VzJyBpbiBuYXZpZ2F0b3IpIHx8ICgnbW96R2V0VlJEZXZpY2VzJyBpbiBuYXZpZ2F0b3IpO1xyXG59O1xyXG5cclxuXHJcbldlYlZSUG9seWZpbGwucHJvdG90eXBlLmVuYWJsZVBvbHlmaWxsID0gZnVuY3Rpb24oKSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBvdXIgdmlydHVhbCBWUiBkZXZpY2VzLlxyXG4gIGlmICh0aGlzLmlzQ2FyZGJvYXJkQ29tcGF0aWJsZSgpKSB7XHJcbiAgICB0aGlzLmRldmljZXMucHVzaChuZXcgQ2FyZGJvYXJkSE1EVlJEZXZpY2UoKSk7XHJcbiAgfVxyXG5cclxuICAvLyBQb2x5ZmlsbCB1c2luZyB0aGUgcmlnaHQgcG9zaXRpb24gc2Vuc29yLlxyXG4gIGlmICh0aGlzLmlzTW9iaWxlKCkpIHtcclxuICAgIC8vdGhpcy5kZXZpY2VzLnB1c2gobmV3IE9yaWVudGF0aW9uUG9zaXRpb25TZW5zb3JWUkRldmljZSgpKTtcclxuICAgIHRoaXMuZGV2aWNlcy5wdXNoKG5ldyBGdXNpb25Qb3NpdGlvblNlbnNvclZSRGV2aWNlKCkpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIVdlYlZSQ29uZmlnLk1PVVNFX0tFWUJPQVJEX0NPTlRST0xTX0RJU0FCTEVEKSB7XHJcbiAgICAgIHRoaXMuZGV2aWNlcy5wdXNoKG5ldyBNb3VzZUtleWJvYXJkUG9zaXRpb25TZW5zb3JWUkRldmljZSgpKTtcclxuICAgIH1cclxuICAgIC8vIFVuY29tbWVudCB0byBhZGQgcG9zaXRpb25hbCB0cmFja2luZyB2aWEgd2ViY2FtLlxyXG4gICAgLy90aGlzLmRldmljZXMucHVzaChuZXcgV2ViY2FtUG9zaXRpb25TZW5zb3JWUkRldmljZSgpKTtcclxuICB9XHJcblxyXG4gIC8vIFByb3ZpZGUgbmF2aWdhdG9yLmdldFZSRGV2aWNlcy5cclxuICBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzID0gdGhpcy5nZXRWUkRldmljZXMuYmluZCh0aGlzKTtcclxuXHJcbiAgLy8gUHJvdmlkZSB0aGUgQ2FyZGJvYXJkSE1EVlJEZXZpY2UgYW5kIFBvc2l0aW9uU2Vuc29yVlJEZXZpY2Ugb2JqZWN0cy5cclxuICB3aW5kb3cuSE1EVlJEZXZpY2UgPSBITURWUkRldmljZTtcclxuICB3aW5kb3cuUG9zaXRpb25TZW5zb3JWUkRldmljZSA9IFBvc2l0aW9uU2Vuc29yVlJEZXZpY2U7XHJcbn07XHJcblxyXG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5nZXRWUkRldmljZXMgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgZGV2aWNlcyA9IHRoaXMuZGV2aWNlcztcclxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXNvbHZlKGRldmljZXMpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICByZWplY3QoZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIGlmIGEgZGV2aWNlIGlzIG1vYmlsZS5cclxuICovXHJcbldlYlZSUG9seWZpbGwucHJvdG90eXBlLmlzTW9iaWxlID0gZnVuY3Rpb24oKSB7XHJcbiAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxyXG4gICAgICAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbn07XHJcblxyXG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5pc0NhcmRib2FyZENvbXBhdGlibGUgPSBmdW5jdGlvbigpIHtcclxuICAvLyBGb3Igbm93LCBzdXBwb3J0IGFsbCBpT1MgYW5kIEFuZHJvaWQgZGV2aWNlcy5cclxuICAvLyBBbHNvIGVuYWJsZSB0aGUgV2ViVlJDb25maWcuRk9SQ0VfVlIgZmxhZyBmb3IgZGVidWdnaW5nLlxyXG4gIHJldHVybiB0aGlzLmlzTW9iaWxlKCkgfHwgV2ViVlJDb25maWcuRk9SQ0VfRU5BQkxFX1ZSO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJWUlBvbHlmaWxsO1xyXG5cclxufSx7XCIuL2Jhc2UuanNcIjoxLFwiLi9jYXJkYm9hcmQtaG1kLXZyLWRldmljZS5qc1wiOjIsXCIuL2Z1c2lvbi1wb3NpdGlvbi1zZW5zb3ItdnItZGV2aWNlLmpzXCI6NCxcIi4vbW91c2Uta2V5Ym9hcmQtcG9zaXRpb24tc2Vuc29yLXZyLWRldmljZS5qc1wiOjZ9XX0se30sWzVdKTtcclxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJhZnJhbWVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC4xLjFcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkJ1aWxkaW5nIGJsb2NrcyBmb3IgdGhlIFZSIFdlYlwiLFxuICBcIm1haW5cIjogXCJzcmMvaW5kZXguanNcIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJicm93c2VyaWZ5IHNyYy9pbmRleC5qcyAtcyAnQUZSQU1FJyAtcCBicm93c2VyaWZ5LWRlcmVxdWlyZVwiLFxuICAgIFwiYnVpbGRcIjogXCJta2RpcnAgYnVpbGQvICYmIG5wbSBydW4gYnJvd3NlcmlmeSAtLSAtLWRlYnVnIC1vIGJ1aWxkL2FmcmFtZS5qc1wiLFxuICAgIFwiZGV2XCI6IFwibnBtIHJ1biBidWlsZCAmJiBub2RlIC4vc2NyaXB0cy9idWRvXCIsXG4gICAgXCJkaXN0XCI6IFwibWtkaXJwIGRpc3QvICYmIG5wbSBydW4gYnJvd3NlcmlmeSAtcyAtLSAtLWRlYnVnIHwgZXhvcmNpc3QgZGlzdC9hZnJhbWUuanMubWFwID4gZGlzdC9hZnJhbWUuanMgJiYgdWdsaWZ5anMgZGlzdC9hZnJhbWUuanMgLWMgd2FybmluZ3M9ZmFsc2UgLW0gLW8gZGlzdC9hZnJhbWUubWluLmpzXCIsXG4gICAgXCJnaC1wYWdlc1wiOiBcIm5wbSBydW4gZ2hwYWdlc1wiLFxuICAgIFwiZ2hwYWdlc1wiOiBcIm5vZGUgLi9zY3JpcHRzL2doLXBhZ2VzXCIsXG4gICAgXCJsaW50XCI6IFwic2VtaXN0YW5kYXJkIC12ICQoZ2l0IGxzLWZpbGVzICcqLmpzJykgfCBzdGFuZGFyZC1yZXBvcnRlciAtLXN0eWxpc2hcIixcbiAgICBcInByZWNvbW1pdFwiOiBcIm5wbSBydW4gbGludFwiLFxuICAgIFwicHJlZ2hwYWdlc1wiOiBcIm5wbSBydW4gZGlzdCAmJiByaW1yYWYgZ2gtcGFnZXMgJiYgbWtkaXJwIGdoLXBhZ2VzICYmIGNwIC1yIHsubm9qZWt5bGwsZGlzdCxsaWIsZXhhbXBsZXMsaW5kZXguaHRtbCxzdHlsZX0gZ2gtcGFnZXMvLiAyPi9kZXYvbnVsbCB8fCA6ICYmIGdpdCBjaGVja291dCBkaXN0LyAmJiByZXBsYWNlICdidWlsZC9hZnJhbWUuanMnICdkaXN0L2FmcmFtZS5taW4uanMnIGdoLXBhZ2VzLyAtciAtLXNpbGVudFwiLFxuICAgIFwicmVsZWFzZTpidW1wXCI6IFwibnBtIHJ1biBkaXN0ICYmIGdpdCBjb21taXQgLWFtICdidW1wIGRpc3QnICYmIG5wbSB2ZXJzaW9uIHBhdGNoIC0tcHJlbWlub3JcIixcbiAgICBcInJlbGVhc2U6cHVzaFwiOiBcIm5wbSBsb2dpbiAmJiBucG0gcHVibGlzaCAmJiBnaXQgcHVzaCAtLWZvbGxvdy10YWdzXCIsXG4gICAgXCJzdGFydFwiOiBcIm5wbSBydW4gZGV2XCIsXG4gICAgXCJ0ZXN0XCI6IFwia2FybWEgc3RhcnQgLi90ZXN0cy9rYXJtYS5jb25mLmpzXCIsXG4gICAgXCJ0ZXN0OmNpXCI6IFwiVEVTVF9FTlY9Y2kga2FybWEgc3RhcnQgLi90ZXN0cy9rYXJtYS5jb25mLmpzIC0tc2luZ2xlLXJ1blwiLFxuICAgIFwidmVyc2lvblwiOiBcIm5wbSBydW4gZGlzdFwiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiBcImFmcmFtZXZyL2FmcmFtZVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnJvd3NlcmlmeS1jc3NcIjogXCJeMC44LjJcIixcbiAgICBcImRlYnVnXCI6IFwiXjIuMi4wXCIsXG4gICAgXCJkb2N1bWVudC1yZWdpc3Rlci1lbGVtZW50XCI6IFwiXjAuNS4yXCIsXG4gICAgXCJlczYtcHJvbWlzZVwiOiBcIl4zLjAuMlwiLFxuICAgIFwib2JqZWN0LWFzc2lnblwiOiBcIl40LjAuMVwiLFxuICAgIFwicHJlc2VudFwiOiBcIjAuMC42XCIsXG4gICAgXCJyZXF1ZXN0LWludGVydmFsXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJzdHlsZS1hdHRyXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJ0aHJlZS1kZXZcIjogXCJeMC43NC4wLWJldGE4XCIsXG4gICAgXCJ0d2Vlbi5qc1wiOiBcIl4xNS4wLjBcIixcbiAgICBcIndlYnZyLXBvbHlmaWxsXCI6IFwiYm9yaXNtdXMvd2VidnItcG9seWZpbGwjM2Y0Nzc5NlwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyb3dzZXJpZnlcIjogXCJeMTEuMC4xXCIsXG4gICAgXCJicm93c2VyaWZ5LWNzc1wiOiBcIl4wLjguMlwiLFxuICAgIFwiYnJvd3NlcmlmeS1kZXJlcXVpcmVcIjogXCJeMC45LjRcIixcbiAgICBcImJ1ZG9cIjogXCJeNy4wLjJcIixcbiAgICBcImNoYWktc2hhbGxvdy1kZWVwLWVxdWFsXCI6IFwiXjEuMy4wXCIsXG4gICAgXCJjb3B5ZmlsZXNcIjogXCIwLjIuMVwiLFxuICAgIFwiZXhvcmNpc3RcIjogXCJeMC40LjBcIixcbiAgICBcImdoLXBhZ2VzXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJodG1sLW1pbmlmaWVyXCI6IFwiXjAuOC4wXCIsXG4gICAgXCJodXNreVwiOiBcIl4wLjEwLjFcIixcbiAgICBcImthcm1hXCI6IFwiXjAuMTMuMTVcIixcbiAgICBcImthcm1hLWJyb3dzZXJpZnlcIjogXCJeNC40LjBcIixcbiAgICBcImthcm1hLWNoYWktc2hhbGxvdy1kZWVwLWVxdWFsXCI6IFwiMC4wLjRcIixcbiAgICBcImthcm1hLWVudi1wcmVwcm9jZXNzb3JcIjogXCJeMC4xLjFcIixcbiAgICBcImthcm1hLWZpcmVmb3gtbGF1bmNoZXJcIjogXCJeMC4xLjZcIixcbiAgICBcImthcm1hLW1vY2hhXCI6IFwiXjAuMi4wXCIsXG4gICAgXCJrYXJtYS1tb2NoYS1yZXBvcnRlclwiOiBcIl4xLjEuMFwiLFxuICAgIFwia2FybWEtc2lub24tY2hhaVwiOiBcIl4xLjEuMFwiLFxuICAgIFwibWtkaXJwXCI6IFwiMC41LjFcIixcbiAgICBcIm1vY2hhXCI6IFwiXjIuMy4zXCIsXG4gICAgXCJtb3ppbGxhLWRvd25sb2FkXCI6IFwiXjEuMC41XCIsXG4gICAgXCJuY3BcIjogXCIyLjAuMFwiLFxuICAgIFwib3BlblwiOiBcIjAuMC41XCIsXG4gICAgXCJwb2x5bWVyaXplXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJyZXBsYWNlXCI6IFwiXjAuMy4wXCIsXG4gICAgXCJyaW1yYWZcIjogXCIyLjUuMFwiLFxuICAgIFwic2VtaXN0YW5kYXJkXCI6IFwiXjcuMC4yXCIsXG4gICAgXCJzdGFuZGFyZC1yZXBvcnRlclwiOiBcIl4xLjAuNVwiLFxuICAgIFwidWdsaWZ5anNcIjogXCJeMi40LjEwXCJcbiAgfSxcbiAgXCJsaW5rXCI6IHRydWUsXG4gIFwiYnJvd3NlcmlmeVwiOiB7XG4gICAgXCJ0cmFuc2Zvcm1cIjogW1xuICAgICAgXCJicm93c2VyaWZ5LWNzc1wiLFxuICAgICAgW1xuICAgICAgICBcInBvbHltZXJpemVcIixcbiAgICAgICAge1xuICAgICAgICAgIFwibWF0Y2hcIjogXCIuKi5odG1sJFwiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICBdXG4gIH0sXG4gIFwic2VtaXN0YW5kYXJkXCI6IHtcbiAgICBcImlnbm9yZVwiOiBbXG4gICAgICBcImJ1aWxkLyoqXCIsXG4gICAgICBcImRpc3QvKipcIixcbiAgICAgIFwiZXhhbXBsZXMvX2pzLyoqXCIsXG4gICAgICBcImxpYi92ZW5kb3IvKipcIlxuICAgIF1cbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJhZnJhbWVcIixcbiAgICBcInZyXCIsXG4gICAgXCJ3ZWJ2clwiLFxuICAgIFwiM2RcIixcbiAgICBcInRocmVlXCIsXG4gICAgXCJjb21wb25lbnRzXCIsXG4gICAgXCJlbGVtZW50c1wiXG4gIF0sXG4gIFwiYnJvd3NlcmlmeS1jc3NcIjoge1xuICAgIFwibWluaWZ5XCI6IHRydWVcbiAgfSxcbiAgXCJlbmdpbmVzXCI6IHtcbiAgICBcIm5vZGVcIjogXCI+PSAwLjEyLjdcIixcbiAgICBcIm5wbVwiOiBcIj49IDIuMTIuMVwiXG4gIH1cbn1cbiIsInZhciByZWdpc3RlckNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2NhbWVyYScsIHtcbiAgc2NoZW1hOiB7XG4gICAgYWN0aXZlOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICBmYXI6IHsgZGVmYXVsdDogMTAwMDAgfSxcbiAgICBmb3Y6IHsgZGVmYXVsdDogODAsIG1pbjogMCB9LFxuICAgIG5lYXI6IHsgZGVmYXVsdDogMC41LCBtaW46IDAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aHJlZS5qcyBjYW1lcmEsIGFkZGluZyBpdCB0byB0aGUgZW50aXR5LlxuICAgKiBBZGRzIGEgcmVmZXJlbmNlIGZyb20gdGhlIHNjZW5lIHRvIHRoaXMgZW50aXR5IGFzIHRoZSBjYW1lcmEuXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBlbC5zZXRPYmplY3QzRCgnY2FtZXJhJywgY2FtZXJhKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGNhbWVyYSBvbiByZW1vdmUgKGNhbGxiYWNrKS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwuc2V0T2JqZWN0M0QoJ2NhbWVyYScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRocmVlLmpzIGNhbWVyYS5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBzY2VuZUVsID0gZWwuc2NlbmVFbDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XG4gICAgY2FtZXJhLmFzcGVjdCA9IGRhdGEuYXNwZWN0IHx8ICh3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY2FtZXJhLmZhciA9IGRhdGEuZmFyO1xuICAgIGNhbWVyYS5mb3YgPSBkYXRhLmZvdjtcbiAgICBjYW1lcmEubmVhciA9IGRhdGEubmVhcjtcbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIC8vIElmIHRoZSBhY3RpdmUgcHJvcGVydHkgaGFzIGNoYW5nZXMgb3Igb24gZmlyc3QgdXBkYXRlIGNhbGxcbiAgICBpZiAoIW9sZERhdGEgfHwgb2xkRGF0YS5hY3RpdmUgIT09IGRhdGEuYWN0aXZlKSB7XG4gICAgICBpZiAoZGF0YS5hY3RpdmUpIHtcbiAgICAgICAgc2NlbmVFbC5zZXRBY3RpdmVDYW1lcmEoY2FtZXJhKTtcbiAgICAgIH0gZWxzZSBpZiAoc2NlbmVFbC5jYW1lcmEgPT09IGNhbWVyYSkge1xuICAgICAgICAvLyBJZiB0aGUgY2FtZXJhIGlzIGRpc2FibGVkIGFuZCBpcyB0aGUgY3VycmVudCBhY3RpdmUgb25lXG4gICAgICAgIHNjZW5lRWwuc2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbiIsInZhciByZWdpc3RlckNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy8nKTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2N1cnNvcicsIHtcbiAgc2NoZW1hOiB7XG4gICAgdGltZW91dDogeyBkZWZhdWx0OiAxNTAwLCBtaW46IDAgfSxcbiAgICBtYXhEaXN0YW5jZTogeyBkZWZhdWx0OiA1LCBtaW46IDAgfSxcbiAgICBmdXNlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgfSxcblxuICBkZXBlbmRlbmNpZXM6IFsgJ3JheWNhc3RlcicgXSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yYXljYXN0ZXIgPSB0aGlzLmVsLmNvbXBvbmVudHMucmF5Y2FzdGVyO1xuICAgIC8vIFRoZSBjdXJzb3IgZGVmYXVsdHMgdG8gZnVzZSBpbiBtb2JpbGUgZW52aXJvbm1lbnRzXG4gICAgdGhpcy5zY2hlbWEuZnVzZS5kZWZhdWx0ID0gdXRpbHMuaXNNb2JpbGUoKTtcbiAgICB0aGlzLmF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgYXR0YWNoRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBjYW52YXMgPSBlbC5zY2VuZUVsLmNhbnZhcztcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcykpO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG5cbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnRlcnNlY3Rpb24nLCB0aGlzLm9uSW50ZXJzZWN0aW9uLmJpbmQodGhpcykpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ludGVyc2VjdGlvbmNsZWFyZWQnLCB0aGlzLm9uSW50ZXJzZWN0aW9uQ2xlYXJlZC5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgIHRoaXMuZW1pdCgnbW91c2Vkb3duJyk7XG4gICAgdGhpcy5tb3VzZURvd25FbCA9IHRoaXMuaW50ZXJzZWN0ZWRFbDtcbiAgfSxcblxuICBvbk1vdXNlVXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVtaXQoJ21vdXNldXAnKTtcbiAgICBpZiAodGhpcy5kYXRhLmZ1c2UpIHsgcmV0dXJuOyB9XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdGVkRWwpIHsgcmV0dXJuOyB9XG4gICAgaWYgKHRoaXMubW91c2VEb3duRWwgPT09IHRoaXMuaW50ZXJzZWN0ZWRFbCkge1xuICAgICAgdGhpcy5lbWl0KCdjbGljaycpO1xuICAgIH1cbiAgfSxcblxuICBlbWl0OiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIGludGVyc2VjdGVkRWwgPSB0aGlzLmludGVyc2VjdGVkRWw7XG4gICAgdGhpcy5lbC5lbWl0KGV2dCk7XG4gICAgaWYgKGludGVyc2VjdGVkRWwpIHsgaW50ZXJzZWN0ZWRFbC5lbWl0KGV2dCk7IH1cbiAgfSxcblxuICBlbWl0dGVyOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW1pdChldnQpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgfSxcblxuICBvbkludGVyc2VjdGlvbjogZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSBldnQuZGV0YWlsLmVsO1xuICAgIHZhciBkaXN0YW5jZSA9IGV2dC5kZXRhaWwuZGlzdGFuY2U7XG4gICAgaWYgKHRoaXMuaW50ZXJzZWN0ZWRFbCA9PT0gZWwpIHsgcmV0dXJuOyB9XG4gICAgaWYgKGRpc3RhbmNlID49IHRoaXMuZGF0YS5tYXhEaXN0YW5jZSkgeyByZXR1cm47IH1cbiAgICB0aGlzLmludGVyc2VjdGVkRWwgPSBlbDtcbiAgICBlbC5hZGRTdGF0ZSgnaG92ZXJlZCcpO1xuICAgIGVsLmVtaXQoJ21vdXNlZW50ZXInKTtcbiAgICB0aGlzLmVsLmFkZFN0YXRlKCdob3ZlcmluZycpO1xuICAgIGlmIChkYXRhLnRpbWVvdXQgPT09IDApIHsgcmV0dXJuOyB9XG4gICAgaWYgKCFkYXRhLmZ1c2UpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5lbC5hZGRTdGF0ZSgnZnVzaW5nJyk7XG4gICAgdGhpcy5mdXNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVzZSwgZGF0YS50aW1lb3V0KTtcbiAgICBmdW5jdGlvbiBmdXNlICgpIHtcbiAgICAgIHNlbGYuZWwucmVtb3ZlU3RhdGUoJ2Z1c2luZycpO1xuICAgICAgc2VsZi5lbWl0KCdjbGljaycpO1xuICAgIH1cbiAgfSxcblxuICBvbkludGVyc2VjdGlvbkNsZWFyZWQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICB2YXIgZWwgPSBldnQuZGV0YWlsLmVsO1xuICAgIGlmICghZWwgfHwgIXRoaXMuaW50ZXJzZWN0ZWRFbCkgeyByZXR1cm47IH1cbiAgICB0aGlzLmludGVyc2VjdGVkRWwgPSBudWxsO1xuICAgIGVsLnJlbW92ZVN0YXRlKCdob3ZlcmVkJyk7XG4gICAgZWwuZW1pdCgnbW91c2VsZWF2ZScpO1xuICAgIHRoaXMuZWwucmVtb3ZlU3RhdGUoJ2hvdmVyaW5nJyk7XG4gICAgdGhpcy5lbC5yZW1vdmVTdGF0ZSgnZnVzaW5nJyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZnVzZVRpbWVvdXQpO1xuICB9XG59KTtcbiIsInZhciByZWdpc3RlciA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlYnVnJyk7XG5cbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6Zm9nOndhcm4nKTtcblxuLyoqXG4gKiBGb2cgY29tcG9uZW50LlxuICogQXBwbGllcyBvbmx5IHRvIHRoZSBzY2VuZSBlbnRpdHkuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyKCdmb2cnLCB7XG4gIHNjaGVtYToge1xuICAgIGNvbG9yOiB7IGRlZmF1bHQ6ICcjMDAwJyB9LFxuICAgIGRlbnNpdHk6IHsgZGVmYXVsdDogMC4wMDAyNSB9LFxuICAgIGZhcjogeyBkZWZhdWx0OiAxMDAwLCBtaW46IDAgfSxcbiAgICBuZWFyOiB7IGRlZmF1bHQ6IDEsIG1pbjogMCB9LFxuICAgIHR5cGU6IHsgZGVmYXVsdDogJ2xpbmVhcicsIG9uZU9mOiBbJ2xpbmVhcicsICdleHBvbmVudGlhbCddIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBmb2cgPSB0aGlzLmVsLm9iamVjdDNELmZvZztcblxuICAgIGlmICghZWwuaXNTY2VuZSkge1xuICAgICAgd2FybignRm9nIGNvbXBvbmVudCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIDxhLXNjZW5lPicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIChSZSljcmVhdGUgZm9nIGlmIGZvZyBkb2Vzbid0IGV4aXN0IG9yIGZvZyB0eXBlIGNoYW5nZWQuXG4gICAgaWYgKCFmb2cgfHwgZGF0YS50eXBlICE9PSBmb2cubmFtZSkge1xuICAgICAgZWwub2JqZWN0M0QuZm9nID0gZ2V0Rm9nKGRhdGEpO1xuICAgICAgZWwudXBkYXRlTWF0ZXJpYWxzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9nIGRhdGEgY2hhbmdlZC4gVXBkYXRlIGZvZy5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICBpZiAoa2V5ID09PSAnY29sb3InKSB7IHZhbHVlID0gbmV3IFRIUkVFLkNvbG9yKHZhbHVlKTsgfVxuICAgICAgZm9nW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGZvZyBvbiByZW1vdmUgKGNhbGxiYWNrKS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2cgPSB0aGlzLmVsLm9iamVjdDNELmZvZztcbiAgICBpZiAoZm9nKSB7XG4gICAgICBmb2cuZGVuc2l0eSA9IDA7XG4gICAgICBmb2cuZmFyID0gMDtcbiAgICAgIGZvZy5uZWFyID0gMDtcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmb2cgb2JqZWN0LiBTZXRzIGZvZy5uYW1lIHRvIGJlIGFibGUgdG8gZGV0ZWN0IGZvZyB0eXBlIGNoYW5nZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBGb2cgZGF0YS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IGZvZ1xuICovXG5mdW5jdGlvbiBnZXRGb2cgKGRhdGEpIHtcbiAgdmFyIGZvZztcbiAgaWYgKGRhdGEudHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgIGZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKGRhdGEuY29sb3IsIGRhdGEuZGVuc2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgZm9nID0gbmV3IFRIUkVFLkZvZyhkYXRhLmNvbG9yLCBkYXRhLm5lYXIsIGRhdGEuZmFyKTtcbiAgfVxuICBmb2cubmFtZSA9IGRhdGEudHlwZTtcbiAgcmV0dXJuIGZvZztcbn1cbiIsInZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgREVGQVVMVF9SQURJVVMgPSAxO1xudmFyIGhlbHBlck1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG52YXIgZGVnVG9SYWQgPSBUSFJFRS5NYXRoLmRlZ1RvUmFkO1xudmFyIHdhcm4gPSBkZWJ1ZygnY29tcG9uZW50czpnZW9tZXRyeTp3YXJuJyk7XG5cbi8qKlxuICogR2VvbWV0cnkgY29tcG9uZW50LiBDb21iaW5lZCB3aXRoIG1hdGVyaWFsIGNvbXBvbmVudCB0byBtYWtlIGEgbWVzaCBpbiAzRCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmM9MzYwXSAtXG4gKiAgIFVzZWQgYnkgdG9ydXMuIEEgY2VudHJhbCBhbmdsZSB0aGF0IGRldGVybWluZXMgYXJjIGxlbmd0aCBvZiB0aGUgdG9ydXMuIEluIGRlZ3JlZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTJdIC0gVXNlZCBieSBib3guIERlcHRoIG9mIHRoZSBzaWRlcyBvbiB0aGUgWiBheGlzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHQ9Ml0gLVxuICogICBVc2VkIGJ5IGJveCwgY3lsaW5kZXIsIHBsYW5lLiBIZWlnaHQgb2YgdGhlIHNpZGVzIG9uIHRoZSBZIGF4aXMuXG4gKiBAcGFyYW0ge2Jvb2x9IFtvcGVuRW5kZWQ9ZmFsc2VdIC0gVXNlZCBieSBjeWxpbmRlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcD0yXSAtIFVzZWQgYnkgdG9ydXNLbm90LiBDb3ByaW1lIG9mIHEuXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW1pdGl2ZT1udWxsXSAtIHR5cGUgb2Ygc2hhcGUgKGUuZy4sIGJveCwgc3BoZXJlKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcT0zXSAtIFVzZWQgYnkgdG9ydXNLbm90LiBDb3ByaW1lIG9mIHAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3JhZGl1cz0xXSAtIFVzZWQgYnkgY2lyY2xlLCBjeWxpbmRlciwgcmluZywgc3BoZXJlLCB0b3J1cywgdG9ydXNLbm90LlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNCb3R0b209MV0gLSBVc2VkIGJ5IGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNJbm5lcj0wLjhdIC0gVXNlZCBieSByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNPdXRlcj0xLjJdIC0gVXNlZCBieSByaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNUb3A9MV0gLSBVc2VkIGJ5IGN5bGluZGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpdXNUdWJlPTAuMl0gLSBVc2VkIGJ5IHRvcnVzLiBUdWJlIHJhZGl1cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVIZWlnaHQ9MV0gLSBVc2VkIGJ5IHRvcnVzS25vdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2VnbWVudHM9OF0gLSBVc2VkIGJ5IGNpcmNsZS4gTnVtYmVyIG9mIHNlZ21lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzZWdtZW50c0hlaWdodD0xOF0gLSBVc2VkIGJ5IGN5bGluZGVyLCBzcGhlcmUuIE51bWJlciBvZiBzZWdtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2VnbWVudHNQaGk9OF0gLSBVc2VkIGJ5IHJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NlZ21lbnRzUmFkaWFsPTM2XSAtIFVzZWQgYnkgY3lsaW5kZXIuIE51bWJlciBvZiBzZWdtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2VnbWVudHNUaGV0YT04XSAtXG4gKiAgIFVzZWQgYnkgcmluZy4gTnVtYmVyIG9mIHNlZ21lbnRzLiBBIGhpZ2hlciBudW1iZXIgbWVhbnMgdGhlIHJpbmcgd2lsbCBiZSBtb3JlIHJvdW5kLlxuICogICBNaW5pbXVtIGlzIDMuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NlZ21lbnRzVHVidWxhcj04XSAtIFVzZWQgYnkgdG9ydXMsIHRvcnVzS25vdC4gTnVtYmVyIG9mIHNlZ21lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzZWdtZW50c1dpZHRoPTM2XSAtIFVzZWQgYnkgc3BoZXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YUxlbmd0aD0zNjBdIC0gVXNlZCBieSBjaXJjbGUsIGN5bGluZGVyLCByaW5nLiBJbiBkZWdyZWVzLlxuICogQHBhcmFtIHtudW1iZXJ9IFt0aGV0YVN0YXJ0PTBdIC0gVXNlZCBieSBjaXJjbGUsIGN5bGluZGVyLCByaW5nLiBJbiBkZWdyZWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zbGF0ZSAtXG4gKiAgIERlZmluZWQgYXMgYSBjb29yZGluYXRlIChlLmcuLCBgLTEgMCA1YCkgdGhhdCB0cmFuc2xhdGVzIGdlb21ldHJ5IHZlcnRpY2VzLiBVc2VmdWwgZm9yXG4gKiAgIGVmZmVjdGl2ZWx5IGNoYW5naW5nIHRoZSBwaXZvdCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9Ml0gLSBVc2VkIGJ5IGJveCwgcGxhbmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdnZW9tZXRyeScsIHtcbiAgc2NoZW1hOiB7XG4gICAgYXJjOiB7IGRlZmF1bHQ6IDM2MCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3RvcnVzJ10gfSB9LFxuICAgIGRlcHRoOiB7IGRlZmF1bHQ6IDIsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2JveCddIH0gfSxcbiAgICBoZWlnaHQ6IHsgZGVmYXVsdDogMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsnYm94JywgJ3BsYW5lJ10gfSB9LFxuICAgIG9wZW5FbmRlZDogeyBkZWZhdWx0OiBmYWxzZSwgaWY6IHsgcHJpbWl0aXZlOiBbJ2N5bGluZGVyJ10gfSB9LFxuICAgIHA6IHsgZGVmYXVsdDogMiwgaWY6IHsgcHJpbWl0aXZlOiBbJ3RvcnVzS25vdCddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgcHJpbWl0aXZlOiB7XG4gICAgICBkZWZhdWx0OiAnJyxcbiAgICAgIG9uZU9mOiBbJycsICdib3gnLCAnY2lyY2xlJywgJ2N5bGluZGVyJywgJ3BsYW5lJyxcbiAgICAgICAgICAgICAgJ3JpbmcnLCAnc3BoZXJlJywgJ3RvcnVzJywgJ3RvcnVzS25vdCddIH0sXG4gICAgcTogeyBkZWZhdWx0OiAzLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXNLbm90J10gfSwgdHlwZTogJ2ludCcgfSxcbiAgICBwaGlMZW5ndGg6IHsgZGVmYXVsdDogMzYwLCBpZjogeyBwcmltaXRpdmU6IFsnc3BoZXJlJ10gfSB9LFxuICAgIHBoaVN0YXJ0OiB7IGRlZmF1bHQ6IDAsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3NwaGVyZSddIH0gfSxcbiAgICByYWRpdXM6IHsgZGVmYXVsdDogREVGQVVMVF9SQURJVVMsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2NpcmNsZScsICdjeWxpbmRlcicsICdzcGhlcmUnLCAndG9ydXMnLCAndG9ydXNLbm90J10gfSB9LFxuICAgIHJhZGl1c0JvdHRvbTogeyBkZWZhdWx0OiBERUZBVUxUX1JBRElVUywgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsnY3lsaW5kZXInXSB9IH0sXG4gICAgcmFkaXVzSW5uZXI6IHsgZGVmYXVsdDogMC44LCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydyaW5nJ10gfSB9LFxuICAgIHJhZGl1c091dGVyOiB7IGRlZmF1bHQ6IDEuMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsncmluZyddIH0gfSxcbiAgICByYWRpdXNUb3A6IHsgZGVmYXVsdDogREVGQVVMVF9SQURJVVMsIGlmOiB7IHByaW1pdGl2ZTogWydjeWxpbmRlciddIH0gfSxcbiAgICByYWRpdXNUdWJ1bGFyOiB7IGRlZmF1bHQ6IDAuMiwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXMnXSB9IH0sXG4gICAgc2NhbGVIZWlnaHQ6IHsgZGVmYXVsdDogMSwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsndG9ydXNLbm90J10gfSB9LFxuICAgIHNlZ21lbnRzOiB7IGRlZmF1bHQ6IDgsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2NpcmNsZSddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgc2VnbWVudHNIZWlnaHQ6IHsgZGVmYXVsdDogMTgsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2N5bGluZGVyJywgJ3NwaGVyZSddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgc2VnbWVudHNQaGk6IHsgZGVmYXVsdDogOCwgbWluOiAwLCBpZjogeyBwcmltaXRpdmU6IFsncmluZyddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgc2VnbWVudHNSYWRpYWw6IHsgZGVmYXVsdDogMzYsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ2N5bGluZGVyJ10gfSwgdHlwZTogJ2ludCcgfSxcbiAgICBzZWdtZW50c1RoZXRhOiB7IGRlZmF1bHQ6IDgsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3JpbmcnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzVHVidWxhcjogeyBkZWZhdWx0OiA4LCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWyd0b3J1cycsICd0b3J1c0tub3QnXSB9LCB0eXBlOiAnaW50JyB9LFxuICAgIHNlZ21lbnRzV2lkdGg6IHsgZGVmYXVsdDogMzYsIG1pbjogMCwgaWY6IHsgcHJpbWl0aXZlOiBbJ3NwaGVyZSddIH0sIHR5cGU6ICdpbnQnIH0sXG4gICAgdGhldGFMZW5ndGg6IHsgZGVmYXVsdDogMzYwLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydjaXJjbGUnLCAnY3lsaW5kZXInLCAncmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzcGhlcmUnXSB9IH0sXG4gICAgdGhldGFTdGFydDogeyBkZWZhdWx0OiAwLCBpZjogeyBwcmltaXRpdmU6IFsnY2lyY2xlJywgJ2N5bGluZGVyJywgJ3JpbmcnLCAnc3BoZXJlJ10gfSB9LFxuICAgIHRyYW5zbGF0ZTogeyB0eXBlOiAndmVjMycgfSxcbiAgICB3aWR0aDogeyBkZWZhdWx0OiAyLCBtaW46IDAsIGlmOiB7IHByaW1pdGl2ZTogWydib3gnLCAncGxhbmUnXSB9IH1cbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBnZW9tZXRyeSBvbiBldmVyeSB1cGRhdGUgYXMgdGhlcmUncyBub3QgYW4gZWFzeSB3YXkgdG9cbiAgICogdXBkYXRlIGEgZ2VvbWV0cnkgdGhhdCB3b3VsZCBiZSBmYXN0ZXIgdGhhbiBqdXN0IGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHByZXZpb3VzRGF0YSkge1xuICAgIHByZXZpb3VzRGF0YSA9IHByZXZpb3VzRGF0YSB8fCB7fTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgY3VycmVudFRyYW5zbGF0ZSA9IHByZXZpb3VzRGF0YS50cmFuc2xhdGUgfHwgdGhpcy5zY2hlbWEudHJhbnNsYXRlLmRlZmF1bHQ7XG4gICAgdmFyIGRpZmYgPSB1dGlscy5kaWZmKHByZXZpb3VzRGF0YSwgZGF0YSk7XG4gICAgdmFyIG1lc2ggPSB0aGlzLmVsLmdldE9yQ3JlYXRlT2JqZWN0M0QoJ21lc2gnLCBUSFJFRS5NZXNoKTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIHZhciBnZW9tZXRyeU5lZWRzVXBkYXRlID0gIShPYmplY3Qua2V5cyhkaWZmKS5sZW5ndGggPT09IDEgJiYgJ3RyYW5zbGF0ZScgaW4gZGlmZik7XG4gICAgdmFyIHRyYW5zbGF0ZU5lZWRzVXBkYXRlID0gIXV0aWxzLmRlZXBFcXVhbChkYXRhLnRyYW5zbGF0ZSwgY3VycmVudFRyYW5zbGF0ZSk7XG5cbiAgICBpZiAoZ2VvbWV0cnlOZWVkc1VwZGF0ZSkge1xuICAgICAgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5ID0gZ2V0R2VvbWV0cnkodGhpcy5kYXRhLCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmICh0cmFuc2xhdGVOZWVkc1VwZGF0ZSkge1xuICAgICAgYXBwbHlUcmFuc2xhdGUoZ2VvbWV0cnksIGRhdGEudHJhbnNsYXRlLCBjdXJyZW50VHJhbnNsYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgZ2VvbWV0cnkgb24gcmVtb3ZlIChjYWxsYmFjaykuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsLmdldE9iamVjdDNEKCdtZXNoJykuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocmVlLmpzIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBnZW9tZXRyeVxuICovXG5mdW5jdGlvbiBnZXRHZW9tZXRyeSAoZGF0YSwgc2NoZW1hKSB7XG4gIGlmIChkYXRhLnByaW1pdGl2ZSA9PT0gJ2N1YmUnKSB7XG4gICAgd2FybignZ2VvbWV0cnkucHJpbWl0aXZlPVwiY3ViZVwiIHNob3VsZCBiZSBcImJveFwiJyk7XG4gIH1cblxuICBzd2l0Y2ggKGRhdGEucHJpbWl0aXZlKSB7XG4gICAgY2FzZSAnYm94Jzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCwgZGF0YS5kZXB0aCk7XG4gICAgfVxuICAgIGNhc2UgJ2NpcmNsZSc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgIGRhdGEucmFkaXVzLCBkYXRhLnNlZ21lbnRzLCBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ2NvbmUnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoXG4gICAgICAgIGRhdGEucmFkaXVzVG9wLCBkYXRhLnJhZGl1c0JvdHRvbSwgZGF0YS5oZWlnaHQsXG4gICAgICAgIGRhdGEuc2VnbWVudHNSYWRpYWwsIGRhdGEuc2VnbWVudHNIZWlnaHQsXG4gICAgICAgIGRhdGEub3BlbkVuZGVkLCBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ2N5bGluZGVyJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICBkYXRhLnJhZGl1cywgZGF0YS5yYWRpdXMsIGRhdGEuaGVpZ2h0LFxuICAgICAgICBkYXRhLnNlZ21lbnRzUmFkaWFsLCBkYXRhLnNlZ21lbnRzSGVpZ2h0LFxuICAgICAgICBkYXRhLm9wZW5FbmRlZCwgZGVnVG9SYWQoZGF0YS50aGV0YVN0YXJ0KSwgZGVnVG9SYWQoZGF0YS50aGV0YUxlbmd0aCkpO1xuICAgIH1cbiAgICBjYXNlICdwbGFuZSc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeShkYXRhLndpZHRoLCBkYXRhLmhlaWdodCk7XG4gICAgfVxuICAgIGNhc2UgJ3JpbmcnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlJpbmdHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXNJbm5lciwgZGF0YS5yYWRpdXNPdXRlciwgZGF0YS5zZWdtZW50c1RoZXRhLCBkYXRhLnNlZ21lbnRzUGhpLFxuICAgICAgICBkZWdUb1JhZChkYXRhLnRoZXRhU3RhcnQpLCBkZWdUb1JhZChkYXRhLnRoZXRhTGVuZ3RoKSk7XG4gICAgfVxuICAgIGNhc2UgJ3NwaGVyZSc6IHtcbiAgICAgIC8vIHRoZXRhTGVuZ3RoJ3MgZGVmYXVsdCBmb3Igc3BoZXJlcyBpcyBkaWZmZXJlbnQgZnJvbSB0aG9zZSBvZiB0aGUgb3RoZXIgZ2VvbWV0cmllcy5cbiAgICAgIC8vIEZvciBub3csIHdlIGRldGVjdCBpZiB0aGV0YUxlbmd0aCBpcyBleGFjdGx5IDM2MCB0byBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgZGVmYXVsdC5cbiAgICAgIGlmIChkYXRhLnRoZXRhTGVuZ3RoID09PSAzNjApIHsgZGF0YS50aGV0YUxlbmd0aCA9IDE4MDsgfVxuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXMsIGRhdGEuc2VnbWVudHNXaWR0aCwgZGF0YS5zZWdtZW50c0hlaWdodCwgZGVnVG9SYWQoZGF0YS5waGlTdGFydCksXG4gICAgICAgIGRlZ1RvUmFkKGRhdGEucGhpTGVuZ3RoKSwgZGVnVG9SYWQoZGF0YS50aGV0YVN0YXJ0KSwgZGVnVG9SYWQoZGF0YS50aGV0YUxlbmd0aCkpO1xuICAgIH1cbiAgICBjYXNlICd0b3J1cyc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuVG9ydXNHZW9tZXRyeShcbiAgICAgICAgZGF0YS5yYWRpdXMsIGRhdGEucmFkaXVzVHVidWxhciAqIDIsIGRhdGEuc2VnbWVudHNSYWRpYWwsIGRhdGEuc2VnbWVudHNUdWJ1bGFyLFxuICAgICAgICBkZWdUb1JhZChkYXRhLmFyYykpO1xuICAgIH1cbiAgICBjYXNlICd0b3J1c0tub3QnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxuICAgICAgICBkYXRhLnJhZGl1cywgZGF0YS5yYWRpdXNUdWJ1bGFyICogMiwgZGF0YS5zZWdtZW50c1JhZGlhbCwgZGF0YS5zZWdtZW50c1R1YnVsYXIsXG4gICAgICAgIGRhdGEucCwgZGF0YS5xLCBkYXRhLnNjYWxlSGVpZ2h0KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2FybignUHJpbWl0aXZlIHR5cGUgbm90IHN1cHBvcnRlZDogJyArIGRhdGEucHJpbWl0aXZlKTtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIGdlb21ldHJ5IHZlcnRpY2VzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnZW9tZXRyeSAtIHRocmVlLmpzIGdlb21ldHJ5LlxuICogQHBhcmFtIHtvYmplY3R9IHRyYW5zbGF0ZSAtIE5ldyB0cmFuc2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50VHJhbnNsYXRlIC0gQ3VycmVudGx5IGFwcGxpZWQgdHJhbnNsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRlIChnZW9tZXRyeSwgdHJhbnNsYXRlLCBjdXJyZW50VHJhbnNsYXRlKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IGhlbHBlck1hdHJpeC5tYWtlVHJhbnNsYXRpb24oXG4gICAgdHJhbnNsYXRlLnggLSBjdXJyZW50VHJhbnNsYXRlLngsXG4gICAgdHJhbnNsYXRlLnkgLSBjdXJyZW50VHJhbnNsYXRlLnksXG4gICAgdHJhbnNsYXRlLnogLSBjdXJyZW50VHJhbnNsYXRlLnpcbiAgKTtcbiAgZ2VvbWV0cnkuYXBwbHlNYXRyaXgodHJhbnNsYXRpb24pO1xuICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRzVXBkYXRlID0gdHJ1ZTtcbn1cbiIsInJlcXVpcmUoJy4uL2NvbXBvbmVudHMvY2FtZXJhJyk7XG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL2N1cnNvcicpO1xucmVxdWlyZSgnLi4vY29tcG9uZW50cy9mb2cnKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvZ2VvbWV0cnknKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvbGlnaHQnKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvbG9hZGVyJyk7XG5yZXF1aXJlKCcuLi9jb21wb25lbnRzL2xvb2stYXQnKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvbG9vay1jb250cm9scycpO1xucmVxdWlyZSgnLi4vY29tcG9uZW50cy9tYXRlcmlhbCcpO1xucmVxdWlyZSgnLi4vY29tcG9uZW50cy9wb3NpdGlvbicpO1xucmVxdWlyZSgnLi4vY29tcG9uZW50cy9yYXljYXN0ZXInKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvcm90YXRpb24nKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvc2NhbGUnKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvc291bmQnKTtcbnJlcXVpcmUoJy4uL2NvbXBvbmVudHMvdmlzaWJsZScpO1xucmVxdWlyZSgnLi4vY29tcG9uZW50cy93YXNkLWNvbnRyb2xzJyk7XG4iLCJ2YXIgZGlmZiA9IHJlcXVpcmUoJy4uL3V0aWxzJykuZGlmZjtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG5cbnZhciBkZWdUb1JhZCA9IFRIUkVFLk1hdGguZGVnVG9SYWQ7XG52YXIgd2FybiA9IGRlYnVnKCdjb21wb25lbnRzOmxpZ2h0Ondhcm4nKTtcblxuLyoqXG4gKiBMaWdodCBjb21wb25lbnQuXG4gKlxuICogQG5hbWVzcGFjZSBsaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IFthbmdsZT02MF0gLSBtYXhpbXVtIGV4dGVudCBvZiBsaWdodCBmcm9tIGl0cyBkaXJlY3Rpb24sXG4gICAgICAgICAgaW4gZGVncmVlcy4gRm9yIHNwb3QgbGlnaHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2xvcj0jRkZGXSAtIGxpZ2h0IGNvbG9yLiBGb3IgZXZlcnkgbGlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2RlY2F5PTFdIC0gYW1vdW50IHRoZSBsaWdodCBkaW1zIGFsb25nIHRoZSBkaXN0YW5jZSBvZiB0aGVcbiAgICAgICAgICBsaWdodC4gRm9yIHBvaW50IGFuZCBzcG90IGxpZ2h0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZXhwb25lbnQ9MTAuMF0gLSByYXBpZGl0eSBvZiBmYWxsb2ZmIG9mIGxpZ2h0IGZyb20gaXRzXG4gICAgICAgICAgdGFyZ2V0IGRpcmVjdGlvbi4gRm9yIHNwb3QgbGlnaHRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtncm91bmRDb2xvcj0jRkZGXSAtIGdyb3VuZCBsaWdodCBjb2xvci4gRm9yIGhlbWlzcGhlcmVcbiAgICAgICAgICBsaWdodHMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVuc2l0eT0xLjBdIC0gbGlnaHQgc3RyZW5ndGguIEZvciBldmVyeSBsaWdodCBleGNlcHRcbiAgICAgICAgICBhbWJpZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPWRpcmVjdGlvbmFsXSAtIGxpZ2h0IHR5cGUgKGFtYmllbnQsIGRpcmVjdGlvbmFsLFxuICAgICAgICAgIGhlbWlzcGhlcmUsIHBvaW50LCBzcG90KS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xpZ2h0Jywge1xuICBzY2hlbWE6IHtcbiAgICBhbmdsZTogeyBkZWZhdWx0OiA2MCwgaWY6IHsgdHlwZTogWydzcG90J10gfSB9LFxuICAgIGNvbG9yOiB7IGRlZmF1bHQ6ICcjRkZGJyB9LFxuICAgIGdyb3VuZENvbG9yOiB7IGRlZmF1bHQ6ICcjRkZGJywgaWY6IHsgdHlwZTogWydoZW1pc3BoZXJlJ10gfSB9LFxuICAgIGRlY2F5OiB7IGRlZmF1bHQ6IDEsIGlmOiB7IHR5cGU6IFsncG9pbnQnLCAnc3BvdCddIH0gfSxcbiAgICBkaXN0YW5jZTogeyBkZWZhdWx0OiAwLjAsIG1pbjogMCwgaWY6IHsgdHlwZTogWydwb2ludCcsICdzcG90J10gfSB9LFxuICAgIGV4cG9uZW50OiB7IGRlZmF1bHQ6IDEwLjAsIGlmOiB7IHR5cGU6IFsnc3BvdCddIH0gfSxcbiAgICBpbnRlbnNpdHk6IHsgZGVmYXVsdDogMS4wLCBtaW46IDAsIGlmOiB7IHR5cGU6IFsnZGlyZWN0aW9uYWwnLCAnaGVtaXNwaGVyZScsICdwb2ludCcsICdzcG90J10gfSB9LFxuICAgIHR5cGU6IHsgZGVmYXVsdDogJ2RpcmVjdGlvbmFsJyxcbiAgICAgICAgICAgIG9uZU9mOiBbJ2FtYmllbnQnLCAnZGlyZWN0aW9uYWwnLCAnaGVtaXNwaGVyZScsICdwb2ludCcsICdzcG90J11cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHNjZW5lIGEgbGlnaHQgaGFzIGJlZW4gYWRkZWQgdG8gcmVtb3ZlIGRlZmF1bHQgbGlnaHRpbmcuXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB0aGlzLmxpZ2h0ID0gbnVsbDtcbiAgICBlbC5zY2VuZUVsLnJlZ2lzdGVyTGlnaHQoZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAoUmUpY3JlYXRlIG9yIHVwZGF0ZSBsaWdodC5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKG9sZERhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgZGlmZkRhdGEgPSBkaWZmKGRhdGEsIG9sZERhdGEgfHwge30pO1xuICAgIHZhciBsaWdodCA9IHRoaXMubGlnaHQ7XG5cbiAgICAvLyBFeGlzdGluZyBsaWdodC5cbiAgICBpZiAobGlnaHQgJiYgISgndHlwZScgaW4gZGlmZkRhdGEpKSB7XG4gICAgICAvLyBMaWdodCB0eXBlIGhhcyBub3QgY2hhbmdlZC4gVXBkYXRlIGxpZ2h0LlxuICAgICAgT2JqZWN0LmtleXMoZGlmZkRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhW2tleV07XG4gICAgICAgIGlmIChbJ2NvbG9yJywgJ2dyb3VuZENvbG9yJ10uaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFRIUkVFLkNvbG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsaWdodFtrZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBObyBsaWdodCB5ZXQgb3IgbGlnaHQgdHlwZSBoYXMgY2hhbmdlZC4gQ3JlYXRlIGFuZCBhZGQgbGlnaHQuXG4gICAgdGhpcy5zZXRMaWdodCh0aGlzLmRhdGEpO1xuICB9LFxuXG4gIHNldExpZ2h0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICB2YXIgbmV3TGlnaHQgPSBnZXRMaWdodChkYXRhKTtcbiAgICBpZiAobmV3TGlnaHQpIHtcbiAgICAgIGlmICh0aGlzLmxpZ2h0KSB7XG4gICAgICAgIGVsLnNldE9iamVjdDNEKCdsaWdodCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxpZ2h0ID0gbmV3TGlnaHQ7XG4gICAgICB0aGlzLmxpZ2h0LmVsID0gZWw7XG4gICAgICBlbC5zZXRPYmplY3QzRCgnbGlnaHQnLCB0aGlzLmxpZ2h0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaWdodCBvbiByZW1vdmUgKGNhbGxiYWNrKS5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwuc2V0T2JqZWN0M0QoJ2xpZ2h0Jyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGhyZWUuanMgbGlnaHQgb2JqZWN0IGdpdmVuIGRhdGEgb2JqZWN0IGRlZmluaW5nIHRoZSBsaWdodC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiBnZXRMaWdodCAoZGF0YSkge1xuICB2YXIgYW5nbGUgPSBkYXRhLmFuZ2xlO1xuICB2YXIgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoZGF0YS5jb2xvcikuZ2V0SGV4KCk7XG4gIHZhciBkZWNheSA9IGRhdGEuZGVjYXk7XG4gIHZhciBkaXN0YW5jZSA9IGRhdGEuZGlzdGFuY2U7XG4gIHZhciBncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihkYXRhLmdyb3VuZENvbG9yKS5nZXRIZXgoKTtcbiAgdmFyIGludGVuc2l0eSA9IGRhdGEuaW50ZW5zaXR5O1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcblxuICBzd2l0Y2ggKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2FtYmllbnQnOiB7XG4gICAgICByZXR1cm4gbmV3IFRIUkVFLkFtYmllbnRMaWdodChjb2xvcik7XG4gICAgfVxuICAgIGNhc2UgJ2RpcmVjdGlvbmFsJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KGNvbG9yLCBpbnRlbnNpdHkpO1xuICAgIH1cbiAgICBjYXNlICdoZW1pc3BoZXJlJzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoY29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkpO1xuICAgIH1cbiAgICBjYXNlICdwb2ludCc6IHtcbiAgICAgIHJldHVybiBuZXcgVEhSRUUuUG9pbnRMaWdodChjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkpO1xuICAgIH1cbiAgICBjYXNlICdzcG90Jzoge1xuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5TcG90TGlnaHQoY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGRlZ1RvUmFkKGFuZ2xlKSwgZGF0YS5leHBvbmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2F5KTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2FybignJXMgaXMgbm90IGEgdmFsaWQgbGlnaHQgdHlwZS4gJyArXG4gICAgICAgICAgICdDaG9vc2UgZnJvbSBhbWJpZW50LCBkaXJlY3Rpb25hbCwgaGVtaXNwaGVyZSwgcG9pbnQsIHNwb3QuJywgdHlwZSk7XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciBwYXJzZVVybCA9IHJlcXVpcmUoJy4uL3V0aWxzL3NyYy1sb2FkZXInKS5wYXJzZVVybDtcbnZhciBUSFJFRSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJlZScpO1xuXG52YXIgd2FybiA9IGRlYnVnKCdjb21wb25lbnRzOmxvYWRlcjp3YXJuJyk7XG5cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdsb2FkZXInLCB7XG4gIGRlcGVuZGVuY2llczogWyAnbWF0ZXJpYWwnIF0sXG5cbiAgc2NoZW1hOiB7XG4gICAgc3JjOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgbXRsOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICBkZWZhdWx0OiAnb2JqJyxcbiAgICAgIG9uZU9mOiBbJ29iaicsICdjb2xsYWRhJ11cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgIHZhciB1cmwgPSBwYXJzZVVybChkYXRhLnNyYyk7XG4gICAgdmFyIG10bFVybCA9IHBhcnNlVXJsKGRhdGEubXRsKTtcbiAgICB2YXIgZm9ybWF0ID0gZGF0YS5mb3JtYXQ7XG4gICAgaWYgKG1vZGVsKSB7IGVsLnNldE9iamVjdDNEKCdtZXNoJyk7IH1cbiAgICBpZiAoIXVybCkge1xuICAgICAgd2FybignTW9kZWwgVVJMIG5vdCBwcm92aWRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgY2FzZSAnb2JqJzpcbiAgICAgICAgdGhpcy5sb2FkT2JqKHVybCwgbXRsVXJsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjb2xsYWRhJzpcbiAgICAgICAgdGhpcy5sb2FkQ29sbGFkYSh1cmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oJ01vZGVsIGZvcm1hdCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9LFxuXG4gIGxvYWRPYmo6IGZ1bmN0aW9uIChvYmpVcmwsIG10bFVybCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBvYmpMb2FkZXIgPSBuZXcgVEhSRUUuT0JKTG9hZGVyKCk7XG4gICAgaWYgKG10bFVybCkge1xuICAgICAgLy8gLk9CSiArIC5NVEwgYXNzZXRzLlxuICAgICAgaWYgKGVsLmNvbXBvbmVudHMubWF0ZXJpYWwpIHtcbiAgICAgICAgd2FybignTWF0ZXJpYWwgY29tcG9uZW50IGlzIGlnbm9yZWQgd2hlbiBhIC5NVEwgaXMgcHJvdmlkZWQnKTtcbiAgICAgIH1cbiAgICAgIHZhciBtdGxMb2FkZXIgPSBuZXcgVEhSRUUuTVRMTG9hZGVyKG9iakxvYWRlci5tYW5hZ2VyKTtcbiAgICAgIG10bExvYWRlci5zZXRCYXNlVXJsKG10bFVybC5zdWJzdHIoMCwgbXRsVXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKSk7XG4gICAgICBtdGxMb2FkZXIubG9hZChtdGxVcmwsIGZ1bmN0aW9uIChtYXRlcmlhbHMpIHtcbiAgICAgICAgbWF0ZXJpYWxzLnByZWxvYWQoKTtcbiAgICAgICAgb2JqTG9hZGVyLnNldE1hdGVyaWFscyhtYXRlcmlhbHMpO1xuICAgICAgICBvYmpMb2FkZXIubG9hZChvYmpVcmwsIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICBzZWxmLm1vZGVsID0gb2JqZWN0O1xuICAgICAgICAgIGVsLnNldE9iamVjdDNEKCdtZXNoJywgb2JqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gLk9CSiBhc3NldCBvbmx5LlxuICAgICAgb2JqTG9hZGVyLmxvYWQob2JqVXJsLCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIHNlbGYubW9kZWwgPSBvYmplY3Q7XG4gICAgICAgIHNlbGYuYXBwbHlNYXRlcmlhbCgpO1xuICAgICAgICBlbC5zZXRPYmplY3QzRCgnbWVzaCcsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgYXBwbHlNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBtYXRlcmlhbCA9IHRoaXMuZWwuY29tcG9uZW50cy5tYXRlcmlhbC5tYXRlcmlhbDtcbiAgICBpZiAoIXRoaXMubW9kZWwpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5tb2RlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRIUkVFLk1lc2gpIHtcbiAgICAgICAgY2hpbGQubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBsb2FkQ29sbGFkYTogZnVuY3Rpb24gKHVybCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuQ29sbGFkYUxvYWRlcigpO1xuICAgIGxvYWRlci5vcHRpb25zLmNvbnZlcnRVcEF4aXMgPSB0cnVlO1xuICAgIGxvYWRlci5sb2FkKHVybCwgZnVuY3Rpb24gKGNvbGxhZGEpIHtcbiAgICAgIHNlbGYubW9kZWwgPSBjb2xsYWRhLnNjZW5lO1xuICAgICAgZWwuc2V0T2JqZWN0M0QoJ21lc2gnLCBjb2xsYWRhLnNjZW5lKTtcbiAgICB9KTtcbiAgfVxufSk7XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIGNvb3JkaW5hdGVzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29vcmRpbmF0ZXMnKTtcbnZhciByZWdpc3RlckNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcblxudmFyIHdhcm4gPSBkZWJ1ZygnY29tcG9uZW50czpsb29rLWF0Ondhcm4nKTtcbnZhciBpc0Nvb3JkaW5hdGUgPSBjb29yZGluYXRlcy5pc0Nvb3JkaW5hdGU7XG5cbi8qKlxuICogTG9vay1hdCBjb21wb25lbnQuXG4gKiBNb2RpZmllcyByb3RhdGlvbiB0byBlaXRoZXIgdHJhY2sgYW5vdGhlciBlbnRpdHkgT1IgZG8gYSBvbmUtdGltZSB0dXJuIHRvd2FyZHMgYSBwb3NpdGlvblxuICogdmVjdG9yLlxuICpcbiAqIElmIHRyYWNraW5nIGFuIG9iamVjdCB2aWEgc2V0dGluZyB0aGUgY29tcG9uZW50IHZhbHVlIHZpYSBhIHNlbGVjdG9yLCBsb29rLWF0IHdpbGwgcmVnaXN0ZXJcbiAqIGEgYmVoYXZpb3IgdG8gdGhlIHNjZW5lIHRvIHVwZGF0ZSByb3RhdGlvbiBvbiBldmVyeSB0aWNrLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqIGxvb2stYXQ9XCIjdGhlLW1pcnJvclwiXG4gKiBsb29rLWF0PVwiMCA1IC0yXCJcbiAqXG4gKiBAcGFyYW0gTG9vay1hdCBlaXRoZXIgdGFrZXMgYSB0YXJnZXQgc2VsZWN0b3IgcG9pbnRpbmcgdG8gYW5vdGhlciBvYmplY3Qgb3IgYVxuICogICAgICAgIHBvc2l0aW9uLlxuICogQG1lbWJlciB7b2JqZWN0fSB0YXJnZXQzRCAtIG9iamVjdDNEIG9mIHRhcmdldGVkIGVsZW1lbnQgdGhhdCBsb29rLWF0IGlzIGN1cnJlbnRseVxuICAgICAgICAgICB0cmFja2luZy5cbiAqIEBtZW1iZXIge29iamVjdH0gdmVjdG9yIC0gSGVscGVyIHZlY3RvciB0byBkbyBtYXRyaXggdHJhbnNmb3JtYXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSByZWdpc3RlckNvbXBvbmVudCgnbG9vay1hdCcsIHtcbiAgc2NoZW1hOiB7IGRlZmF1bHQ6ICcnIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGFyZ2V0M0QgPSBudWxsO1xuICAgIHRoaXMudmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgdHJhY2tpbmcgYW4gb2JqZWN0LCB0aGlzIHdpbGwgYmUgY2FsbGVkIG9uIGV2ZXJ5IHRpY2suXG4gICAqIElmIGxvb2tpbmcgYXQgYSBwb3NpdGlvbiB2ZWN0b3IsIHRoaXMgd2lsbCBvbmx5IGJlIGNhbGxlZCBvbmNlICh1bnRpbCBmdXJ0aGVyIHVwZGF0ZXMpLlxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0YXJnZXQgPSBzZWxmLmRhdGE7XG4gICAgdmFyIG9iamVjdDNEID0gc2VsZi5lbC5vYmplY3QzRDtcbiAgICB2YXIgdGFyZ2V0M0QgPSBzZWxmLnRhcmdldDNEO1xuICAgIHZhciB0YXJnZXRFbDtcblxuICAgIC8vIFRyYWNrIHRhcmdldCBvYmplY3QgcG9zaXRpb24uIERlcGVuZHMgb24gcGFyZW50IG9iamVjdCBrZWVwaW5nIGdsb2JhbCB0cmFuc2Zvcm1zIHVwXG4gICAgLy8gdG8gc3RhdGUgd2l0aCB1cGRhdGVNYXRyaXhXb3JsZCgpLiBJbiBwcmFjdGljZSwgdGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICBpZiAodGFyZ2V0M0QpIHtcbiAgICAgIHJldHVybiBvYmplY3QzRC5sb29rQXQoc2VsZi52ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRhcmdldDNELm1hdHJpeFdvcmxkKSk7XG4gICAgfVxuXG4gICAgLy8gTm8gbG9uZ2VyIGxvb2tpbmcgYXQgYW55dGhpbmcgKGkuZS4sIGxvb2stYXQ9XCJcIikuXG4gICAgaWYgKCF0YXJnZXQgfHxcbiAgICAgICAgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmICFPYmplY3Qua2V5cyh0YXJnZXQpLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8vIExvb2sgYXQgYSBwb3NpdGlvbi5cbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBvYmplY3QzRC5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjModGFyZ2V0LngsIHRhcmdldC55LCB0YXJnZXQueikpO1xuICAgIH1cblxuICAgIC8vIEFzc3VtZSB0YXJnZXQgaXMgYSBzdHJpbmcuXG4gICAgLy8gUXVlcnkgZm9yIHRoZSBlbGVtZW50LCBncmFiIGl0cyBvYmplY3QzRCwgdGhlbiByZWdpc3RlciBhIGJlaGF2aW9yIG9uIHRoZSBzY2VuZSB0b1xuICAgIC8vIHRyYWNrIHRoZSB0YXJnZXQgb24gZXZlcnkgdGljay5cbiAgICB0YXJnZXRFbCA9IHNlbGYuZWwuc2NlbmVFbC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgaWYgKCF0YXJnZXRFbCkge1xuICAgICAgd2FybignXCInICsgdGFyZ2V0ICsgJ1wiIGRvZXMgbm90IHBvaW50IHRvIGEgdmFsaWQgZW50aXR5IHRvIGxvb2stYXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXRFbC5oYXNMb2FkZWQpIHtcbiAgICAgIHJldHVybiB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuYmVnaW5UcmFja2luZyh0YXJnZXRFbCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGYuYmVnaW5UcmFja2luZyh0YXJnZXRFbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBmb2xsb3cgYmVoYXZpb3Igb24gcmVtb3ZlIChjYWxsYmFjaykuXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50YXJnZXQzRCkge1xuICAgICAgdGhpcy5lbC5zY2VuZUVsLnJlbW92ZUJlaGF2aW9yKHRoaXMpO1xuICAgICAgdGhpcy50YXJnZXQzRCA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoaXNDb29yZGluYXRlKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXMucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG5cbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBjb29yZGluYXRlcy5zdHJpbmdpZnkoZGF0YSk7XG4gIH0sXG5cbiAgYmVnaW5UcmFja2luZzogZnVuY3Rpb24gKHRhcmdldEVsKSB7XG4gICAgdGhpcy50YXJnZXQzRCA9IHRhcmdldEVsLm9iamVjdDNEO1xuICAgIHRoaXMuZWwuc2NlbmVFbC5hZGRCZWhhdmlvcih0aGlzKTtcbiAgfVxufSk7XG4iLCJ2YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG5cbi8vIFRvIGF2b2lkIHJlY2FsY3VsYXRpb24gYXQgZXZlcnkgbW91c2UgbW92ZW1lbnQgdGlja1xudmFyIFBJXzIgPSBNYXRoLlBJIC8gMjtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ2xvb2stY29udHJvbHMnLCB7XG4gIGRlcGVuZGVuY2llczogWydwb3NpdGlvbicsICdyb3RhdGlvbiddLFxuXG4gIHNjaGVtYToge1xuICAgIGVuYWJsZWQ6IHsgZGVmYXVsdDogdHJ1ZSB9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdGhpcy5kZWx0YVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB0aGlzLnNldHVwTW91c2VDb250cm9scygpO1xuICAgIHRoaXMuc2V0dXBITURDb250cm9scygpO1xuICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcbiAgfSxcblxuICBiaW5kTWV0aG9kczogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub25Nb3VzZURvd24gPSB0aGlzLm9uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbGVhc2VNb3VzZSA9IHRoaXMucmVsZWFzZU1vdXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoU3RhcnQgPSB0aGlzLm9uVG91Y2hTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Ub3VjaE1vdmUgPSB0aGlzLm9uVG91Y2hNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblRvdWNoRW5kID0gdGhpcy5vblRvdWNoRW5kLmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB0aGlzLnByZXZpb3VzUG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBzY2VuZS5hZGRCZWhhdmlvcih0aGlzKTtcbiAgfSxcblxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgc2NlbmUucmVtb3ZlQmVoYXZpb3IodGhpcyk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9LFxuXG4gIHNldHVwTW91c2VDb250cm9sczogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSBjYW52YXMgd2hlcmUgdGhlIHNjZW5lIGlzIHBhaW50ZWRcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMucGl0Y2hPYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICB0aGlzLnlhd09iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICAgIHRoaXMueWF3T2JqZWN0LnBvc2l0aW9uLnkgPSAxMDtcbiAgICB0aGlzLnlhd09iamVjdC5hZGQodGhpcy5waXRjaE9iamVjdCk7XG4gIH0sXG5cbiAgc2V0dXBITURDb250cm9sczogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZG9sbHkgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICB0aGlzLmV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgdGhpcy5jb250cm9scyA9IG5ldyBUSFJFRS5WUkNvbnRyb2xzKHRoaXMuZG9sbHkpO1xuICAgIHRoaXMuemVyb1F1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB9LFxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhc0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYS1zY2VuZScpLmNhbnZhcztcblxuICAgIC8vIE1vdXNlIEV2ZW50c1xuICAgIGNhbnZhc0VsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMucmVsZWFzZU1vdXNlLCBmYWxzZSk7XG4gICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLnJlbGVhc2VNb3VzZSwgZmFsc2UpO1xuXG4gICAgLy8gVG91Y2ggZXZlbnRzXG4gICAgY2FudmFzRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0KTtcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICBjYW52YXNFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCk7XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmVFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Etc2NlbmUnKTtcbiAgICB2YXIgY2FudmFzRWwgPSBzY2VuZUVsICYmIHNjZW5lRWwuY2FudmFzO1xuICAgIGlmICghY2FudmFzRWwpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBNb3VzZSBFdmVudHNcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKTtcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZWxlYXNlTW91c2UpO1xuICAgIGNhbnZhc0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5yZWxlYXNlTW91c2UpO1xuXG4gICAgLy8gVG91Y2ggZXZlbnRzXG4gICAgY2FudmFzRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0KTtcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlKTtcbiAgICBjYW52YXNFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Ub3VjaEVuZCk7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuZW5hYmxlZCkgeyByZXR1cm47IH1cbiAgICB0aGlzLmNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlT3JpZW50YXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gIH0sXG5cbiAgdXBkYXRlT3JpZW50YXRpb246IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhtZEV1bGVyID0gbmV3IFRIUkVFLkV1bGVyKCk7XG4gICAgaG1kRXVsZXIub3JkZXIgPSAnWVhaJztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBpdGNoT2JqZWN0ID0gdGhpcy5waXRjaE9iamVjdDtcbiAgICAgIHZhciB5YXdPYmplY3QgPSB0aGlzLnlhd09iamVjdDtcbiAgICAgIHZhciBobWRRdWF0ZXJuaW9uID0gdGhpcy5jYWxjdWxhdGVITURRdWF0ZXJuaW9uKCk7XG4gICAgICBobWRFdWxlci5zZXRGcm9tUXVhdGVybmlvbihobWRRdWF0ZXJuaW9uKTtcbiAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdyb3RhdGlvbicsIHtcbiAgICAgICAgeDogVEhSRUUuTWF0aC5yYWRUb0RlZyhobWRFdWxlci54KSArIFRIUkVFLk1hdGgucmFkVG9EZWcocGl0Y2hPYmplY3Qucm90YXRpb24ueCksXG4gICAgICAgIHk6IFRIUkVFLk1hdGgucmFkVG9EZWcoaG1kRXVsZXIueSkgKyBUSFJFRS5NYXRoLnJhZFRvRGVnKHlhd09iamVjdC5yb3RhdGlvbi55KSxcbiAgICAgICAgejogVEhSRUUuTWF0aC5yYWRUb0RlZyhobWRFdWxlci56KVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSkoKSxcblxuICBjYWxjdWxhdGVITURRdWF0ZXJuaW9uOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBobWRRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRvbGx5ID0gdGhpcy5kb2xseTtcbiAgICAgIGlmICghdGhpcy56ZXJvZWQgJiYgIWRvbGx5LnF1YXRlcm5pb24uZXF1YWxzKHRoaXMuemVyb1F1YXRlcm5pb24pKSB7XG4gICAgICAgIHRoaXMuemVyb09yaWVudGF0aW9uKCk7XG4gICAgICAgIHRoaXMuemVyb2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGhtZFF1YXRlcm5pb24uY29weSh0aGlzLnplcm9RdWF0ZXJuaW9uKS5tdWx0aXBseShkb2xseS5xdWF0ZXJuaW9uKTtcbiAgICAgIHJldHVybiBobWRRdWF0ZXJuaW9uO1xuICAgIH07XG4gIH0pKCksXG5cbiAgdXBkYXRlUG9zaXRpb246IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gICAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgIHZhciBkZWx0YVBvc2l0aW9uID0gdGhpcy5jYWxjdWxhdGVEZWx0YVBvc2l0aW9uKCk7XG4gICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gZWwuZ2V0Q29tcHV0ZWRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgICB0aGlzLmVsLm9iamVjdDNELm1hdHJpeFdvcmxkLmRlY29tcG9zZShwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUpO1xuICAgICAgZGVsdGFQb3NpdGlvbi5hcHBseVF1YXRlcm5pb24ocXVhdGVybmlvbik7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywge1xuICAgICAgICB4OiBjdXJyZW50UG9zaXRpb24ueCArIGRlbHRhUG9zaXRpb24ueCxcbiAgICAgICAgeTogY3VycmVudFBvc2l0aW9uLnkgKyBkZWx0YVBvc2l0aW9uLnksXG4gICAgICAgIHo6IGN1cnJlbnRQb3NpdGlvbi56ICsgZGVsdGFQb3NpdGlvbi56XG4gICAgICB9KTtcbiAgICB9O1xuICB9KSgpLFxuXG4gIGNhbGN1bGF0ZURlbHRhUG9zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9sbHkgPSB0aGlzLmRvbGx5O1xuICAgIHZhciBkZWx0YVBvc2l0aW9uID0gdGhpcy5kZWx0YVBvc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1Bvc2l0aW9uID0gdGhpcy5wcmV2aW91c1Bvc2l0aW9uO1xuICAgIGRlbHRhUG9zaXRpb24uY29weShkb2xseS5wb3NpdGlvbik7XG4gICAgZGVsdGFQb3NpdGlvbi5zdWIocHJldmlvdXNQb3NpdGlvbik7XG4gICAgcHJldmlvdXNQb3NpdGlvbi5jb3B5KGRvbGx5LnBvc2l0aW9uKTtcbiAgICByZXR1cm4gZGVsdGFQb3NpdGlvbjtcbiAgfSxcblxuICB1cGRhdGVITURRdWF0ZXJuaW9uOiAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBobWRRdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGRvbGx5ID0gdGhpcy5kb2xseTtcbiAgICAgIHRoaXMuY29udHJvbHMudXBkYXRlKCk7XG4gICAgICBpZiAoIXRoaXMuemVyb2VkICYmICFkb2xseS5xdWF0ZXJuaW9uLmVxdWFscyh0aGlzLnplcm9RdWF0ZXJuaW9uKSkge1xuICAgICAgICB0aGlzLnplcm9PcmllbnRhdGlvbigpO1xuICAgICAgICB0aGlzLnplcm9lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBobWRRdWF0ZXJuaW9uLmNvcHkodGhpcy56ZXJvUXVhdGVybmlvbikubXVsdGlwbHkoZG9sbHkucXVhdGVybmlvbik7XG4gICAgICByZXR1cm4gaG1kUXVhdGVybmlvbjtcbiAgICB9O1xuICB9KSgpLFxuXG4gIHplcm9PcmllbnRhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldWxlciA9IG5ldyBUSFJFRS5FdWxlcigpO1xuICAgIGV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKHRoaXMuZG9sbHkucXVhdGVybmlvbi5jbG9uZSgpLmludmVyc2UoKSk7XG4gICAgLy8gQ2FuY2VsIG91dCByb2xsIGFuZCBwaXRjaC4gV2Ugd2FudCB0byBvbmx5IHJlc2V0IHlhd1xuICAgIGV1bGVyLnogPSAwO1xuICAgIGV1bGVyLnggPSAwO1xuICAgIHRoaXMuemVyb1F1YXRlcm5pb24uc2V0RnJvbUV1bGVyKGV1bGVyKTtcbiAgfSxcblxuICBvbk1vdXNlTW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHBpdGNoT2JqZWN0ID0gdGhpcy5waXRjaE9iamVjdDtcbiAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgdmFyIHByZXZpb3VzTW91c2VFdmVudCA9IHRoaXMucHJldmlvdXNNb3VzZUV2ZW50O1xuXG4gICAgaWYgKCF0aGlzLm1vdXNlRG93biB8fCAhdGhpcy5kYXRhLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgbW92ZW1lbnRYID0gZXZlbnQubW92ZW1lbnRYIHx8IGV2ZW50Lm1vek1vdmVtZW50WDtcbiAgICB2YXIgbW92ZW1lbnRZID0gZXZlbnQubW92ZW1lbnRZIHx8IGV2ZW50Lm1vek1vdmVtZW50WTtcblxuICAgIGlmIChtb3ZlbWVudFggPT09IHVuZGVmaW5lZCB8fCBtb3ZlbWVudFkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIHByZXZpb3VzTW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIHByZXZpb3VzTW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH1cbiAgICB0aGlzLnByZXZpb3VzTW91c2VFdmVudCA9IGV2ZW50O1xuXG4gICAgeWF3T2JqZWN0LnJvdGF0aW9uLnkgLT0gbW92ZW1lbnRYICogMC4wMDI7XG4gICAgcGl0Y2hPYmplY3Qucm90YXRpb24ueCAtPSBtb3ZlbWVudFkgKiAwLjAwMjtcbiAgICBwaXRjaE9iamVjdC5yb3RhdGlvbi54ID0gTWF0aC5tYXgoLVBJXzIsIE1hdGgubWluKFBJXzIsIHBpdGNoT2JqZWN0LnJvdGF0aW9uLngpKTtcbiAgfSxcblxuICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgIHRoaXMucHJldmlvdXNNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH0sXG5cbiAgcmVsZWFzZU1vdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfSxcblxuICBvblRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT09IDEpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy50b3VjaFN0YXJ0ID0ge1xuICAgICAgeDogZS50b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgeTogZS50b3VjaGVzWzBdLnBhZ2VZXG4gICAgfTtcbiAgICB0aGlzLnRvdWNoU3RhcnRlZCA9IHRydWU7XG4gIH0sXG5cbiAgb25Ub3VjaE1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRlbHRhWTtcbiAgICB2YXIgeWF3T2JqZWN0ID0gdGhpcy55YXdPYmplY3Q7XG4gICAgaWYgKCF0aGlzLnRvdWNoU3RhcnRlZCkgeyByZXR1cm47IH1cbiAgICBkZWx0YVkgPSAyICogTWF0aC5QSSAqIChlLnRvdWNoZXNbMF0ucGFnZVggLSB0aGlzLnRvdWNoU3RhcnQueCkgLyB0aGlzLmNhbnZhc0VsLmNsaWVudFdpZHRoO1xuICAgIC8vIExpbWl0cyB0b3VjaCBvcmllbnRhaW9uIHRvIHRvIHlhdyAoeSBheGlzKVxuICAgIHlhd09iamVjdC5yb3RhdGlvbi55IC09IGRlbHRhWSAqIDAuNTtcbiAgICB0aGlzLnRvdWNoU3RhcnQgPSB7XG4gICAgICB4OiBlLnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICB5OiBlLnRvdWNoZXNbMF0ucGFnZVlcbiAgICB9O1xuICB9LFxuXG4gIG9uVG91Y2hFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRvdWNoU3RhcnRlZCA9IGZhbHNlO1xuICB9XG59KTtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG52YXIgZGVidWcgPSByZXF1aXJlKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIGRpZmYgPSByZXF1aXJlKCcuLi91dGlscycpLmRpZmY7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHNyY0xvYWRlciA9IHJlcXVpcmUoJy4uL3V0aWxzL3NyYy1sb2FkZXInKTtcbnZhciBUSFJFRSA9IHJlcXVpcmUoJy4uLy4uL2xpYi90aHJlZScpO1xuXG52YXIgQ3ViZUxvYWRlciA9IG5ldyBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpO1xudmFyIGVycm9yID0gZGVidWcoJ2NvbXBvbmVudHM6bWF0ZXJpYWw6ZXJyb3InKTtcbnZhciBUZXh0dXJlTG9hZGVyID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKTtcbnZhciB0ZXh0dXJlUHJvbWlzZXMgPSB7fTtcbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6bWF0ZXJpYWw6d2FybicpO1xuXG52YXIgTUFURVJJQUxfVFlQRV9CQVNJQyA9ICdNZXNoQmFzaWNNYXRlcmlhbCc7XG52YXIgTUFURVJJQUxfVFlQRV9TVEFOREFSRCA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XG5cbi8qKlxuICogTWF0ZXJpYWwgY29tcG9uZW50LlxuICpcbiAqIEBuYW1lc3BhY2UgbWF0ZXJpYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvciAtIERpZmZ1c2UgY29sb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW52TWFwIC0gVG8gbG9hZCBhIGVudmlyb25tZW50IGN1YmVtYXAuIFRha2VzIGEgc2VsZWN0b3JcbiAqICAgICAgICAgdG8gYW4gZWxlbWVudCBjb250YWluaW5nIHNpeCBpbWcgZWxlbWVudHMsIG9yIGEgY29tbWEtc2VwYXJhdGVkXG4gKiAgICAgICAgIHN0cmluZyBvZiBkaXJlY3QgdXJsKClzLlxuICogQHBhcmFtIHtib29sZWFufSBmb2cgLSBXaGV0aGVyIG9yIG5vdCB0byBiZSBhZmZlY3RlZCBieSBmb2cuXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IHRvIHJlbmRlciB0ZXh0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IG1ldGFsbmVzcyAtIFBhcmFtZXRlciBmb3IgcGh5c2ljYWwvc3RhbmRhcmQgbWF0ZXJpYWwuXG4gKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eSAtIFswLTFdLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlcGVhdCAtIFggYW5kIFkgdmFsdWUgZm9yIHNpemUgb2YgdGV4dHVyZSByZXBlYXRpbmdcbiAqICAgICAgICAgKGluIFVWIHVuaXRzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3VnaG5lc3MgLSBQYXJhbWV0ZXIgZm9yIHBoeXNpY2FsL3N0YW5kYXJkIG1hdGVyaWFsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzaWRlPWZyb250XSAtIFdoaWNoIHNpZGUocykgdG8gcmVuZGVyIChpLmUuLCBmcm9udCwgYmFjayxcbiAqICAgICAgICAgYm90aCkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc2hhZGVyIC0gRGV0ZXJtaW5lcyBob3cgbWF0ZXJpYWwgaXMgc2hhZGVkLiBEZWZhdWx0cyB0byBgc3RhbmRhcmRgLFxuICogICAgICAgICB0aHJlZS5qcydzIGltcGxlbWVudGF0aW9uIG9mIFBCUi4gQW5vdGhlciBvcHRpb24gaXMgYGZsYXRgIHdoZXJlIHdlIHVzZVxuICogICAgICAgICBNZXNoQmFzaWNNYXRlcmlhbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgLSBUbyBsb2FkIGEgdGV4dHVyZS4gdGFrZXMgYSBzZWxlY3RvciB0byBhbiBpbWcvdmlkZW9cbiAqICAgICAgICAgZWxlbWVudCBvciBhIGRpcmVjdCB1cmwoKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhbnNwYXJlbnQgLSBXaGV0aGVyIHRvIHJlbmRlciB0cmFuc3BhcmVudCB0aGUgYWxwaGFcbiAqICAgICAgICAgY2hhbm5lbCBvZiBhIHRleHR1cmUgKGUuZy4sIC5wbmcpLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggdG8gcmVuZGVyIHRleHR1cmUuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdtYXRlcmlhbCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgY29sb3I6IHsgZGVmYXVsdDogJyNGRkYnIH0sXG4gICAgZW52TWFwOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgZm9nOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICBoZWlnaHQ6IHsgZGVmYXVsdDogMzYwIH0sXG4gICAgbWV0YWxuZXNzOiB7IGRlZmF1bHQ6IDAuMCwgbWluOiAwLjAsIG1heDogMS4wLCBpZjogeyBzaGFkZXI6IFsnc3RhbmRhcmQnXSB9IH0sXG4gICAgb3BhY2l0eTogeyBkZWZhdWx0OiAxLjAsIG1pbjogMC4wLCBtYXg6IDEuMCB9LFxuICAgIHJlcGVhdDogeyBkZWZhdWx0OiAnJyB9LFxuICAgIHJvdWdobmVzczogeyBkZWZhdWx0OiAwLjUsIG1pbjogMC4wLCBtYXg6IDEuMCwgaWY6IHsgc2hhZGVyOiBbJ3N0YW5kYXJkJ10gfSB9LFxuICAgIHNoYWRlcjogeyBkZWZhdWx0OiAnc3RhbmRhcmQnLCBvbmVPZjogWydmbGF0JywgJ3N0YW5kYXJkJ10gfSxcbiAgICBzaWRlOiB7IGRlZmF1bHQ6ICdmcm9udCcsIG9uZU9mOiBbJ2Zyb250JywgJ2JhY2snLCAnZG91YmxlJ10gfSxcbiAgICBzcmM6IHsgZGVmYXVsdDogJycgfSxcbiAgICB0cmFuc3BhcmVudDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHdpZHRoOiB7IGRlZmF1bHQ6IDY0MCB9XG4gIH0sXG5cbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNMb2FkaW5nRW52TWFwID0gZmFsc2U7XG4gICAgdGhpcy5tYXRlcmlhbCA9IG51bGw7XG4gICAgdGhpcy50ZXh0dXJlU3JjID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIG9yIGNyZWF0ZSBtYXRlcmlhbC5cbiAgICpcbiAgICogTWF0ZXJpYWwgdHlwZSBkZXBlbmRzIG9uIHNoYWRlcjpcbiAgICogICBzaGFkZXI9ZmxhdCAtIE1lc2hCYXNpY01hdGVyaWFsLlxuICAgKiAgIHNoYWRlcj1YWFggLSBNZXNoU3RhbmRhcmRNYXRlcmlhbC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R8bnVsbH0gb2xkRGF0YVxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBtYXRlcmlhbDtcbiAgICB2YXIgbWF0ZXJpYWxUeXBlID0gZ2V0TWF0ZXJpYWxUeXBlKGRhdGEpO1xuICAgIHZhciBzcmMgPSBkYXRhLnNyYztcblxuICAgIGlmICghb2xkRGF0YSB8fCBnZXRNYXRlcmlhbFR5cGUob2xkRGF0YSkgIT09IG1hdGVyaWFsVHlwZSkge1xuICAgICAgbWF0ZXJpYWwgPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKGdldE1hdGVyaWFsRGF0YShkYXRhKSwgbWF0ZXJpYWxUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0ZXJpYWwgPSB0aGlzLnVwZGF0ZU1hdGVyaWFsKHByb2Nlc3NNYXRlcmlhbERhdGEoZGlmZihvbGREYXRhLCBkYXRhKSkpO1xuICAgIH1cblxuICAgIC8vIExvYWQgdGV4dHVyZXMgYW5kL29yIGN1YmVtYXBzLlxuICAgIGlmIChtYXRlcmlhbC50eXBlID09PSBNQVRFUklBTF9UWVBFX1NUQU5EQVJEKSB7IHRoaXMudXBkYXRlRW52TWFwKCk7IH1cbiAgICB0aGlzLnVwZGF0ZVRleHR1cmUoc3JjKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIG1hdGVyaWFsIG9uIHJlbW92ZSAoY2FsbGJhY2spLlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgZGVmYXVsdENvbG9yID0gdGhpcy5zY2hlbWEuY29sb3IuZGVmYXVsdDtcbiAgICB2YXIgZGVmYXVsdE1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IGRlZmF1bHRDb2xvciB9KTtcbiAgICB2YXIgb2JqZWN0M0QgPSBlbC5nZXRPYmplY3QzRCgnbWVzaCcpO1xuICAgIGlmIChvYmplY3QzRCkgeyBvYmplY3QzRC5tYXRlcmlhbCA9IGRlZmF1bHRNYXRlcmlhbDsgfVxuICAgIGVsLnNjZW5lRWwudW5yZWdpc3Rlck1hdGVyaWFsKHRoaXMubWF0ZXJpYWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiAoUmUpY3JlYXRlIG5ldyBtYXRlcmlhbC4gSGFzIHNpZGUtZWZmZWN0cyBvZiBzZXR0aW5nIGB0aGlzLm1hdGVyaWFsYCBhbmQgdXBkYXRpbmdcbiAgICogbWF0ZXJpYWwgcmVnaXN0cmF0aW9uIGluIHNjZW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIE1hdGVyaWFsIGNvbXBvbmVudCBkYXRhLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHlwZSAtIE1hdGVyaWFsIHR5cGUgdG8gY3JlYXRlLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBNYXRlcmlhbC5cbiAgICovXG4gIGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkge1xuICAgIHZhciBtYXRlcmlhbDtcbiAgICB2YXIgbWVzaCA9IHRoaXMuZWwuZ2V0T3JDcmVhdGVPYmplY3QzRCgnbWVzaCcsIFRIUkVFLk1lc2gpO1xuICAgIHZhciBzY2VuZUVsID0gdGhpcy5lbC5zY2VuZUVsO1xuICAgIGlmICh0aGlzLm1hdGVyaWFsKSB7IHNjZW5lRWwudW5yZWdpc3Rlck1hdGVyaWFsKHRoaXMubWF0ZXJpYWwpOyB9XG4gICAgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbCA9IG5ldyBUSFJFRVt0eXBlXShkYXRhKTtcbiAgICBzY2VuZUVsLnJlZ2lzdGVyTWF0ZXJpYWwobWF0ZXJpYWwpO1xuICAgIHJldHVybiBtYXRlcmlhbDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRpbmcgZXhpc3RpbmcgbWF0ZXJpYWwuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gTWF0ZXJpYWwgY29tcG9uZW50IGRhdGEuXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IE1hdGVyaWFsLlxuICAgKi9cbiAgdXBkYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIG1hdGVyaWFsW2tleV0gPSBkYXRhW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdGVyaWFsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZW52aXJvbm1lbnQgY3ViZW1hcC4gVGV4dHVyZXMgYXJlIGNhY2hlZCBpbiB0ZXh0dXJlUHJvbWlzZXMuXG4gICAqL1xuICB1cGRhdGVFbnZNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICB2YXIgZW52TWFwID0gdGhpcy5kYXRhLmVudk1hcDtcbiAgICAvLyBFbnZpcm9ubWVudCBjdWJlbWFwcy5cbiAgICBpZiAoIWVudk1hcCB8fCB0aGlzLmlzTG9hZGluZ0Vudk1hcCkge1xuICAgICAgbWF0ZXJpYWwuZW52TWFwID0gbnVsbDtcbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc0xvYWRpbmdFbnZNYXAgPSB0cnVlO1xuICAgIGlmICh0ZXh0dXJlUHJvbWlzZXNbZW52TWFwXSkge1xuICAgICAgLy8gQW5vdGhlciBtYXRlcmlhbCBpcyBhbHJlYWR5IGxvYWRpbmcgdGhpcyB0ZXh0dXJlLiBXYWl0IG9uIHByb21pc2UuXG4gICAgICB0ZXh0dXJlUHJvbWlzZXNbZW52TWFwXS50aGVuKGZ1bmN0aW9uIChjdWJlKSB7XG4gICAgICAgIHNlbGYuaXNMb2FkaW5nRW52TWFwID0gZmFsc2U7XG4gICAgICAgIG1hdGVyaWFsLmVudk1hcCA9IGN1YmU7XG4gICAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNYXRlcmlhbCBpcyBmaXJzdCB0byBsb2FkIHRoaXMgdGV4dHVyZS4gTG9hZCBhbmQgcmVzb2x2ZSB0ZXh0dXJlLlxuICAgICAgdGV4dHVyZVByb21pc2VzW2Vudk1hcF0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzcmNMb2FkZXIudmFsaWRhdGVDdWJlbWFwU3JjKGVudk1hcCwgZnVuY3Rpb24gbG9hZEVudk1hcCAodXJscykge1xuICAgICAgICAgIEN1YmVMb2FkZXIubG9hZCh1cmxzLCBmdW5jdGlvbiAoY3ViZSkge1xuICAgICAgICAgICAgLy8gVGV4dHVyZSBsb2FkZWQuXG4gICAgICAgICAgICBzZWxmLmlzTG9hZGluZ0Vudk1hcCA9IGZhbHNlO1xuICAgICAgICAgICAgbWF0ZXJpYWwuZW52TWFwID0gY3ViZTtcbiAgICAgICAgICAgIHJlc29sdmUoY3ViZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIFVwZGF0ZXMgbWF0ZXJpYWwgdGV4dHVyZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gc3JjIC0gQW4gPGltZz4gLyA8dmlkZW8+IGVsZW1lbnQgb3IgdXJsIHRvIGFuIGltYWdlL3ZpZGVvIGZpbGUuXG4gICAqL1xuICB1cGRhdGVUZXh0dXJlOiBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcbiAgICBpZiAoc3JjKSB7XG4gICAgICBpZiAoc3JjICE9PSB0aGlzLnRleHR1cmVTcmMpIHtcbiAgICAgICAgLy8gVGV4dHVyZSBhZGRlZCBvciBjaGFuZ2VkLlxuICAgICAgICB0aGlzLnRleHR1cmVTcmMgPSBzcmM7XG4gICAgICAgIHNyY0xvYWRlci52YWxpZGF0ZVNyYyhzcmMsIGxvYWRJbWFnZSwgbG9hZFZpZGVvKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGV4dHVyZSByZW1vdmVkLlxuICAgICAgbWF0ZXJpYWwubWFwID0gbnVsbDtcbiAgICAgIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZEltYWdlIChzcmMpIHsgbG9hZEltYWdlVGV4dHVyZShtYXRlcmlhbCwgc3JjLCBkYXRhLnJlcGVhdCk7IH1cbiAgICBmdW5jdGlvbiBsb2FkVmlkZW8gKHNyYykgeyBsb2FkVmlkZW9UZXh0dXJlKG1hdGVyaWFsLCBzcmMsIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0KTsgfVxuICB9XG59KTtcblxuLyoqXG4gKiBTZXRzIGltYWdlIHRleHR1cmUgb24gbWF0ZXJpYWwgYXMgYG1hcGAuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1hdGVyaWFsIC0gdGhyZWUuanMgbWF0ZXJpYWwuXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNyYyAtIEFuIDxpbWc+IGVsZW1lbnQgb3IgdXJsIHRvIGFuIGltYWdlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVwZWF0IC0gWCBhbmQgWSB2YWx1ZSBmb3Igc2l6ZSBvZiB0ZXh0dXJlIHJlcGVhdGluZyAoaW4gVVYgdW5pdHMpLlxuICovXG5mdW5jdGlvbiBsb2FkSW1hZ2VUZXh0dXJlIChtYXRlcmlhbCwgc3JjLCByZXBlYXQpIHtcbiAgdmFyIGlzRWwgPSB0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJztcblxuICB2YXIgb25Mb2FkID0gY3JlYXRlVGV4dHVyZTtcbiAgdmFyIG9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoeGhyKSB7XG4gICAgZXJyb3IoJ1RoZSBVUkwgXCIkc1wiIGNvdWxkIG5vdCBiZSBmZXRjaGVkIChFcnJvciBjb2RlOiAlczsgUmVzcG9uc2U6ICVzKScsXG4gICAgICAgICAgeGhyLnN0YXR1cywgeGhyLnN0YXR1c1RleHQpO1xuICB9O1xuXG4gIGlmIChpc0VsKSB7XG4gICAgY3JlYXRlVGV4dHVyZShzcmMpO1xuICB9IGVsc2Uge1xuICAgIFRleHR1cmVMb2FkZXIubG9hZChzcmMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlICh0ZXh0dXJlKSB7XG4gICAgaWYgKCEodGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUpKSB7IHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSh0ZXh0dXJlKTsgfVxuICAgIHZhciByZXBlYXRYWTtcbiAgICBpZiAocmVwZWF0KSB7XG4gICAgICByZXBlYXRYWSA9IHJlcGVhdC5zcGxpdCgnICcpO1xuICAgICAgaWYgKHJlcGVhdFhZLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XG4gICAgICAgIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcbiAgICAgICAgdGV4dHVyZS5yZXBlYXQuc2V0KHBhcnNlSW50KHJlcGVhdFhZWzBdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChyZXBlYXRYWVsxXSwgMTApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWF0ZXJpYWwubWFwID0gdGV4dHVyZTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdmlkZW8gZWxlbWVudCB0byBiZSB1c2VkIGFzIGEgdGV4dHVyZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbWF0ZXJpYWwgLSB0aHJlZS5qcyBtYXRlcmlhbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgLSBVcmwgdG8gYSB2aWRlbyBmaWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZGVvLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgdmlkZW8uXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gVmlkZW8gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVmlkZW9FbCAobWF0ZXJpYWwsIHNyYywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgZWwgPSBtYXRlcmlhbC52aWRlb0VsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gIGZ1bmN0aW9uIG9uRXJyb3IgKCkge1xuICAgIHdhcm4oJ1RoZSBVUkwgXCIkc1wiIGlzIG5vdCBhIHZhbGlkIGltYWdlIG9yIHZpZGVvJywgc3JjKTtcbiAgfVxuICBlbC53aWR0aCA9IHdpZHRoO1xuICBlbC5oZWlnaHQgPSBoZWlnaHQ7XG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgaWYgYnJhbmQgbmV3IHZpZGVvIGVsZW1lbnQuXG4gIGlmIChlbCAhPT0gdGhpcy52aWRlb0VsKSB7XG4gICAgZWwuYXV0b3BsYXkgPSB0cnVlO1xuICAgIGVsLmxvb3AgPSB0cnVlO1xuICAgIGVsLmNyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IsIHRydWUpO1xuICAgIG1hdGVyaWFsLnZpZGVvRWwgPSBlbDtcbiAgfVxuICBlbC5zcmMgPSBzcmM7XG4gIHJldHVybiBlbDtcbn1cblxuLyoqXG4gKiBTZXRzIHZpZGVvIHRleHR1cmUgb24gbWF0ZXJpYWwgYXMgbWFwLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXRlcmlhbCAtIHRocmVlLmpzIG1hdGVyaWFsLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIFVybCB0byBhIHZpZGVvIGZpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgdmlkZW8uXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSB2aWRlby5cbiovXG5mdW5jdGlvbiBsb2FkVmlkZW9UZXh0dXJlIChtYXRlcmlhbCwgc3JjLCBoZWlnaHQsIHdpZHRoKSB7XG4gIC8vIHRocmVlLmpzIHZpZGVvIHRleHR1cmUgbG9hZGVyIHJlcXVpcmVzIGEgPHZpZGVvPi5cbiAgdmFyIHZpZGVvRWwgPSB0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJyA/IGZpeFZpZGVvQXR0cmlidXRlcyhzcmMpIDogY3JlYXRlVmlkZW9FbChtYXRlcmlhbCwgc3JjLCBoZWlnaHQsIHdpZHRoKTtcbiAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVmlkZW9UZXh0dXJlKHZpZGVvRWwpO1xuICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIG1hdGVyaWFsLm1hcCA9IHRleHR1cmU7XG4gIG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBGaXhlcyBhIHZpZGVvIGVsZW1lbnQncyBhdHRyaWJ1dGVzIHRvIHByZXZlbnQgZGV2ZWxvcGVycyBmcm9tIGFjY2lkZW50YWxseVxuICogcGFzc2luZyB0aGUgd3JvbmcgYXR0cmlidXRlIHZhbHVlcyB0byBjb21tb25seSBtaXN1c2VkIHZpZGVvIGF0dHJpYnV0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvdmlkZW8jQXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50fSB2aWRlb0VsIC0gVmlkZW8gZWxlbWVudC5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBWaWRlbyBlbGVtZW50IHdpdGggdGhlIGNvcnJlY3QgcHJvcGVydGllcyB1cGRhdGVkLlxuICovXG5mdW5jdGlvbiBmaXhWaWRlb0F0dHJpYnV0ZXMgKHZpZGVvRWwpIHtcbiAgLy8gVGhlIGA8dmlkZW8+YCBlbGVtZW50IHRyZWF0cyBgbG9vcGAgYW5kIGBtdXRlZGAgYXMgYm9vbGVhbiBhdHRyaWJ1dGVzLCBidXRcbiAgLy8gb2YgY291cnNlIGRvZXMgbm90IHdpdGggYGF1dG9wbGF5YCwgYGNvbnRyb2xzYCwgYHByZWxvYWRgIChhbmQgYGNyb3Nzb3JpZ2luYCkuXG4gIC8vIElmIHdlIGdldCBwYXNzZWQgYSBgPHZpZGVvIGF1dG9wbGF5PVwiZmFsc2VcIj5gLCBsZXQncyBhc3N1bWUgdGhlIGRldiB3YW50ZWRcbiAgLy8gYGF1dG9wbGF5YCB0byBiZSBkaXNhYmxlZC5cbiAgdmlkZW9FbC5hdXRvcGxheSA9IHZpZGVvRWwuZ2V0QXR0cmlidXRlKCdhdXRvcGxheScpICE9PSAnZmFsc2UnO1xuICB2aWRlb0VsLmNvbnRyb2xzID0gdmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ2NvbnRyb2xzJykgIT09ICdmYWxzZSc7XG4gIGlmICh2aWRlb0VsLmdldEF0dHJpYnV0ZSgncHJlbG9hZCcpID09PSAnZmFsc2UnKSB7XG4gICAgdmlkZW9FbC5wcmVsb2FkID0gJ25vbmUnO1xuICB9XG4gIHJldHVybiB2aWRlb0VsO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhbmQgbm9ybWFsaXplIG1hdGVyaWFsIGRhdGEsIG5vcm1hbGl6aW5nIHN0dWZmIGFsb25nIHRoZSB3YXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBNYXRlcmlhbCBkYXRhLlxuICogQHJldHVybnMge29iamVjdH0gZGF0YSAtIFByb2Nlc3NlZCBtYXRlcmlhbCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXRlcmlhbERhdGEgKGRhdGEpIHtcbiAgdmFyIG1hdGVyaWFsRGF0YSA9IHtcbiAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICBzaWRlOiBkYXRhLnNpZGUsXG4gICAgb3BhY2l0eTogZGF0YS5vcGFjaXR5LFxuICAgIHRyYW5zcGFyZW50OiBkYXRhLnRyYW5zcGFyZW50ICE9PSBmYWxzZSB8fCBkYXRhLm9wYWNpdHkgPCAxLjBcbiAgfTtcbiAgaWYgKGdldE1hdGVyaWFsVHlwZShkYXRhKSA9PT0gTUFURVJJQUxfVFlQRV9TVEFOREFSRCkge1xuICAgIC8vIEF0dGFjaCBzdGFuZGFyZCBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgIG1hdGVyaWFsRGF0YS5tZXRhbG5lc3MgPSBkYXRhLm1ldGFsbmVzcztcbiAgICBtYXRlcmlhbERhdGEucm91Z2huZXNzID0gZGF0YS5yb3VnaG5lc3M7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3NNYXRlcmlhbERhdGEobWF0ZXJpYWxEYXRhKTtcbn1cblxuLyoqXG4gKiBOZWNlc3NhcnkgdHJhbnNmb3JtcyB0byBtYXRlcmlhbCBkYXRhIGJlZm9yZSBwYXNzaW5nIHRvIHRocmVlLmpzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gTWF0ZXJpYWwgZGF0YS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFByb2Nlc3NlZCBtYXRlcmlhbCBkYXRhLlxuICovXG5mdW5jdGlvbiBwcm9jZXNzTWF0ZXJpYWxEYXRhIChkYXRhKSB7XG4gIGlmICgnY29sb3InIGluIGRhdGEpIHtcbiAgICBkYXRhLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGRhdGEuY29sb3IpO1xuICB9XG4gIGlmICgnb3BhY2l0eScgaW4gZGF0YSAmJiBkYXRhLm9wYWNpdHkgPCAxKSB7XG4gICAgZGF0YS50cmFuc3BhcmVudCA9IHRydWU7XG4gIH1cbiAgaWYgKCdzaWRlJyBpbiBkYXRhKSB7XG4gICAgZGF0YS5zaWRlID0gZ2V0U2lkZShkYXRhLnNpZGUpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCBtYXRlcmlhbCB0eXBlIGJhc2VkIG9uIHNoYWRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gTWF0ZXJpYWwgY29tcG9uZW50IGRhdGEuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBNYXRlcmlhbCB0eXBlIChhcyB0aHJlZS5qcyBjb25zdHJ1Y3RvciBuYW1lKVxuICovXG5mdW5jdGlvbiBnZXRNYXRlcmlhbFR5cGUgKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2hhZGVyID09PSAnZmxhdCcgPyBNQVRFUklBTF9UWVBFX0JBU0lDIDogTUFURVJJQUxfVFlQRV9TVEFOREFSRDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdGhyZWUuanMgY29uc3RhbnQgZGV0ZXJtaW5pbmcgd2hpY2ggbWF0ZXJpYWwgZmFjZSBzaWRlcyB0byByZW5kZXJcbiAqIGJhc2VkIG9uIHRoZSBzaWRlIHBhcmFtZXRlciAocGFzc2VkIGFzIGEgY29tcG9uZW50IHByb3BlcnR5KS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NpZGU9ZnJvbnRdIC0gYGZyb250YCwgYGJhY2tgLCBvciBgZG91YmxlYC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRIUkVFLkZyb250U2lkZSwgVEhSRUUuQmFja1NpZGUsIG9yIFRIUkVFLkRvdWJsZVNpZGUuXG4gKi9cbmZ1bmN0aW9uIGdldFNpZGUgKHNpZGUpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAnYmFjayc6IHtcbiAgICAgIHJldHVybiBUSFJFRS5CYWNrU2lkZTtcbiAgICB9XG4gICAgY2FzZSAnZG91YmxlJzoge1xuICAgICAgcmV0dXJuIFRIUkVFLkRvdWJsZVNpZGU7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIC8vIEluY2x1ZGluZyBjYXNlIGBmcm9udGAuXG4gICAgICByZXR1cm4gVEhSRUUuRnJvbnRTaWRlO1xuICAgIH1cbiAgfVxufVxuIiwidmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3Bvc2l0aW9uJywge1xuICBzY2hlbWE6IHsgdHlwZTogJ3ZlYzMnIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iamVjdDNEID0gdGhpcy5lbC5vYmplY3QzRDtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBvYmplY3QzRC5wb3NpdGlvbi5zZXQoZGF0YS54LCBkYXRhLnksIGRhdGEueik7XG4gIH1cbn0pO1xuIiwidmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcbnZhciByZXF1ZXN0SW50ZXJ2YWwgPSByZXF1aXJlKCdyZXF1ZXN0LWludGVydmFsJyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3JheWNhc3RlcicsIHtcbiAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xuICAgIHRoaXMuaW50ZXJzZWN0ZWRFbCA9IG51bGw7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucG9sbEZvckhvdmVySW50ZXJzZWN0aW9ucygpO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvbGxJbnRlcnZhbCA9IHRoaXMucG9sbEludGVydmFsO1xuICAgIGlmICghcG9sbEludGVydmFsKSB7IHJldHVybjsgfVxuICAgIHJlcXVlc3RJbnRlcnZhbC5jbGVhcih0aGlzLnBvbGxJbnRlcnZhbCk7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9LFxuXG4gIHBvbGxGb3JIb3ZlckludGVyc2VjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbCA9IHJlcXVlc3RJbnRlcnZhbCgxMDAsIHRoaXMuZ2V0SW50ZXJzZWN0aW9ucy5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsb3Nlc3QgPSB0aGlzLmdldENsb3Nlc3RJbnRlcnNlY3RlZCgpO1xuICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICB0aGlzLmhhbmRsZUludGVyc2VjdGlvbihjbG9zZXN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBubyBpbnRlcnNlY3Rpb25zIG90aGVyIHRoYW4gdGhlIGN1cnNvciBpdHNlbGYsXG4gICAgLy8gYnV0IHdlIHN0aWxsIGhhdmUgYSBwcmV2aW91c2x5IGludGVyc2VjdGVkIGVsZW1lbnQsIGNsZWFyIGl0LlxuICAgIGlmICh0aGlzLmludGVyc2VjdGVkRWwpIHtcbiAgICAgIHRoaXMuY2xlYXJFeGlzdGluZ0ludGVyc2VjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIChvYmplY3RzKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgcmF5Y2FzdGVyID0gdGhpcy5yYXljYXN0ZXI7XG4gICAgdmFyIGN1cnNvciA9IGVsLm9iamVjdDNEO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlLm9iamVjdDNEO1xuICAgIHZhciBvcmlnaW5Qb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHBhcmVudC5tYXRyaXhXb3JsZCk7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oY3Vyc29yLm1hdHJpeFdvcmxkKTtcbiAgICB2YXIgZGlyZWN0aW9uID0gY3Vyc29yUG9zaXRpb24uc3ViKG9yaWdpblBvc2l0aW9uKS5ub3JtYWxpemUoKTtcbiAgICByYXljYXN0ZXIuc2V0KG9yaWdpblBvc2l0aW9uLCBkaXJlY3Rpb24pO1xuICAgIHJldHVybiByYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0cyhvYmplY3RzLCB0cnVlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xvc2VzdCBpbnRlcnNlY3RlZCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH1cbiAgICogICBUaGUgY2xvc2VzdCBpbnRlcnNlY3RlZCBlbGVtZW50IHRoYXQgaXMgbm90IHRoZSBjdXJzb3IgaXRzZWxmLFxuICAgKiAgIGFuIGludmlzaWJsZSBlbGVtZW50LCBvciBub3QgYSBhLWZyYW1lIGVudGl0eSBlbGVtZW50LlxuICAgKiAgIElmIG5vIG9iamVjdHMgYXJlIGludGVyc2VjdGVkLCBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRDbG9zZXN0SW50ZXJzZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmVsLnNjZW5lRWwub2JqZWN0M0Q7XG4gICAgdmFyIGN1cnNvckVsID0gdGhpcy5lbDtcbiAgICB2YXIgaW50ZXJzZWN0ZWRPYmo7XG4gICAgdmFyIGludGVyc2VjdGVkT2JqcyA9IHRoaXMuaW50ZXJzZWN0KHNjZW5lLmNoaWxkcmVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVyc2VjdGVkT2Jqcy5sZW5ndGg7ICsraSkge1xuICAgICAgaW50ZXJzZWN0ZWRPYmogPSBpbnRlcnNlY3RlZE9ianNbaV07XG4gICAgICAvLyBJZiB0aGUgaW50ZXJzZWN0ZWQgb2JqZWN0IGlzIHRoZSBjdXJzb3IgaXRzZWxmXG4gICAgICAvLyBvciB0aGUgb2JqZWN0IGlzIGZ1cnRoZXIgdGhhbiB0aGUgbWF4IGRpc3RhbmNlXG4gICAgICBpZiAoaW50ZXJzZWN0ZWRPYmoub2JqZWN0LmVsID09PSB1bmRlZmluZWQpIHsgY29udGludWU7IH1cbiAgICAgIGlmIChpbnRlcnNlY3RlZE9iai5vYmplY3QuZWwgPT09IGN1cnNvckVsKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIWludGVyc2VjdGVkT2JqLm9iamVjdC52aXNpYmxlKSB7IGNvbnRpbnVlOyB9XG4gICAgICByZXR1cm4gaW50ZXJzZWN0ZWRPYmo7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1lbWJlcnMgdGhlIGxhc3QgaW50ZXJzZWN0ZWQgZWxlbWVudFxuICAgKi9cbiAgc2V0RXhpc3RpbmdJbnRlcnNlY3Rpb246IGZ1bmN0aW9uIChlbCwgZGlzdGFuY2UpIHtcbiAgICB0aGlzLmludGVyc2VjdGVkRWwgPSBlbDtcbiAgICB0aGlzLmVsLmVtaXQoJ2ludGVyc2VjdGlvbicsIHsgZWw6IGVsLCBkaXN0YW5jZTogZGlzdGFuY2UgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgYG1vdXNlbGVhdmVgIGV2ZW50IGFuZCBjbGVhcnMgaW5mbyBhYm91dCB0aGUgbGFzdCBpbnRlcnNlY3Rpb24uXG4gICAqL1xuICBjbGVhckV4aXN0aW5nSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGludGVyc2VjdGVkRWwgPSB0aGlzLmludGVyc2VjdGVkRWw7XG4gICAgdGhpcy5lbC5lbWl0KCdpbnRlcnNlY3Rpb25jbGVhcmVkJywgeyBlbDogaW50ZXJzZWN0ZWRFbCB9KTtcbiAgICB0aGlzLmludGVyc2VjdGVkRWwgPSBudWxsO1xuICB9LFxuXG4gIGhhbmRsZUludGVyc2VjdGlvbjogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBlbCA9IG9iai5vYmplY3QuZWw7XG5cbiAgICAvLyBBIG5ldyBpbnRlcnNlY3Rpb24gd2hlcmUgcHJldmlvdXNseSBhIGRpZmZlcmVudCBlbGVtZW50IHdhc1xuICAgIC8vIGFuZCBub3cgbmVlZHMgYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgIGlmICh0aGlzLmludGVyc2VjdGVkRWwgIT09IGVsKSB7XG4gICAgICB0aGlzLmNsZWFyRXhpc3RpbmdJbnRlcnNlY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5zZXRFeGlzdGluZ0ludGVyc2VjdGlvbihlbCwgb2JqLmRpc3RhbmNlKTtcbiAgfVxufSk7XG4iLCJ2YXIgZGVnVG9SYWQgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKS5NYXRoLmRlZ1RvUmFkO1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gcmVxdWlyZSgnLi4vY29yZS9jb21wb25lbnQnKS5yZWdpc3RlckNvbXBvbmVudDtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3JvdGF0aW9uJywge1xuICBzY2hlbWE6IHsgdHlwZTogJ3ZlYzMnIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgb2JqZWN0M0Qgcm90YXRpb24uXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2JqZWN0M0QgPSB0aGlzLmVsLm9iamVjdDNEO1xuICAgIG9iamVjdDNELnJvdGF0aW9uLnNldChkZWdUb1JhZChkYXRhLngpLCBkZWdUb1JhZChkYXRhLnkpLCBkZWdUb1JhZChkYXRhLnopKTtcbiAgICBvYmplY3QzRC5yb3RhdGlvbi5vcmRlciA9ICdZWFonO1xuICB9XG59KTtcbiIsInZhciByZWdpc3RlckNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG5cbi8vIEF2b2lkcyB0cmlnZ2VyaW5nIGEgemVyby1kZXRlcm1pbmFudCB3aGljaCBtYWtlcyBvYmplY3QzRCBtYXRyaXggbm9uLWludmVydGlibGUuXG52YXIgemVyb1NjYWxlID0gMC4wMDAwMTtcblxubW9kdWxlLmV4cG9ydHMuQ29tcG9uZW50ID0gcmVnaXN0ZXJDb21wb25lbnQoJ3NjYWxlJywge1xuICBzY2hlbWE6IHtcbiAgICB0eXBlOiAndmVjMycsXG4gICAgZGVmYXVsdDogeyB4OiAxLCB5OiAxLCB6OiAxIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2JqZWN0M0QgPSB0aGlzLmVsLm9iamVjdDNEO1xuICAgIHZhciB4ID0gZGF0YS54ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS54O1xuICAgIHZhciB5ID0gZGF0YS55ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS55O1xuICAgIHZhciB6ID0gZGF0YS56ID09PSAwID8gemVyb1NjYWxlIDogZGF0YS56O1xuICAgIG9iamVjdDNELnNjYWxlLnNldCh4LCB5LCB6KTtcbiAgfVxufSk7XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCcuLi91dGlscy9kZWJ1ZycpO1xudmFyIGRpZmYgPSByZXF1aXJlKCcuLi91dGlscycpLmRpZmY7XG52YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG5cbnZhciB3YXJuID0gZGVidWcoJ2NvbXBvbmVudHM6c291bmQ6d2FybicpO1xuXG4vKipcbiAqIFNvdW5kIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2x9IFthdXRvcGxheT1mYWxzZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBvblxuICogQHBhcmFtIHtib29sfSBbbG9vcD1mYWxzZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbdm9sdW1lPTFdXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCdzb3VuZCcsIHtcbiAgc2NoZW1hOiB7XG4gICAgc3JjOiB7IGRlZmF1bHQ6ICcnIH0sXG4gICAgb246IHsgZGVmYXVsdDogJ2NsaWNrJyB9LFxuICAgIGF1dG9wbGF5OiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgbG9vcDogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIHZvbHVtZTogeyBkZWZhdWx0OiAxIH1cbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XG4gICAgdGhpcy5zb3VuZCA9IG51bGw7XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAob2xkRGF0YSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBkaWZmRGF0YSA9IGRpZmYob2xkRGF0YSB8fCB7fSwgZGF0YSk7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgc291bmQgPSB0aGlzLnNvdW5kO1xuICAgIHZhciBzcmMgPSBkYXRhLnNyYztcbiAgICB2YXIgc3JjQ2hhbmdlZCA9ICdzcmMnIGluIGRpZmZEYXRhO1xuXG4gICAgLy8gQ3JlYXRlIG5ldyBzb3VuZCBpZiBub3QgeWV0IGNyZWF0ZWQgb3IgY2hhbmdpbmcgYHNyY2AuXG4gICAgaWYgKHNyY0NoYW5nZWQpIHtcbiAgICAgIGlmICghc3JjKSB7XG4gICAgICAgIHdhcm4oJ0F1ZGlvIHNvdXJjZSB3YXMgbm90IHNwZWNpZmllZCB3aXRoIGBzcmNgJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNvdW5kID0gdGhpcy5zZXR1cFNvdW5kKCk7XG4gICAgfVxuXG4gICAgaWYgKHNyY0NoYW5nZWQgfHwgJ2F1dG9wbGF5JyBpbiBkaWZmRGF0YSkge1xuICAgICAgc291bmQuYXV0b3BsYXkgPSBkYXRhLmF1dG9wbGF5O1xuICAgIH1cblxuICAgIGlmIChzcmNDaGFuZ2VkIHx8ICdsb29wJyBpbiBkaWZmRGF0YSkge1xuICAgICAgc291bmQuc2V0TG9vcChkYXRhLmxvb3ApO1xuICAgIH1cblxuICAgIGlmIChzcmNDaGFuZ2VkIHx8ICd2b2x1bWUnIGluIGRpZmZEYXRhKSB7XG4gICAgICBzb3VuZC5zZXRWb2x1bWUoZGF0YS52b2x1bWUpO1xuICAgIH1cblxuICAgIGlmICgnb24nIGluIGRpZmZEYXRhKSB7XG4gICAgICBpZiAob2xkRGF0YSAmJiBvbGREYXRhLm9uKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIob2xkRGF0YS5vbik7XG4gICAgICB9XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGRhdGEub24sIHRoaXMucGxheS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgc291bmQgdmFsdWVzIHNldC4gTG9hZCBpbiBgc3JjLlxuICAgIGlmIChzcmNDaGFuZ2VkKSB7XG4gICAgICBzb3VuZC5sb2FkKHNyYyk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwuc2V0T2JqZWN0M0QoJ3NvdW5kJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgY3VycmVudCBzb3VuZCBvYmplY3QsIGNyZWF0ZXMgbmV3IHNvdW5kIG9iamVjdCwgYWRkcyB0byBlbnRpdHkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHNvdW5kXG4gICAqL1xuICBzZXR1cFNvdW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICB2YXIgbGlzdGVuZXI7XG4gICAgdmFyIHNvdW5kID0gdGhpcy5zb3VuZDtcblxuICAgIGlmIChzb3VuZCkge1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICBlbC5zZXRPYmplY3QzRCgnc291bmQnKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXIgPSBuZXcgVEhSRUUuQXVkaW9MaXN0ZW5lcigpO1xuICAgIHNvdW5kID0gdGhpcy5zb3VuZCA9IG5ldyBUSFJFRS5BdWRpbyhsaXN0ZW5lcik7XG4gICAgZWwuc2V0T2JqZWN0M0QoJ3NvdW5kJywgc291bmQpO1xuICAgIHJldHVybiBzb3VuZDtcbiAgfSxcblxuICBwbGF5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zb3VuZC5wbGF5KCk7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc291bmQuc3RvcCgpO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zb3VuZC5wYXVzZSgpO1xuICB9XG59KTtcbiIsInZhciByZWdpc3RlckNvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvcmUvY29tcG9uZW50JykucmVnaXN0ZXJDb21wb25lbnQ7XG5cbi8qKlxuICogVmlzaWJpbGl0eSBjb21wb25lbnQuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCd2aXNpYmxlJywge1xuICBzY2hlbWE6IHtcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWwub2JqZWN0M0QudmlzaWJsZSA9IHRoaXMuZGF0YTtcbiAgfVxufSk7XG4iLCJ2YXIgcmVnaXN0ZXJDb21wb25lbnQgPSByZXF1aXJlKCcuLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG5cbnZhciBNQVhfREVMVEEgPSAwLjI7XG5cbi8qKlxuICogV0FTRCBjb21wb25lbnQuXG4gKlxuICogQ29udHJvbCB5b3VyIGVudGl0aWVzIHdpdGggdGhlIFdBU0Qga2V5cy5cbiAqXG4gKiBAbmFtZXNwYWNlIHdhc2QtY29udHJvbHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZWFzaW5nPTIwXSAtIEhvdyBmYXN0IHRoZSBtb3ZlbWVudCBkZWNlbGVyYXRlcy4gSWYgeW91IGhvbGQgdGhlXG4gKiBrZXlzIHRoZSBlbnRpdHkgbW92ZXMgYW5kIGlmIHlvdSByZWxlYXNlIGl0IHdpbGwgc3RvcC4gRWFzaW5nIHNpbXVsYXRlcyBmcmljdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYWNjZWxlcmF0aW9uPTY1XSAtIERldGVybWluZXMgdGhlIGFjY2VsZXJhdGlvbiBnaXZlblxuICogdG8gdGhlIGVudGl0eSB3aGVuIHByZXNzaW5nIHRoZSBrZXlzLlxuICogQHBhcmFtIHtib29sfSBbZW5hYmxlZD10cnVlXSAtIFRvIGNvbXBsZXRlbHkgZW5hYmxlIG9yIGRpc2FibGUgdGhlIGNvbnRyb2xzXG4gKiBAcGFyYW0ge2Jvb2x9IFtmbHk9ZmFsc2VdIC0gRGV0ZXJtaW5lcyBpZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudCBzdGlja3NcbiAqIHRvIHRoZSBwbGFuZSB3aGVyZSB0aGUgZW50aXR5IHN0YXJ0ZWQgb2ZmIG9yIGlmIHRoZXJlIGFyZSA2IGRlZ3JlZXMgb2ZcbiAqIGZyZWVkb20gYXMgYSBkaXZlciB1bmRlcndhdGVyIG9yIGEgcGxhbmUgZmx5aW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFt3c0F4aXM9J3onXSAtIFRoZSBheGlzIHRoYXQgdGhlIFcgYW5kIFMga2V5cyBvcGVyYXRlIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FkQXhpcz0neCddIC0gVGhlIGF4aXMgdGhhdCB0aGUgQSBhbmQgRCBrZXlzIG9wZXJhdGUgb25cbiAqIEBwYXJhbSB7Ym9vbH0gW3dzSW52ZXJ0ZWQ9ZmFsc2VdIC0gV1MgQXhpcyBpcyBpbnZlcnRlZFxuICogQHBhcmFtIHtib29sfSBbYWRJbnZlcnRlZD1mYWxzZV0gLSBBRCBBeGlzIGlzIGludmVydGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNvbXBvbmVudCA9IHJlZ2lzdGVyQ29tcG9uZW50KCd3YXNkLWNvbnRyb2xzJywge1xuICBzY2hlbWE6IHtcbiAgICBlYXNpbmc6IHsgZGVmYXVsdDogMjAgfSxcbiAgICBhY2NlbGVyYXRpb246IHsgZGVmYXVsdDogNjUgfSxcbiAgICBlbmFibGVkOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICBmbHk6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB3c0F4aXM6IHsgZGVmYXVsdDogJ3onLCBvbmVPZjogWyAneCcsICd5JywgJ3onIF0gfSxcbiAgICBhZEF4aXM6IHsgZGVmYXVsdDogJ3gnLCBvbmVPZjogWyAneCcsICd5JywgJ3onIF0gfSxcbiAgICB3c0ludmVydGVkOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgd3NFbmFibGVkOiB7IGRlZmF1bHQ6IHRydWUgfSxcbiAgICBhZEludmVydGVkOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgYWRFbmFibGVkOiB7IGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZlbG9jaXR5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAvLyBUbyBrZWVwIHRyYWNrIG9mIHRoZSBwcmVzc2VkIGtleXNcbiAgICB0aGlzLmtleXMgPSB7fTtcbiAgICB0aGlzLm9uS2V5RG93biA9IHRoaXMub25LZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbktleVVwID0gdGhpcy5vbktleVVwLmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzY2VuZSA9IHRoaXMuZWwuc2NlbmVFbDtcbiAgICB0aGlzLmF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgc2NlbmUuYWRkQmVoYXZpb3IodGhpcyk7XG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2NlbmUgPSB0aGlzLmVsLnNjZW5lRWw7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHNjZW5lLnJlbW92ZUJlaGF2aW9yKHRoaXMpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIChwcmV2aW91c0RhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgYWNjZWxlcmF0aW9uID0gZGF0YS5hY2NlbGVyYXRpb247XG4gICAgdmFyIGVhc2luZyA9IGRhdGEuZWFzaW5nO1xuICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHk7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5wcmV2VGltZSA9IHRoaXMucHJldlRpbWUgfHwgRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICB2YXIgZGVsdGEgPSAodGltZSAtIHByZXZUaW1lKSAvIDEwMDA7XG4gICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG4gICAgdmFyIG1vdmVtZW50VmVjdG9yO1xuICAgIHZhciBhZEF4aXMgPSBkYXRhLmFkQXhpcztcbiAgICB2YXIgd3NBeGlzID0gZGF0YS53c0F4aXM7XG4gICAgdmFyIGFkU2lnbiA9IGRhdGEuYWRJbnZlcnRlZCA/IC0xIDogMTtcbiAgICB2YXIgd3NTaWduID0gZGF0YS53c0ludmVydGVkID8gLTEgOiAxO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdGhpcy5wcmV2VGltZSA9IHRpbWU7XG5cbiAgICAvLyBJZiBkYXRhIGhhcyBjaGFuZ2VkIG9yIEZQUyBpcyB0b28gbG93XG4gICAgLy8gd2UgcmVzZXQgdGhlIHZlbG9jaXR5XG4gICAgaWYgKHByZXZpb3VzRGF0YSB8fCBkZWx0YSA+IE1BWF9ERUxUQSkge1xuICAgICAgdmVsb2NpdHlbYWRBeGlzXSA9IDA7XG4gICAgICB2ZWxvY2l0eVt3c0F4aXNdID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2ZWxvY2l0eVthZEF4aXNdIC09IHZlbG9jaXR5W2FkQXhpc10gKiBlYXNpbmcgKiBkZWx0YTtcbiAgICB2ZWxvY2l0eVt3c0F4aXNdIC09IHZlbG9jaXR5W3dzQXhpc10gKiBlYXNpbmcgKiBkZWx0YTtcblxuICAgIHZhciBwb3NpdGlvbiA9IGVsLmdldENvbXB1dGVkQXR0cmlidXRlKCdwb3NpdGlvbicpO1xuXG4gICAgaWYgKGRhdGEuZW5hYmxlZCkge1xuICAgICAgaWYgKGRhdGEuYWRFbmFibGVkKSB7XG4gICAgICAgIGlmIChrZXlzWzY1XSkgeyB2ZWxvY2l0eVthZEF4aXNdIC09IGFkU2lnbiAqIGFjY2VsZXJhdGlvbiAqIGRlbHRhOyB9IC8vIExlZnRcbiAgICAgICAgaWYgKGtleXNbNjhdKSB7IHZlbG9jaXR5W2FkQXhpc10gKz0gYWRTaWduICogYWNjZWxlcmF0aW9uICogZGVsdGE7IH0gLy8gUmlnaHRcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLndzRW5hYmxlZCkge1xuICAgICAgICBpZiAoa2V5c1s4N10pIHsgdmVsb2NpdHlbd3NBeGlzXSAtPSB3c1NpZ24gKiBhY2NlbGVyYXRpb24gKiBkZWx0YTsgfSAvLyBVcFxuICAgICAgICBpZiAoa2V5c1s4M10pIHsgdmVsb2NpdHlbd3NBeGlzXSArPSB3c1NpZ24gKiBhY2NlbGVyYXRpb24gKiBkZWx0YTsgfSAvLyBEb3duXG4gICAgICB9XG4gICAgfVxuXG4gICAgbW92ZW1lbnRWZWN0b3IgPSB0aGlzLmdldE1vdmVtZW50VmVjdG9yKGRlbHRhKTtcbiAgICBlbC5vYmplY3QzRC50cmFuc2xhdGVYKG1vdmVtZW50VmVjdG9yLngpO1xuICAgIGVsLm9iamVjdDNELnRyYW5zbGF0ZVkobW92ZW1lbnRWZWN0b3IueSk7XG4gICAgZWwub2JqZWN0M0QudHJhbnNsYXRlWihtb3ZlbWVudFZlY3Rvci56KTtcblxuICAgIGVsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7XG4gICAgICB4OiBwb3NpdGlvbi54ICsgbW92ZW1lbnRWZWN0b3IueCxcbiAgICAgIHk6IHBvc2l0aW9uLnkgKyBtb3ZlbWVudFZlY3Rvci55LFxuICAgICAgejogcG9zaXRpb24ueiArIG1vdmVtZW50VmVjdG9yLnpcbiAgICB9KTtcbiAgfSxcblxuICBhdHRhY2hFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24sIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLm9uS2V5VXAsIGZhbHNlKTtcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xuICAgIC8vIEtleWJvYXJkIGV2ZW50c1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24pO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMub25LZXlVcCk7XG4gIH0sXG5cbiAgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB0aGlzLmtleXNbZXZlbnQua2V5Q29kZV0gPSB0cnVlO1xuICB9LFxuXG4gIG9uS2V5VXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMua2V5c1tldmVudC5rZXlDb2RlXSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldE1vdmVtZW50VmVjdG9yOiAoZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgdmFyIGRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIHZhciByb3RhdGlvbiA9IG5ldyBUSFJFRS5FdWxlcigwLCAwLCAwLCAnWVhaJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgIHZhciBlbFJvdGF0aW9uID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoJ3JvdGF0aW9uJyk7XG4gICAgICBkaXJlY3Rpb24uY29weSh2ZWxvY2l0eSk7XG4gICAgICBkaXJlY3Rpb24ubXVsdGlwbHlTY2FsYXIoZGVsdGEpO1xuICAgICAgaWYgKCFlbFJvdGF0aW9uKSB7IHJldHVybiBkaXJlY3Rpb247IH1cbiAgICAgIGlmICghdGhpcy5kYXRhLmZseSkgeyBlbFJvdGF0aW9uLnggPSAwOyB9XG4gICAgICByb3RhdGlvbi5zZXQoVEhSRUUuTWF0aC5kZWdUb1JhZChlbFJvdGF0aW9uLngpLFxuICAgICAgICAgICAgICAgICAgIFRIUkVFLk1hdGguZGVnVG9SYWQoZWxSb3RhdGlvbi55KSwgMCk7XG4gICAgICBkaXJlY3Rpb24uYXBwbHlFdWxlcihyb3RhdGlvbik7XG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG4gIH0pKClcbn0pO1xuIiwiLyoqXG4gKiBBbmltYXRpb24gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBUV0VFTi5qcyBhbmltYXRpb25zLlxuICogVXNlZCBieSBgPGEtYW5pbWF0aW9uPmAuXG4gKi9cbnZhciBUV0VFTiA9IHJlcXVpcmUoJ3R3ZWVuLmpzJyk7XG5cbnZhciBESVJFQ1RJT05TID0ge1xuICBhbHRlcm5hdGU6ICdhbHRlcm5hdGUnLFxuICBhbHRlcm5hdGVSZXZlcnNlOiAnYWx0ZXJuYXRlLXJldmVyc2UnLFxuICBub3JtYWw6ICdub3JtYWwnLFxuICByZXZlcnNlOiAncmV2ZXJzZSdcbn07XG5cbnZhciBFQVNJTkdfRlVOQ1RJT05TID0ge1xuICAnbGluZWFyJzogVFdFRU4uRWFzaW5nLkxpbmVhci5Ob25lLFxuXG4gICdlYXNlJzogVFdFRU4uRWFzaW5nLkN1YmljLkluT3V0LFxuICAnZWFzZS1pbic6IFRXRUVOLkVhc2luZy5DdWJpYy5JbixcbiAgJ2Vhc2Utb3V0JzogVFdFRU4uRWFzaW5nLkN1YmljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0JzogVFdFRU4uRWFzaW5nLkN1YmljLkluT3V0LFxuXG4gICdlYXNlLWN1YmljJzogVFdFRU4uRWFzaW5nLkN1YmljLkluLFxuICAnZWFzZS1pbi1jdWJpYyc6IFRXRUVOLkVhc2luZy5DdWJpYy5JbixcbiAgJ2Vhc2Utb3V0LWN1YmljJzogVFdFRU4uRWFzaW5nLkN1YmljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogVFdFRU4uRWFzaW5nLkN1YmljLkluT3V0LFxuXG4gICdlYXNlLXF1YWQnOiBUV0VFTi5FYXNpbmcuUXVhZHJhdGljLkluT3V0LFxuICAnZWFzZS1pbi1xdWFkJzogVFdFRU4uRWFzaW5nLlF1YWRyYXRpYy5JbixcbiAgJ2Vhc2Utb3V0LXF1YWQnOiBUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LXF1YWQnOiBUV0VFTi5FYXNpbmcuUXVhZHJhdGljLkluT3V0LFxuXG4gICdlYXNlLXF1YXJ0JzogVFdFRU4uRWFzaW5nLlF1YXJ0aWMuSW5PdXQsXG4gICdlYXNlLWluLXF1YXJ0JzogVFdFRU4uRWFzaW5nLlF1YXJ0aWMuSW4sXG4gICdlYXNlLW91dC1xdWFydCc6IFRXRUVOLkVhc2luZy5RdWFydGljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogVFdFRU4uRWFzaW5nLlF1YXJ0aWMuSW5PdXQsXG5cbiAgJ2Vhc2UtcXVpbnQnOiBUV0VFTi5FYXNpbmcuUXVpbnRpYy5Jbk91dCxcbiAgJ2Vhc2UtaW4tcXVpbnQnOiBUV0VFTi5FYXNpbmcuUXVpbnRpYy5JbixcbiAgJ2Vhc2Utb3V0LXF1aW50JzogVFdFRU4uRWFzaW5nLlF1aW50aWMuT3V0LFxuICAnZWFzZS1pbi1vdXQtcXVpbnQnOiBUV0VFTi5FYXNpbmcuUXVpbnRpYy5Jbk91dCxcblxuICAnZWFzZS1zaW5lJzogVFdFRU4uRWFzaW5nLlNpbnVzb2lkYWwuSW5PdXQsXG4gICdlYXNlLWluLXNpbmUnOiBUV0VFTi5FYXNpbmcuU2ludXNvaWRhbC5JbixcbiAgJ2Vhc2Utb3V0LXNpbmUnOiBUV0VFTi5FYXNpbmcuU2ludXNvaWRhbC5PdXQsXG4gICdlYXNlLWluLW91dC1zaW5lJzogVFdFRU4uRWFzaW5nLlNpbnVzb2lkYWwuSW5PdXQsXG5cbiAgJ2Vhc2UtZXhwbyc6IFRXRUVOLkVhc2luZy5FeHBvbmVudGlhbC5Jbk91dCxcbiAgJ2Vhc2UtaW4tZXhwbyc6IFRXRUVOLkVhc2luZy5FeHBvbmVudGlhbC5JbixcbiAgJ2Vhc2Utb3V0LWV4cG8nOiBUV0VFTi5FYXNpbmcuRXhwb25lbnRpYWwuT3V0LFxuICAnZWFzZS1pbi1vdXQtZXhwbyc6IFRXRUVOLkVhc2luZy5FeHBvbmVudGlhbC5Jbk91dCxcblxuICAnZWFzZS1jaXJjJzogVFdFRU4uRWFzaW5nLkNpcmN1bGFyLkluT3V0LFxuICAnZWFzZS1pbi1jaXJjJzogVFdFRU4uRWFzaW5nLkNpcmN1bGFyLkluLFxuICAnZWFzZS1vdXQtY2lyYyc6IFRXRUVOLkVhc2luZy5DaXJjdWxhci5PdXQsXG4gICdlYXNlLWluLW91dC1jaXJjJzogVFdFRU4uRWFzaW5nLkNpcmN1bGFyLkluT3V0LFxuXG4gICdlYXNlLWVsYXN0aWMnOiBUV0VFTi5FYXNpbmcuRWxhc3RpYy5Jbk91dCxcbiAgJ2Vhc2UtaW4tZWxhc3RpYyc6IFRXRUVOLkVhc2luZy5FbGFzdGljLkluLFxuICAnZWFzZS1vdXQtZWxhc3RpYyc6IFRXRUVOLkVhc2luZy5FbGFzdGljLk91dCxcbiAgJ2Vhc2UtaW4tb3V0LWVsYXN0aWMnOiBUV0VFTi5FYXNpbmcuRWxhc3RpYy5Jbk91dCxcblxuICAnZWFzZS1iYWNrJzogVFdFRU4uRWFzaW5nLkJhY2suSW5PdXQsXG4gICdlYXNlLWluLWJhY2snOiBUV0VFTi5FYXNpbmcuQmFjay5JbixcbiAgJ2Vhc2Utb3V0LWJhY2snOiBUV0VFTi5FYXNpbmcuQmFjay5PdXQsXG4gICdlYXNlLWluLW91dC1iYWNrJzogVFdFRU4uRWFzaW5nLkJhY2suSW5PdXQsXG5cbiAgJ2Vhc2UtYm91bmNlJzogVFdFRU4uRWFzaW5nLkJvdW5jZS5Jbk91dCxcbiAgJ2Vhc2UtaW4tYm91bmNlJzogVFdFRU4uRWFzaW5nLkJvdW5jZS5JbixcbiAgJ2Vhc2Utb3V0LWJvdW5jZSc6IFRXRUVOLkVhc2luZy5Cb3VuY2UuT3V0LFxuICAnZWFzZS1pbi1vdXQtYm91bmNlJzogVFdFRU4uRWFzaW5nLkJvdW5jZS5Jbk91dFxufTtcblxudmFyIEZJTExTID0ge1xuICBiYWNrd2FyZHM6ICdiYWNrd2FyZHMnLFxuICBib3RoOiAnYm90aCcsXG4gIGZvcndhcmRzOiAnZm9yd2FyZHMnLFxuICBub25lOiAnbm9uZSdcbn07XG5cbnZhciBSRVBFQVRTID0ge1xuICBpbmRlZmluaXRlOiAnaW5kZWZpbml0ZSdcbn07XG5cbnZhciBERUZBVUxUUyA9IHtcbiAgYXR0cmlidXRlOiAncm90YXRpb24nLFxuICBiZWdpbjogJzAnLFxuICBkdXI6IDEwMDAsXG4gIGVhc2luZzogJ2Vhc2UnLFxuICBkaXJlY3Rpb246IERJUkVDVElPTlMubm9ybWFsLFxuICBmaWxsOiBGSUxMUy5mb3J3YXJkcyxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICByZXBlYXQ6IDAsXG4gIHRvOiB1bmRlZmluZWRcbn07XG5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHRzID0gREVGQVVMVFM7XG5tb2R1bGUuZXhwb3J0cy5kaXJlY3Rpb25zID0gRElSRUNUSU9OUztcbm1vZHVsZS5leHBvcnRzLmVhc2luZ0Z1bmN0aW9ucyA9IEVBU0lOR19GVU5DVElPTlM7XG5tb2R1bGUuZXhwb3J0cy5maWxscyA9IEZJTExTO1xubW9kdWxlLmV4cG9ydHMucmVwZWF0cyA9IFJFUEVBVFM7XG4iLCJ2YXIgQU5vZGUgPSByZXF1aXJlKCcuL2Etbm9kZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cy9hbmltYXRpb24nKTtcbnZhciBjb29yZGluYXRlcyA9IHJlcXVpcmUoJy4uL3V0aWxzLycpLmNvb3JkaW5hdGVzO1xudmFyIHBhcnNlUHJvcGVydHkgPSByZXF1aXJlKCcuL3NjaGVtYScpLnBhcnNlUHJvcGVydHk7XG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgVFdFRU4gPSByZXF1aXJlKCd0d2Vlbi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvJyk7XG5cbnZhciBERUZBVUxUUyA9IGNvbnN0YW50cy5kZWZhdWx0cztcbnZhciBESVJFQ1RJT05TID0gY29uc3RhbnRzLmRpcmVjdGlvbnM7XG52YXIgRUFTSU5HX0ZVTkNUSU9OUyA9IGNvbnN0YW50cy5lYXNpbmdGdW5jdGlvbnM7XG52YXIgRklMTFMgPSBjb25zdGFudHMuZmlsbHM7XG52YXIgUkVQRUFUUyA9IGNvbnN0YW50cy5yZXBlYXRzO1xudmFyIGlzQ29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzLmlzQ29vcmRpbmF0ZTtcblxuLyoqXG4gKiBBbmltYXRpb24gZWxlbWVudCB0aGF0IGFwcGxpZXMgVHdlZW4gYW5pbWF0aW9uIHRvIHBhcmVudCBlbGVtZW50IChlbnRpdHkpLlxuICogVGFrZXMgYWZ0ZXIgdGhlIFdlYiBBbmltYXRpb25zIHNwZWMuXG4gKlxuICogQG5hbWVzcGFjZSA8YS1hbmltYXRpb24+XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIC1cbiAqICAgRW50aXR5IGF0dHJpYnV0ZSB0byBhbmltYXRlLiBDYW4gYmUgYSBjb21wb25lbnQgbmFtZSAoZS5nLiwgYHBvc2l0aW9uYCkgaWYgdGhlIGNvbXBvbmVudFxuICogICBpcyBzZXQgdmlhIGEgc2luZ2xlIHZhbHVlLiBPciBjYW4gYmUgYSBkb3Qtc2VwYXJhdGVkIGNvbXBvbmVudE5hbWUuY29tcG9uZW50UHJvcCB0b1xuICogICBhbmltYXRlIGEgc2luZ2xlIGNvbXBvbmVudCBwcm9wZXJ0eSAoZS5nLiwgYGxpZ2h0LmludGVuc2l0eWAsIGBtYXRlcmlhbC5vcGFjaXR5YCkuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGJlZ2luIC1cbiAqICAgRWl0aGVyIG1pbGxpc2Vjb25kcyB0byBkZWxheSBvciBhbiBldmVudCBuYW1lIHRvIHdhaXQgdXBvbiBiZWZvcmUgc3RhcnRpbmcgYW5pbWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiAtXG4gKiAgIERpcmVjdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGJldHdlZW4gZnJvbSBhbmQgdG8uXG4gKiAgICAgLSBhbHRlcm5hdGU6IEV2ZW4gaXRlcmF0aW9ucyBwbGF5ZWQgYXMgc3BlY2lmaWVkLCBvZGQgaXRlcmF0aW9ucyBwbGF5ZWQgaW4gcmV2ZXJzZVxuICogICAgICAgICAgICAgICAgZGlyZWN0aW9uIGZyb20gd2F5IHNwZWNpZmllZC5cbiAqICAgICAtIGFsdGVybmF0ZS1yZXZlcnNlOiBFdmVuIGl0ZXJhdGlvbnMgYXJlIHBsYXllZCBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb24gZnJvbSB3YXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBvZGQgaXRlcmF0aW9ucyBwbGF5ZWQgYXMgc3BlY2lmaWVkLlxuICogICAgIC0gbm9ybWFsOiBBbGwgaXRlcmF0aW9ucyBhcmUgcGxheWVkIGFzIHNwZWNpZmllZC5cbiAqICAgICAtIHJldmVyc2U6IEFsbCBpdGVyYXRpb25zIGFyZSBwbGF5ZWQgaW4gcmV2ZXJzZSBkaXJlY3Rpb24gZnJvbSB3YXkgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGR1ciAtIEhvdyBsb25nIHRvIHJ1biB0aGUgYW5pbWF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlYXNpbmcgLVxuICogICBFYXNpbmcgZnVuY3Rpb24gb2YgYW5pbWF0aW9uIChlLmcuLCBlYXNlLCBlYXNlLWluLCBlYXNlLWluLW91dCwgZWFzZS1vdXQsIGxpbmVhcikuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZpbGw9Zm9yd2FyZHNdIC1cbiAqICAgRGV0ZXJtaW5lcyBlZmZlY3Qgb2YgYW5pbWF0aW9uIHdoZW4gbm90IGluIHBsYXkuXG4gKiAgICAgLSBiYWNrd2FyZHM6IEJlZm9yZSBhbmltYXRpb24sIHNldCBpbml0aWFsIHZhbHVlIHRvIGBmcm9tYC5cbiAqICAgICAtIGJvdGg6IEJlZm9yZSBhbmltYXRpb24sIGJhY2t3YXJkcyBmaWxsLiBBZnRlciBhbmltYXRpb24sIGZvcndhcmRzIGZpbGwuXG4gKiAgICAgLSBmb3J3YXJkczogQWZ0ZXIgYW5pbWF0aW9uLCB2YWx1ZSB3aWxsIHN0YXkgYXQgYHRvYC5cbiAqICAgICAtIG5vbmU6IEFuaW1hdGlvbiBoYXMgbm8gZWZmZWN0IHdoZW4gbm90IGluIHBsYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbSAtIFN0YXJ0IHZhbHVlLiBEZWZhdWx0cyB0byB0aGUgZW50aXR5J3MgY3VycmVudCB2YWx1ZSBmb3IgdGhhdCBhdHRyLlxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSByZXBlYXQgLVxuICogICBIb3cgdGhlIGFuaW1hdGlvbiBzaG91bGQgcmVwZWF0IChlLmcuLCBhIG51bWJlciBvciBgaW5kZWZpbml0ZWApLlxuICogQHBhcmFtIHtudW1iZXJ9IHRvIC0gRW5kIHZhbHVlLlxuICogQG1lbWJlciB7bnVtYmVyfSBjb3VudCAtXG4gKiAgIERlY3JlbWVudGluZyBjb3VudGVyIGZvciBob3cgbWFueSBjeWNsZXMgb2YgYW5pbWF0aW9ucyBsZWZ0IHRvIHJ1bi5cbiAqIEBtZW1iZXIge0VsZW1lbnR9IGVsIC0gRW50aXR5IHdoaWNoIHRoZSBhbmltYXRpb24gaXMgbW9kaWZ5aW5nIHRvLlxuICogQG1lbWJlciBpbml0aWFsVmFsdWUgLSBWYWx1ZSBiZWZvcmUgYW5pbWF0aW9uIHN0YXJ0ZWQuIFVzZWQgdG8gcmVzdG9yZSBzdGF0ZS5cbiAqIEBtZW1iZXIge2Jvb2x9IGlzUnVubmluZyAtIFdoZXRoZXIgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICogQG1lbWJlciB7ZnVuY3Rpb259IHBhcnRpYWxTZXRBdHRyaWJ1dGUgLVxuICogICBzZXRBdHRyaWJ1dGUgZnVuY3Rpb24gdGhhdCBpcyBhZ25vc3RpYyB0byB3aGV0aGVyIHdlIGFyZSBzZXR0aW5nIGFuIGF0dHJpYnV0ZSB2YWx1ZVxuICogICBvciBhIGNvbXBvbmVudCBwcm9wZXJ0eSB2YWx1ZS4gVGhlIGVsIGFuZCB0aGUgYXR0cmlidXRlIG5hbWVzIGFyZSBidW5kbGVkIHdpdGhcbiAqICAgdGhlIGZ1bmN0aW9uLlxuICogQG1lbWJlciB7b2JqZWN0fSB0d2VlbiAtIHR3ZWVuLmpzIG9iamVjdC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuQUFuaW1hdGlvbiA9IHJlZ2lzdGVyRWxlbWVudCgnYS1hbmltYXRpb24nLCB7XG4gIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShBTm9kZS5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYmluZE1ldGhvZHMoKTtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJ0aWFsU2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9O1xuICAgICAgICB0aGlzLnR3ZWVuID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZWwgPSBzZWxmLmVsID0gc2VsZi5wYXJlbnROb2RlO1xuXG4gICAgICAgIGlmIChlbC5pc05vZGUpIHtcbiAgICAgICAgICBpZiAoZWwuaGFzTG9hZGVkKSB7XG4gICAgICAgICAgICBpbml0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZCcsIGluaXQuYmluZChzZWxmKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRvIGhhbmRsZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgeWV0IGA8YS1lbnRpdHk+YHMgKGUuZy4sIHRlbXBsYXRlcykuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignbm9kZXJlYWR5JywgaW5pdC5iaW5kKHNlbGYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQgKCkge1xuICAgICAgICAgIHNlbGYuYXBwbHlNaXhpbigpO1xuICAgICAgICAgIHNlbGYudXBkYXRlKCk7XG4gICAgICAgICAgc2VsZi5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQgfHwgIXRoaXMuaXNSdW5uaW5nKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdGhpcy5hcHBseU1peGluKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIFR3ZWVuIG9iamVjdCB0byBoYW5kbGUgYW5pbWF0aW9ucy5cbiAgICAgKiBVc2VzIHR3ZWVuLmpzJ3MgZnJvbSwgdG8sIGRlbGF5LCBlYXNpbmcsIHJlcGVhdCwgb25VcGRhdGUsIGFuZCBvbkNvbXBsZXRlLlxuICAgICAqIE5vdGU6IHR3ZWVuLmpzIHRha2VzIG9iamVjdHMgZm9yIGl0cyBgZnJvbWAgYW5kIGB0b2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRUd2Vlbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IHNlbGYuZGF0YTtcbiAgICAgICAgdmFyIGVsID0gc2VsZi5lbDtcbiAgICAgICAgdmFyIGFuaW1hdGlvblZhbHVlcztcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGRhdGEuYXR0cmlidXRlO1xuICAgICAgICB2YXIgYmVnaW4gPSBwYXJzZUludChkYXRhLmJlZ2luLCAxMCk7XG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBlbC5nZXRDb21wdXRlZEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gc2VsZi5nZXREaXJlY3Rpb24oZGF0YS5kaXJlY3Rpb24pO1xuICAgICAgICB2YXIgZWFzaW5nID0gRUFTSU5HX0ZVTkNUSU9OU1tkYXRhLmVhc2luZ107XG4gICAgICAgIHZhciBmaWxsID0gZGF0YS5maWxsO1xuICAgICAgICB2YXIgZnJvbTtcbiAgICAgICAgdmFyIHJlcGVhdCA9IGRhdGEucmVwZWF0ID09PSBSRVBFQVRTLmluZGVmaW5pdGUgPyBJbmZpbml0eSA6IDA7XG4gICAgICAgIHZhciB0bztcbiAgICAgICAgdmFyIHRvVGVtcDtcbiAgICAgICAgdmFyIHlveW8gPSBmYWxzZTtcblxuICAgICAgICBhbmltYXRpb25WYWx1ZXMgPSBnZXRBbmltYXRpb25WYWx1ZXMoZWwsIGF0dHJpYnV0ZSwgZGF0YS5mcm9tIHx8IHNlbGYuaW5pdGlhbFZhbHVlLCBkYXRhLnRvLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICBmcm9tID0gYW5pbWF0aW9uVmFsdWVzLmZyb207XG4gICAgICAgIHRvID0gYW5pbWF0aW9uVmFsdWVzLnRvO1xuICAgICAgICBzZWxmLnBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBhbmltYXRpb25WYWx1ZXMucGFydGlhbFNldEF0dHJpYnV0ZTtcblxuICAgICAgICBpZiAoc2VsZi5jb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZi5jb3VudCA9IHJlcGVhdCA9PT0gSW5maW5pdHkgPyAwIDogcGFyc2VJbnQoZGF0YS5yZXBlYXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hTihiZWdpbikpIHsgYmVnaW4gPSAwOyB9XG5cbiAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAgc2VsZi5pbml0aWFsVmFsdWUgPSBzZWxmLmluaXRpYWxWYWx1ZSB8fCBjbG9uZVZhbHVlKGN1cnJlbnRWYWx1ZSk7XG5cbiAgICAgICAgLy8gSGFuZGxlIGluZGVmaW5pdGUgKyBmb3J3YXJkcyArIGFsdGVybmF0ZSB5b3lvIGVkZ2UtY2FzZSAoIzQwNSkuXG4gICAgICAgIGlmIChyZXBlYXQgPT09IEluZmluaXR5ICYmIGZpbGwgPT09IEZJTExTLmZvcndhcmRzICYmXG4gICAgICAgICAgICBbRElSRUNUSU9OUy5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgRElSRUNUSU9OUy5hbHRlcm5hdGVSZXZlcnNlXS5pbmRleE9mKGRhdGEuZGlyZWN0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICB5b3lvID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHJldmVyc2luZywgc3dhcCBmcm9tIGFuZCB0by5cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OUy5yZXZlcnNlKSB7XG4gICAgICAgICAgdG9UZW1wID0gdG87XG4gICAgICAgICAgdG8gPSBjbG9uZVZhbHVlKGZyb20pO1xuICAgICAgICAgIGZyb20gPSBjbG9uZVZhbHVlKHRvVGVtcCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBmaWxsIGlzIGJhY2t3YXJkcyBvciBib3RoLCBzdGFydCBhbmltYXRpb24gYXQgdGhlIHNwZWNpZmllZCBmcm9tLlxuICAgICAgICBpZiAoW0ZJTExTLmJhY2t3YXJkcywgRklMTFMuYm90aF0uaW5kZXhPZihmaWxsKSAhPT0gLTEpIHtcbiAgICAgICAgICBzZWxmLnBhcnRpYWxTZXRBdHRyaWJ1dGUoZnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgVHdlZW4uXG4gICAgICAgIHJldHVybiBuZXcgVFdFRU4uVHdlZW4oY2xvbmVWYWx1ZShmcm9tKSlcbiAgICAgICAgICAudG8odG8sIGRhdGEuZHVyKVxuICAgICAgICAgIC5kZWxheShiZWdpbilcbiAgICAgICAgICAuZWFzaW5nKGVhc2luZylcbiAgICAgICAgICAucmVwZWF0KHJlcGVhdClcbiAgICAgICAgICAueW95byh5b3lvKVxuICAgICAgICAgIC5vblVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZWxmLnBhcnRpYWxTZXRBdHRyaWJ1dGUodGhpcyk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub25Db21wbGV0ZShzZWxmLm9uQ29tcGxldGVkLmJpbmQoc2VsZikpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gcGFyYW1ldGVycyBjaGFuZ2VkLiBTdG9wIGN1cnJlbnQgYW5pbWF0aW9uLCBnZXQgYSBuZXcgb25lLCBhbmQgc3RhcnQgaXQuXG4gICAgICovXG4gICAgdXBkYXRlOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgdmFyIGJlZ2luID0gZGF0YS5iZWdpbjtcbiAgICAgICAgLy8gQ2FuY2VsIHByZXZpb3VzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZXZ0KTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycyhiZWdpbik7XG4gICAgICAgIC8vIFN0b3JlIG5ldyBldmVudCBuYW1lLlxuICAgICAgICB0aGlzLmV2dCA9IGJlZ2luO1xuICAgICAgICAvLyBJZiBgYmVnaW5gIGlzIGEgbnVtYmVyLCBzdGFydCB0aGUgYW5pbWF0aW9uIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICghaXNOYU4oYmVnaW4pKSB7XG4gICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiBhIGN5Y2xlIG9mIGFuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZS4gSGFuZGxlcyB3aGVuIHRvIGNvbXBsZXRlbHlcbiAgICAgKiBmaW5pc2ggdGhlIGFuaW1hdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGByZXBlYXRgIGlzIHNldCB0byBhIHZhbHVlLCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCByZXBlYXQuIFJlcGVhdHMgYXJlXG4gICAgICogaGFuZGxlZCBieSBlbmRpbmcgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCBjcmVhdGluZyBhIG5ldyBvbmUgd2l0aCBgY291bnRgIHVwZGF0ZWQuXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzICpub3QqIGNhbGxlZCBpZiByZXBlYXQgaXMgc2V0IHRvIGBpbmRlZmluaXRlYC5cbiAgICAgKi9cbiAgICBvbkNvbXBsZXRlZDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChbRklMTFMuYmFja3dhcmRzLCBGSUxMUy5ub25lXS5pbmRleE9mKGRhdGEuZmlsbCkgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5wYXJ0aWFsU2V0QXR0cmlidXRlKHRoaXMuaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuY291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5lbWl0KCdhbmltYXRpb25lbmQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXJ0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1J1bm5pbmcgfHwgdGhpcy5lbC5wYXVzZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHRoaXMudHdlZW4gPSB0aGlzLmdldFR3ZWVuKCk7XG4gICAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50d2Vlbi5zdGFydCgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgc3RvcDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHR3ZWVuID0gdGhpcy50d2VlbjtcbiAgICAgICAgaWYgKCF0d2VlbikgeyByZXR1cm47IH1cbiAgICAgICAgdHdlZW4uc3RvcCgpO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcnRpYWxTZXRBdHRyaWJ1dGUodGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICB0aGlzLmVtaXQoJ2FuaW1hdGlvbnN0b3AnKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYWx0ZXJuYXRpbmcgZGlyZWN0aW9ucy4gR2l2ZW4gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjYWxjdWxhdGUgdGhlIG5leHQgb25lLFxuICAgICAqIGFuZCBzdG9yZSB0aGUgY3VycmVudCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gRGlyZWN0aW9uIHRoYXQgdGhlIG5leHQgaW5kaXZpZHVhbCBjeWNsZSBvZiB0aGUgYW5pbWF0aW9uIHdpbGwgZ29cbiAgICAgKiAgICAgICAgICB0b3dhcmRzLlxuICAgICAqL1xuICAgIGdldERpcmVjdGlvbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OUy5hbHRlcm5hdGUpIHtcbiAgICAgICAgICB0aGlzLnByZXZEaXJlY3Rpb24gPVxuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0aW9uID09PSBESVJFQ1RJT05TLm5vcm1hbCA/IERJUkVDVElPTlMucmV2ZXJzZSA6IERJUkVDVElPTlMubm9ybWFsO1xuICAgICAgICAgIHJldHVybiB0aGlzLnByZXZEaXJlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OUy5hbHRlcm5hdGVSZXZlcnNlKSB7XG4gICAgICAgICAgdGhpcy5wcmV2RGlyZWN0aW9uID1cbiAgICAgICAgICAgIHRoaXMucHJldkRpcmVjdGlvbiA9PT0gRElSRUNUSU9OUy5yZXZlcnNlID8gRElSRUNUSU9OUy5ub3JtYWwgOiBESVJFQ1RJT05TLnJldmVyc2U7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHJldkRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVlbXB0aXZlIGJpbmRpbmcgdG8gYXR0YWNoL2RldGFjaCBldmVudCBsaXN0ZW5lcnMgKHNlZSBgdXBkYXRlYCkuXG4gICAgICovXG4gICAgYmluZE1ldGhvZHM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RvcCA9IHRoaXMuc3RvcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3RhdGVBZGRlZCA9IHRoaXMub25TdGF0ZUFkZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25TdGF0ZVJlbW92ZWQgPSB0aGlzLm9uU3RhdGVSZW1vdmVkLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZEV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGV2dHMpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB1dGlscy5zcGxpdFN0cmluZyhldnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgc2VsZi5zdGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgdGhpcy5zdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgdGhpcy5zdG9wKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVhZGRlZCcsIHRoaXMub25TdGF0ZUFkZGVkKTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVyZW1vdmVkJywgdGhpcy5vblN0YXRlUmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGV2dHMpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgICAgdXRpbHMuc3BsaXRTdHJpbmcoZXZ0cykuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIHN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRlYWRkZWQnLCB0aGlzLm9uU3RhdGVBZGRlZCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0YXRlcmVtb3ZlZCcsIHRoaXMub25TdGF0ZVJlbW92ZWQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvblN0YXRlQWRkZWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuZGV0YWlsLnN0YXRlID09PSB0aGlzLmRhdGEuYmVnaW4pIHsgdGhpcy5zdGFydCgpOyB9XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgb25TdGF0ZVJlbW92ZWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuZGV0YWlsLnN0YXRlID09PSB0aGlzLmRhdGEuYmVnaW4pIHsgdGhpcy5zdG9wKCk7IH1cbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuaW1hdGlvbiBkYXRhIGZyb20gYSBtaXhpbiBlbGVtZW50LlxuICAgICAqIFdvcmtzIHRoZSBzYW1lIGFzIGNvbXBvbmVudCBtaXhpbnMgYnV0IHJlaW1wbGVtZW50ZWQgYmVjYXVzZSBhbmltYXRpb25zXG4gICAgICogYXJlbid0IGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgYXBwbHlNaXhpbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyIGVsRGF0YTtcbiAgICAgICAgdmFyIG1peGluRGF0YTtcbiAgICAgICAgdmFyIG1peGluRWw7XG5cbiAgICAgICAgLy8gR2V0IG1peGluIGRhdGEuXG4gICAgICAgIG1peGluRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMuZ2V0QXR0cmlidXRlKCdtaXhpbicpKTtcbiAgICAgICAgbWl4aW5EYXRhID0gbWl4aW5FbCA/IHV0aWxzLmdldEVsRGF0YShtaXhpbkVsLCBERUZBVUxUUykgOiB7fTtcblxuICAgICAgICBlbERhdGEgPSB1dGlscy5nZXRFbERhdGEodGhpcywgREVGQVVMVFMpO1xuICAgICAgICB1dGlscy5leHRlbmQoZGF0YSwgREVGQVVMVFMsIG1peGluRGF0YSwgZWxEYXRhKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59KTtcblxuZnVuY3Rpb24gY2xvbmVWYWx1ZSAodmFsKSB7XG4gIHJldHVybiB1dGlscy5leHRlbmQoe30sIHZhbCk7XG59XG5cbi8qKlxuICogRGVkdWNlcyBkaWZmZXJlbnQgYW5pbWF0aW9uIHZhbHVlcyBiYXNlZCBvbiB3aGV0aGVyIHdlIGFyZTpcbiAqICAgLSBhbmltYXRpbmcgYW4gaW5uZXIgYXR0cmlidXRlIG9mIGEgY29tcG9uZW50LlxuICogICAtIGFuaW1hdGluZyBhIGNvb3JkaW5hdGUgY29tcG9uZW50LlxuICogICAtIGFuaW1hdGluZyBhIGJvb2xlYW4uXG4gKiAgIC0gYW5pbWF0aW5nIGEgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgLSBUZWxscyB3aGF0IHRvIGFuaW1hdGUgYmFzZWQgb24gd2hldGhlciBpdCBpcyBkb3Qtc2VwYXJhdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFGcm9tIC0gRGF0YSBgZnJvbWAgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVRvIC0gRGF0YSBgdG9gIHZhbHVlLlxuICogQHBhcmFtIGN1cnJlbnRWYWx1ZVxuICogQHJldHVybnMge29iamVjdH1cbiAqICAgT2JqZWN0IHdpdGgga2V5cyBbZnJvbSwgdG8sIHBhcnRpYWxTZXRBdHRyaWJ1dGVdLlxuICogICAgIGBmcm9tYCBhbmQgYHRvYFxuICogICAgICAgIE9iamVjdHMgd2hlcmUga2V5IGlzIGF0dHJpYnV0ZSBiZWluZyBhbmltYXRlZCBhbmQgdmFsdWUgaXMgdmFsdWUuXG4gKiAgICAgYHBhcnRpYWxTZXRBdHRyaWJ1dGVgXG4gKiAgICAgICAgQ2xvc3VyZWQtZnVuY3Rpb24gdGhhdCB0ZWxscyB0d2VlbiBob3cgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEFuaW1hdGlvblZhbHVlcyAoZWwsIGF0dHJpYnV0ZSwgZGF0YUZyb20sIGRhdGFUbywgY3VycmVudFZhbHVlKSB7XG4gIHZhciBhdHRyaWJ1dGVTcGxpdCA9IGF0dHJpYnV0ZS5zcGxpdCgnLicpO1xuICB2YXIgc2NoZW1hO1xuICB2YXIgY29tcG9uZW50O1xuICB2YXIgY29tcG9uZW50UHJvcE5hbWU7XG4gIHZhciBjb21wb25lbnROYW1lO1xuICB2YXIgZnJvbSA9IHt9O1xuICB2YXIgcGFydGlhbFNldEF0dHJpYnV0ZTtcbiAgdmFyIHRvID0ge307XG5cbiAgaWYgKGF0dHJpYnV0ZVNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgIGdldEZvckNvbXBvbmVudEF0dHJpYnV0ZSgpO1xuICB9IGVsc2UgaWYgKGRhdGFUbyAmJiBpc0Nvb3JkaW5hdGUoZGF0YVRvKSkge1xuICAgIGdldEZvckNvb3JkaW5hdGVDb21wb25lbnQoKTtcbiAgfSBlbHNlIGlmIChbJ3RydWUnLCAnZmFsc2UnXS5pbmRleE9mKGRhdGFUbykgIT09IC0xKSB7XG4gICAgZ2V0Rm9yQm9vbGVhbigpO1xuICB9IGVsc2Uge1xuICAgIGdldEZvck51bWJlcigpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZnJvbTogZnJvbSxcbiAgICBwYXJ0aWFsU2V0QXR0cmlidXRlOiBwYXJ0aWFsU2V0QXR0cmlidXRlLFxuICAgIHRvOiB0b1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbmltYXRpbmcgYSBjb21wb25lbnQgdGhhdCBoYXMgbXVsdGlwbGUgYXR0cmlidXRlcyAoZS5nLiwgZ2VvbWV0cnkud2lkdGgpLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Rm9yQ29tcG9uZW50QXR0cmlidXRlICgpIHtcbiAgICBjb21wb25lbnROYW1lID0gYXR0cmlidXRlU3BsaXRbMF07XG4gICAgY29tcG9uZW50UHJvcE5hbWUgPSBhdHRyaWJ1dGVTcGxpdFsxXTtcbiAgICBjb21wb25lbnQgPSBlbC5jb21wb25lbnRzW2NvbXBvbmVudE5hbWVdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoY29tcG9uZW50TmFtZSwgJycpO1xuICAgICAgY29tcG9uZW50ID0gZWwuY29tcG9uZW50c1tjb21wb25lbnROYW1lXTtcbiAgICB9XG4gICAgc2NoZW1hID0gY29tcG9uZW50LnNjaGVtYTtcbiAgICBpZiAoZGF0YUZyb20gPT09IHVuZGVmaW5lZCkgeyAgLy8gZGF0YUZyb20gY2FuIGJlIDAuXG4gICAgICBmcm9tW2F0dHJpYnV0ZV0gPSBlbC5nZXRDb21wdXRlZEF0dHJpYnV0ZShjb21wb25lbnROYW1lKVtjb21wb25lbnRQcm9wTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21bYXR0cmlidXRlXSA9IGRhdGFGcm9tO1xuICAgIH1cbiAgICBmcm9tW2F0dHJpYnV0ZV0gPSBwYXJzZVByb3BlcnR5KGZyb21bYXR0cmlidXRlXSwgc2NoZW1hW2NvbXBvbmVudFByb3BOYW1lXSk7XG4gICAgdG9bYXR0cmlidXRlXSA9IHBhcnNlUHJvcGVydHkoZGF0YVRvLCBzY2hlbWFbY29tcG9uZW50UHJvcE5hbWVdKTtcbiAgICBwYXJ0aWFsU2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoY29tcG9uZW50TmFtZSwgY29tcG9uZW50UHJvcE5hbWUsIHZhbHVlW2F0dHJpYnV0ZV0pO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0aW5nIGEgY29tcG9uZW50IHRoYXQgaXMgYW4gWFlaIGNvb3JkaW5hdGUgKGUuZy4sIHBvc2l0aW9uKS5cbiAgICogV2lsbCBiZSB0d2VlbmluZyB7eCwgeSwgen0gYWxsIGF0IG9uY2UuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRGb3JDb29yZGluYXRlQ29tcG9uZW50ICgpIHtcbiAgICBmcm9tID0gZGF0YUZyb20gPyBjb29yZGluYXRlcy5wYXJzZShkYXRhRnJvbSkgOiBjdXJyZW50VmFsdWU7XG4gICAgdG8gPSBjb29yZGluYXRlcy5wYXJzZShkYXRhVG8pO1xuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFuaW1hdGlvbiBhIGJvb2xlYW4gKGUuZy4sIHZpc2libGUpLlxuICAgKiBIYXZlIHRvIGNvbnZlcnQgZnJvbSBib29sZWFuIHRvIGFuIGludGVnZXIgKDAgaXMgZmFsc2UsID4gMCBpcyB0cnVlKSBmb3IgdHdlZW4uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRGb3JCb29sZWFuICgpIHtcbiAgICBpZiAoZGF0YUZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbVthdHRyaWJ1dGVdID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21bYXR0cmlidXRlXSA9IHN0clRvQm9vbChkYXRhRnJvbSk7XG4gICAgfVxuICAgIGZyb21bYXR0cmlidXRlXSA9IGJvb2xUb051bShmcm9tW2F0dHJpYnV0ZV0pO1xuICAgIHRvW2F0dHJpYnV0ZV0gPSBib29sVG9OdW0oc3RyVG9Cb29sKGRhdGFUbykpO1xuICAgIHBhcnRpYWxTZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsICEhdmFsdWVbYXR0cmlidXRlXSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbmltYXRpbmcgYSBudW1iZXJlZCBhdHRyaWJ1dGUgKGUuZy4sIG9wYWNpdHkpLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Rm9yTnVtYmVyICgpIHtcbiAgICBpZiAoZGF0YUZyb20gPT09IHVuZGVmaW5lZCkgeyAgLy8gZGF0YUZyb20gY2FuIGJlIDAuXG4gICAgICBmcm9tW2F0dHJpYnV0ZV0gPSBwYXJzZUZsb2F0KGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbVthdHRyaWJ1dGVdID0gcGFyc2VGbG9hdChkYXRhRnJvbSk7XG4gICAgfVxuICAgIHRvW2F0dHJpYnV0ZV0gPSBwYXJzZUZsb2F0KGRhdGFUbyk7XG4gICAgcGFydGlhbFNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWVbYXR0cmlidXRlXSk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMuZ2V0QW5pbWF0aW9uVmFsdWVzID0gZ2V0QW5pbWF0aW9uVmFsdWVzO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBib29sLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBgdHJ1ZWAgb3IgYGZhbHNlYC5cbiAqIEByZXR1cm5zIHtib29sfVxuICovXG5mdW5jdGlvbiBzdHJUb0Jvb2wgKHN0cikge1xuICBpZiAoc3RyID09PSAndHJ1ZScpIHsgcmV0dXJuIHRydWU7IH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGJvb2xlYW4gdG8gbnVtYmVyLlxuICpcbiAqIEBwYXJhbSB7Ym9vbH1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGJvb2xUb051bSAoYm9vbCkge1xuICByZXR1cm4gYm9vbCA/IDEgOiAwO1xufVxuIiwidmFyIEFOb2RlID0gcmVxdWlyZSgnLi9hLW5vZGUnKTtcbnZhciByZWdpc3RlckVsZW1lbnQgPSByZXF1aXJlKCcuL2EtcmVnaXN0ZXItZWxlbWVudCcpLnJlZ2lzdGVyRWxlbWVudDtcblxuLyoqXG4gKiBUT0RPOiBCbG9jayBvbiBhc3NldHMgYmVmb3JlIGxvYWRpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJFbGVtZW50KCdhLWFzc2V0cycsIHtcbiAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKEFOb2RlLnByb3RvdHlwZSwge1xuICAgIGxvYWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEFOb2RlLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG4iLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWxzL2RlYnVnJyk7XG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG5cbnZhciB3YXJuID0gZGVidWcoJ2NvcmU6Y3ViZW1hcDp3YXJuJyk7XG5cbi8qKlxuICogQ3ViZW1hcCBlbGVtZW50IHRoYXQgaGFuZGxlcyB2YWxpZGF0aW9uIGFuZCBleHBvc2VzIGxpc3Qgb2YgVVJMcy5cbiAqIERvZXMgbm90IGxpc3RlbiB0byB1cGRhdGVzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRWxlbWVudCgnYS1jdWJlbWFwJywge1xuICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGlzLnNyY3MuXG4gICAgICovXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zcmNzID0gdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBleGFjdGx5IHNpeCBlbGVtZW50cyB3aXRoIFtzcmNdLlxuICAgICAqIERvZXMgbm90IGNoZWNrIGV4cGxpY2l0bHkgZm9yIDxpbWc+cyBpbiBjYXNlIHVzZXIgZG9lcyBub3Qgd2FudFxuICAgICAqIHByZWZldGNoaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fG51bGx9IC0gc2l4IFVSTHMgaWYgdmFsaWQsIGVsc2UgbnVsbC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbc3JjXScpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHNyY3MgPSBbXTtcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3Jjcy5wdXNoKGVsZW1lbnRzW2ldLmdldEF0dHJpYnV0ZSgnc3JjJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3JjcztcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIGlmIHRoZXJlIGFyZSBub3Qgc2l4IGVsZW1lbnRzLCB0aHJvdyBhIHdhcm5pbmcuXG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJzxhLWN1YmVtYXA+IGRpZCBub3QgY29udGFpbiBleGFjdGx5IHNpeCBlbGVtZW50cyBlYWNoIHdpdGggYSAnICtcbiAgICAgICAgICAnYHNyY2AgYXR0cmlidXRlLicpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICB9XG4gIH0pXG59KTtcbiIsIi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xudmFyIEFOb2RlID0gcmVxdWlyZSgnLi9hLW5vZGUnKTtcbnZhciBjb21wb25lbnRzID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKS5jb21wb25lbnRzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbHMvZGVidWcnKTtcbnZhciByZSA9IHJlcXVpcmUoJy4vYS1yZWdpc3Rlci1lbGVtZW50Jyk7XG52YXIgVEhSRUUgPSByZXF1aXJlKCcuLi8uLi9saWIvdGhyZWUnKTtcblxudmFyIGlzTm9kZSA9IHJlLmlzTm9kZTtcbnZhciBsb2cgPSBkZWJ1ZygnY29yZTphLWVudGl0eScpO1xudmFyIGVycm9yID0gZGVidWcoJ2NvcmU6YS1lbnRpdHk6ZXJyb3InKTtcbnZhciByZWdpc3RlckVsZW1lbnQgPSByZS5yZWdpc3RlckVsZW1lbnQ7XG5cbnZhciBBRW50aXR5O1xuXG4vKipcbiAqIEVudGl0eSBlbGVtZW50IGRlZmluaXRpb24uXG4gKiBFbnRpdGllcyByZXByZXNlbnQgYWxsIGVsZW1lbnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIHNjZW5lLCBhbmQgYWx3YXlzIGhhdmVcbiAqIGEgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmQgc2NhbGUuXG4gKiBJbiB0aGUgZW50aXR5LWNvbXBvbmVudCBzeXN0ZW0sIGVudGl0aWVzIGFyZSBqdXN0IGEgY29udGFpbmVyIG9mIGNvbXBvbmVudHMuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlIG9mIGluaGVyaXRpbmcgY29tcG9uZW50cywgdGhlIHNjZW5lIGVsZW1lbnQgaW5oZXJpdHMgZnJvbVxuICogdGhpcyBwcm90b3R5cGUuIFdoZW4gbmVjZXNzYXJ5LCBpdCBkaWZmZXJlbnRpYXRlcyBpdHNlbGYgYnkgc2V0dGluZ1xuICogYHRoaXMuaXNTY2VuZWAuXG4gKlxuICogQG5hbWVzcGFjZSBFbnRpdHlcbiAqIEBtZW1iZXIge29iamVjdH0gY29tcG9uZW50cyAtIGVudGl0eSdzIGN1cnJlbnRseSBpbml0aWFsaXplZCBjb21wb25lbnRzLlxuICogQG1lbWJlciB7b2JqZWN0fSBvYmplY3QzRCAtIHRocmVlLmpzIG9iamVjdC5cbiAqIEBtZW1iZXIge2FycmF5fSBzdGF0ZXNcbiAqIEBtZW1iZXIge2Jvb2xlYW59IHBhdXNlZCAtIHRydWUgaWYgZHluYW1pYyBiZWhhdmlvciBvZiB0aGUgZW50aXR5IGlzIHBhdXNlZFxuICovXG52YXIgcHJvdG8gPSBPYmplY3QuY3JlYXRlKEFOb2RlLnByb3RvdHlwZSwge1xuICBkZWZhdWx0czoge1xuICAgIHZhbHVlOiB7XG4gICAgICBwb3NpdGlvbjogJycsXG4gICAgICByb3RhdGlvbjogJycsXG4gICAgICBzY2FsZTogJycsXG4gICAgICB2aXNpYmxlOiAnJ1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkQ2FsbGJhY2s6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5pc0VudGl0eSA9IHRydWU7XG4gICAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgICB0aGlzLm9iamVjdDNELmVsID0gdGhpcztcbiAgICAgIHRoaXMub2JqZWN0czNEID0ge307XG4gICAgfVxuICB9LFxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHRoaXMuc2V0RW50aXR5QXR0cmlidXRlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICB9XG4gIH0sXG5cbiAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmFkZFRvUGFyZW50KCk7XG4gICAgICBpZiAoIXRoaXMuaXNTY2VuZSkge1xuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlbGwgcGFyZW50IHRvIHJlbW92ZSB0aGlzIGVsZW1lbnQncyBvYmplY3QzRCBmcm9tIGl0cyBvYmplY3QzRC5cbiAgICogRG8gbm90IGNhbGwgb24gc2NlbmUgZWxlbWVudCBiZWNhdXNlIHRoYXQgd2lsbCBjYXVzZSBhIGNhbGwgdG9cbiAgICogZG9jdW1lbnQuYm9keS5yZW1vdmUoKS5cbiAgICovXG4gIGRldGFjaGVkQ2FsbGJhY2s6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudEVsIHx8IHRoaXMuaXNTY2VuZSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMucmVtb3ZlQ29tcG9uZW50cygpO1xuICAgICAgdGhpcy5wYXJlbnRFbC5yZW1vdmUodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIGFwcGx5TWl4aW46IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHZhciBhdHRyVmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIGlmICghYXR0cikge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQoYXR0ciwgYXR0clZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgbWFwU3RhdGVNaXhpbnM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHN0YXRlLCBvcCkge1xuICAgICAgdmFyIG1peGlucyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtaXhpbicpO1xuICAgICAgdmFyIG1peGluSWRzO1xuICAgICAgaWYgKCFtaXhpbnMpIHsgcmV0dXJuOyB9XG4gICAgICBtaXhpbklkcyA9IG1peGlucy5zcGxpdCgnICcpO1xuICAgICAgbWl4aW5JZHMuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG1peGluSWQgPSBpZCArICctJyArIHN0YXRlO1xuICAgICAgICBvcChtaXhpbklkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnRzKCk7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVN0YXRlTWl4aW5zOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChuZXdNaXhpbnMsIG9sZE1peGlucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgb2xkTWl4aW5zID0gb2xkTWl4aW5zIHx8ICcnO1xuICAgICAgdmFyIG5ld01peGluc0lkcyA9IG5ld01peGlucy5zcGxpdCgnICcpO1xuICAgICAgdmFyIG9sZE1peGluc0lkcyA9IG9sZE1peGlucyA/IG9sZE1peGlucy5zcGxpdCgnICcpIDogW107XG4gICAgICAvLyBUaGUgbGlzdCBvZiBtaXhpbnMgdGhhdCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZCBvbiB1cGRhdGVcbiAgICAgIHZhciBkaWZmID0gb2xkTWl4aW5zSWRzLmZpbHRlcihmdW5jdGlvbiAoaSkgeyByZXR1cm4gbmV3TWl4aW5zSWRzLmluZGV4T2YoaSkgPCAwOyB9KTtcbiAgICAgIC8vIFJlbW92ZSB0aGUgbWl4aW5zIHRoYXQgYXJlIGdvbmUgb24gdXBkYXRlXG4gICAgICBkaWZmLmZvckVhY2goZnVuY3Rpb24gKG1peGluSWQpIHtcbiAgICAgICAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgICAgICAgLy8gU3RhdGUgTWl4aW5zXG4gICAgICAgIHZhciBzdGF0ZU1peGluc0VscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF49JyArIG1peGluSWQgKyAnLV0nKTtcbiAgICAgICAgdmFyIHN0YXRlTWl4aW5JZHMgPSBbXTtcbiAgICAgICAgZm9yRWFjaC5jYWxsKHN0YXRlTWl4aW5zRWxzLCBmdW5jdGlvbiAoZWwpIHsgc3RhdGVNaXhpbklkcy5wdXNoKGVsLmlkKTsgfSk7XG4gICAgICAgIHN0YXRlTWl4aW5JZHMuZm9yRWFjaChzZWxmLnVucmVnaXN0ZXJNaXhpbi5iaW5kKHNlbGYpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgbmV3TWl4aW5zSWRzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgdmFyIG1peGluSWQgPSBpZCArICctJyArIHN0YXRlO1xuICAgICAgICAgIHNlbGYucmVnaXN0ZXJNaXhpbihtaXhpbklkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0T2JqZWN0M0Q6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9iamVjdHMzRFt0eXBlXTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0T2JqZWN0M0Q6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuICAgICAgdmFyIG9sZE9iaiA9IHRoaXMub2JqZWN0czNEW3R5cGVdO1xuICAgICAgaWYgKG9sZE9iaikgeyB0aGlzLm9iamVjdDNELnJlbW92ZShvbGRPYmopOyB9XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QpIHtcbiAgICAgICAgdGhpcy5vYmplY3RzM0RbdHlwZV0gPSBvYmo7XG4gICAgICAgIG9iai5lbCA9IHRoaXM7XG4gICAgICAgIHRoaXMub2JqZWN0M0QuYWRkKG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdDNEIG9mIGEgZ2l2ZW4gdHlwZSBvciBjcmVhdGVzIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgYW5kXG4gICAqIGEgQ29uc3RydWN0b3IgaXMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgb2JqZWN0M0QgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIENvbXBvbmVudCBuYW1lLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3JDcmVhdGVPYmplY3QzRDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgIHZhciBvYmplY3QzRCA9IHRoaXMuZ2V0T2JqZWN0M0QodHlwZSk7XG4gICAgICBpZiAoIW9iamVjdDNEICYmIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIG9iamVjdDNEID0gdGhpcy5vYmplY3RzM0RbdHlwZV0gPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5zZXRPYmplY3QzRCh0eXBlLCBvYmplY3QzRCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0M0Q7XG4gICAgfVxuICB9LFxuXG4gIGFkZDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGlmICghZWwub2JqZWN0M0QpIHtcbiAgICAgICAgZXJyb3IoXCJUcnlpbmcgdG8gYWRkIGFuIG9iamVjdDNEIHRoYXQgZG9lc24ndCBleGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JqZWN0M0QuYWRkKGVsLm9iamVjdDNEKTtcbiAgICB9XG4gIH0sXG5cbiAgYWRkVG9QYXJlbnQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50RWwgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICB2YXIgYXR0YWNoZWRUb1BhcmVudCA9IHRoaXMuYXR0YWNoZWRUb1BhcmVudDtcbiAgICAgIGlmICghcGFyZW50IHx8IGF0dGFjaGVkVG9QYXJlbnQpIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoaXNOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgYXR0YWNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgaXNuJ3QgYW4gYEFOb2RlYCBidXQgZXZlbnR1YWxseSBpdCB3aWxsIGJlXG4gICAgICAvLyB3aGVuIGEgdGVtcGxhdGVkIGVsZW1lbnQgaXMgY3JlYXRlZCwgd2Ugd2FudCB0byBhdHRhY2hcbiAgICAgIC8vIHRoaXMgZWxlbWVudCB0byB0aGUgcGFyZW50IHRoZW4uXG4gICAgICBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbm9kZXJlYWR5JywgYXR0YWNoKTtcbiAgICAgIGZ1bmN0aW9uIGF0dGFjaCAoKSB7XG4gICAgICAgIC8vIFRvIHByZXZlbnQgYW4gb2JqZWN0IHRvIGF0dGFjaCBpdHNlbGYgbXVsdGlwbGUgdGltZXMgdG8gdGhlIHBhcmVudC5cbiAgICAgICAgc2VsZi5hdHRhY2hlZFRvUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBhcmVudC5hZGQpIHtcbiAgICAgICAgICBwYXJlbnQuYWRkKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxvYWQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMuaGFzTG9hZGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAvLyBBdHRhY2ggdG8gcGFyZW50IG9iamVjdDNELlxuICAgICAgdGhpcy5hZGRUb1BhcmVudCgpO1xuXG4gICAgICBpZiAodGhpcy5pc1NjZW5lKSB7XG4gICAgICAgIEFOb2RlLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcywgdGhpcy51cGRhdGVDb21wb25lbnRzLmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQU5vZGUucHJvdG90eXBlLmxvYWQuY2FsbCh0aGlzLCB0aGlzLnVwZGF0ZUNvbXBvbmVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLmlzRW50aXR5OyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgfSxcblxuICByZW1vdmU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICB0aGlzLm9iamVjdDNELnJlbW92ZShlbC5vYmplY3QzRCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7YXJyYXl9IERpcmVjdCBjaGlsZHJlbiB0aGF0IGFyZSBlbnRpdGllcy5cbiAgICovXG4gIGdldENoaWxkRW50aXRpZXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciBjaGlsZEVudGl0aWVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEFFbnRpdHkpIHtcbiAgICAgICAgICBjaGlsZEVudGl0aWVzLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZEVudGl0aWVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgZGVmaW5lZCBmb3IgYW4gZW50aXR5LCBpbmNsdWRpbmcgZGVmYXVsdHMgYW5kIG1peGlucy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBDb21wb25lbnQgbmFtZS5cbiAgICovXG4gIGlzQ29tcG9uZW50RGVmaW5lZDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgLy8gSWYgdGhlIGRlZmF1bHRzIGNvbnRhaW4gdGhlIGNvbXBvbmVudFxuICAgICAgdmFyIGluRGVmYXVsdHMgPSB0aGlzLmRlZmF1bHRzW25hbWVdO1xuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgY29udGFpbnMgdGhlIGNvbXBvbmVudFxuICAgICAgdmFyIGluQXR0cmlidXRlID0gdGhpcy5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICBpZiAoaW5EZWZhdWx0cyAhPT0gdW5kZWZpbmVkIHx8IGluQXR0cmlidXRlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICByZXR1cm4gdGhpcy5pc0NvbXBvbmVudE1peGVkSW4obmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIGlzQ29tcG9uZW50TWl4ZWRJbjoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgaW5NaXhpbiA9IGZhbHNlO1xuICAgICAgdmFyIG1peGluRWxzID0gdGhpcy5taXhpbkVscztcbiAgICAgLy8gSWYgYW55IG9mIHRoZSBtaXhpbnMgY29udGFpbnMgdGhlIGNvbXBvbmVudFxuICAgICAgZm9yIChpID0gMDsgaSA8IG1peGluRWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGluTWl4aW4gPSBtaXhpbkVsc1tpXS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIGlmIChpbk1peGluKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5NaXhpbjtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdENvbXBvbmVudDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgaXNEZXBlbmRlbmN5KSB7XG4gICAgICB2YXIgaXNDb21wb25lbnREZWZpbmVkO1xuICAgICAgLy8gSWYgaXQncyBub3QgYSBjb21wb25lbnQgbmFtZSBvclxuICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBpcyBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICBpZiAoIWNvbXBvbmVudHNbbmFtZV0gfHwgdGhpcy5jb21wb25lbnRzW25hbWVdKSB7IHJldHVybjsgfVxuICAgICAgaXNDb21wb25lbnREZWZpbmVkID0gdGhpcy5pc0NvbXBvbmVudERlZmluZWQobmFtZSk7XG4gICAgICAvLyBJZiB0aGUgY29tcG9uZW50IGlzIG5vdCBkZWZpbmVkIGZvciB0aGUgZWxlbWVudFxuICAgICAgaWYgKCFpc0NvbXBvbmVudERlZmluZWQgJiYgIWlzRGVwZW5kZW5jeSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuaW5pdENvbXBvbmVudERlcGVuZGVuY2llcyhuYW1lKTtcbiAgICAgIC8vIElmIGEgY29tcG9uZW50IGl0J3MgYSBkZXBlbmRlbmN5IG9mIGFub3RoZXIgYnV0IGl0J3Mgbm90IGRlZmluZWRcbiAgICAgIC8vIG9uIHRoZSBhdHRyaWJ1dGUsIG1peGlucyBvciBlbnRpdHkgZGVmYXVsdHNcbiAgICAgIC8vIHdlIGhhdmUgdG8gYWRkIGl0LlxuICAgICAgaWYgKGlzRGVwZW5kZW5jeSAmJiAhaXNDb21wb25lbnREZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tuYW1lXSA9IG5ldyBjb21wb25lbnRzW25hbWVdLkNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkgeyB0aGlzLmNvbXBvbmVudHNbbmFtZV0ucGxheSgpOyB9XG4gICAgICB9XG4gICAgICBsb2coJ0NvbXBvbmVudCBpbml0aWFsaXplZDogJXMnLCBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgaW5pdENvbXBvbmVudERlcGVuZGVuY2llczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbmFtZV07XG4gICAgICB2YXIgZGVwZW5kZW5jaWVzO1xuICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWNvbXBvbmVudCkgeyByZXR1cm47IH1cbiAgICAgIGRlcGVuZGVuY2llcyA9IGNvbXBvbmVudHNbbmFtZV0uZGVwZW5kZW5jaWVzO1xuICAgICAgaWYgKCFkZXBlbmRlbmNpZXMpIHsgcmV0dXJuOyB9XG4gICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHNlbGYuaW5pdENvbXBvbmVudChjb21wb25lbnQsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbW92ZUNvbXBvbmVudHM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGVudGl0eUNvbXBvbmVudHMgPSBPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpO1xuICAgICAgZW50aXR5Q29tcG9uZW50cy5mb3JFYWNoKHJlbW92ZUNvbXBvbmVudCk7XG4gICAgICBmdW5jdGlvbiByZW1vdmVDb21wb25lbnQgKG5hbWUpIHtcbiAgICAgICAgc2VsZi5jb21wb25lbnRzW25hbWVdLnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgc2VsZi5jb21wb25lbnRzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGVDb21wb25lbnRzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBlbnRpdHlDb21wb25lbnRzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgICAvLyBVcGRhdGVzIGNvbXBvbmVudHNcbiAgICAgIGVudGl0eUNvbXBvbmVudHMuZm9yRWFjaCh1cGRhdGVDb21wb25lbnQpO1xuICAgICAgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50IChuYW1lKSB7XG4gICAgICAgIHZhciBlbFZhbHVlID0gc2VsZi5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIHNlbGYudXBkYXRlQ29tcG9uZW50KG5hbWUsIGVsVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSwgdXBkYXRlLCBvciByZW1vdmUgYSBzaW5nbGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBXaGVuIGluaXRpYWxpemluZywgd2Ugc2V0IHRoZSBjb21wb25lbnQgb24gYHRoaXMuY29tcG9uZW50c2AuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gQ29tcG9uZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdEYXRhIC0gVGhlIG5ldyBwcm9wZXJ0aWVzIGFzc2lnbmVkIHRvIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgbmV3RGF0YSkge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgIHZhciBpc0RlZmF1bHQgPSBuYW1lIGluIHRoaXMuZGVmYXVsdHM7XG4gICAgICB2YXIgaXNNaXhlZEluID0gdGhpcy5pc0NvbXBvbmVudE1peGVkSW4obmFtZSk7XG4gICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgIC8vIEF0dHJpYnV0ZSB3YXMgcmVtb3ZlZC4gUmVtb3ZlIGNvbXBvbmVudC5cbiAgICAgICAgLy8gMS4gSWYgdGhlIGNvbXBvbmVudCBpcyBub3QgZGVmaW5lZCBpbiB0aGUgZGVmYXVsdHMsXG4gICAgICAgIC8vIG1peGlucyBvciBlbGVtZW50IGF0dHJpYnV0ZVxuICAgICAgICAvLyAyLiBJZiB0aGUgbmV3IGRhdGEgaXMgbnVsbCwgaXQncyBub3QgYSBkZWZhdWx0XG4gICAgICAgIC8vIGNvbXBvbmVudCBhbmQgdGhlIGNvbXBvbmVudCBpdCdzIG5vdCBkZWZpbmVkIHZpYVxuICAgICAgICAvLyBtaXhpbnNcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcG9uZW50RGVmaW5lZChuYW1lKSB8fFxuICAgICAgICAgICAgbmV3RGF0YSA9PT0gbnVsbCAmJiAhaXNEZWZhdWx0ICYmICFpc01peGVkSW4pIHtcbiAgICAgICAgICBjb21wb25lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY29tcG9uZW50c1tuYW1lXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcG9uZW50IGFscmVhZHkgaW5pdGlhbGl6ZWQuIFVwZGF0ZSBjb21wb25lbnQuXG4gICAgICAgIGNvbXBvbmVudC51cGRhdGVQcm9wZXJ0aWVzKG5ld0RhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDb21wb25lbnQgbm90IHlldCBpbml0aWFsaXplZC4gSW5pdGlhbGl6ZSBjb21wb25lbnQuXG4gICAgICB0aGlzLmluaXRDb21wb25lbnQobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXR0cmAgaXMgYSBjb21wb25lbnQgbmFtZSBhbmQgYGNvbXBvbmVudFByb3BgIGlzIG5vdCBkZWZpbmVkLCByZW1vdmVBdHRyaWJ1dGUgcmVtb3Zlc1xuICAgKiB0aGUgZW50aXJlIGNvbXBvbmVudCBmcm9tIHRoZSBlbnRpdHkuXG4gICAqXG4gICAqIElmIGBhdHRyYCBpcyBhIGNvbXBvbmVudCBuYW1lIGFuZCBgY29tcG9uZW50UHJvcGAgaXMgZGVmaW5lZCwgcmVtb3ZlQXR0cmlidXRlIHJlbW92ZXMgYVxuICAgKiBzaW5nbGUgcHJvcGVydHkgZnJvbSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIEF0dHJpYnV0ZSBuYW1lLCB3aGljaCBjb3VsZCBhbHNvIGJlIGEgY29tcG9uZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRQcm9wIC0gQ29tcG9uZW50IHByb3BlcnR5IG5hbWUuXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIGNvbXBvbmVudFByb3ApIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2F0dHJdO1xuICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50UHJvcCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGF0dHIsIGNvbXBvbmVudFByb3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRFbnRpdHlBdHRyaWJ1dGUoYXR0ciwgdW5kZWZpbmVkLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnRzIGFueSBkeW5hbWljIGJlaGF2aW9yIGFzc29jaWF0ZWQgdG8gdGhlIGVudGl0eVxuICAgKiB0aGlzIGludm9sdmVzIGR5bmFtaWMgY29tcG9uZW50cyBhbmQgYW5pbWF0aW9uc1xuICAgKi9cbiAgcGxheToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cztcbiAgICAgIHZhciBjb21wb25lbnRLZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50cyk7XG4gICAgICBpZiAoIXRoaXMucGF1c2VkKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIGNvbXBvbmVudEtleXMuZm9yRWFjaChwbGF5Q29tcG9uZW50KTtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRFbnRpdGllcygpLmZvckVhY2gocGxheSk7XG4gICAgICBmdW5jdGlvbiBwbGF5IChvYmopIHsgb2JqLnBsYXkoKTsgfVxuICAgICAgZnVuY3Rpb24gcGxheUNvbXBvbmVudCAoa2V5KSB7XG4gICAgICAgIGNvbXBvbmVudHNba2V5XS5wbGF5KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ3BsYXknKTtcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3BzIGFueSBkeW5hbWljIGJlaGF2aW9yIGFzc29jaWF0ZWQgdG8gdGhlIGVudGl0eVxuICAgKiBUaGlzIGludm9sdmVzIGR5bmFtaWMgY29tcG9uZW50cyBhbmQgYW5pbWF0aW9uc1xuICAgKi9cbiAgcGF1c2U6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmNvbXBvbmVudHM7XG4gICAgICB2YXIgY29tcG9uZW50S2V5cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudHMpO1xuICAgICAgaWYgKHRoaXMucGF1c2VkKSB7IHJldHVybjsgfVxuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgICAgY29tcG9uZW50S2V5cy5mb3JFYWNoKHBhdXNlQ29tcG9uZW50KTtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRFbnRpdGllcygpLmZvckVhY2gocGF1c2UpO1xuICAgICAgZnVuY3Rpb24gcGF1c2UgKG9iaikgeyBvYmoucGF1c2UoKTsgfVxuICAgICAgZnVuY3Rpb24gcGF1c2VDb21wb25lbnQgKGtleSkgeyBjb21wb25lbnRzW2tleV0ucGF1c2UoKTsgfVxuICAgICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSxcblxuICAvKipcbiAgICogRGVhbHMgd2l0aCB1cGRhdGVzIG9uIGVudGl0eS1zcGVjaWZpYyBhdHRyaWJ1dGVzIChpLmUuLCBjb21wb25lbnRzIGFuZCBtaXhpbnMpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gbmV3VmFsXG4gICAqL1xuICBzZXRFbnRpdHlBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1thdHRyXTtcbiAgICAgIG9sZFZhbCA9IG9sZFZhbCB8fCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIC8vIFdoZW4gY3JlYXRpbmcgZW50aXRpZXMgcHJvZ3JhbWF0aWNhbGx5IGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGl0IGlzIG5vdCBwYXJ0XG4gICAgICAvLyBvZiB0aGUgc2NlbmUgdW50aWwgaXQgaXMgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLiBUaGlzIGRvZXMgbm90IGFwcGx5IHRvIHNjZW5lcyBhc1xuICAgICAgLy8gc2NlbmVzIGRlcGVuZCBvbiBpdHMgY2hpbGQgZW50aXRpZXMgdG8gbG9hZC5cbiAgICAgIGlmICghdGhpcy5oYXNMb2FkZWQgJiYgIXRoaXMuaXNTY2VuZSkgeyByZXR1cm47IH1cbiAgICAgIGlmIChhdHRyID09PSAnbWl4aW4nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVNaXhpbnMobmV3VmFsLCBvbGRWYWwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudHMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBvbmVudCkgeyB0aGlzLnVwZGF0ZUNvbXBvbmVudChhdHRyLCBuZXdWYWwpOyB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhdHRyaWJ1dGUgaXMgYSBjb21wb25lbnQsIHNldEF0dHJpYnV0ZSB3aWxsIGFwcGx5IHRoZSB2YWx1ZSB0byB0aGVcbiAgICogZXhpc3RpbmcgY29tcG9uZW50IGRhdGEsIG5vdCByZXBsYWNlIGl0LiBFeGFtcGxlczpcbiAgICpcbiAgICogRXhhbXBsZXM6XG4gICAqXG4gICAqIHNldEF0dHJpYnV0ZSgnaWQnLCAnbXktZWxlbWVudCcpO1xuICAgKiBzZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywgeyBjb2xvcjogJ2NyaW1zb24nIH0pO1xuICAgKiBzZXRBdHRyaWJ1dGUoJ21hdGVyaWFsJywgJ2NvbG9yJywgJ2NyaW1zb24nKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBBdHRyaWJ1dGUgbmFtZS4gc2V0QXR0cmlidXRlIHdpbGwgaW5pdGlhbGl6ZSBvciB1cGRhdGVcbiAgICogICAgICAgIGEgY29tcG9uZW50IGlmIHRoZSBuYW1lIGNvcnJlc3BvbmRzIHRvIGEgcmVnaXN0ZXJlZCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gdmFsdWUgLSBJZiBhIHN0cmluZywgc2V0QXR0cmlidXRlIHdpbGwgdXBkYXRlIHRoZSBhdHRyaWJ1dGUgb3IuXG4gICAqICAgICAgICBjb21wb25lbnQuIElmIGFuIG9iamVjdCwgdGhlIHZhbHVlIHdpbGwgYmUgbWl4ZWQgaW50byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50UHJvcFZhbHVlIC0gSWYgZGVmaW5lZCwgYHZhbHVlYCB3aWxsIGFjdCBhcyB0aGUgcHJvcGVydHlcbiAgICogICAgICAgIG5hbWUgYW5kIHNldEF0dHJpYnV0ZSB3aWxsIG9ubHkgc2V0IGEgc2luZ2xlIGNvbXBvbmVudCBwcm9wZXJ0eS5cbiAgICovXG4gIHNldEF0dHJpYnV0ZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgdmFsdWUsIGNvbXBvbmVudFByb3BWYWx1ZSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbYXR0cl07XG4gICAgICB2YXIgcGFydGlhbENvbXBvbmVudERhdGE7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuICAgICAgdmFyIHZhbHVlU3RyID0gdmFsdWU7XG4gICAgICB2YXIgb2xkVmFsdWU7XG5cbiAgICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgY29tcG9uZW50UHJvcFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgY3VycmVudGx5LWRlZmluZWQgY29tcG9uZW50IGRhdGEgd2l0aCB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICAgICAgICAgIHBhcnRpYWxDb21wb25lbnREYXRhID0gc2VsZi5nZXRBdHRyaWJ1dGUoYXR0cikgfHwge307XG4gICAgICAgICAgcGFydGlhbENvbXBvbmVudERhdGFbdmFsdWVdID0gY29tcG9uZW50UHJvcFZhbHVlO1xuICAgICAgICAgIHZhbHVlID0gcGFydGlhbENvbXBvbmVudERhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVTdHIgPSBjb21wb25lbnQuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgb2xkVmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIEFOb2RlLnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUuY2FsbChzZWxmLCBhdHRyLCB2YWx1ZVN0cik7XG4gICAgICBzZWxmLnNldEVudGl0eUF0dHJpYnV0ZShhdHRyLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXR0cmAgaXMgYSBjb21wb25lbnQsIHJldHVybnMgSlVTVCB0aGUgY29tcG9uZW50IGRhdGEgc3BlY2lmaWVkIGluIHRoZSBIVE1MXG4gICAqIGJ5IHBhcnNpbmcgdGhlIHN0eWxlLWxpa2Ugc3RyaW5nIGludG8gYW4gb2JqZWN0LiBMaWtlIGEgcGFydGlhbCB2ZXJzaW9uIG9mXG4gICAqIGBnZXRDb21wdXRlZEF0dHJpYnV0ZWAgYXMgcmV0dXJuZWQgY29tcG9uZW50IGRhdGEgZG9lcyBub3QgaW5jbHVkZSBhcHBsaWVkIG1peGlucyBvclxuICAgKiBkZWZhdWx0cy5cbiAgICpcbiAgICogSWYgYGF0dHJgIGlzIG5vdCBhIGNvbXBvbmVudCwgZmFsbCBiYWNrIHRvIEhUTUwgZ2V0QXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcmV0dXJucyB7b2JqZWN0fHN0cmluZ30gT2JqZWN0IGlmIGNvbXBvbmVudCwgZWxzZSBzdHJpbmcuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2F0dHJdO1xuICAgICAgdmFyIHZhbHVlID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgICAgaWYgKCFjb21wb25lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgIHJldHVybiBjb21wb25lbnQucGFyc2UodmFsdWUpO1xuICAgIH0sXG4gICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXR0cmAgaXMgYSBjb21wb25lbnQsIHJldHVybnMgQUxMIGNvbXBvbmVudCBkYXRhIGluY2x1ZGluZyBhcHBsaWVkIG1peGlucyBhbmRcbiAgICogZGVmYXVsdHMuXG4gICAqXG4gICAqIElmIGBhdHRyYCBpcyBub3QgYSBjb21wb25lbnQsIGZhbGwgYmFjayB0byBIVE1MIGdldEF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybnMge29iamVjdHxzdHJpbmd9IE9iamVjdCBpZiBjb21wb25lbnQsIGVsc2Ugc3RyaW5nLlxuICAgKi9cbiAgZ2V0Q29tcHV0ZWRBdHRyaWJ1dGU6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudHNbYXR0cl07XG4gICAgICBpZiAoY29tcG9uZW50KSB7IHJldHVybiBjb21wb25lbnQuZ2V0RGF0YSgpOyB9XG4gICAgICByZXR1cm4gSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgIH1cbiAgfSxcblxuICBhZGRTdGF0ZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmlzKHN0YXRlKSkgeyByZXR1cm47IH1cbiAgICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgdGhpcy5tYXBTdGF0ZU1peGlucyhzdGF0ZSwgdGhpcy5yZWdpc3Rlck1peGluLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5lbWl0KCdzdGF0ZWFkZGVkJywge3N0YXRlOiBzdGF0ZX0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVTdGF0ZToge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIHZhciBzdGF0ZUluZGV4ID0gdGhpcy5pcyhzdGF0ZSk7XG4gICAgICBpZiAoc3RhdGVJbmRleCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICB0aGlzLnN0YXRlcy5zcGxpY2Uoc3RhdGVJbmRleCwgMSk7XG4gICAgICB0aGlzLm1hcFN0YXRlTWl4aW5zKHN0YXRlLCB0aGlzLnVucmVnaXN0ZXJNaXhpbi5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZW1pdCgnc3RhdGVyZW1vdmVkJywge3N0YXRlOiBzdGF0ZX0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBlbGVtZW50IGlzIGluIGEgZ2l2ZW4gc3RhdGUuIGUuZy4gZWwuaXMoJ2FsaXZlJyk7XG4gICAqIEB0eXBlIHtzdHJpbmd9IHN0YXRlIC0gTmFtZSBvZiB0aGUgc3RhdGUgd2Ugd2FudCB0byBjaGVja1xuICAgKi9cbiAgaXM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICB2YXIgaXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKGVsU3RhdGUsIGluZGV4KSB7XG4gICAgICAgIGlmIChlbFN0YXRlID09PSBzdGF0ZSkgeyBpcyA9IGluZGV4OyB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpcztcbiAgICB9XG4gIH1cbn0pO1xuXG5BRW50aXR5ID0gcmVnaXN0ZXJFbGVtZW50KCdhLWVudGl0eScsIHtcbiAgcHJvdG90eXBlOiBwcm90b1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFFbnRpdHk7XG4iLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbnZhciBBQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50JykuY29tcG9uZW50cztcbnZhciBBTm9kZSA9IHJlcXVpcmUoJy4vYS1ub2RlJyk7XG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJFbGVtZW50KFxuICAnYS1taXhpbicsXG4gIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBBTm9kZS5wcm90b3R5cGUsXG4gICAgICB7XG4gICAgICAgIGF0dGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0QXR0cmlidXRlOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IEFDb21wb25lbnRzW2F0dHJdO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gY29tcG9uZW50LnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0ciwgdmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEF0dHJpYnV0ZToge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IEFDb21wb25lbnRzW2F0dHJdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gSFRNTEVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIGF0dHIpO1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgeyByZXR1cm4gdmFsdWU7IH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQucGFyc2UodmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuIiwiLyogZ2xvYmFsIEhUTUxFbGVtZW50LCBNdXRhdGlvbk9ic2VydmVyICovXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy8nKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBBLUZyYW1lIHRoYXQgbWFuYWdlcyBsb2FkaW5nIG9mIG9iamVjdHMuXG4gKlxuICogTm9kZXMgY2FuIGJlIG1vZGlmaWVkIHVzaW5nIG1peGlucy5cbiAqIE5vZGVzIGVtaXQgYSBgbG9hZGVkYCBldmVudCB3aGVuIHRoZXkgYW5kIHRoZWlyIGNoaWxkcmVuIGhhdmUgaW5pdGlhbGl6ZWQuIFdoaWNoIGNoaWxkcmVuXG4gKiB0byB3YWl0IGZvciBjYW4gYmUgY3VzdG9taXplZCB1c2luZyBgbG9hZENoaWxkcmVuRmlsdGVyYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlckVsZW1lbnQoJ2Etbm9kZScsIHtcbiAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIGNyZWF0ZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1peGluRWxzID0gW107XG4gICAgICAgIHRoaXMubWl4aW5PYnNlcnZlcnMgPSB7fTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1peGlucyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtaXhpbicpO1xuXG4gICAgICAgIHRoaXMuc2NlbmVFbCA9IHRoaXMuY2xvc2VzdCgnYS1zY2VuZScpO1xuICAgICAgICB0aGlzLmVtaXQoJ25vZGVyZWFkeScsIHt9LCBmYWxzZSk7XG4gICAgICAgIGlmIChtaXhpbnMpIHsgdGhpcy51cGRhdGVNaXhpbnMobWl4aW5zKTsgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgaWYgKGF0dHIgPT09ICdtaXhpbicpIHsgdGhpcy51cGRhdGVNaXhpbnMobmV3VmFsLCBvbGRWYWwpOyB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIGEgQ1NTXG4gICAgICogc2VsZWN0b3IgYnkgdHJhdmVyc2luZyB1cCB0aGUgRE9NIHRyZWUgc3RhcnRpbmdcbiAgICAgKiBmcm9tIChhbmQgaW5jbHVkaW5nKSB0aGUgcmVjZWl2ZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgLSBDU1Mgc2VsZWN0b3Igb2YgdGhlIG1hdGNjaGVkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBjbG9zZXN0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VzdCAoc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLm1hdGNoZXMgfHwgdGhpcy5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICB0aGlzLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHRoaXMub01hdGNoZXNTZWxlY3RvciB8fCB0aGlzLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKSB7IGJyZWFrOyB9XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciBjaGlsZHJlbiB0byBsb2FkLCBpZiBhbnkuXG4gICAgICogVGhlbiBlbWl0IGBsb2FkZWRgIGV2ZW50IGFuZCBzZXQgYGhhc0xvYWRlZGAuXG4gICAgICovXG4gICAgbG9hZDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjYiwgY2hpbGRGaWx0ZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgICB2YXIgY2hpbGRyZW5Mb2FkZWQ7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZiAoc2VsZi5oYXNMb2FkZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byB3YWl0aW5nIGZvciBhbGwgbm9kZXMuXG4gICAgICAgIGNoaWxkRmlsdGVyID0gY2hpbGRGaWx0ZXIgfHwgZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pc05vZGU7IH07XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgY2hpbGRyZW4gdG8gbG9hZCAoaWYgYW55KSwgdGhlbiBsb2FkLlxuICAgICAgICBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY2hpbGRyZW5Mb2FkZWQgPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGRGaWx0ZXIpLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gd2FpdEZvckxvYWRlZCAocmVzb2x2ZSkge1xuICAgICAgICAgICAgY2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgcmVzb2x2ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIFByb21pc2UuYWxsKGNoaWxkcmVuTG9hZGVkKS50aGVuKGZ1bmN0aW9uIGVtaXRMb2FkZWQgKCkge1xuICAgICAgICAgIGlmIChjYikgeyBjYigpOyB9XG4gICAgICAgICAgc2VsZi5oYXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIHNlbGYuZW1pdCgnbG9hZGVkJywge30sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuXG4gICAgZ2V0Q2hpbGRyZW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdXBkYXRlTWl4aW5zOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG5ld01peGlucywgb2xkTWl4aW5zKSB7XG4gICAgICAgIHZhciBuZXdNaXhpbnNJZHMgPSBuZXdNaXhpbnMuc3BsaXQoJyAnKTtcbiAgICAgICAgdmFyIG9sZE1peGluc0lkcyA9IG9sZE1peGlucyA/IG9sZE1peGlucy5zcGxpdCgnICcpIDogW107XG4gICAgICAgIC8vIFRvIGRldGVybWluZSB3aGF0IGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgdmFyIGRpZmYgPSBvbGRNaXhpbnNJZHMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBuZXdNaXhpbnNJZHMuaW5kZXhPZihpKSA8IDA7IH0pO1xuICAgICAgICB0aGlzLm1peGluRWxzID0gW107XG4gICAgICAgIGRpZmYuZm9yRWFjaCh0aGlzLnVucmVnaXN0ZXJNaXhpbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgbmV3TWl4aW5zSWRzLmZvckVhY2godGhpcy5yZWdpc3Rlck1peGluLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGRNaXhpbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtaXhpbklkKSB7XG4gICAgICAgIHZhciBtaXhpbnMgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWl4aW4nKTtcbiAgICAgICAgdmFyIG1peGluSWRzID0gbWl4aW5zLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWl4aW5JZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAobWl4aW5JZHNbaV0gPT09IG1peGluSWQpIHsgcmV0dXJuOyB9XG4gICAgICAgIH1cbiAgICAgICAgbWl4aW5JZHMucHVzaChtaXhpbklkKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ21peGluJywgbWl4aW5JZHMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTWl4aW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5JZCkge1xuICAgICAgICB2YXIgbWl4aW5zID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21peGluJyk7XG4gICAgICAgIHZhciBtaXhpbklkcyA9IG1peGlucy5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1peGluSWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKG1peGluSWRzW2ldID09PSBtaXhpbklkKSB7XG4gICAgICAgICAgICBtaXhpbklkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbWl4aW4nLCBtaXhpbklkcy5qb2luKCcgJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZWdpc3Rlck1peGluOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG1peGluSWQpIHtcbiAgICAgICAgdmFyIG1peGluRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdhLW1peGluIycgKyBtaXhpbklkKTtcbiAgICAgICAgaWYgKCFtaXhpbkVsKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmF0dGFjaE1peGluTGlzdGVuZXIobWl4aW5FbCk7XG4gICAgICAgIHRoaXMubWl4aW5FbHMucHVzaChtaXhpbkVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0QXR0cmlidXRlOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAnbWl4aW4nKSB7IHRoaXMudXBkYXRlTWl4aW5zKG5ld1ZhbHVlKTsgfVxuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLmNhbGwodGhpcywgYXR0ciwgbmV3VmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bnJlZ2lzdGVyTWl4aW46IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5JZCkge1xuICAgICAgICB2YXIgbWl4aW5FbHMgPSB0aGlzLm1peGluRWxzO1xuICAgICAgICB2YXIgbWl4aW5FbDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaXhpbkVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG1peGluRWwgPSBtaXhpbkVsc1tpXTtcbiAgICAgICAgICBpZiAobWl4aW5JZCA9PT0gbWl4aW5FbC5pZCkge1xuICAgICAgICAgICAgbWl4aW5FbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlTWl4aW5MaXN0ZW5lcihtaXhpbklkKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlTWl4aW5MaXN0ZW5lcjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtaXhpbklkKSB7XG4gICAgICAgIHZhciBvYnNlcnZlciA9IHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF07XG4gICAgICAgIGlmICghb2JzZXJ2ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5taXhpbk9ic2VydmVyc1ttaXhpbklkXSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGF0dGFjaE1peGluTGlzdGVuZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWl4aW5FbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBtaXhpbklkID0gbWl4aW5FbC5pZDtcbiAgICAgICAgdmFyIGN1cnJlbnRPYnNlcnZlciA9IHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF07XG4gICAgICAgIGlmICghbWl4aW5FbCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKGN1cnJlbnRPYnNlcnZlcikgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgICAgICAgIHZhciBhdHRyID0gbXV0YXRpb25zWzBdLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgc2VsZi5hcHBseU1peGluKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHsgYXR0cmlidXRlczogdHJ1ZSB9O1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKG1peGluRWwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMubWl4aW5PYnNlcnZlcnNbbWl4aW5JZF0gPSBvYnNlcnZlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlNaXhpbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhIERPTSBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogICBOYW1lIG9mIGV2ZW50ICh1c2UgYSBzcGFjZS1kZWxpbWl0ZWQgc3RyaW5nIGZvciBtdWx0aXBsZSBldmVudHMpLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gW2RldGFpbD17fV1cbiAgICAgKiAgIEN1c3RvbSBkYXRhIHRvIHBhc3MgYXMgYGRldGFpbGAgdG8gdGhlIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbj19IFtidWJibGVzPXRydWVdXG4gICAgICogICBXaGV0aGVyIHRoZSBldmVudCBzaG91bGQgYnViYmxlLlxuICAgICAqL1xuICAgIGVtaXQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSwgZGV0YWlsLCBidWJibGVzKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9O1xuICAgICAgICBpZiAoYnViYmxlcyA9PT0gdW5kZWZpbmVkKSB7IGJ1YmJsZXMgPSB0cnVlOyB9XG4gICAgICAgIHZhciBkYXRhID0geyBidWJibGVzOiAhIWJ1YmJsZXMsIGRldGFpbDogZGV0YWlsIH07XG4gICAgICAgIHJldHVybiBuYW1lLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHMuZmlyZUV2ZW50KHNlbGYsIGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvc3VyZSB0aGF0IGVtaXRzIGEgRE9NIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiAgIE5hbWUgb2YgZXZlbnQgKHVzZSBhIHNwYWNlLWRlbGltaXRlZCBzdHJpbmcgZm9yIG11bHRpcGxlIGV2ZW50cykuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRldGFpbFxuICAgICAqICAgQ3VzdG9tIGRhdGEgKG9wdGlvbmFsKSB0byBwYXNzIGFzIGBkZXRhaWxgIGlmIHRoZSBldmVudCBpcyB0b1xuICAgICAqICAgYmUgYSBgQ3VzdG9tRXZlbnRgLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYnViYmxlc1xuICAgICAqICAgV2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGJ1YmJsZS5cbiAgICAgKi9cbiAgICBlbWl0dGVyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKG5hbWUsIGRldGFpbCwgYnViYmxlcykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KG5hbWUsIGRldGFpbCwgYnViYmxlcyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG4iLCIvLyBQb2x5ZmlsbCBgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50YC5cbnJlcXVpcmUoJ2RvY3VtZW50LXJlZ2lzdGVyLWVsZW1lbnQnKTtcblxuLypcbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAtLS0tLS0tLS0tLS0tIFdBUk5JTkcgV0FSTklORyBXQVJOSU5HIFdBUk5JTkcgLS0tLS0tLS0tLS0tLS1cbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuIFRoaXMgbW9kdWxlIHdyYXBzIHJlZ2lzdGVyRWxlbWVudCB0byBkZWFsIHdpdGhcbiBjb21wb25lbnRzIHRoYXQgaW5oZXJpdCBmcm9tIGBBTm9kZWAgYW5kIGBBRW50aXR5YC5cbiBJdCdzIGEgcGFzcyB0aHJvdWdoIGluIGFueSBvdGhlciBjYXNlLlxuXG4gSXQgd3JhcHMgc29tZSBvZiB0aGUgcHJvdG90eXBlIG1ldGhvZHNcbiBvZiB0aGUgY3JlYXRlZCBlbGVtZW50IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gZnVuY3Rpb25zIGluIHRoZSBiYXNlIGNsYXNzZXMgKGBBRW50aXR5YCBhbmQgYEFOb2RlYCkgYXJlIGFsc29cbiBpbnZva2VkLiBUaGUgbWV0aG9kIGluIHRoZSBiYXNlIGNsYXNzIGlzIGFsd2F5cyBjYWxsZWQgYmVmb3JlIHRoZVxuIG9uZSBpbiB0aGUgZGVyaXZlZCBvYmplY3QuXG5cbiovXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50O1xuXG52YXIga25vd25UYWdzID0gbW9kdWxlLmV4cG9ydHMua25vd25UYWdzID0ge307XG5cbnZhciBhZGRUYWdOYW1lID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAga25vd25UYWdzW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgdHlwZSBpcyBvbmUgb2Ygb3VyIGtub3duIHJlZ2lzdGVyZWQgb25lc1xuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9IG5vZGUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0byByZWdpc3RlclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRhZyBuYW1lIG1hdGNoZXMgdGhhdCBvZiBvdXIgcmVnaXN0ZXJlZFxuICogICAgICAgICAgICAgICAgICAgIGN1c3RvbSBlbGVtZW50c1xuICovXG5tb2R1bGUuZXhwb3J0cy5pc05vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgaW4ga25vd25UYWdzIHx8IG5vZGUuaXNOb2RlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSAgIHtvYmplY3R9IG9iaiBUaGUgcHJvdG90eXBlIG9mIHRoZSBuZXcgZWxlbWVudFxuICogQHJldHVybnMge29iamVjdH0gVGhlIHByb3RvdHlwZSBvZiB0aGUgbmV3IGVsZW1lbnRcbiAqL1xubW9kdWxlLmV4cG9ydHMucmVnaXN0ZXJFbGVtZW50ID0gZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG9iaikge1xuICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqLnByb3RvdHlwZSk7XG4gIHZhciBuZXdPYmogPSBvYmo7XG4gIHZhciBpc0FOb2RlID0gQU5vZGUgJiYgcHJvdG8gPT09IEFOb2RlLnByb3RvdHlwZTtcbiAgdmFyIGlzQUVudGl0eSA9IEFFbnRpdHkgJiYgcHJvdG8gPT09IEFFbnRpdHkucHJvdG90eXBlO1xuXG4gIGlmIChpc0FOb2RlIHx8IGlzQUVudGl0eSkgeyBhZGRUYWdOYW1lKHRhZ05hbWUpOyB9XG5cbiAgLy8gRG9lcyB0aGUgZWxlbWVudCBpbmhlcml0IGZyb20gYEFOb2RlYD9cbiAgaWYgKGlzQU5vZGUpIHtcbiAgICBuZXdPYmogPSB3cmFwQU5vZGVNZXRob2RzKG9iai5wcm90b3R5cGUpO1xuICAgIG5ld09iaiA9IHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUocHJvdG8sIG5ld09iail9O1xuICB9XG5cbiAgLy8gRG9lcyB0aGUgZWxlbWVudCBpbmhlcml0IGZyb20gYEFFbnRpdHlgP1xuICBpZiAoaXNBRW50aXR5KSB7XG4gICAgbmV3T2JqID0gd3JhcEFFbnRpdHlNZXRob2RzKG9iai5wcm90b3R5cGUpO1xuICAgIG5ld09iaiA9IHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUocHJvdG8sIG5ld09iail9O1xuICB9XG5cbiAgcmV0dXJuIHJlZ2lzdGVyRWxlbWVudC5jYWxsKGRvY3VtZW50LCB0YWdOYW1lLCBuZXdPYmopO1xufTtcblxuLyoqXG4gKiBUaGlzIHdyYXBzIHNvbWUgb2YgdGhlIG9iaiBtZXRob2RzIHRvIGNhbGwgdGhvc2Ugb24gYEFOb2RlYCBiYXNlIGNsYXNlLlxuICogQHBhcmFtICB7b2JqZWN0fSBvYmogVGhlIG9iamVjdHMgdGhhdCBjb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgd3JhcHBlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgaW5wdXQgcGFyYW1ldGVyIGJ1dFxuICogd2l0aCBzb21lIG9mIG1ldGhvZHMgd3JhcHBlZC5cbiAqL1xuZnVuY3Rpb24gd3JhcEFOb2RlTWV0aG9kcyAob2JqKSB7XG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIEFOb2RlTWV0aG9kcyA9IFtcbiAgICAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgJ2NyZWF0ZWRDYWxsYmFjaydcbiAgXTtcbiAgd3JhcE1ldGhvZHMobmV3T2JqLCBBTm9kZU1ldGhvZHMsIG9iaiwgQU5vZGUucHJvdG90eXBlKTtcbiAgY29weVByb3BlcnRpZXMob2JqLCBuZXdPYmopO1xuICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIFRoaXMgd3JhcHMgc29tZSBvZiB0aGUgb2JqIG1ldGhvZHMgdG8gY2FsbCB0aG9zZSBvbiBgQUVudGl0eWAgYmFzZSBjbGFzcy5cbiAqIEBwYXJhbSAge29iamVjdH0gb2JqIFRoZSBvYmplY3RzIHRoYXQgY29udGFpbnMgdGhlIG1ldGhvZHMgdGhhdCB3aWxsIGJlIHdyYXBwZWQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIGlucHV0IHBhcmFtZXRlciBidXRcbiAqIHdpdGggc29tZSBvZiBtZXRob2RzIHdyYXBwZWQuXG4gKi9cbmZ1bmN0aW9uIHdyYXBBRW50aXR5TWV0aG9kcyAob2JqKSB7XG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIEFOb2RlTWV0aG9kcyA9IFtcbiAgICAnYXR0YWNoZWRDYWxsYmFjaycsXG4gICAgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaycsXG4gICAgJ2NyZWF0ZWRDYWxsYmFjaydcbiAgXTtcbiAgdmFyIEFFbnRpdHlNZXRob2RzID0gW1xuICAgICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snLFxuICAgICdhdHRhY2hlZENhbGxiYWNrJyxcbiAgICAnY3JlYXRlZENhbGxiYWNrJyxcbiAgICAnZGV0YWNoZWRDYWxsYmFjaydcbiAgXTtcbiAgd3JhcE1ldGhvZHMobmV3T2JqLCBBTm9kZU1ldGhvZHMsIG9iaiwgQU5vZGUucHJvdG90eXBlKTtcbiAgd3JhcE1ldGhvZHMobmV3T2JqLCBBRW50aXR5TWV0aG9kcywgb2JqLCBBRW50aXR5LnByb3RvdHlwZSk7XG4gIC8vIENvcGllcyB0aGUgcmVtYWluaW5nIHByb3BlcnRpZXMgaW50byB0aGUgbmV3IG9iamVjdFxuICBjb3B5UHJvcGVydGllcyhvYmosIG5ld09iaik7XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogV3JhcHMgYSBsaXN0IGEgbWV0aG9kcyB0byBlbnN1cmUgdGhhdCB0aG9zZSBpbiB0aGUgYmFzZSBjbGFzcyBhcmUgY2FsbGVkIHRocm91Z2ggdGhlIGRlcml2ZWQgb25lLlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXRPYmogT2JqZWN0IHRoYXQgd2lsbCBjb250YWluIHRoZSB3cmFwcGVkIG1ldGhvZHNcbiAqIEBwYXJhbSAge2FycmF5fSBtZXRob2RMaXN0IExpc3Qgb2YgbWV0aG9kcyBmcm9tIHRoZSBkZXJpdmVkT2JqIHRoYXQgd2lsbCBiZSB3cmFwcGVkXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlcml2ZWRPYmplY3QgT2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYmFzZU9ialxuICogQHBhcmFtICB7b2JqZWN0fSBiYXNlT2JqIE9iamVjdCB0aGF0IGRlcml2ZWRPYmogaW5oZXJpdHMgZnJvbVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiB3cmFwTWV0aG9kcyAodGFyZ2V0T2JqLCBtZXRob2RMaXN0LCBkZXJpdmVkT2JqLCBiYXNlT2JqKSB7XG4gIG1ldGhvZExpc3QuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIHdyYXBNZXRob2QodGFyZ2V0T2JqLCBtZXRob2ROYW1lLCBkZXJpdmVkT2JqLCBiYXNlT2JqKTtcbiAgfSk7XG59XG5cbi8qKlxuICogV3JhcHMgb25lIG1ldGhvZCB0byBlbnN1cmUgdGhhdCB0aGUgb25lIGluIHRoZSBiYXNlIGNsYXNzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIG9uZVxuICogaW4gdGhlIGRlcml2ZWQgb25lXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9iaiBPYmplY3QgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIHdyYXBwZWQgbWV0aG9kXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgd3JhcHBlZFxuICogQHBhcmFtICB7b2JqZWN0fSBkZXJpdmVkT2JqZWN0IE9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGJhc2VPYmpcbiAqIEBwYXJhbSAge29iamVjdH0gYmFzZU9iaiBPYmplY3QgdGhhdCBkZXJpdmVkT2JqIGluaGVyaXRzIGZyb21cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gd3JhcE1ldGhvZCAob2JqLCBtZXRob2ROYW1lLCBkZXJpdmVkT2JqLCBiYXNlT2JqKSB7XG4gIHZhciBkZXJpdmVkTWV0aG9kID0gZGVyaXZlZE9ialttZXRob2ROYW1lXTtcbiAgdmFyIGJhc2VNZXRob2QgPSBiYXNlT2JqW21ldGhvZE5hbWVdO1xuICBpZiAoIWRlcml2ZWRNZXRob2QgfHwgIWJhc2VNZXRob2QpIHsgcmV0dXJuOyB9XG4gIC8vIFRoZSBkZXJpdmVkIGNsYXNzIGRvZXNuJ3Qgb3ZlcnJpZGUgdGhlIG9uZSBpbiB0aGUgYmFzZSBvbmVcbiAgaWYgKGRlcml2ZWRNZXRob2QgPT09IGJhc2VNZXRob2QpIHsgcmV0dXJuOyB9XG4gIC8vIFdyYXBwZXJcbiAgLy8gVGhlIGJhc2UgbWV0aG9kIGlzIGNhbGxlZCBiZWZvcmUgdGhlIG9uZSBpbiB0aGUgZGVyaXZlZCBjbGFzc1xuICB2YXIgd3JhcHBlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBiYXNlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGRlcml2ZWRNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgb2JqW21ldGhvZE5hbWVdID0ge3ZhbHVlOiB3cmFwcGVyTWV0aG9kLCB3cml0YWJsZTogd2luZG93LmRlYnVnfTtcbn1cblxuLyoqXG4gKiBJdCBjb3BpZXMgdGhlIHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gZGVzdGluYXRpb24gb2JqZWN0XG4gKiBpZiB0aGV5IGRvbid0IGV4aXN0IGFscmVhZHlcbiAqIEBwYXJhbSAge29iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgd2hlcmUgcHJvcGVydGllcyBhcmUgY29waWVkIGZyb21cbiAqIEBwYXJhbSAge3R5cGV9IGRlc3RpbmF0aW9uIFRoZSBvYmplY3Qgd2hlcmUgcHJvcGVydGllcyBhcmUgY29waWVkIHRvXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzIChzb3VyY2UsIGRlc3RpbmF0aW9uKSB7XG4gIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZSk7XG4gIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgZGVzYztcbiAgICBpZiAoIWRlc3RpbmF0aW9uW3Byb3BdKSB7XG4gICAgICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3ApO1xuICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSB7dmFsdWU6IHNvdXJjZVtwcm9wXSwgd3JpdGFibGU6IGRlc2Mud3JpdGFibGV9O1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBBTm9kZSA9IHJlcXVpcmUoJy4vYS1ub2RlJyk7XG52YXIgQUVudGl0eSA9IHJlcXVpcmUoJy4vYS1lbnRpdHknKTtcbiIsIi8qIGdsb2JhbCBNZXNzYWdlQ2hhbm5lbCwgUHJvbWlzZSAqL1xudmFyIHJlID0gcmVxdWlyZSgnLi9hLXJlZ2lzdGVyLWVsZW1lbnQnKTtcbnZhciBSU3RhdHMgPSByZXF1aXJlKCcuLi8uLi9saWIvdmVuZG9yL3JTdGF0cycpO1xudmFyIFRIUkVFID0gcmVxdWlyZSgnLi4vLi4vbGliL3RocmVlJyk7XG52YXIgVFdFRU4gPSByZXF1aXJlKCd0d2Vlbi5qcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvJyk7XG52YXIgQUVudGl0eSA9IHJlcXVpcmUoJy4vYS1lbnRpdHknKTtcbnZhciBBTm9kZSA9IHJlcXVpcmUoJy4vYS1ub2RlJyk7XG52YXIgV2FrZWxvY2sgPSByZXF1aXJlKCcuLi8uLi9saWIvdmVuZG9yL3dha2Vsb2NrL3dha2Vsb2NrJyk7XG5cbnZhciBkdW1teURvbGx5ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG52YXIgY29udHJvbHMgPSBuZXcgVEhSRUUuVlJDb250cm9scyhkdW1teURvbGx5KTtcbnZhciBERUZBVUxUX0NBTUVSQV9BVFRSID0gJ2RhdGEtYWZyYW1lLWRlZmF1bHQtY2FtZXJhJztcbnZhciBERUZBVUxUX0xJR0hUX0FUVFIgPSAnZGF0YS1hZnJhbWUtZGVmYXVsdC1saWdodCc7XG52YXIgSElEREVOX0NMQVNTID0gJ2EtaGlkZGVuJztcbnZhciByZWdpc3RlckVsZW1lbnQgPSByZS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgRU5URVJfVlJfQ0xBU1MgPSAnYS1lbnRlci12cic7XG52YXIgRU5URVJfVlJfTk9fSEVBRFNFVCA9ICdkYXRhLWEtZW50ZXItdnItbm8taGVhZHNldCc7XG52YXIgRU5URVJfVlJfTk9fV0VCVlIgPSAnZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyJztcbnZhciBFTlRFUl9WUl9CVE5fQ0xBU1MgPSAnYS1lbnRlci12ci1idXR0b24nO1xudmFyIEVOVEVSX1ZSX01PREFMX0NMQVNTID0gJ2EtZW50ZXItdnItbW9kYWwnO1xudmFyIE9SSUVOVEFUSU9OX01PREFMX0NMQVNTID0gJ2Etb3JpZW50YXRpb24tbW9kYWwnO1xudmFyIGlzTW9iaWxlID0gdXRpbHMuaXNNb2JpbGUoKTtcblxuLyoqXG4gKiBTY2VuZSBlbGVtZW50LCBob2xkcyBhbGwgZW50aXRpZXMuXG4gKlxuICogQG1lbWJlciB7bnVtYmVyfSBhbmltYXRpb25GcmFtZUlEXG4gKiBAbWVtYmVyIHthcnJheX0gYmVoYXZpb3JzIC0gQ29tcG9uZW50IGluc3RhbmNlcyB0aGF0IGhhdmUgcmVnaXN0ZXJlZCB0aGVtc2VsdmVzIHRvIGJlXG4gICAgICAgICAgIHVwZGF0ZWQgb24gZXZlcnkgdGljay5cbiAqIEBtZW1iZXIge29iamVjdH0gY2FudmFzXG4gKiBAbWVtYmVyIHtFbGVtZW50fSBlbnRlclZSRWxcbiAqIEBtZW1iZXIge2Jvb2x9IGluc2lkZUlmcmFtZVxuICogQG1lbWJlciB7Ym9vbH0gaW5zaWRlTG9hZGVyXG4gKiBAbWVtYmVyIHtib29sfSBpc1NjZW5lIC0gRGlmZmVyZW50aWF0ZXMgdGhpcyBhcyBhIHNjZW5lIGVudGl0eSBhcyBvcHBvc2VkXG4gICAgICAgICAgIHRvIG90aGVyIGBBRW50aXR5YHMuXG4gKiBAbWVtYmVyIHtib29sfSBpc01vYmlsZSAtIFdoZXRoZXIgYnJvd3NlciBpcyBtb2JpbGUgKHZpYSBVQSBkZXRlY3Rpb24pLlxuICogQG1lbWJlciB7b2JqZWN0fSBvYmplY3QzRCAtIFRoZSByb290IHRocmVlLmpzIFNjZW5lIG9iamVjdC5cbiAqIEBtZW1iZXIge29iamVjdH0gbW9ub1JlbmRlcmVyXG4gKiBAbWVtYmVyIHtvYmplY3R9IHJlbmRlcmVyXG4gKiBAbWVtYmVyIHtib29sfSByZW5kZXJTdGFydGVkXG4gKiBAbWVtYmVyIHtvYmplY3R9IHN0YXRzXG4gKiBAbWVtYmVyIHtvYmplY3R9IHN0ZXJlb1JlbmRlcmVyXG4gKiBAbWVtYmVyIHtvYmplY3R9IHdha2Vsb2NrXG4gKi9cbnZhciBBU2NlbmUgPSBtb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyRWxlbWVudCgnYS1zY2VuZScsIHtcbiAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKEFFbnRpdHkucHJvdG90eXBlLCB7XG4gICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRMaWdodHNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbnRlclZSRWwgPSBudWxsO1xuICAgICAgICB0aGlzLmluc2lkZUlmcmFtZSA9IHdpbmRvdy50b3AgIT09IHdpbmRvdy5zZWxmO1xuICAgICAgICB0aGlzLmluc2lkZUxvYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2NlbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9iamVjdDNEID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzID0gW107XG4gICAgICAgIHRoaXMubWF0ZXJpYWxzID0ge307XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhUTUwgPSB0aGlzLmlubmVySFRNTDtcbiAgICAgICAgdGhpcy5zZXR1cENhbnZhcygpO1xuICAgICAgICB0aGlzLnNldHVwUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgICAgdGhpcy5zZXR1cERlZmF1bHRMaWdodHMoKTtcbiAgICAgICAgdGhpcy5zZXR1cERlZmF1bHRDYW1lcmEoKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgICAgIGluamVjdE1ldGFUYWdzKCk7XG4gICAgICAgICAgdGhpcy53YWtlbG9jayA9IG5ldyBXYWtlbG9jaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0YWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH0sXG5cbiAgICBhdHRhY2hFdmVudExpc3RlbmVyczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc2l6ZUNhbnZhcyA9IHRoaXMucmVzaXplQ2FudmFzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBLZXlib2FyZFNob3J0Y3V0cygpO1xuICAgICAgICB0aGlzLmF0dGFjaEZ1bGxzY3JlZW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hPcmllbnRhdGlvbkxpc3RlbmVycygpO1xuICAgICAgICAvLyBGb3IgQ2hyb21lIChodHRwczovL2dpdGh1Yi5jb20vYWZyYW1ldnIvYWZyYW1lLWNvcmUvaXNzdWVzLzMyMSkuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzaXplQ2FudmFzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHN0YXRzLlxuICAgICAqIFRPRE86IG1vdmUgc3RhdHMgdG8gYSBjb21wb25lbnQuXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICAgIGlmIChvbGRWYWwgPT09IG5ld1ZhbCkgeyByZXR1cm47IH1cbiAgICAgICAgaWYgKGF0dHIgPT09ICdzdGF0cycpIHsgdGhpcy5zZXR1cFN0YXRzKCk7IH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2h1dHMgZG93biBzY2VuZSBvbiBkZXRhY2guXG4gICAgICovXG4gICAgZGV0YWNoZWRDYWxsYmFjazoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVJRCk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBiZWhhdmlvciAtIEdlbmVyYWxseSBhIGNvbXBvbmVudC4gTXVzdCBpbXBsZW1lbnQgYSAudXBkYXRlKCkgbWV0aG9kIHRvXG4gICAgICogICAgICAgIGJlIGNhbGxlZCBvbiBldmVyeSB0aWNrLlxuICAgICAqL1xuICAgIGFkZEJlaGF2aW9yOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGJlaGF2aW9yKSB7XG4gICAgICAgIHRoaXMuYmVoYXZpb3JzLnB1c2goYmVoYXZpb3IpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRhY2hPcmllbnRhdGlvbkxpc3RlbmVyczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuc2hvd09yaWVudGF0aW9uTW9kYWwuYmluZCh0aGlzKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNob3dPcmllbnRhdGlvbk1vZGFsOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXV0aWxzLmlzSU9TKCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIGlmICghdXRpbHMuaXNMYW5kc2NhcGUoKSAmJiB0aGlzLnJlbmRlcmVyID09PSB0aGlzLnN0ZXJlb1JlbmRlcmVyKSB7XG4gICAgICAgICAgdGhpcy5vcmllbnRhdGlvbk1vZGFsLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9yaWVudGF0aW9uTW9kYWwuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN3aXRjaCBiYWNrIHRvIG1vbm8gcmVuZGVyZXIgaWYgbm8gbG9uZ2VyIGluIGZ1bGxzY3JlZW4gVlIuXG4gICAgICogTG9jayB0byBsYW5kc2NhcGUgb3JpZW50YXRpb24gb24gbW9iaWxlIHdoZW4gZnVsbHNjcmVlbi5cbiAgICAgKi9cbiAgICBhdHRhY2hGdWxsc2NyZWVuTGlzdGVuZXJzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxsc2NyZWVuQ2hhbmdlIChlKSB7XG4gICAgICAgICAgdmFyIGZzRWxlbWVudCA9IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICAgIGlmICh3aW5kb3cuc2NyZWVuLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBMb2NrIHRvIGxhbmRzY2FwZSBvcmllbnRhdGlvbiBvbiBtb2JpbGUuXG4gICAgICAgICAgICBpZiAoZnNFbGVtZW50ICYmIHRoaXMuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgd2luZG93LnNjcmVlbi5vcmllbnRhdGlvbi5sb2NrKCdsYW5kc2NhcGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5zY3JlZW4ub3JpZW50YXRpb24udW5sb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnNFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNob3dVSSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRNb25vUmVuZGVyZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMud2FrZWxvY2spIHsgdGhpcy53YWtlbG9jay5yZWxlYXNlKCk7IH1cbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFZSIGFuZCBmdWxsc2NyZWVuIGJlaGF2aW9yIGZvciB3aGVuIHdlIGFyZSBpbnNpZGUgYW4gaWZyYW1lLlxuICAgICAqL1xuICAgIGF0dGFjaE1lc3NhZ2VMaXN0ZW5lcnM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLmRhdGEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZS5kYXRhLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnbG9hZGVyUmVhZHknOiB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnNpZGVMb2FkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlRW50ZXJWUkJ1dHRvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgJ2Z1bGxzY3JlZW4nOiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmRhdGEuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgLy8gU2V0IHJlbmRlcmVyIHdpdGggZnVsbHNjcmVlbiBWUiBlbnRlciBhbmQgZXhpdC5cbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXRTdGVyZW9SZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2V4aXQnOlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldE1vbm9SZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnRlcnMgVlIgd2hlbiA/bW9kZT12ciBpcyBzcGVjaWZpZWQgaW4gdGhlIHF1ZXJ5c3RyaW5nLlxuICAgICAqL1xuICAgIGNoZWNrVXJsUGFyYW1ldGVyczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGUgPSB1dGlscy5nZXRVcmxQYXJhbWV0ZXIoJ21vZGUnKTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICd2cicpIHtcbiAgICAgICAgICB0aGlzLmVudGVyVlIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1aSA9IHV0aWxzLmdldFVybFBhcmFtZXRlcigndWknKTtcbiAgICAgICAgaWYgKHVpID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgdGhpcy5oaWRlVUkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbnRlclZSOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhpZGVVSSgpO1xuICAgICAgICB0aGlzLnNldFN0ZXJlb1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMuc2V0RnVsbHNjcmVlbigpO1xuICAgICAgICB0aGlzLnNob3dPcmllbnRhdGlvbk1vZGFsKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGV4aXRWUjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaG93VUkoKTtcbiAgICAgICAgdGhpcy5zZXRNb25vUmVuZGVyZXIoKTtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbk1vZGFsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q2FudmFzU2l6ZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhlaWdodDogY2FudmFzLm9mZnNldEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogY2FudmFzLm9mZnNldFdpZHRoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZGVVSToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHNFbCkge1xuICAgICAgICAgIHRoaXMuc3RhdHNFbC5jbGFzc0xpc3QuYWRkKEhJRERFTl9DTEFTUyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW50ZXJWUkVsKSB7XG4gICAgICAgICAgdGhpcy5lbnRlclZSRWwuY2xhc3NMaXN0LmFkZChISURERU5fQ0xBU1MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBjYW1lcmEgdG8gYmUgdXNlZCBieSB0aGUgcmVuZGVyZXJcbiAgICAgKiBJdCBhbHNlIHJlbW92ZXMgdGhlIGRlZmF1bHQgb25lIGlmIGFueSBhbmQgZGlzYWJsZXMgYW55IG90aGVyIGNhbWVyYVxuICAgICAqIGluIHRoZSBzY2VuZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsIC0gb2JqZWN0IGhvbGRpbmcgYW4gZW50aXR5IHdpdGggYSBjYW1lcmEgY29tcG9uZW50IG9yIFRIUkVFIGNhbWVyYS5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVDYW1lcmE6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmV3Q2FtZXJhKSB7XG4gICAgICAgIHZhciBkZWZhdWx0Q2FtZXJhV3JhcHBlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1snICsgREVGQVVMVF9DQU1FUkFfQVRUUiArICddJyk7XG4gICAgICAgIHZhciBkZWZhdWx0Q2FtZXJhRWwgPSBkZWZhdWx0Q2FtZXJhV3JhcHBlciAmJiBkZWZhdWx0Q2FtZXJhV3JhcHBlci5xdWVyeVNlbGVjdG9yKCdbY2FtZXJhXScpO1xuICAgICAgICBpZiAobmV3Q2FtZXJhIGluc3RhbmNlb2YgQUVudGl0eSkge1xuICAgICAgICAgIG5ld0NhbWVyYS5zZXRBdHRyaWJ1dGUoJ2NhbWVyYScsICdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgICBpZiAobmV3Q2FtZXJhICE9PSBkZWZhdWx0Q2FtZXJhRWwpIHsgdGhpcy5yZW1vdmVEZWZhdWx0Q2FtZXJhKCk7IH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW1lcmEgPSBuZXdDYW1lcmE7XG4gICAgICAgIHRoaXMudXBkYXRlQ2FtZXJhcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGFjdGl2ZSBjYW1lcmEgYW5kIGRpc2FibGVzIHRoZSByZXN0XG4gICAgICogQHR5cGUgb2JqZWN0IC0gYWN0aXZlQ2FtZXJhIC0gVGhlIGNhbWVyYSB1c2VkIGJ5IHRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIHVwZGF0ZUNhbWVyYXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVDYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgdmFyIGFjdGl2ZUNhbWVyYUVsID0gYWN0aXZlQ2FtZXJhICYmIGFjdGl2ZUNhbWVyYS5lbDtcbiAgICAgICAgdmFyIGNhbWVyYUVsO1xuICAgICAgICB2YXIgc2NlbmVDYW1lcmFzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbY2FtZXJhXScpO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKCFhY3RpdmVDYW1lcmEpIHtcbiAgICAgICAgICBhY3RpdmVDYW1lcmFFbCA9IHNjZW5lQ2FtZXJhc1tzY2VuZUNhbWVyYXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYWN0aXZlQ2FtZXJhRWwuc2V0QXR0cmlidXRlKCdjYW1lcmEnLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjZW5lQ2FtZXJhcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNhbWVyYUVsID0gc2NlbmVDYW1lcmFzW2ldO1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUNhbWVyYUVsID09PSBjYW1lcmFFbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkgeyBhY3RpdmVDYW1lcmFFbC5wbGF5KCk7IH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYW1lcmFFbC5zZXRBdHRyaWJ1dGUoJ2NhbWVyYScsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgICAgICAgY2FtZXJhRWwucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVEZWZhdWx0Q2FtZXJhOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FtZXJhRWwgPSB0aGlzLmNhbWVyYSAmJiB0aGlzLmNhbWVyYS5lbDtcbiAgICAgICAgaWYgKCFjYW1lcmFFbCkgeyByZXR1cm47IH1cbiAgICAgICAgLy8gUmVtb3ZlcyBkZWZhdWx0IGNhbWVyYSBpZiBhbnlcbiAgICAgICAgdmFyIGRlZmF1bHRDYW1lcmEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbJyArIERFRkFVTFRfQ0FNRVJBX0FUVFIgKyAnXScpO1xuICAgICAgICB2YXIgZGVmYXVsdENhbWVyYUVsID0gZGVmYXVsdENhbWVyYSAmJiBkZWZhdWx0Q2FtZXJhLnF1ZXJ5U2VsZWN0b3IoJ1tjYW1lcmFdJyk7XG4gICAgICAgIC8vIFJlbW92ZSBkZWZhdWx0IGNhbWVyYSBpZiBhbnlcbiAgICAgICAgaWYgKGRlZmF1bHRDYW1lcmFFbCAmJiBkZWZhdWx0Q2FtZXJhRWwgIT09IGNhbWVyYUVsKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChkZWZhdWx0Q2FtZXJhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgc2NlbmUgdGhhdCBsaWdodCBoYXMgYmVlbiBhZGRlZCBhbmQgdG8gcmVtb3ZlIHRoZSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGVsIC0gZWxlbWVudCBob2xkaW5nIHRoZSBsaWdodCBjb21wb25lbnQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJMaWdodDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB2YXIgZGVmYXVsdExpZ2h0cztcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdExpZ2h0c0VuYWJsZWQgJiYgIWVsLmhhc0F0dHJpYnV0ZShERUZBVUxUX0xJR0hUX0FUVFIpKSB7XG4gICAgICAgICAgLy8gVXNlciBhZGRlZCBhIGxpZ2h0LCByZW1vdmUgZGVmYXVsdCBsaWdodHMgdGhyb3VnaCBET00uXG4gICAgICAgICAgZGVmYXVsdExpZ2h0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgREVGQVVMVF9MSUdIVF9BVFRSICsgJ10nKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRMaWdodHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoZGVmYXVsdExpZ2h0c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGVmYXVsdExpZ2h0c0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIG1hdGVyaWFsIGluIGNhc2UgYW4gdXBkYXRlIHRyaWdnZXIgaXMgbmVlZGVkIChlLmcuLCBmb2cpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1hdGVyaWFsXG4gICAgICovXG4gICAgcmVnaXN0ZXJNYXRlcmlhbDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xuICAgICAgICB0aGlzLm1hdGVyaWFsc1ttYXRlcmlhbC51dWlkXSA9IG1hdGVyaWFsO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gYmVoYXZpb3IgLSBHZW5lcmFsbHkgYSBjb21wb25lbnQuIEhhcyByZWdpc3RlcmVkIGl0c2VsZiB0byBiZWhhdmlvcnMuXG4gICAgICovXG4gICAgcmVtb3ZlQmVoYXZpb3I6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYmVoYXZpb3IpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9ycyA9IHRoaXMuYmVoYXZpb3JzO1xuICAgICAgICB2YXIgaW5kZXggPSBiZWhhdmlvcnMuaW5kZXhPZihiZWhhdmlvcik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHsgcmV0dXJuOyB9XG4gICAgICAgIGJlaGF2aW9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVFbnRlclZSOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbnRlclZSRWwpIHtcbiAgICAgICAgICB0aGlzLmVudGVyVlJFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZW50ZXJWUkVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZXNpemVDYW52YXM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjYW1lcmEgaXMgbm90IGluamVjdGVkIHlldC5cbiAgICAgICAgaWYgKCFjYW1lcmEpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRDYW52YXNTaXplKCk7XG4gICAgICAgIC8vIFVwZGF0ZXMgY2FtZXJhXG4gICAgICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIC8vIE5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgdGhlIHNpemUgY2hhbmdlXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBoYW5kbGVzIGZ1bGxzY3JlZW4gZm9yIG5vbi1WUiBtb2JpbGUgd2hlcmUgdGhlIHJlbmRlcmVyJyBWUlxuICAgICAqIGRpc3BsYXkgaXMgbm90IHBvbHlmaWxsZWQuIEFsc28gc2V0cyB3YWtlbG9jayBmb3IgbW9iaWxlIGluIHRoZSBwcm9jZXNzLlxuICAgICAqXG4gICAgICogRGVza3RvcCBqdXN0IHdvcmtzIHNvIHVzZSB0aGUgcmVuZGVyZXIuc2V0RnVsbFNjcmVlbiBpbiB0aGF0IGNhc2UuXG4gICAgICovXG4gICAgc2V0RnVsbHNjcmVlbjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgICAgIGlmICghdGhpcy5pc01vYmlsZSkge1xuICAgICAgICAgIHRoaXMuc3RlcmVvUmVuZGVyZXIuc2V0RnVsbFNjcmVlbih0cnVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53YWtlbG9jaykgeyB0aGlzLndha2Vsb2NrLnJlcXVlc3QoKTsgfVxuXG4gICAgICAgIGlmIChjYW52YXMucmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICBjYW52YXMucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICBjYW52YXMubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW52YXMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgICAgICBjYW52YXMud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHJlbmRlcmVyIHRvIG1vbm8gKG9uZSBleWUpIGFuZCByZXNpemVzIGNhbnZhcy5cbiAgICAgKi9cbiAgICBzZXRNb25vUmVuZGVyZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLm1vbm9SZW5kZXJlcjtcbiAgICAgICAgdGhpcy5yZXNpemVDYW52YXMoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyByZW5kZXJlciB0byBzdGVyZW8gKHR3byBleWVzKSBhbmQgcmVzaXplcyBjYW52YXMuXG4gICAgICovXG4gICAgc2V0U3RlcmVvUmVuZGVyZXI6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLnN0ZXJlb1JlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXR1cENhbnZhczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhc1NlbGVjdG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NhbnZhcycpO1xuICAgICAgICB2YXIgY2FudmFzO1xuXG4gICAgICAgIGlmIChjYW52YXNTZWxlY3Rvcikge1xuICAgICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihjYW52YXNTZWxlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2EtY2FudmFzJyk7XG4gICAgICAgIC8vIFByZXZlbnRzIG92ZXJzY3JvbGwgb24gbW9iaWxlIGRldmljZXMuXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUNhbnZhcy5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWZhdWx0IGNhbWVyYSBpZiB1c2VyIGhhcyBub3QgYWRkZWQgb25lIGR1cmluZyB0aGUgaW5pdGlhbC5cbiAgICAgKiBzY2VuZSB0cmF2ZXJzYWwuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IGNhbWVyYSBoZWlnaHQgaXMgYXQgaHVtYW4gbGV2ZWwgKH4xLjhtKSBhbmQgYmFjayBzdWNoIHRoYXRcbiAgICAgKiBlbnRpdGllcyBhdCB0aGUgb3JpZ2luICgwLCAwLCAwKSBhcmUgd2VsbC1jZW50ZXJlZC5cbiAgICAgKi9cbiAgICBzZXR1cERlZmF1bHRDYW1lcmE6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYW1lcmFXcmFwcGVyRWw7XG4gICAgICAgIHZhciBkZWZhdWx0Q2FtZXJhO1xuICAgICAgICB2YXIgc2NlbmVDYW1lcmFzID0gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdbY2FtZXJhXScpO1xuICAgICAgICBpZiAoc2NlbmVDYW1lcmFzLmxlbmd0aCAhPT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgICAvLyBET00gY2FsbHMgdG8gY3JlYXRlIGNhbWVyYS5cbiAgICAgICAgY2FtZXJhV3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICAgICAgY2FtZXJhV3JhcHBlckVsLnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCB7eDogMCwgeTogMS44LCB6OiA0fSk7XG4gICAgICAgIGNhbWVyYVdyYXBwZXJFbC5zZXRBdHRyaWJ1dGUoREVGQVVMVF9DQU1FUkFfQVRUUiwgJycpO1xuICAgICAgICBkZWZhdWx0Q2FtZXJhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICAgICAgZGVmYXVsdENhbWVyYS5zZXRBdHRyaWJ1dGUoJ2NhbWVyYScsIHsnYWN0aXZlJzogdHJ1ZX0pO1xuICAgICAgICBkZWZhdWx0Q2FtZXJhLnNldEF0dHJpYnV0ZSgnd2FzZC1jb250cm9scycpO1xuICAgICAgICBkZWZhdWx0Q2FtZXJhLnNldEF0dHJpYnV0ZSgnbG9vay1jb250cm9scycpO1xuICAgICAgICBjYW1lcmFXcmFwcGVyRWwuYXBwZW5kQ2hpbGQoZGVmYXVsdENhbWVyYSk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2FtZXJhV3JhcHBlckVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlc2NpYmUgZGVmYXVsdCBsaWdodHMgdG8gdGhlIHNjZW5lLlxuICAgICAqIERvZXMgc28gYnkgaW5qZWN0aW5nIG1hcmt1cCBzdWNoIHRoYXQgdGhpcyBzdGF0ZSBpcyBub3QgaW52aXNpYmxlLlxuICAgICAqIFRoZXNlIGxpZ2h0cyBhcmUgcmVtb3ZlZCBpZiB0aGUgdXNlciBhZGRzIGFueSBsaWdodHMuXG4gICAgICovXG4gICAgc2V0dXBEZWZhdWx0TGlnaHRzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYW1iaWVudExpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICAgICAgYW1iaWVudExpZ2h0LnNldEF0dHJpYnV0ZSgnbGlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvcjogJyNmZmYnLCB0eXBlOiAnYW1iaWVudCd9KTtcbiAgICAgICAgYW1iaWVudExpZ2h0LnNldEF0dHJpYnV0ZShERUZBVUxUX0xJR0hUX0FUVFIsICcnKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChhbWJpZW50TGlnaHQpO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb25hbExpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1lbnRpdHknKTtcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5zZXRBdHRyaWJ1dGUoJ2xpZ2h0JywgeyBjb2xvcjogJyNmZmYnLCBpbnRlbnNpdHk6IDAuMiB9KTtcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgeyB4OiAtMSwgeTogMiwgejogMSB9KTtcbiAgICAgICAgZGlyZWN0aW9uYWxMaWdodC5zZXRBdHRyaWJ1dGUoREVGQVVMVF9MSUdIVF9BVFRSLCAnJyk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZGlyZWN0aW9uYWxMaWdodCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNldHVwRW50ZXJWUjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW50ZXJWUkVsKSB7IHJldHVybjsgfVxuICAgICAgICB0aGlzLmVudGVyVlJFbCA9IGNyZWF0ZUVudGVyVlIodGhpcy5lbnRlclZSLmJpbmQodGhpcykpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZW50ZXJWUkVsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0dXBPcmllbnRhdGlvbk1vZGFsOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kYWwgPSB0aGlzLm9yaWVudGF0aW9uTW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbW9kYWwuY2xhc3NOYW1lID0gT1JJRU5UQVRJT05fTU9EQUxfQ0xBU1M7XG4gICAgICAgIG1vZGFsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTtcblxuICAgICAgICB2YXIgZXhpdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBleGl0LmlubmVySFRNTCA9ICdFeGl0IFZSJztcbiAgICAgICAgZXhpdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZXhpdFZSLmJpbmQodGhpcykpO1xuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChleGl0KTtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIGtleWJvYXJkIHNob3J0Y3V0cyB0bzpcbiAgICAgKiAgIC0gRW50ZXIgVlIgd2hlbiBgZmAgaXMgcHJlc3NlZC5cbiAgICAgKiAgIC0gUmVzZXQgc2Vuc29yIHdoZW4gYHpgIGlzIHByZXNzZWQuXG4gICAgICovXG4gICAgc2V0dXBLZXlib2FyZFNob3J0Y3V0czoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gNzApIHsgIC8vIGYuXG4gICAgICAgICAgICBzZWxmLmVudGVyVlIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDkwKSB7ICAvLyB6LlxuICAgICAgICAgICAgY29udHJvbHMucmVzZXRTZW5zb3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGZvciBWUiBtb2RlIGJlZm9yZSBraWNraW5nIG9mZiByZW5kZXIgbG9vcC5cbiAgICAgKi9cbiAgICBzZXR1cExvYWRlcjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmIChzZWxmLmluc2lkZUlmcmFtZSkge1xuICAgICAgICAgIHNlbGYuYXR0YWNoTWVzc2FnZUxpc3RlbmVycygpO1xuICAgICAgICAgIHNlbGYudnJMb2FkZXJNb2RlKCkudGhlbihmdW5jdGlvbiAoaXNWcikge1xuICAgICAgICAgICAgaWYgKGlzVnIpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRTdGVyZW9SZW5kZXJlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRNb25vUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy50b3AucG9zdE1lc3NhZ2Uoe3R5cGU6ICdyZWFkeSd9LCAnKicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5pbnNpZGVMb2FkZXIpIHtcbiAgICAgICAgICBzZWxmLnNldHVwRW50ZXJWUigpO1xuICAgICAgICAgIHNlbGYuc2V0dXBPcmllbnRhdGlvbk1vZGFsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0dXBSZW5kZXJlcjoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICAvLyBTZXQgYXQgc3RhcnR1cC4gVG8gZW5hYmxlL2Rpc2FibGUgYW50aWFsaWFzXG4gICAgICAgIC8vIGF0IHJ1bnR0aW1lIHdlIHdvdWxkIGhhdmUgdG8gcmVjcmVhdGUgdGhlIHdob2xlIGNvbnRleHRcbiAgICAgICAgdmFyIGFudGlhbGlhcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhbnRpYWxpYXMnKSA9PT0gJ3RydWUnO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyID0gdGhpcy5tb25vUmVuZGVyZXIgPVxuICAgICAgICAgIG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgICAgYW50aWFsaWFzOiBhbnRpYWxpYXMsXG4gICAgICAgICAgICBhbHBoYTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgcmVuZGVyZXIuc29ydE9iamVjdHMgPSBmYWxzZTtcbiAgICAgICAgQVNjZW5lLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuc3RlcmVvUmVuZGVyZXIgPSBuZXcgVEhSRUUuVlJFZmZlY3QocmVuZGVyZXIpO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVE9ETzogbW92ZSBzdGF0cyB0byBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0dXBTdGF0czoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRzRW5hYmxlZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0cycpID09PSAndHJ1ZSc7XG4gICAgICAgIHZhciBzdGF0c0VsID0gdGhpcy5zdGF0c0VsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJzLWJhc2UnKTtcbiAgICAgICAgaWYgKCFzdGF0c0VuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoc3RhdHNFbCkgeyBzdGF0c0VsLmNsYXNzTGlzdC5hZGQoSElEREVOX0NMQVNTKTsgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHNFbCkgeyBzdGF0c0VsLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKTsgfVxuICAgICAgICBpZiAodGhpcy5zdGF0cykgeyByZXR1cm47IH1cbiAgICAgICAgdGhpcy5zdGF0cyA9IG5ldyBSU3RhdHMoe1xuICAgICAgICAgIENTU1BhdGg6ICcuLi8uLi9zdHlsZS8nLFxuICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgZnBzOiB7IGNhcHRpb246ICdmcHMnLCBiZWxvdzogMzAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ3JvdXBzOiBbXG4gICAgICAgICAgICB7IGNhcHRpb246ICdGcmFtZXJhdGUnLCB2YWx1ZXM6IFsgJ2ZwcycsICdyYWYnIF0gfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RhdHNFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ycy1iYXNlJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNob3dVSToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRzRW5hYmxlZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0cycpID09PSAndHJ1ZSc7XG4gICAgICAgIGlmIChzdGF0c0VuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0YXRzRWwuY2xhc3NMaXN0LnJlbW92ZShISURERU5fQ0xBU1MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVudGVyVlJFbCkge1xuICAgICAgICAgIHRoaXMuZW50ZXJWUkVsLmNsYXNzTGlzdC5yZW1vdmUoSElEREVOX0NMQVNTKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGF0dGFjaGVkIHRvIGVsZW1lbnRzIHRvIGhlbHAgc2NlbmUga25vdyB3aGVuIHRvIGtpY2sgb2ZmLlxuICAgICAqIFNjZW5lIHdhaXRzIGZvciBhbGwgZW50aXRpZXMgdG8gbG9hZC5cbiAgICAgKi9cbiAgICBwbGF5OiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJTdGFydGVkKSB7XG4gICAgICAgICAgQUVudGl0eS5wcm90b3R5cGUucGxheS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJTdGFydGVkKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgdGhpcy5zZXR1cExvYWRlcigpO1xuICAgICAgICAgIEFFbnRpdHkucHJvdG90eXBlLnBsYXkuY2FsbChzZWxmKTtcbiAgICAgICAgICBzZWxmLnNldHVwU3RhdHMoKTtcbiAgICAgICAgICBzZWxmLnJlc2l6ZUNhbnZhcygpO1xuICAgICAgICAgIC8vIEtpY2sgb2ZmIHJlbmRlciBsb29wLlxuICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgICAgc2VsZi5yZW5kZXJTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3JlbmRlcnN0YXJ0Jyk7XG4gICAgICAgICAgc2VsZi5jaGVja1VybFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgQUVudGl0eS5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdG9wcyB0cmFja2luZyBtYXRlcmlhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtYXRlcmlhbFxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJNYXRlcmlhbDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5tYXRlcmlhbHNbbWF0ZXJpYWwudXVpZF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdXBkYXRlIHRvIGFsbCByZWdpc3RlcmVkIG1hdGVyaWFscy5cbiAgICAgKi9cbiAgICB1cGRhdGVNYXRlcmlhbHM6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAobWF0ZXJpYWwpIHtcbiAgICAgICAgdmFyIG1hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzO1xuICAgICAgICBPYmplY3Qua2V5cyhtYXRlcmlhbHMpLmZvckVhY2goZnVuY3Rpb24gKHV1aWQpIHtcbiAgICAgICAgICBtYXRlcmlhbHNbdXVpZF0ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFByb21pc2UgdGhhdCByZXNvbHZlcyBhIGJvb2wgd2hldGhlciBsb2FkZXIgaXMgaW4gVlJcbiAgICAgKiAgICAgICAgICBtb2RlLlxuICAgICAqL1xuICAgIHZyTG9hZGVyTW9kZToge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgICB3aW5kb3cudG9wLnBvc3RNZXNzYWdlKHt0eXBlOiAnY2hlY2tWcid9LCAnKicsIFtjaGFubmVsLnBvcnQyXSk7XG4gICAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgcmVzb2x2ZSghIW1lc3NhZ2UuZGF0YS5kYXRhLmlzVnIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyIGxvb3AuXG4gICAgICpcbiAgICAgKiBVcGRhdGVzIHN0YXRzLlxuICAgICAqIFVwZGF0ZXMgYW5pbWF0aW9ucy5cbiAgICAgKiBVcGRhdGVzIGJlaGF2aW9ycy5cbiAgICAgKiBSZW5kZXJzIHdpdGggcmVxdWVzdCBhbmltYXRpb24gZnJhbWUuXG4gICAgICovXG4gICAgcmVuZGVyOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xuXG4gICAgICAgIGlmIChzdGF0cykge1xuICAgICAgICAgIHN0YXRzKCdyQUYnKS50aWNrKCk7XG4gICAgICAgICAgc3RhdHMoJ0ZQUycpLmZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgVFdFRU4udXBkYXRlKHQpO1xuICAgICAgICB0aGlzLmJlaGF2aW9ycy5mb3JFYWNoKGZ1bmN0aW9uIChiZWhhdmlvcikge1xuICAgICAgICAgIGJlaGF2aW9yLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5vYmplY3QzRCwgY2FtZXJhKTtcbiAgICAgICAgaWYgKHN0YXRzKSB7IHN0YXRzKCkudXBkYXRlKCk7IH1cbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZUlEID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgICB0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICAgIH0sXG4gICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIHNjZW5lIHRvIHRoZSBvcmlnaW5hbCBET00gY29udGVudFxuICAgICAqIEB0eXBlIHtib29sfSAtIHBhdXNlZCAtIEl0IHJlbG9hZHMgdGhlIHNjZW5lIHdpdGggYWxsIHRoZVxuICAgICAqIGR5bmFtaWMgYmVoYXZpb3IgcGF1c2VkOiBkeW5hbWljIGNvbXBvbmVudHMgYW5kIGFuaW1hdGlvbnNcbiAgICAgKi9cbiAgICByZWxvYWQ6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGF1c2VkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHBhdXNlZCkgeyB0aGlzLnBhdXNlKCk7IH1cbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSB0aGlzLm9yaWdpbmFsSFRNTDtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIEFOb2RlLnByb3RvdHlwZS5sb2FkLmNhbGwodGhpcywgcGxheSk7XG4gICAgICAgIGZ1bmN0aW9uIHBsYXkgKCkge1xuICAgICAgICAgIGlmIChzZWxmLnBhdXNlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICBBRW50aXR5LnByb3RvdHlwZS5wbGF5LmNhbGwoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSlcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgRW50ZXIgVlIgZmxvdyAoYnV0dG9uIGFuZCBjb21wYXRpYmlsaXR5IG1vZGFsKS5cbiAqXG4gKiBDcmVhdGVzIGEgYnV0dG9uIHRoYXQgd2hlbiBjbGlja2VkIHdpbGwgZW50ZXIgaW50byBzdGVyZW8tcmVuZGVyaW5nIG1vZGUgZm9yIFZSLlxuICpcbiAqIEZvciBjb21wYXRpYmlsaXR5OlxuICogICAtIE1vYmlsZSBhbHdheXMgaGFzIGNvbXBhdGliaWxpdHkgdmlhIHBvbHlmaWxsLlxuICogICAtIElmIGRlc2t0b3AgYnJvd3NlciBkb2VzIG5vdCBoYXZlIFdlYlZSIGV4Y2x1ZGluZyBwb2x5ZmlsbCwgZGlzYWJsZSBidXR0b24sIHNob3cgbW9kYWwuXG4gKiAgIC0gSWYgZGVza3RvcCBicm93c2VyIGhhcyBXZWJWUiBleGNsdWRpbmcgcG9seWZpbGwgYnV0IG5vdCBoZWFkc2V0IGNvbm5lY3RlZCxcbiAqICAgICBkb24ndCBkaXNhYmxlIGJ1dHRvbiwgYnV0IHNob3cgbW9kYWwuXG4gKiAgIC0gSWYgZGVza3RvcCBicm93c2VyIGhhcyBXZWJWUiBleGNsdWRpbmcgcG9seWZpbGwgYW5kIGhhcyBoZWFkc2V0IGNvbm5lY3RlZCwgdGhlblxuICogICAgIHRoZW4gbm8gbW9kYWwuXG4gKlxuICogU3RydWN0dXJlOiA8ZGl2Pjxtb2RhbC8+PGJ1dHRvbj48L2Rpdj5cbiAqXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gV3JhcHBlciA8ZGl2Pi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW50ZXJWUiAoZW50ZXJWUkhhbmRsZXIpIHtcbiAgdmFyIGNvbXBhdE1vZGFsO1xuICB2YXIgY29tcGF0TW9kYWxMaW5rO1xuICB2YXIgY29tcGF0TW9kYWxUZXh0O1xuICAvLyB3aW5kb3cuaGFzTmF0aXZlVlJTdXBwb3J0IGlzIHNldCBpbiBzcmMvYWZyYW1lLWNvcmUuanMuXG4gIHZhciBoYXNXZWJWUiA9IGlzTW9iaWxlIHx8IHdpbmRvdy5oYXNOb25Qb2x5ZmlsbFdlYlZSU3VwcG9ydDtcbiAgdmFyIG9yaWVudGF0aW9uO1xuICB2YXIgdnJCdXR0b247XG4gIHZhciB3cmFwcGVyO1xuXG4gIC8vIENyZWF0ZSBlbGVtZW50cy5cbiAgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoRU5URVJfVlJfQ0xBU1MpO1xuICBjb21wYXRNb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb21wYXRNb2RhbC5jbGFzc05hbWUgPSBFTlRFUl9WUl9NT0RBTF9DTEFTUztcbiAgY29tcGF0TW9kYWxUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICBjb21wYXRNb2RhbExpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGNvbXBhdE1vZGFsTGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnaHR0cDovL21venZyLmNvbS8jc3RhcnQnKTtcbiAgY29tcGF0TW9kYWxMaW5rLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgJ19ibGFuaycpO1xuICBjb21wYXRNb2RhbExpbmsuaW5uZXJIVE1MID0gJ0xlYXJuIG1vcmUuJztcbiAgdnJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgdnJCdXR0b24uY2xhc3NOYW1lID0gRU5URVJfVlJfQlROX0NMQVNTO1xuXG4gIC8vIEluc2VydCBlbGVtZW50cy5cbiAgaWYgKGNvbXBhdE1vZGFsKSB7XG4gICAgY29tcGF0TW9kYWwuYXBwZW5kQ2hpbGQoY29tcGF0TW9kYWxUZXh0KTtcbiAgICBjb21wYXRNb2RhbC5hcHBlbmRDaGlsZChjb21wYXRNb2RhbExpbmspO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY29tcGF0TW9kYWwpO1xuICB9XG4gIHdyYXBwZXIuYXBwZW5kQ2hpbGQodnJCdXR0b24pO1xuXG4gIGlmICghY2hlY2tIZWFkc2V0Q29ubmVjdGVkKCkgJiYgIWlzTW9iaWxlKSB7XG4gICAgY29tcGF0TW9kYWxUZXh0LmlubmVySFRNTCA9ICdZb3VyIGJyb3dzZXIgc3VwcG9ydHMgV2ViVlIuIFRvIGVudGVyIFZSLCBjb25uZWN0IGEgaGVhZHNldCwgb3IgdXNlIGEgbW9iaWxlIHBob25lLic7XG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoRU5URVJfVlJfTk9fSEVBRFNFVCwgJycpO1xuICB9XG5cbiAgLy8gSGFuZGxlIGVudGVyIFZSIGZsb3dzLlxuICBpZiAoIWhhc1dlYlZSKSB7XG4gICAgY29tcGF0TW9kYWxUZXh0LmlubmVySFRNTCA9ICdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJWUi4gVG8gZW50ZXIgVlIsIHVzZSBhIFZSLWNvbXBhdGlibGUgYnJvd3NlciBvciBhIG1vYmlsZSBwaG9uZS4nO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKEVOVEVSX1ZSX05PX1dFQlZSLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgdnJCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlbnRlclZSSGFuZGxlcik7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIENoZWNrIGZvciBoZWFkc2V0IGNvbm5lY3Rpb24gYnkgbG9va2luZyBhdCBvcmllbnRhdGlvbiB7MCAwIDB9LlxuICAgKi9cbiAgZnVuY3Rpb24gY2hlY2tIZWFkc2V0Q29ubmVjdGVkICgpIHtcbiAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICBvcmllbnRhdGlvbiA9IGR1bW15RG9sbHkucXVhdGVybmlvbjtcbiAgICBpZiAob3JpZW50YXRpb24uX3ggIT09IDAgfHwgb3JpZW50YXRpb24uX3kgIT09IDAgfHwgb3JpZW50YXRpb24uX3ogIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluamVjdHMgdGhlIG5lY2Vzc2FyeSBtZXRhdGFncyBpbiB0aGUgZG9jdW1lbnQgZm9yIG1vYmlsZSBzdXBwb3J0IHRvOlxuICogMS4gUHJldmVudCB0aGUgdXNlciB0byB6b29tIGluIHRoZSBkb2N1bWVudFxuICogMi4gRW5zdXJlIHRoYXQgd2luZG93LmlubmVyV2lkdGggYW5kIHdpbmRvdy5pbm5lckhlaWdodCBoYXZlIHRoZSBjb3JyZWN0XG4gKiAgICB2YWx1ZXMgYW5kIHRoZSBjYW52YXMgaXMgcHJvcGVybHkgc2NhbGVkXG4gKiAzLiBUbyBhbGxvdyBmdWxsc2NyZWVuIG1vZGUgd2hlbiBwaW5uaW5nIGEgd2ViIGFwcCBvbiB0aGUgaG9tZSBzY3JlZW4gb25cbiAqICAgIGlPUy5cbiAqIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL3dlYl9kZXNpZ24vY29tbWVudHMvM2xhMDRwL1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGluamVjdE1ldGFUYWdzICgpIHtcbiAgdmFyIGhlYWRFbDtcbiAgdmFyIG1ldGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ2aWV3cG9ydFwiXScpO1xuICBpZiAobWV0YSkgeyByZXR1cm47IH0gIC8vIEFscmVhZHkgZXhpc3RzLlxuXG4gIGhlYWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIG1ldGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gIG1ldGEubmFtZSA9ICd2aWV3cG9ydCc7XG4gIG1ldGEuY29udGVudCA9XG4gICAgJ3dpZHRoPWRldmljZS13aWR0aCxpbml0aWFsLXNjYWxlPTEsc2hyaW5rLXRvLWZpdD1ubyx1c2VyLXNjYWxhYmxlPW5vJztcbiAgaGVhZEVsLmFwcGVuZENoaWxkKG1ldGEpO1xuXG4gIC8vIGlPUy1zcGVjaWZpYyBtZXRhIHRhZ3MgZm9yIGZ1bGxzY3JlZW4gd2hlbiBwaW5uaW5nIHRvIGhvbWVzY3JlZW4uXG4gIG1ldGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gIG1ldGEubmFtZSA9ICdhcHBsZS1tb2JpbGUtd2ViLWFwcC1jYXBhYmxlJztcbiAgbWV0YS5jb250ZW50ID0gJ3llcyc7XG4gIGhlYWRFbC5hcHBlbmRDaGlsZChtZXRhKTtcblxuICBtZXRhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICBtZXRhLm5hbWUgPSAnYXBwbGUtbW9iaWxlLXdlYi1hcHAtc3RhdHVzLWJhci1zdHlsZSc7XG4gIG1ldGEuY29udGVudCA9ICdibGFjayc7XG4gIGhlYWRFbC5hcHBlbmRDaGlsZChtZXRhKTtcbn1cbiIsIi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbHMvZGVidWcnKTtcbnZhciBwcm9wZXJ0eVR5cGVzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eVR5cGVzJykucHJvcGVydHlUeXBlcztcbnZhciBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xudmFyIHN0eWxlUGFyc2VyID0gcmVxdWlyZSgnc3R5bGUtYXR0cicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvJyk7XG5cbnZhciBwYXJzZVByb3BlcnRpZXMgPSBzY2hlbWEucGFyc2VQcm9wZXJ0aWVzO1xudmFyIHBhcnNlUHJvcGVydHkgPSBzY2hlbWEucGFyc2VQcm9wZXJ0eTtcbnZhciBpc1NpbmdsZVByb3AgPSBzY2hlbWEuaXNTaW5nbGVQcm9wZXJ0eTtcbnZhciBwcm9jZXNzU2NoZW1hID0gc2NoZW1hLnByb2Nlc3M7XG52YXIgZXJyb3IgPSBkZWJ1ZygnY29yZTpyZWdpc3Rlci1jb21wb25lbnQ6ZXJyb3InKTtcblxudmFyIGNvbXBvbmVudHMgPSBtb2R1bGUuZXhwb3J0cy5jb21wb25lbnRzID0ge307ICAvLyBLZWVwIHRyYWNrIG9mIHJlZ2lzdGVyZWQgY29tcG9uZW50cy5cblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3MgZGVmaW5pdGlvbi5cbiAqXG4gKiBDb21wb25lbnRzIGNvbmZpZ3VyZSBhcHBlYXJhbmNlLCBtb2RpZnkgYmVoYXZpb3IsIG9yIGFkZCBmdW5jdGlvbmFsaXR5IHRvXG4gKiBlbnRpdGllcy4gVGhlIGJlaGF2aW9yIGFuZCBhcHBlYXJhbmNlIG9mIGFuIGVudGl0eSBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lXG4gKiBieSBhZGRpbmcsIHJlbW92aW5nLCBvciB1cGRhdGluZyBjb21wb25lbnRzLiBFbnRpdGllcyBkbyBub3Qgc2hhcmUgaW5zdGFuY2VzXG4gKiBvZiBjb21wb25lbnRzLlxuICpcbiAqIEBuYW1lc3BhY2UgQ29tcG9uZW50XG4gKiBAcHJvcGVydHkge29iamVjdH0gZGF0YSAtIFN0b3JlcyBjb21wb25lbnQgZGF0YSwgcG9wdWxhdGVkIGJ5IHBhcnNpbmcgdGhlXG4gKiAgICAgICAgICAgYXR0cmlidXRlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBwbHVzIGFwcGx5aW5nIGRlZmF1bHRzIGFuZCBtaXhpbnMuXG4gKiBAcHJvcGVydHkge29iamVjdH0gZWwgLSBSZWZlcmVuY2UgdG8gdGhlIGVudGl0eSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdGhlIGNvbXBvbmVudCBpcyBjb25uZWN0ZWRcbiAqICAgICAgICAgICB0by5cbiAqIEBtZW1iZXIge0VsZW1lbnR9IGVsXG4gKiBAbWVtYmVyIHtvYmplY3R9IGRhdGFcbiAqIEBtZW1iZXIge2Z1bmN0aW9ufSBnZXREYXRhXG4gKiBAbWVtYmVyIHtmdW5jdGlvbn0gaW5pdFxuICogQG1lbWJlciB7ZnVuY3Rpb259IHVwZGF0ZVxuICogQG1lbWJlciB7ZnVuY3Rpb259IHJlbW92ZVxuICogQG1lbWJlciB7ZnVuY3Rpb259IHBhcnNlXG4gKiBAbWVtYmVyIHtmdW5jdGlvbn0gc3RyaW5naWZ5XG4gKi9cbnZhciBDb21wb25lbnQgPSBtb2R1bGUuZXhwb3J0cy5Db21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHtcbiAgdmFyIHJhd0RhdGEgPSBIVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLmNhbGwoZWwsIHRoaXMubmFtZSk7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5kYXRhID0ge307XG4gIHRoaXMuYnVpbGREYXRhKHRoaXMucGFyc2UocmF3RGF0YSkpO1xuICB0aGlzLmluaXQoKTtcbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbkNvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBDb250YWlucyB0aGUgdHlwZSBzY2hlbWEgYW5kIGRlZmF1bHRzIGZvciB0aGUgZGF0YSB2YWx1ZXMuXG4gICAqIERhdGEgaXMgY29lcmNlZCBpbnRvIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzIG9mIHRoZSBkZWZhdWx0cy5cbiAgICovXG4gIHNjaGVtYToge30sXG5cbiAgLyoqXG4gICAqIEluaXQgaGFuZGxlci4gU2ltaWxhciB0byBhdHRhY2hlZENhbGxiYWNrLlxuICAgKiBDYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbiBhbmQgaXMgb25seSBydW4gb25jZS5cbiAgICogQ29tcG9uZW50cyBjYW4gdXNlIHRoaXMgdG8gc2V0IGluaXRpYWwgc3RhdGUuXG4gICAqL1xuICBpbml0OiBmdW5jdGlvbiAoKSB7IC8qIG5vLW9wICovIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBzdGFydCBhbnkgZHluYW1pYyBiZWhhdmlvclxuICAgKiBsaWtlIGFuaW1hdGlvbnMsIEFJLCBwaHlzaWNzLlxuICAgKi9cbiAgcGxheTogZnVuY3Rpb24gKCkgeyAvKiBuby1vcCAqLyB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gc3RvcCBhbnkgZHluYW1pYyBiZWhhdmlvclxuICAgKiBsaWtlIGFuaW1hdGlvbnMsIEFJLCBwaHlzaWNzLlxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHsgLyogbm8tb3AgKi8gfSxcblxuICAvKipcbiAgICogVXBkYXRlIGhhbmRsZXIuIFNpbWlsYXIgdG8gYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgY29tcG9uZW50J3MgZGF0YSBjaGFuZ2VzLlxuICAgKiBBbHNvIGNhbGxlZCBvbiBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24gd2hlbiB0aGUgY29tcG9uZW50IHJlY2VpdmVzIGluaXRpYWwgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZpb3VzRGF0YSAtIFByZXZpb3VzIGF0dHJpYnV0ZXMgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24gKHByZXZpb3VzRGF0YSkgeyAvKiBuby1vcCAqLyB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaGFuZGxlci4gU2ltaWxhciB0byBkZXRhY2hlZENhbGxiYWNrLlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgZW50aXR5IChpLmUuLCByZW1vdmVBdHRyaWJ1dGUpLlxuICAgKiBDb21wb25lbnRzIGNhbiB1c2UgdGhpcyB0byByZXNldCBiZWhhdmlvciBvbiB0aGUgZW50aXR5LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7IC8qIG5vLW9wICovIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBlYWNoIHByb3BlcnR5IGJhc2VkIG9uIHByb3BlcnR5IHR5cGUuXG4gICAqIElmIGNvbXBvbmVudCBpcyBzaW5nbGUtcHJvcGVydHksIHRoZW4gcGFyc2VzIHRoZSBzaW5nbGUgcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIEhUTUwgYXR0cmlidXRlIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDb21wb25lbnQgZGF0YS5cbiAgICovXG4gIHBhcnNlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgdHlwZU5hbWU7XG4gICAgdmFyIHR5cGU7XG5cbiAgICBpZiAoaXNTaW5nbGVQcm9wKHRoaXMuc2NoZW1hKSkge1xuICAgICAgdHlwZU5hbWUgPSB0aGlzLnNjaGVtYS50eXBlO1xuICAgICAgdHlwZSA9IHByb3BlcnR5VHlwZXNbdHlwZU5hbWVdO1xuICAgICAgaWYgKHR5cGUpIHsgcmV0dXJuIHR5cGUucGFyc2UuY2FsbCh0aGlzLCB2YWx1ZSk7IH1cbiAgICAgIHJldHVybiBlcnJvcih0eXBlTmFtZSArICcgaXMgbm90IGEgdmFsaWQgdHlwZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0UGFyc2UodmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdHJpbmdpZmllcyBlYWNoIHByb3BlcnR5IGJhc2VkIG9uIHByb3BlcnR5IHR5cGUuXG4gICAqIElmIGNvbXBvbmVudCBpcyBzaW5nbGUtcHJvcGVydHksIHRoZW4gc3RyaW5naWZpZXMgdGhlIHNpbmdsZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZU5hbWU7XG4gICAgdmFyIHR5cGU7XG5cbiAgICBpZiAoaXNTaW5nbGVQcm9wKHRoaXMuc2NoZW1hKSkge1xuICAgICAgdHlwZU5hbWUgPSB0aGlzLnNjaGVtYS50eXBlO1xuICAgICAgdHlwZSA9IHByb3BlcnR5VHlwZXNbdHlwZU5hbWVdO1xuICAgICAgaWYgKHR5cGUpIHsgcmV0dXJuIHR5cGUuc3RyaW5naWZ5LmNhbGwodGhpcywgZGF0YSk7IH1cbiAgICAgIHJldHVybiBlcnJvcih0eXBlTmFtZSArICcgaXMgbm90IGEgdmFsaWQgdHlwZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqZWN0U3RyaW5naWZ5KGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiBkYXRhIHN1Y2ggdGhhdCB3ZSBkb24ndCBleHBvc2UgdGhlIHByaXZhdGUgdGhpcy5kYXRhLlxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBkYXRhXG4gICAqL1xuICBnZXREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZGF0YTsgfVxuICAgIHJldHVybiB1dGlscy5leHRlbmQoe30sIGRhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBuZXcgdmFsdWUgaXMgY29taW5nIGZyb20gdGhlIGVudGl0eSAoZS5nLiwgYXR0cmlidXRlQ2hhbmdlZENiKVxuICAgKiBvciBmcm9tIGl0cyBtaXhpbnMuIERvZXMgc29tZSBwYXJzaW5nIGFuZCBhcHBseWluZyBiZWZvcmUgdXBkYXRpbmcgdGhlXG4gICAqIGNvbXBvbmVudC5cbiAgICogRG9lcyBub3QgdXBkYXRlIGlmIGRhdGEgaGFzIG5vdCBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBIVE1MIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICovXG4gIHVwZGF0ZVByb3BlcnRpZXM6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBpc1NpbmdsZVByb3BTY2hlbWEgPSBpc1NpbmdsZVByb3AodGhpcy5zY2hlbWEpO1xuICAgIHZhciBwcmV2aW91c0RhdGEgPSBleHRlbmRQcm9wZXJ0aWVzKHt9LCB0aGlzLmRhdGEsIGlzU2luZ2xlUHJvcFNjaGVtYSk7XG4gICAgdGhpcy5idWlsZERhdGEodGhpcy5wYXJzZSh2YWx1ZSkpO1xuXG4gICAgLy8gRG9uJ3QgdXBkYXRlIGlmIHByb3BlcnRpZXMgaGF2ZW4ndCBjaGFuZ2VkXG4gICAgaWYgKCFpc1NpbmdsZVByb3BTY2hlbWEgJiYgdXRpbHMuZGVlcEVxdWFsKHByZXZpb3VzRGF0YSwgdGhpcy5kYXRhKSkgeyByZXR1cm47IH1cblxuICAgIHRoaXMudXBkYXRlKHByZXZpb3VzRGF0YSk7XG5cbiAgICB0aGlzLmVsLmVtaXQoJ2NvbXBvbmVudGNoYW5nZWQnLCB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBuZXdEYXRhOiB0aGlzLmdldERhdGEoKSxcbiAgICAgIG9sZERhdGE6IHByZXZpb3VzRGF0YVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCdWlsZHMgY29tcG9uZW50IGRhdGEgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZW50aXR5LCB1bHRpbWF0ZWx5XG4gICAqIHVwZGF0aW5nIHRoaXMuZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGNvbXBvbmVudCB3YXMgZGV0YWNoZWQgY29tcGxldGVseSwgc2V0IGRhdGEgdG8gbnVsbC5cbiAgICpcbiAgICogUHJlY2VkZW5jZTpcbiAgICogMS4gRGVmYXVsdHMgZGF0YVxuICAgKiAyLiBNaXhpbiBkYXRhLlxuICAgKiAzLiBBdHRyaWJ1dGUgZGF0YS5cbiAgICpcbiAgICogRmluYWxseSBjb2VyY2UgdGhlIGRhdGEgdG8gdGhlIHR5cGVzIG9mIHRoZSBkZWZhdWx0cy5cbiAgICovXG4gIGJ1aWxkRGF0YTogZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSB7fTtcbiAgICB2YXIgc2NoZW1hID0gc2VsZi5zY2hlbWE7XG4gICAgdmFyIGlzU2luZ2xlUHJvcFNjaGVtYSA9IGlzU2luZ2xlUHJvcChzY2hlbWEpO1xuICAgIHZhciBlbCA9IHNlbGYuZWw7XG4gICAgdmFyIG1peGluRWxzID0gZWwubWl4aW5FbHM7XG4gICAgdmFyIG5hbWUgPSBzZWxmLm5hbWU7XG5cbiAgICAvLyAxLiBEZWZhdWx0IHZhbHVlcyAobG93ZXN0IHByZWNlbmRlbmNlKS5cbiAgICBpZiAoaXNTaW5nbGVQcm9wU2NoZW1hKSB7XG4gICAgICBkYXRhID0gc2NoZW1hLmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKHNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiBhcHBseURlZmF1bHQgKGtleSkge1xuICAgICAgICBkYXRhW2tleV0gPSBzY2hlbWFba2V5XS5kZWZhdWx0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gMi4gTWl4aW4gdmFsdWVzLlxuICAgIG1peGluRWxzLmZvckVhY2goYXBwbHlNaXhpbik7XG4gICAgZnVuY3Rpb24gYXBwbHlNaXhpbiAobWl4aW5FbCkge1xuICAgICAgdmFyIG1peGluRGF0YSA9IG1peGluRWwuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgZXh0ZW5kUHJvcGVydGllcyhkYXRhLCBtaXhpbkRhdGEsIGlzU2luZ2xlUHJvcFNjaGVtYSk7XG4gICAgfVxuXG4gICAgLy8gMy4gQXR0cmlidXRlIHZhbHVlcyAoaGlnaGVzdCBwcmVjZW5kZW5jZSkuXG4gICAgZGF0YSA9IGV4dGVuZFByb3BlcnRpZXMoZGF0YSwgbmV3RGF0YSwgaXNTaW5nbGVQcm9wU2NoZW1hKTtcblxuICAgIC8vIFBhcnNlIGFuZCBjb2VyY2UgdXNpbmcgdGhlIHNjaGVtYS5cbiAgICBpZiAoaXNTaW5nbGVQcm9wU2NoZW1hKSB7XG4gICAgICB0aGlzLmRhdGEgPSBwYXJzZVByb3BlcnR5KGRhdGEsIHNjaGVtYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGF0YSA9IHBhcnNlUHJvcGVydGllcyhkYXRhLCBzY2hlbWEpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjb21wb25lbnQgdG8gQS1GcmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIENvbXBvbmVudCBuYW1lLlxuICogQHBhcmFtIHtvYmplY3R9IGRlZmluaXRpb24gLSBDb21wb25lbnQgcHJvcGVydHkgYW5kIG1ldGhvZHMuXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBDb21wb25lbnQuXG4gKi9cbm1vZHVsZS5leHBvcnRzLnJlZ2lzdGVyQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgdmFyIE5ld0NvbXBvbmVudDtcbiAgdmFyIHByb3RvID0ge307XG5cbiAgLy8gRm9ybWF0IGRlZmluaXRpb24gb2JqZWN0IHRvIHByb3RvdHlwZSBvYmplY3QuXG4gIE9iamVjdC5rZXlzKGRlZmluaXRpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHByb3RvW2tleV0gPSB7XG4gICAgICB2YWx1ZTogZGVmaW5pdGlvbltrZXldLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICB9KTtcblxuICBpZiAoY29tcG9uZW50c1tuYW1lXSkge1xuICAgIGVycm9yKCdUaGUgY29tcG9uZW50IFwiJyArIG5hbWUgKyAnXCIgaGFzIGJlZW4gYWxyZWFkeSByZWdpc3RlcmVkJyk7XG4gIH1cbiAgTmV3Q29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgQ29tcG9uZW50LmNhbGwodGhpcywgZWwpO1xuICB9O1xuICBOZXdDb21wb25lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlLCBwcm90byk7XG4gIE5ld0NvbXBvbmVudC5wcm90b3R5cGUubmFtZSA9IG5hbWU7XG4gIE5ld0NvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXdDb21wb25lbnQ7XG4gIGNvbXBvbmVudHNbbmFtZV0gPSB7XG4gICAgQ29tcG9uZW50OiBOZXdDb21wb25lbnQsXG4gICAgZGVwZW5kZW5jaWVzOiBOZXdDb21wb25lbnQucHJvdG90eXBlLmRlcGVuZGVuY2llcyxcbiAgICBwYXJzZTogTmV3Q29tcG9uZW50LnByb3RvdHlwZS5wYXJzZS5iaW5kKE5ld0NvbXBvbmVudC5wcm90b3R5cGUpLFxuICAgIHNjaGVtYTogcHJvY2Vzc1NjaGVtYShOZXdDb21wb25lbnQucHJvdG90eXBlLnNjaGVtYSksXG4gICAgc3RyaW5naWZ5OiBOZXdDb21wb25lbnQucHJvdG90eXBlLnN0cmluZ2lmeS5iaW5kKE5ld0NvbXBvbmVudC5wcm90b3R5cGUpLFxuICAgIHR5cGU6IE5ld0NvbXBvbmVudC5wcm90b3R5cGUudHlwZVxuICB9O1xuICByZXR1cm4gTmV3Q29tcG9uZW50O1xufTtcblxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgc3R5bGUtbGlrZSBzdHJpbmcgaW50byBhbiBvYmplY3Qgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBIVE1MIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IFByb3BlcnR5IGRhdGEua1xuICovXG5mdW5jdGlvbiBvYmplY3RQYXJzZSAodmFsdWUpIHtcbiAgdmFyIHBhcnNlZERhdGE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7IHJldHVybiB2YWx1ZTsgfVxuICBwYXJzZWREYXRhID0gc3R5bGVQYXJzZXIucGFyc2UodmFsdWUpO1xuICByZXR1cm4gdHJhbnNmb3JtS2V5c1RvQ2FtZWxDYXNlKHBhcnNlZERhdGEpO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBvYmplY3Qgb2YgcHJvcGVydGllcyBpbnRvIGEgc3R5bGUtbGlrZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBQcm9wZXJ0eSBkYXRhLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gb2JqZWN0U3RyaW5naWZ5IChkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGRhdGE7IH1cbiAgcmV0dXJuIHN0eWxlUGFyc2VyLnN0cmluZ2lmeShkYXRhKTtcbn1cblxuLyoqXG4qIE9iamVjdCBleHRlbmRpbmcgd2l0aCBjaGVja2luZyBmb3Igc2luZ2xlLXByb3BlcnR5IHNjaGVtYS5cbipcbiogQHBhcmFtIGRlc3QgLSBEZXN0aW5hdGlvbiBvYmplY3Qgb3IgdmFsdWUuXG4qIEBwYXJhbSBzb3VyY2UgLSBTb3VyY2Ugb2JqZWN0IG9yIHZhbHVlXG4qIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW5nbGVQcm9wU2NoZW1hIC0gV2hldGhlciBvciBub3Qgc2NoZW1hIGlzIG9ubHkgYSBzaW5nbGUgcHJvcGVydHkuXG4qIEByZXR1cm5zIE92ZXJyaWRkZW4gb2JqZWN0IG9yIHZhbHVlLlxuKi9cbmZ1bmN0aW9uIGV4dGVuZFByb3BlcnRpZXMgKGRlc3QsIHNvdXJjZSwgaXNTaW5nbGVQcm9wU2NoZW1hKSB7XG4gIGlmIChpc1NpbmdsZVByb3BTY2hlbWEpIHtcbiAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGRlc3Q7IH1cbiAgICByZXR1cm4gc291cmNlO1xuICB9XG4gIHJldHVybiB1dGlscy5leHRlbmQoZGVzdCwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgZnJvbSBoeXBoZW4gdG8gY2FtZWxDYXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBTdHJpbmcgdG8gY2FtZWxDYXNlLlxuICogQHJldHVybiB7c3RyaW5nfSBDYW1lbENhc2VkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9DYW1lbENhc2UgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIGNhbWVsQ2FzZSk7XG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZSAoZykgeyByZXR1cm4gZ1sxXS50b1VwcGVyQ2FzZSgpOyB9XG59XG5cbi8qKlxuICogQ29udmVydHMgb2JqZWN0J3Mga2V5cyBmcm9tIGh5cGhlbnMgdG8gY2FtZWxDYXNlIChlLmcuLCBgbWF4LXZhbHVlYCB0b1xuICogYG1heFZhbHVlYCkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAtIFRoZSBvYmplY3QgdG8gY2FtZWxDYXNlIGtleXMuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBvYmplY3Qgd2l0aCBrZXlzIGNhbWVsQ2FzZWQuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleXNUb0NhbWVsQ2FzZSAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgdmFyIGNhbWVsQ2FzZU9iaiA9IHt9O1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjYW1lbENhc2VLZXkgPSB0b0NhbWVsQ2FzZShrZXkpO1xuICAgIGNhbWVsQ2FzZU9ialtjYW1lbENhc2VLZXldID0gb2JqW2tleV07XG4gIH0pO1xuICByZXR1cm4gY2FtZWxDYXNlT2JqO1xufVxuIiwidmFyIGNvb3JkaW5hdGVzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29vcmRpbmF0ZXMnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG5cbnZhciBlcnJvciA9IGRlYnVnKCdjb3JlOnByb3BlcnR5VHlwZXM6d2FybicpO1xuXG52YXIgcHJvcGVydHlUeXBlcyA9IG1vZHVsZS5leHBvcnRzLnByb3BlcnR5VHlwZXMgPSB7fTtcblxuLy8gQnVpbHQtaW4gcHJvcGVydHkgdHlwZXMuXG5yZWdpc3RlclByb3BlcnR5VHlwZSgnYm9vbGVhbicsIGZhbHNlLCBib29sUGFyc2UpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ2ludCcsIDAsIGludFBhcnNlKTtcbnJlZ2lzdGVyUHJvcGVydHlUeXBlKCdudW1iZXInLCAwLCBudW1iZXJQYXJzZSk7XG5yZWdpc3RlclByb3BlcnR5VHlwZSgnc2VsZWN0b3InLCAnJywgc2VsZWN0b3JQYXJzZSwgc2VsZWN0b3JTdHJpbmdpZnkpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ3N0cmluZycsICcnLCBkZWZhdWx0UGFyc2UsIGRlZmF1bHRTdHJpbmdpZnkpO1xucmVnaXN0ZXJQcm9wZXJ0eVR5cGUoJ3ZlYzMnLCB7IHg6IDAsIHk6IDAsIHo6IDAgfSwgY29vcmRpbmF0ZXMucGFyc2UsIGNvb3JkaW5hdGVzLnN0cmluZ2lmeSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBwYXJzZXIgZm9yIHJlLXVzZSBzdWNoIHRoYXQgd2hlbiBzb21lb25lIHVzZXMgYHR5cGVgIGluIHRoZSBzY2hlbWEsXG4gKiBgc2NoZW1hLnByb2Nlc3NgIHdpbGwgc2V0IHRoZSBwcm9wZXJ0eSBgcGFyc2VgIGFuZCBgc3RyaW5naWZ5YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFR5cGUgbmFtZS5cbiAqIEBwYXJhbSBbZGVmYXVsdFZhbHVlPW51bGxdIC1cbiAqICAgRGVmYXVsdCB2YWx1ZSB0byB1c2UgaWYgY29tcG9uZW50IGRvZXMgbm90IGRlZmluZSBkZWZhdWx0IHZhbHVlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3BhcnNlPWRlZmF1bHRQYXJzZV0gLSBQYXJzZSBzdHJpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc3RyaW5naWZ5PWRlZmF1bHRTdHJpbmdpZnldIC0gU3RyaW5naWZ5IHRvIERPTSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJQcm9wZXJ0eVR5cGUgKHR5cGUsIGRlZmF1bHRWYWx1ZSwgcGFyc2UsIHN0cmluZ2lmeSkge1xuICBpZiAoJ3R5cGUnIGluIHByb3BlcnR5VHlwZXMpIHtcbiAgICBlcnJvcignUHJvcGVydHkgdHlwZSBcIicgKyB0eXBlICsgJ1wiIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9wZXJ0eVR5cGVzW3R5cGVdID0ge1xuICAgIGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZSxcbiAgICBwYXJzZTogcGFyc2UgfHwgZGVmYXVsdFBhcnNlLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5IHx8IGRlZmF1bHRTdHJpbmdpZnlcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzLnJlZ2lzdGVyUHJvcGVydHlUeXBlID0gcmVnaXN0ZXJQcm9wZXJ0eVR5cGU7XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJzZSAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5naWZ5ICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gYm9vbFBhcnNlICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09ICdmYWxzZScgJiYgdmFsdWUgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpbnRQYXJzZSAodmFsdWUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlclBhcnNlICh2YWx1ZSkge1xuICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSwgMTApO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvclBhcnNlICh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7IHJldHVybiBudWxsOyB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JTdHJpbmdpZnkgKGVsKSB7XG4gIC8vIEN1cnJlbnRseSBubyB3YXkgdG8gaW5mZXIgdGhlIHNlbGVjdG9yIHVzZWQgZm9yIHRoaXMgY29tcG9uZW50LlxuICBpZiAoZWwpIHsgcmV0dXJuICcjJyArIGVsLmdldEF0dHJpYnV0ZSgnaWQnKTsgfVxuICByZXR1cm4gJyc7XG59XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpO1xudmFyIHByb3BlcnR5VHlwZXMgPSByZXF1aXJlKCcuL3Byb3BlcnR5VHlwZXMnKS5wcm9wZXJ0eVR5cGVzO1xuXG52YXIgd2FybiA9IGRlYnVnKCdjb3JlOnNjaGVtYTp3YXJuJyk7XG5cbi8qKlxuICogQSBzY2hlbWEgaXMgY2xhc3NpZmllZCBhcyBhIHNjaGVtYSBmb3IgYSBzaW5nbGUgcHJvcGVydHkgaWY6XG4gKiAtIGB0eXBlYCBpcyBkZWZpbmVkIG9uIHRoZSBzY2hlbWEgYXMgYSBzdHJpbmcuXG4gKiAtIE9SIGBkZWZhdWx0YCBpcyBkZWZpbmVkIG9uIHRoZSBzY2hlbWEsIGFzIGEgcmVzZXJ2ZWQga2V5d29yZC5cbiAqIC0gT1Igc2NoZW1hIGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBpc1NpbmdsZVByb3BlcnR5IChzY2hlbWEpIHtcbiAgaWYgKCd0eXBlJyBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNjaGVtYS50eXBlID09PSAnc3RyaW5nJztcbiAgfVxuICByZXR1cm4gJ2RlZmF1bHQnIGluIHNjaGVtYSB8fCBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMDtcbn1cbm1vZHVsZS5leHBvcnRzLmlzU2luZ2xlUHJvcGVydHkgPSBpc1NpbmdsZVByb3BlcnR5O1xuXG4vKipcbiAqIEJ1aWxkIHN0ZXAgdG8gc2NoZW1hIHRvIHVzZSBgdHlwZWAgdG8gaW5qZWN0IGRlZmF1bHQgdmFsdWUsIHBhcnNlciwgYW5kIHN0cmluZ2lmaWVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEByZXR1cm5zIHtvYmplY3R9IFNjaGVtYS5cbiAqL1xubW9kdWxlLmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChzY2hlbWEpIHtcbiAgLy8gRm9yIHNpbmdsZSBwcm9wZXJ0eSBzY2hlbWEsIHJ1biBwcm9jZXNzUHJvcERlZmluaXRpb24gb3ZlciB0aGUgd2hvbGUgc2NoZW1hLlxuICBpZiAoaXNTaW5nbGVQcm9wZXJ0eShzY2hlbWEpKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NQcm9wZXJ0eURlZmluaXRpb24oc2NoZW1hKTtcbiAgfVxuXG4gIC8vIEZvciBtdWx0aS1wcm9wZXJ0eSBzY2hlbWEsIHJ1biBwcm9jZXNzUHJvcERlZmluaXRpb24gb3ZlciBlYWNoIHByb3BlcnR5IGRlZmluaXRpb24uXG4gIE9iamVjdC5rZXlzKHNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICBzY2hlbWFbcHJvcE5hbWVdID0gcHJvY2Vzc1Byb3BlcnR5RGVmaW5pdGlvbihzY2hlbWFbcHJvcE5hbWVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG4vKipcbiAqIEluamVjdCBkZWZhdWx0IHZhbHVlLCBwYXJzZXIsIHN0cmluZ2lmaWVyIGZvciBzaW5nbGUgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NQcm9wZXJ0eURlZmluaXRpb24gKHByb3BEZWZpbml0aW9uKSB7XG4gIHZhciBwcm9wVHlwZTtcbiAgdmFyIGRlZmF1bHRWYWwgPSBwcm9wRGVmaW5pdGlvbi5kZWZhdWx0O1xuICB2YXIgdHlwZU5hbWUgPSBwcm9wRGVmaW5pdGlvbi50eXBlO1xuXG4gIGlmICghcHJvcERlZmluaXRpb24udHlwZSkge1xuICAgIGlmIChkZWZhdWx0VmFsICE9PSB1bmRlZmluZWQgJiYgWydib29sZWFuJywgJ251bWJlciddLmluZGV4T2YodHlwZW9mIGRlZmF1bHRWYWwpICE9PSAtMSkge1xuICAgICAgLy8gVHlwZSBpbmZlcmVuY2UuXG4gICAgICB0eXBlTmFtZSA9IHR5cGVvZiBkZWZhdWx0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gc3RyaW5nLlxuICAgICAgdHlwZU5hbWUgPSAnc3RyaW5nJztcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvcERlZmluaXRpb24udHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgdHlwZU5hbWUgPSAnYm9vbGVhbic7XG4gIH0gZWxzZSBpZiAocHJvcERlZmluaXRpb24udHlwZSA9PT0gJ2Zsb2F0Jykge1xuICAgIHR5cGVOYW1lID0gJ251bWJlcic7XG4gIH1cblxuICBwcm9wVHlwZSA9IHByb3BlcnR5VHlwZXNbdHlwZU5hbWVdO1xuXG4gIGlmICghcHJvcFR5cGUpIHtcbiAgICB3YXJuKCdVbmtub3duIHByb3BlcnR5IHR5cGU6ICcgKyB0eXBlTmFtZSk7XG4gICAgcmV0dXJuIHByb3BEZWZpbml0aW9uO1xuICB9XG5cbiAgcHJvcERlZmluaXRpb24ucGFyc2UgPSBwcm9wVHlwZS5wYXJzZTtcbiAgcHJvcERlZmluaXRpb24uc3RyaW5naWZ5ID0gcHJvcFR5cGUuc3RyaW5naWZ5O1xuICBwcm9wRGVmaW5pdGlvbi50eXBlID0gdHlwZU5hbWU7XG4gIGlmICghKCdkZWZhdWx0JyBpbiBwcm9wRGVmaW5pdGlvbikpIHtcbiAgICBwcm9wRGVmaW5pdGlvbi5kZWZhdWx0ID0gcHJvcFR5cGUuZGVmYXVsdDtcbiAgfVxuXG4gIHJldHVybiBwcm9wRGVmaW5pdGlvbjtcbn1cbm1vZHVsZS5leHBvcnRzLnByb2Nlc3NQcm9wZXJ0eURlZmluaXRpb24gPSBwcm9jZXNzUHJvcGVydHlEZWZpbml0aW9uO1xuXG4vKipcbiAqIElmIGB2YWx1ZWAgaXMgb2JqZWN0LCBwYXJzZSB2YWx1ZXMgb2YgYHZhbGAgaW50byB0eXBlcyBkZWZpbmVkIGJ5IGBzY2hlbWFgLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gdmFsdWUgLSB2YWx1ZShzKSB0byBjb2VyY2UuXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hIC0gT2JqZWN0IHdoaWNoIHZhbHVlcyB3aWxsIGJlIHVzZWQgdG8gY29lcmNlIHRvLlxuICogQHJldHVybnMgQ29lcmNlZCB2YWx1ZSBvciBvYmplY3QuXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChwcm9wRGF0YSwgc2NoZW1hKSB7XG4gIE9iamVjdC5rZXlzKHNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgcHJvcERlZmluaXRpb24gPSBzY2hlbWFbcHJvcE5hbWVdO1xuICAgIGlmICghcHJvcERlZmluaXRpb24pIHtcbiAgICAgIHdhcm4oJ1Vua25vd24gY29tcG9uZW50IHByb3BlcnR5OiAnICsgcHJvcE5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wRGF0YVtwcm9wTmFtZV07XG4gICAgcHJvcFZhbHVlID0gcHJvcFZhbHVlID09PSB1bmRlZmluZWQgPyBwcm9wRGVmaW5pdGlvbi5kZWZhdWx0IDogcHJvcFZhbHVlO1xuICAgIHByb3BEYXRhW3Byb3BOYW1lXSA9IHBhcnNlUHJvcGVydHkocHJvcFZhbHVlLCBwcm9wRGVmaW5pdGlvbik7XG4gIH0pO1xuXG4gIHJldHVybiBwcm9wRGF0YTtcbn07XG5cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHkgKHZhbHVlLCBwcm9wRGVmaW5pdGlvbikge1xuICAvLyBBbHJlYWR5IHBhcnNlZCBieSBjb21wb25lbnQgYGJ1aWxkRGF0YWAgc2V0dGluZyBkZWZhdWx0IHZhbHVlLlxuICAvLyBUT0RPOiBNb3ZlIHRoYXQgbG9naWMgdG8gdGhlIHNjaGVtYS5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB2YWx1ZTsgfVxuICByZXR1cm4gcHJvcERlZmluaXRpb24ucGFyc2UodmFsdWUpO1xufVxubW9kdWxlLmV4cG9ydHMucGFyc2VQcm9wZXJ0eSA9IHBhcnNlUHJvcGVydHk7XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlscy53cmFwQUV2ZW50RWxlbWVudCgnYS1jbGljaycsICdjbGljaycpO1xuIiwiLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xuXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgc3RhdGVFbHMgPSB7fTtcbnZhciBsaXN0ZW5lcnMgPSB7fTtcbnZhciB0YXJnZXREYXRhID0ge307XG5cbnZhciBhdHRyaWJ1dGVCbGFja2xpc3QgPSB7XG4gIC8vIFRPRE86IENvbnNpZGVyIGlnbm9yaW5nIHVuaXF1ZSBhdHRyaWJ1dGVzIHRvb1xuICAvLyAoZS5nLiwgYGNsYXNzYCwgYGlkYCwgYG5hbWVgLCBldGMuKS5cbiAgdGFyZ2V0OiB0cnVlXG59O1xuXG4vLyBTdGF0ZSBtYW5hZ2VtZW50XG5cbmZ1bmN0aW9uIGFkZFN0YXRlIChlbCwgc3RhdGUpIHtcbiAgZWwuYWRkU3RhdGUoc3RhdGUpO1xuICByZWNvcmRTdGF0ZShlbCwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiByZWNvcmRTdGF0ZSAoZWwsIHN0YXRlKSB7XG4gIGlmIChzdGF0ZSBpbiBzdGF0ZUVscykge1xuICAgIHN0YXRlRWxzW3N0YXRlXS5wdXNoKGVsKTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZUVsc1tzdGF0ZV0gPSBbZWxdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVjb3JkU3RhdGUgKGVsLCBzdGF0ZSkge1xuICBpZiAoIShzdGF0ZSBpbiBzdGF0ZUVscykpIHsgcmV0dXJuOyB9XG4gIHZhciBlbElkeCA9IHN0YXRlRWxzW3N0YXRlXS5pbmRleE9mKGVsKTtcbiAgaWYgKGVsSWR4ID09PSAtMSkgeyByZXR1cm47IH1cbiAgc3RhdGVFbHNbc3RhdGVdLnNwbGljZShlbElkeCwgMSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0YXRlIChlbCwgc3RhdGUpIHtcbiAgZWwucmVtb3ZlU3RhdGUoc3RhdGUpO1xuICB1bnJlY29yZFN0YXRlKGVsLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGhhc1N0YXRlIChlbCwgc3RhdGUpIHtcbiAgaWYgKCEoc3RhdGUgaW4gc3RhdGVFbHMpKSB7IHJldHVybiBmYWxzZTsgfVxuICB2YXIgZWxJZHggPSBzdGF0ZUVsc1tzdGF0ZV0uaW5kZXhPZihlbCk7XG4gIHJldHVybiBlbElkeCAhPT0gLTE7XG59XG5cbi8vIFVuaXF1ZSBldmVudCBsaXN0ZW5lcnNcblxuZnVuY3Rpb24gcmVjb3JkTGlzdGVuZXIgKGVsLCB0eXBlKSB7XG4gIGlmICh0eXBlIGluIGxpc3RlbmVycykge1xuICAgIGxpc3RlbmVyc1t0eXBlXS5wdXNoKGVsKTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lcnNbdHlwZV0gPSBbZWxdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0xpc3RlbmVyIChlbCwgdHlwZSkge1xuICBpZiAoISh0eXBlIGluIGxpc3RlbmVycykpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHZhciBlbElkeCA9IGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGVsKTtcbiAgcmV0dXJuIGVsSWR4ICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gYWRkRGVsZWdhdGVkTGlzdGVuZXIgKGVsLCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICBpZiAoaGFzTGlzdGVuZXIoZWwsIHR5cGUpKSB7IHJldHVybjsgfSAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciBvbmx5IG9uY2UuXG4gIHJlY29yZExpc3RlbmVyKGVsLCB0eXBlKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG59XG5cbi8vIFRhcmdldCBkYXRhXG5cbmZ1bmN0aW9uIHJlY29yZFRhcmdldERhdGEgKHR5cGUsIHNvdXJjZUVsLCB0YXJnZXRTZWwsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGtleSA9IHR5cGU7XG4gIHZhciBvYmogPSB7c291cmNlRWw6IHNvdXJjZUVsLCB0YXJnZXRTZWw6IHRhcmdldFNlbCwgYXR0cmlidXRlczogYXR0cmlidXRlc307XG4gIGlmIChrZXkgaW4gdGFyZ2V0RGF0YSkge1xuICAgIHRhcmdldERhdGFba2V5XS5wdXNoKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0RGF0YVtrZXldID0gW29ial07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0RGF0YSAodHlwZSkge1xuICB2YXIga2V5ID0gdHlwZTtcbiAgcmV0dXJuIHRhcmdldERhdGFba2V5XTtcbn1cblxuZnVuY3Rpb24gdGFyZ2V0TGlzdGVuZXIgKGUpIHtcbiAgLy8gTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIGB0YXJnZXRgIHdlIGFyZSBtb2RpZnlpbmcgYmVsb3cuXG4gIHZhciBldmVudEZpcmVkT25FbCA9IGdldFJlYWxOb2RlKGUudGFyZ2V0KTtcbiAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcblxuICB2YXIgYWxsVGFyZ2V0RGF0YSA9IGdldFRhcmdldERhdGEoZXZlbnRUeXBlLCBldmVudEZpcmVkT25FbCk7XG4gIGlmICghYWxsVGFyZ2V0RGF0YSkgeyByZXR1cm47IH1cblxuICBhbGxUYXJnZXREYXRhLmZvckVhY2godXBkYXRlVGFyZ2V0RWwpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhcmdldEVsICh0YXJnZXREYXRhKSB7XG4gICAgdmFyIHNvdXJjZUVsID0gdGFyZ2V0RGF0YS5zb3VyY2VFbDtcbiAgICBpZiAoc291cmNlRWwgIT09IGV2ZW50RmlyZWRPbkVsKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIHRhcmdldEF0dHJpYnV0ZXMgPSB0YXJnZXREYXRhLmF0dHJpYnV0ZXM7XG4gICAgLy8gVE9ETzogU3VwcG9ydCB1cGRhdGluZyBtdWx0aXBsZSBlbGVtZW50cyBsYXRlciBieSB1c2luZyBgJCRgIGFuZCBpdGVyYXRpbmcuXG4gICAgdmFyIHRhcmdldFNlbCA9IHRhcmdldERhdGEudGFyZ2V0U2VsO1xuICAgIHZhciB0YXJnZXRFbCA9IHR5cGVvZiB0YXJnZXRTZWwgPT09ICdzdHJpbmcnID8gdXRpbHMuJCh0YXJnZXRTZWwpIDogdGFyZ2V0U2VsO1xuXG4gICAgaWYgKCF0YXJnZXRFbCkgeyByZXR1cm47IH1cblxuICAgIHVwZGF0ZUF0dHJzKHRhcmdldEVsLCB0YXJnZXRBdHRyaWJ1dGVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAodGFyZ2V0RWwsIHRhcmdldEF0dHJpYnV0ZXMpIHtcbiAgdXRpbHMuJCQodGFyZ2V0QXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgIGlmIChhdHRyLm5hbWUgaW4gYXR0cmlidXRlQmxhY2tsaXN0KSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGF0dHIubmFtZSA9PT0gJ3N0YXRlJykge1xuICAgICAgdmFyIHN0YXRlcyA9IHV0aWxzLnNwbGl0U3RyaW5nKGF0dHIudmFsdWUpO1xuICAgICAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIC8vIFNldCB0aGUgc3RhdGUgb24gdGhpcyBlbGVtZW50LlxuICAgICAgICBhZGRTdGF0ZSh0YXJnZXRFbCwgc3RhdGUpO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXRlIG9uIHRoZSBvdGhlciBlbGVtZW50KHMpLlxuICAgICAgICBzdGF0ZUVsc1tzdGF0ZV0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICBpZiAoZWwgPT09IHRhcmdldEVsKSB7IHJldHVybjsgfSAgLy8gRG9uJ3QgcmVtb3ZlIG15IHN0YXRlIVxuICAgICAgICAgIHJlbW92ZVN0YXRlKGVsLCBzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVsLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFN5bnRoZXNpemUgZXZlbnRzIGZvciBjdXJzb3IgYG1vdXNlZW50ZXJgIGFuZCBgbW91c2VsZWF2ZWBcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3N0YXRlYWRkZWQnLCBmdW5jdGlvbiAoZSkge1xuICB2YXIgZGV0YWlsID0gZS5kZXRhaWw7XG4gIHZhciBzdGF0ZSA9IGRldGFpbC5zdGF0ZTtcbiAgdmFyIGVsID0gZS50YXJnZXQ7XG5cbiAgcmVjb3JkU3RhdGUoZWwsIHN0YXRlKTtcblxuICBpZiAoc3RhdGUgPT09ICdob3ZlcmluZycpIHtcbiAgICBlbC5lbWl0KCdtb3VzZWVudGVyJyk7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnaG92ZXJlZCcpIHtcbiAgICBpZiAoaGFzU3RhdGUoZWwsICdzZWxlY3RlZCcpKSB7XG4gICAgICByZW1vdmVTdGF0ZShlbCwgJ2hvdmVyZWQnKTtcbiAgICB9XG4gIH1cbn0pO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVyZW1vdmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgdmFyIGRldGFpbCA9IGUuZGV0YWlsO1xuICB2YXIgc3RhdGUgPSBkZXRhaWwuc3RhdGU7XG4gIHZhciBlbCA9IGUudGFyZ2V0O1xuXG4gIHVucmVjb3JkU3RhdGUoZWwsIHN0YXRlKTtcblxuICBpZiAoc3RhdGUgPT09ICdob3ZlcmluZycpIHtcbiAgICBlbC5lbWl0KCdtb3VzZWxlYXZlJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHRydWUgbm9kZSAodXNlZnVsIGZvciBhIHdyYXBwZWQgb2JqZWN0IGluIGEgdGVtcGxhdGUgaW5zdGFuY2UpLlxuICovXG5mdW5jdGlvbiBnZXRSZWFsTm9kZSAoZWwpIHtcbiAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Etcm9vdCcpIHtcbiAgICByZXR1cm4gZWwucGFyZW50Tm9kZTtcbiAgfVxuICBpZiAoIWVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgIWVsLm5leHRFbGVtZW50U2libGluZyAmJiBlbC5jbG9zZXN0KCdhLXJvb3QnKSkge1xuICAgIHJldHVybiBlbC5jbG9zZXN0KCdhLXJvb3QnKS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBlbDtcbn1cblxudmFyIEFFdmVudCA9IHJlZ2lzdGVyRWxlbWVudChcbiAgJ2EtZXZlbnQnLFxuICB7XG4gICAgcHJvdG90eXBlOiBPYmplY3QuY3JlYXRlKFxuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAge1xuICAgICAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBlbCA9IHNlbGYucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChlbC5pc05vZGUpIHtcbiAgICAgICAgICAgICAgYXR0YWNoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdub2RlcmVhZHknLCBhdHRhY2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhdHRhY2ggKCkge1xuICAgICAgICAgICAgICBzZWxmLmlzQUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZi50eXBlID0gc2VsZi50eXBlIHx8IHNlbGYuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICAgIHNlbGYudGFyZ2V0ID0gc2VsZi50YXJnZXQgfHwgc2VsZi5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgICAgICAgICAgICBzZWxmLnNjZW5lRWwgPSB1dGlscy4kKCdhLXNjZW5lJyk7XG4gICAgICAgICAgICAgIHNlbGYuYXR0YWNoRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaGVkQ2FsbGJhY2s6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgICAgICAgaWYgKG9sZFZhbCA9PT0gbmV3VmFsKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgaWYgKGF0dHIgPT09ICd0eXBlJykge1xuICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBuZXdWYWw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbmV3VmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaEV2ZW50TGlzdGVuZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUVsO1xuICAgICAgICAgICAgdmFyIHRhcmdldEVsO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBMYW5kIGBvbmAgUFIgaW4gYGFmcmFtZS1jb3JlYDogaHR0cHM6Ly9naXRodWIuY29tL2FmcmFtZXZyL2FmcmFtZS1jb3JlL3B1bGwvMzMwXG5cbiAgICAgICAgICAgIHRoaXMuc2NlbmVFbCA9IHRoaXMuc2NlbmVFbCB8fCB1dGlscy4kKCdhLXNjZW5lJyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLnR5cGUgPT09ICdsb2FkJykge1xuICAgICAgICAgICAgICBzb3VyY2VFbCA9IGdldFJlYWxOb2RlKHNlbGYucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIHRhcmdldEVsID0gc2VsZi50YXJnZXQgPyB1dGlscy4kKHNlbGYudGFyZ2V0KSA6IHNvdXJjZUVsO1xuICAgICAgICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBzb3VyY2VFbCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICB1cGRhdGVBdHRycyh0YXJnZXRFbCwgc2VsZi5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZUVsICYmIHNvdXJjZUVsLmhhc0xvYWRlZCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKHNvdXJjZUVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zY2VuZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdGVuZXIgPSB0YXJnZXRMaXN0ZW5lcjtcblxuICAgICAgICAgICAgLy8gV2UgbXVzdCBkZWxlZ2F0ZSBldmVudHMgYmVjYXVzZSB0aGUgdGFyZ2V0IG5vZGVzIG1heSBub3QgZXhpc3QgeWV0LlxuICAgICAgICAgICAgYWRkRGVsZWdhdGVkTGlzdGVuZXIodGhpcy5zY2VuZUVsLCBzZWxmLnR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHNvdXJjZUVsID0gZ2V0UmVhbE5vZGUoc2VsZi5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIHRhcmdldEVsID0gc2VsZi50YXJnZXQgfHwgc291cmNlRWw7XG4gICAgICAgICAgICByZWNvcmRUYXJnZXREYXRhKHNlbGYudHlwZSwgc291cmNlRWwsIHRhcmdldEVsLCBzZWxmLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICB9XG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFFdmVudDtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xuXG4vKipcbiAqIFdlIGBob3ZlcmAgYnkgYXBwbHlpbmcgYXR0cmlidXRlcyB1cG9uIGBtb3VzZWVudGVyYCBhbmQgdGhlblxuICogcm9sbGluZyBiYWNrIHRoZSBjaGFuZ2VzIHVwb24gYG1vdXNlbGVhdmVgIG9mIHRoZSBlbGVtZW50LlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzLndyYXBBRXZlbnRFbGVtZW50KCdhLWhvdmVyJywgJ21vdXNlZW50ZXInKTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzLndyYXBBRXZlbnRFbGVtZW50KCdhLWxvYWQnLCAnbG9hZCcpO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbHMud3JhcEFFdmVudEVsZW1lbnQoJ2EtbW91c2Vkb3duJywgJ21vdXNlZG93bicpO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vbGliL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbHMud3JhcEFFdmVudEVsZW1lbnQoJ2EtbW91c2VlbnRlcicsICdtb3VzZWVudGVyJyk7XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKCcuLi9saWIvdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlscy53cmFwQUV2ZW50RWxlbWVudCgnYS1tb3VzZWxlYXZlJywgJ21vdXNlbGVhdmUnKTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzLndyYXBBRXZlbnRFbGVtZW50KCdhLW1vdXNldXAnLCAnbW91c2V1cCcpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICdhLWNsaWNrJzogcmVxdWlyZSgnLi9hLWNsaWNrJyksXG4gICdhLWV2ZW50JzogcmVxdWlyZSgnLi9hLWV2ZW50JyksXG4gICdhLWhvdmVyJzogcmVxdWlyZSgnLi9hLWhvdmVyJyksXG4gICdhLWxvYWQnOiByZXF1aXJlKCcuL2EtbG9hZCcpLFxuICAnYS1tb3VzZWRvd24nOiByZXF1aXJlKCcuL2EtbW91c2Vkb3duJyksXG4gICdhLW1vdXNlZW50ZXInOiByZXF1aXJlKCcuL2EtbW91c2VlbnRlcicpLFxuICAnYS1tb3VzZWxlYXZlJzogcmVxdWlyZSgnLi9hLW1vdXNlbGVhdmUnKSxcbiAgJ2EtbW91c2V1cCc6IHJlcXVpcmUoJy4vYS1tb3VzZXVwJylcbn07XG4iLCIvKiBnbG9iYWwgSFRNTFRlbXBsYXRlRWxlbWVudCwgSFRNTEltcG9ydHMsIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0hUTUxJbXBvcnRzTG9hZGVkJywgaW5qZWN0RnJvbVBvbHlmaWxsZWRJbXBvcnRzKTtcblxudmFyIHJlZ2lzdGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL2xpYi9yZWdpc3Rlci10ZW1wbGF0ZScpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcblxuLy8gVE9ETzogRXh0cmFjdCB0byBhZnJhbWUtcHJpbWl0aXZlcyBhbmQgcmVxdWlyZSBhZnJhbWUuXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi4vY29yZS9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG5cbmZ1bmN0aW9uIGluamVjdEZyb21Qb2x5ZmlsbGVkSW1wb3J0cyAoKSB7XG4gIGlmICghSFRNTEltcG9ydHMgfHwgSFRNTEltcG9ydHMudXNlTmF0aXZlKSB7IHJldHVybjsgfVxuXG4gIE9iamVjdC5rZXlzKEhUTUxJbXBvcnRzLmltcG9ydGVyLmRvY3VtZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGRvYyA9IEhUTUxJbXBvcnRzLmltcG9ydGVyLmRvY3VtZW50c1trZXldO1xuICAgIGluc2VydFRlbXBsYXRlRWxlbWVudHMoZG9jKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFRlbXBsYXRlRWxlbWVudHMgKGRvYykge1xuICB2YXIgc2NlbmVFbCA9IHV0aWxzLiQoJ2Etc2NlbmUnKTtcbiAgdmFyIGFzc2V0c0VsID0gdXRpbHMuJCgnYS1hc3NldHMnKTtcbiAgaWYgKCFhc3NldHNFbCkge1xuICAgIGFzc2V0c0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYS1hc3NldHMnKTtcbiAgICBzY2VuZUVsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGFzc2V0c0VsLCBzY2VuZUVsKTtcbiAgfVxuXG4gIHV0aWxzLiQkKCdhLW1peGluJywgZG9jKS5mb3JFYWNoKGZ1bmN0aW9uIChtaXhpbkVsKSB7XG4gICAgdmFyIG1peGluQ2xvbmVFbCA9IGRvY3VtZW50LmltcG9ydE5vZGUobWl4aW5FbCwgdHJ1ZSk7XG4gICAgYXNzZXRzRWwuYXBwZW5kQ2hpbGQobWl4aW5DbG9uZUVsKTtcbiAgfSk7XG5cbiAgdXRpbHMuJCQoJ3RlbXBsYXRlW2lzPVwiYS10ZW1wbGF0ZVwiXScsIGRvYykuZm9yRWFjaChmdW5jdGlvbiAodGVtcGxhdGVFbCkge1xuICAgIHZhciB0ZW1wbGF0ZUNsb25lRWwgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRlbXBsYXRlRWwsIHRydWUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcGxhdGVDbG9uZUVsKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXJFbGVtZW50KFxuICAnYS10ZW1wbGF0ZScsXG4gIHtcbiAgICBleHRlbmRzOiAndGVtcGxhdGUnLCAgLy8gVGhpcyBsZXRzIHVzIGRvIGA8dGVtcGxhdGUgaXM9XCJhLXRlbXBsYXRlXCI+YC5cbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoXG4gICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNlbGYucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgICAgICAvLyBGb3IgQ2hyb21lOiBodHRwczovL2dpdGh1Yi5jb20vYWZyYW1ldnIvYWZyYW1lLWNvcmUvaXNzdWVzLzMyMVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGFwcGVuZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gYXBwZW5kRWxlbWVudCAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5Eb2N1bWVudCA9IHNlbGYub3duZXJEb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIGA8YS1taXhpbj5gIGZyb20gaW1wb3J0ZWQgdGVtcGxhdGVzIGZvciBDaHJvbWUuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0luRG9jdW1lbnQpIHsgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWxmKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFhYWDogSGFjayBmb3IgVlMgdG8gaGlkZSB0ZW1wbGF0ZXMgZnJvbSBzb3VyY2UuXG4gICAgICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBzZWxmLnJlbW92ZVRlbXBsYXRlTGlzdGVuZXIoKTtcbiAgICAgICAgICAgIC8vIHNlbGYucGxhY2Vob2xkZXJzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyAgIHNlbGYuc2NlbmVFbC5yZW1vdmUoZWwpO1xuICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG9hZDoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGVtaXR0aW5nIHRoZSBsb2FkZWQgZXZlbnQgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNMb2FkZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB1dGlscy5maXJlRXZlbnQodGhpcywgJ2xvYWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlZ2lzdGVyOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlclRlbXBsYXRlKHRhZ05hbWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZVRlbXBsYXRlTGlzdGVuZXI6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1peGluT2JzZXJ2ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB0aGlzLm1peGluT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5taXhpbk9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hUZW1wbGF0ZUxpc3RlbmVyOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VsZi5taXhpbk9ic2VydmVyKSB7IHNlbGYubWl4aW5PYnNlcnZlci5kaXNjb25uZWN0KCk7IH1cbiAgICAgICAgICAgIHNlbGYubWl4aW5PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgc2VsZi5wbGFjZWhvbGRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5yZXJlbmRlcih0cnVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYubWl4aW5PYnNlcnZlci5vYnNlcnZlKHNlbGYsIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgfSxcblxuICAgICAgICBpbmplY3Q6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5pbmplY3RlZCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIHNlbGYuaW5qZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHNlbGYuZ2V0QXR0cmlidXRlKCdlbGVtZW50Jyk7XG4gICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgIHNlbGYuYXR0YWNoVGVtcGxhdGVMaXN0ZW5lcih0YWdOYW1lKTtcbiAgICAgICAgICAgIHNlbGYucmVnaXN0ZXIodGFnTmFtZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIH1cbik7XG4iLCJ2YXIgbW9kdWxlcyA9IHtcbiAgJ2EtZXZlbnQnOiByZXF1aXJlKCcuL2EtZXZlbnQnKSxcbiAgJ2EtdGVtcGxhdGUnOiByZXF1aXJlKCcuL2EtdGVtcGxhdGUnKVxufTtcblxuLy8gVGhpcyBpbmplY3RzIHRoZSB0ZW1wbGF0ZSBkZWZpbml0aW9ucyBpbnRvIHRoZSBwYWdlLlxucmVxdWlyZSgnLi90ZW1wbGF0ZXMvaW5kZXguaHRtbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZHVsZXM7XG4iLCIvLyBUT0RPOiBFeHRyYWN0IHRvIGFmcmFtZS1wcmltaXRpdmVzLlxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgcmVnaXN0ZXJFbGVtZW50ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9hLXJlZ2lzdGVyLWVsZW1lbnQnKS5yZWdpc3RlckVsZW1lbnQ7XG52YXIgQUVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvYS1lbnRpdHknKTtcbnZhciBBQ29tcG9uZW50cyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY29tcG9uZW50JykuY29tcG9uZW50cztcblxudmFyIEFUVFJJQlVURV9CTEFDS0xJU1QgPSB1dGlscy5leHRlbmQoe1xuICBpZDogdHJ1ZSxcbiAgbmFtZTogdHJ1ZSxcbiAgY2xhc3M6IHRydWUsXG4gIHRhcmdldDogdHJ1ZVxufSk7XG52YXIgQ09NUE9ORU5UX0JMQUNLTElTVCA9IHV0aWxzLmV4dGVuZCh7fSwgQUNvbXBvbmVudHMpO1xuXG5yZWdpc3RlckVsZW1lbnQoJ2Etcm9vdCcsIHtwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoQUVudGl0eS5wcm90b3R5cGUpfSk7XG5cbi8vIFdlIHVzZSBjb3VudGVycyBzbyB3ZSBjYW4gZ2VuZXJhdGUgdW5pcXVlIGBpZGBzIGZvciBlYWNoIHRlbXBsYXRlIGluc3RhbmNlLlxuLy8gQ29kZSB3aWxsIGJlIHNpbXBsaWZpZWQgYW5kIHRoaXMgY2FuIGJlIHJlbW92ZWQgd2hlbiBcInByaW1pdGl2ZXNcIiBsYW5kLlxuLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL2FmcmFtZXZyL2FmcmFtZS9pc3N1ZXMvMzA4XG52YXIgY291bnRzID0ge307XG5mdW5jdGlvbiBjb3VudEluY3JlbWVudCAodGFnTmFtZSkge1xuICBpZiAoISh0YWdOYW1lIGluIGNvdW50cykpIHtcbiAgICBjb3VudHNbdGFnTmFtZV0gPSAwO1xuICB9XG4gIHJldHVybiBjb3VudHNbdGFnTmFtZV0rKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFnTmFtZSkge1xuICB2YXIgdGFnTmFtZUxvd2VyID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiByZWdpc3RlckVsZW1lbnQoXG4gICAgdGFnTmFtZUxvd2VyLFxuICAgIHtcbiAgICAgIHByb3RvdHlwZTogT2JqZWN0LmNyZWF0ZShcbiAgICAgICAgQUVudGl0eS5wcm90b3R5cGUsIHtcbiAgICAgICAgICBhdHRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSBlbWl0IGFuIGV2ZW50IHNvIGA8YS1lbnRpdHk+YCBrbm93cyB3aGVuIHdlJ3ZlIGJlZW5cbiAgICAgICAgICAgICAgLy8gcmVnaXN0ZXJlZCBhbmQgYWRkcyBvdXIgY2hpbGRyZW4gYXMgYG9iamVjdDNEYHMuXG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZGVkJyk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbm9kZXJlYWR5Jyk7XG4gICAgICAgICAgICAgIHRoaXMucmVyZW5kZXIoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgICAgICAgICAgaWYgKG9sZFZhbCA9PT0gbmV3VmFsKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICB0aGlzLnJlcmVuZGVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBhdHRyaWJ1dGVCbGFja2xpc3Q6IHtcbiAgICAgICAgICAgIHZhbHVlOiBBVFRSSUJVVEVfQkxBQ0tMSVNULFxuICAgICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBjb21wb25lbnRCbGFja2xpc3Q6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDT01QT05FTlRfQkxBQ0tMSVNULFxuICAgICAgICAgICAgd3JpdGFibGU6IHdpbmRvdy5kZWJ1Z1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBkZXRhY2hlZENhbGxiYWNrOiB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuc2NlbmVFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmVFbCA9IHV0aWxzLiQoJ2Etc2NlbmUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnNjZW5lRWwucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB3aW5kb3cuZGVidWdcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgcmVyZW5kZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZm9yY2UsIGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgIGlmICghZm9yY2UgJiYgdGhpcy5sYXN0T3V0ZXJIVE1MID09PSB0aGlzLm91dGVySFRNTCkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gdXRpbHMuJCgndGVtcGxhdGVbaXM9XCJhLXRlbXBsYXRlXCJdW2VsZW1lbnQ9XCInICsgdGFnTmFtZSArICdcIl0nKTtcbiAgICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkgeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHRzIGRlZmluZWQgb24gdGhlIG9yaWdpbmFsIGA8dGVtcGxhdGUgaXM9XCJhLXRlbXBsYXRlXCI+YC5cbiAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQXR0cnMgPSB1dGlscy5tZXJnZUF0dHJzKHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgdXRpbHMuZm9yRWFjaCh0ZW1wbGF0ZS5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gc2VsZi5jb21wb25lbnRCbGFja2xpc3QpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMud2FybignQ2Fubm90IHVzZSBhdHRyaWJ1dGUgbmFtZSBcIiVzXCIgZm9yIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9uIG9mIDwlcz4gYmVjYXVzZSBpdCBpcyBhIGNvcmUgY29tcG9uZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyLm5hbWUsIHRhZ05hbWVMb3dlcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcGxhdGVBdHRyc1thdHRyLm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRlbXBsYXRlQXR0cnMpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0aGlzLmF0dHJpYnV0ZUJsYWNrbGlzdCkge1xuICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGVzZSB1bmlxdWUgaWRlbnRpZmllciBhdHRyaWJ1dGVzIG92ZXJcbiAgICAgICAgICAgICAgICAgIC8vIChpLmUuLCBgaWRgLCBgbmFtZWAsIGBjbGFzc2AsIGB0YXJnZXRgKS5cbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wbGF0ZUF0dHJzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRlbXBsYXRlQXR0cnNba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUF0dHJzW2tleV0gPSBjb21wb25lbnQuc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIHRoaXMucm9vdCA9IHV0aWxzLiQkKHRoaXMuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYS1yb290JztcbiAgICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhLXJvb3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMucm9vdCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVBdHRycy5fX2NvdW50ZXJfXyA9IGNvdW50SW5jcmVtZW50KHRhZ05hbWVMb3dlcikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBuZXdIVE1MID0gdXRpbHMuZm9ybWF0KHRlbXBsYXRlLmlubmVySFRNTCwgdGVtcGxhdGVBdHRycyk7XG4gICAgICAgICAgICAgIGlmIChuZXdIVE1MICE9PSB0aGlzLnJvb3QuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LmlubmVySFRNTCA9IG5ld0hUTUw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmxhc3RPdXRlckhUTUwgPSB0aGlzLm91dGVySFRNTDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG59O1xuIiwiLy8gVE9ETzogRXh0cmFjdCB0byBhZnJhbWUtcHJpbWlpdmVzLlxudmFyIEFFdmVudCA9IHJlcXVpcmUoJy4uL2EtZXZlbnQvYS1ldmVudCcpO1xuXG52YXIgYWZyYW1lQ29yZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbnZhciByZWdpc3RlckVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi9jb3JlL2EtcmVnaXN0ZXItZWxlbWVudCcpLnJlZ2lzdGVyRWxlbWVudDtcblxuLyoqXG4gKiBXcmFwcyBgcXVlcnlTZWxlY3RvcmAgw6AgbGEgalF1ZXJ5J3MgYCRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IHNlbCBDU1Mgc2VsZWN0b3IgdG8gbWF0Y2ggYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudD19IHBhcmVudCBQYXJlbnQgZnJvbSB3aGljaCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtFbGVtZW50fSBFbGVtZW50IG1hdGNoZWQgYnkgc2VsZWN0b3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzLiQgPSBmdW5jdGlvbiAoc2VsLCBwYXJlbnQpIHtcbiAgdmFyIGVsID0gc2VsO1xuICBpZiAoc2VsICYmIHR5cGVvZiBzZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgZWwgPSAocGFyZW50IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKHNlbCk7XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBXcmFwcyBgcXVlcnlTZWxlY3RvckFsbGAgw6AgbGEgalF1ZXJ5J3MgYCRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IHNlbCBDU1Mgc2VsZWN0b3IgdG8gbWF0Y2ggZWxlbWVudHMuXG4gKiBAcGFyYW0ge0VsZW1lbnQ9fSBwYXJlbnQgUGFyZW50IGZyb20gd2hpY2ggdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGVsZW1lbnRzIG1hdGNoZWQgYnkgc2VsZWN0b3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzLiQkID0gZnVuY3Rpb24gKHNlbCwgcGFyZW50KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNlbCkpIHsgcmV0dXJuIHNlbDsgfVxuICB2YXIgZWxzID0gc2VsO1xuICBpZiAoc2VsICYmIHR5cGVvZiBzZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxzID0gKHBhcmVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWwpO1xuICB9XG4gIHJldHVybiB0b0FycmF5KGVscyk7XG59O1xuXG4vKipcbiAqIFR1cm5zIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGludG8gYW4gYXJyYXkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gb2JqIENTUyBzZWxlY3RvciB0byBtYXRjaCBlbGVtZW50cy5cbiAqIEBwYXJhbSB7QXJyYXl8TmFtZWROb2RlTWFwfE5vZGVMaXN0fEhUTUxDb2xsZWN0aW9ufSBhcnIgQW4gYXJyYXktbGlrZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIGVsZW1lbnRzIG1hdGNoZWQgYnkgc2VsZWN0b3IuXG4gKi9cbnZhciB0b0FycmF5ID0gbW9kdWxlLmV4cG9ydHMudG9BcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgeyByZXR1cm4gb2JqOyB9XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgfVxuICByZXR1cm4gW29ial07XG59O1xuXG4vKipcbiAqIFdyYXBzIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyciBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSByZWFsIGFycmF5LlxuICovXG52YXIgZm9yRWFjaCA9IG1vZHVsZS5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAoYXJyLCBmbikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcnIsIGZuKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGF0dHJpYnV0ZXMgw6AgbGEgYE9iamVjdC5hc3NpZ25gLlxuICpcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBlbHNcbiAqICAgQXJyYXktbGlrZSBvYmplY3QgKE5vZGVNYXAsIGFycmF5LCBldGMuKSBvZlxuICogICBwYXJlbnQgZWxlbWVudHMgZnJvbSB3aGljaCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgbWVyZ2VkIGF0dHJpYnV0ZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzLm1lcmdlQXR0cnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtZXJnZWRBdHRycyA9IHt9O1xuICBmb3JFYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgZm9yRWFjaChlbC5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgLy8gTk9URTogV2UgdXNlIGBnZXRDb21wdXRlZEF0dHJpYnV0ZWAgaW5zdGVhZCBvZiBgYXR0ci52YWx1ZWAgc28gb3VyXG4gICAgICAvLyB3cmFwcGVyIGZvciBjb29yZGluYXRlIG9iamVjdHMsIGV0Yy4gZ2V0cyB1c2VkLlxuICAgICAgaWYgKGVsLmdldENvbXB1dGVkQXR0cmlidXRlKSB7XG4gICAgICAgIG1lcmdlZEF0dHJzW2F0dHIubmFtZV0gPSBlbC5nZXRDb21wdXRlZEF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkQXR0cnNbYXR0ci5uYW1lXSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG1lcmdlZEF0dHJzO1xufTtcblxuLyoqXG4gKiBEb2VzIEVTNi1zdHlsZSAob3IgbXVzdGFjaGUtc3R5bGUpIHN0cmluZyBmb3JtYXR0aW5nLlxuICpcbiAqID4gZm9ybWF0KCckezB9JywgWyd6enonXSlcbiAqIFwienp6XCJcbiAqXG4gKiA+IGZvcm1hdCgnJHswfXsxfScsIDEsIDIpXG4gKiBcIjEyXCJcbiAqXG4gKiA+IGZvcm1hdCgnJHt4fScsIHt4OiAxfSlcbiAqIFwiMVwiXG4gKlxuICogPiBmb3JtYXQoJ215IGZhdm91cml0ZSBjb2xvciBpcyAke2NvbG9yPWJsdWV9Jywge3g6IDF9KVxuICogXCJteSBmYXZvdXJpdGUgY29sb3IgaXMgYmx1ZVwiXG4gKlxuICogQHJldHVybnMge1N0cmluZ30gRm9ybWF0dGVkIHN0cmluZyB3aXRoIGludGVycG9sYXRlZCB2YXJpYWJsZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZWdleGVzID0gW1xuICAgIC9cXCQ/XFx7XFxzKihbXn09IF0rKShcXHMqPVxccyooLispKT9cXHMqXFx9L2csXG4gICAgL1xcJD8lN0JcXHMqKFtefT0gXSspKFxccyo9XFxzKiguKykpP1xccyolN0QvZ1xuICBdO1xuICByZXR1cm4gZnVuY3Rpb24gKHMsIGFyZ3MpIHtcbiAgICBpZiAoIXMpIHsgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgc3RyaW5nIGlzIGVtcHR5IScpOyB9XG4gICAgaWYgKCFhcmdzKSB7IHJldHVybjsgfVxuICAgIGlmICghKGFyZ3MgaW5zdGFuY2VvZiBBcnJheSB8fCBhcmdzIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgYXJnc1tTdHJpbmcoa2V5KS50b0xvd2VyQ2FzZSgpXSA9IGFyZ3Nba2V5XTtcbiAgICB9KTtcbiAgICByZWdleGVzLmZvckVhY2goZnVuY3Rpb24gKHJlKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKHJlLCBmdW5jdGlvbiAoXywgbmFtZSwgcmhzLCBkZWZhdWx0VmFsKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW25hbWUudG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIChkZWZhdWx0VmFsIHx8ICcnKS50cmltKCkucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHZhbCB8fCAnJykudHJpbSgpLnJlcGxhY2UoL15bXCInXXxbXCInXSQvZywgJycpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHM7XG4gIH07XG59KSgpO1xuXG4vKipcbiAqIFdyYXBzIGFuIGVsZW1lbnQgYXMgYSBuZXcgb25lIHdpdGggYSBkaWZmZXJlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmV3VGFnTmFtZSAtIE5hbWUgb2YgdGhlIG5ldyBjdXN0b20gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gc3JjRWxlbWVudCAtIE9yaWdpbmFsIGN1c3RvbSBlbGVtZW50IHRvIHdyYXAuXG4gKiBAcGFyYW0ge09iamVjdD19IFtkYXRhPXt9XSAtIERhdGEgZm9yIHRoZSBuZXcgcHJvdG90eXBlLlxuICogQHJldHVybnMge0FycmF5fSBXcmFwcGVkIGN1c3RvbSBlbGVtZW50LlxuICovXG52YXIgd3JhcEVsZW1lbnQgPSBtb2R1bGUuZXhwb3J0cy53cmFwRWxlbWVudCA9IGZ1bmN0aW9uIChuZXdUYWdOYW1lLCBzcmNFbGVtZW50LCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICByZXR1cm4gcmVnaXN0ZXJFbGVtZW50KG5ld1RhZ05hbWUsIHtcbiAgICBwcm90b3R5cGU6IE9iamVjdC5jcmVhdGUoc3JjRWxlbWVudC5wcm90b3R5cGUsIGRhdGEpXG4gIH0pO1xufTtcblxuLyoqXG4gKiBXcmFwcyBgPGEtZXZlbnQ+YCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IGB0eXBlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmV3VGFnTmFtZSAtIE5hbWUgb2YgdGhlIG5ldyBjdXN0b20gZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZXZlbnROYW1lIC0gTmFtZSBvZiBldmVudCB0eXBlLlxuICogQHBhcmFtIHtPYmplY3Q9fSBbZGF0YT17fV0gLSBEYXRhIGZvciB0aGUgbmV3IHByb3RvdHlwZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gV3JhcHBlZCBjdXN0b20gZWxlbWVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMud3JhcEFFdmVudEVsZW1lbnQgPSBmdW5jdGlvbiAobmV3VGFnTmFtZSwgZXZlbnROYW1lLCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLnR5cGUgPSB7XG4gICAgdmFsdWU6IGV2ZW50TmFtZSxcbiAgICB3cml0YWJsZTogd2luZG93LmRlYnVnXG4gIH07XG4gIHJldHVybiB3cmFwRWxlbWVudChuZXdUYWdOYW1lLCBBRXZlbnQsIGRhdGEpO1xufTtcblxuLy8gVXNlZnVsIHV0aWxzIGZyb20gYWZyYW1lLWNvcmUuXG5tb2R1bGUuZXhwb3J0cy5lcnJvciA9IGFmcmFtZUNvcmVVdGlscy5lcnJvcjtcbm1vZHVsZS5leHBvcnRzLmV4dGVuZCA9IGFmcmFtZUNvcmVVdGlscy5leHRlbmQ7XG5tb2R1bGUuZXhwb3J0cy5maXJlRXZlbnQgPSBhZnJhbWVDb3JlVXRpbHMuZmlyZUV2ZW50O1xubW9kdWxlLmV4cG9ydHMubG9nID0gYWZyYW1lQ29yZVV0aWxzLmxvZztcbm1vZHVsZS5leHBvcnRzLnNwbGl0U3RyaW5nID0gYWZyYW1lQ29yZVV0aWxzLnNwbGl0U3RyaW5nO1xubW9kdWxlLmV4cG9ydHMud2FybiA9IGFmcmFtZUNvcmVVdGlscy53YXJuO1xuIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS1jYW1lcmFcXFwiIGZvdj1cXFwiODBcXFwiIG5lYXI9XFxcIjAuNVxcXCIgZmFyPVxcXCIxMDAwMFxcXCIgbG9vay1jb250cm9scy1lbmFibGVkPVxcXCJ0cnVlXFxcIiB3YXNkLWNvbnRyb2xzLWVuYWJsZWQ9XFxcInRydWVcXFwiIGN1cnNvci12aXNpYmxlPVxcXCJ0cnVlXFxcIiBjdXJzb3Itb2Zmc2V0PVxcXCIxXFxcIiBjdXJzb3ItY29sb3I9XFxcIiNGRkZcXFwiIGN1cnNvci1tYXhkaXN0YW5jZT1cXFwiMTAwMFxcXCIgY3Vyc29yLXNjYWxlPVxcXCIxXFxcIiBjdXJzb3Itb3BhY2l0eT1cXFwiMVxcXCI+XFxuICA8YS1lbnRpdHkgY2FtZXJhPVxcXCJmb3Y6ICR7Zm92fTsgbmVhcjogJHtuZWFyfTsgZmFyOiAke2Zhcn1cXFwiIGxvb2stY29udHJvbHM9XFxcImVuYWJsZWQ6ICR7bG9vay1jb250cm9scy1lbmFibGVkfVxcXCIgd2FzZC1jb250cm9scz1cXFwiZW5hYmxlZDogJHt3YXNkLWNvbnRyb2xzLWVuYWJsZWR9XFxcIj5cXG4gICAgPGEtZW50aXR5IHZpc2libGU9XFxcIiR7Y3Vyc29yLXZpc2libGV9XFxcIiBwb3NpdGlvbj1cXFwiMCAwIC0ke2N1cnNvci1vZmZzZXR9XFxcIiBnZW9tZXRyeT1cXFwicHJpbWl0aXZlOiByaW5nOyByYWRpdXNPdXRlcjogMC4wMTY7IHJhZGl1c0lubmVyOiAwLjAxXFxcIiBtYXRlcmlhbD1cXFwiY29sb3I6ICR7Y3Vyc29yLWNvbG9yfTsgc2hhZGVyOiBmbGF0OyB0cmFuc3BhcmVudDogdHJ1ZTsgb3BhY2l0eTogJHtjdXJzb3Itb3BhY2l0eX1cXFwiIHNjYWxlPVxcXCIke2N1cnNvci1zY2FsZX0gJHtjdXJzb3Itc2NhbGV9ICR7Y3Vyc29yLXNjYWxlfVxcXCIgY3Vyc29yPVxcXCJtYXhEaXN0YW5jZTogJHtjdXJzb3ItbWF4ZGlzdGFuY2V9O1xcXCI+XFxuICAgIDwvYS1lbnRpdHk+XFxuICA8L2EtZW50aXR5PlxcbjwvdGVtcGxhdGU+XCIpO1xuXG59KSIsImRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24oKSB7XG52YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbmhlYWQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsXCI8dGVtcGxhdGUgaXM9XFxcImEtdGVtcGxhdGVcXFwiIGVsZW1lbnQ9XFxcImEtY29uZVxcXCIgcmFkaXVzLXRvcD1cXFwiMC4yXFxcIiByYWRpdXMtYm90dG9tPVxcXCIwLjc1XFxcIiBoZWlnaHQ9XFxcIjEuNVxcXCIgc2VnbWVudHMtcmFkaWFsPVxcXCIzNlxcXCIgc2VnbWVudHMtaGVpZ2h0PVxcXCIxXFxcIiB0aGV0YS1zdGFydD1cXFwiMFxcXCIgdGhldGEtbGVuZ3RoPVxcXCIzNjBcXFwiIG9wZW4tZW5kZWQ9XFxcImZhbHNlXFxcIiB0cmFuc2xhdGU9XFxcIjAgMCAwXFxcIiBjb2xvcj1cXFwiZ3JheVxcXCIgb3BhY2l0eT1cXFwiMS4wXFxcIiBzaGFkZXI9XFxcInN0YW5kYXJkXFxcIiB0cmFuc3BhcmVudD1cXFwidHJ1ZVxcXCIgbWV0YWxuZXNzPVxcXCIwLjBcXFwiIHJvdWdobmVzcz1cXFwiMC41XFxcIiBzaWRlPVxcXCJmcm9udFxcXCIgc3JjPVxcXCJcXFwiPlxcbiAgPGEtZW50aXR5IGdlb21ldHJ5PVxcXCJwcmltaXRpdmU6IGNvbmU7XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1RvcDogJHtyYWRpdXMtdG9wfTtcXG4gICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tOiAke3JhZGl1cy1ib3R0b219O1xcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNSYWRpYWw6ICR7c2VnbWVudHMtcmFkaWFsfTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNIZWlnaHQ6ICR7c2VnbWVudHMtaGVpZ2h0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgdGhldGFTdGFydDogJHt0aGV0YS1zdGFydH07XFxuICAgICAgICAgICAgICAgICAgICAgIHRoZXRhTGVuZ3RoOiAke3RoZXRhLWxlbmd0aH07XFxuICAgICAgICAgICAgICAgICAgICAgIG9wZW5FbmRlZDogJHtvcGVuLWVuZGVkfTtcXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiAke3RyYW5zbGF0ZX1cXFwiIG1hdGVyaWFsPVxcXCJjb2xvcjogJHtjb2xvcn07XFxuICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6ICR7b3BhY2l0eX07XFxuICAgICAgICAgICAgICAgICAgICAgIHNoYWRlcjogJHtzaGFkZXJ9O1xcbiAgICAgICAgICAgICAgICAgICAgICBtZXRhbG5lc3M6ICR7bWV0YWxuZXNzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzOiAke3JvdWdobmVzc307XFxuICAgICAgICAgICAgICAgICAgICAgIHNpZGU6ICR7c2lkZX07XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiAke3RyYW5zcGFyZW50fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJHtzcmN9KVxcXCI+PC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLWN1YmVcXFwiIHdpZHRoPVxcXCIxLjVcXFwiIGhlaWdodD1cXFwiMS41XFxcIiBkZXB0aD1cXFwiMS41XFxcIiB0cmFuc2xhdGU9XFxcIjAgMCAwXFxcIiBjb2xvcj1cXFwiZ3JheVxcXCIgb3BhY2l0eT1cXFwiMS4wXFxcIiBzaGFkZXI9XFxcInN0YW5kYXJkXFxcIiB0cmFuc3BhcmVudD1cXFwidHJ1ZVxcXCIgbWV0YWxuZXNzPVxcXCIwLjBcXFwiIHJvdWdobmVzcz1cXFwiMC41XFxcIiBzcmM9XFxcIlxcXCI+XFxuICA8YS1lbnRpdHkgZ2VvbWV0cnk9XFxcInByaW1pdGl2ZTogYm94O1xcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJHt3aWR0aH07XFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtoZWlnaHR9O1xcbiAgICAgICAgICAgICAgICAgICAgICBkZXB0aDogJHtkZXB0aH07XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZTogJHt0cmFuc2xhdGV9XFxcIiBtYXRlcmlhbD1cXFwiY29sb3I6ICR7Y29sb3J9O1xcbiAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAke29wYWNpdHl9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzaGFkZXI6ICR7c2hhZGVyfTtcXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6ICR7dHJhbnNwYXJlbnR9O1xcbiAgICAgICAgICAgICAgICAgICAgICBtZXRhbG5lc3M6ICR7bWV0YWxuZXNzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgcm91Z2huZXNzOiAke3JvdWdobmVzc307XFxuICAgICAgICAgICAgICAgICAgICAgIHNyYzogdXJsKCR7c3JjfSlcXFwiPjwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS1jdXJ2ZWRpbWFnZVxcXCIgcmFkaXVzPVxcXCIxXFxcIiBoZWlnaHQ9XFxcIjFcXFwiIHNlZ21lbnRzLXJhZGlhbD1cXFwiNDhcXFwiIHRoZXRhLXN0YXJ0PVxcXCIwXFxcIiB0aGV0YS1sZW5ndGg9XFxcIjM2MFxcXCIgb3BhY2l0eT1cXFwiMS4wXFxcIiB0cmFuc3BhcmVudD1cXFwidHJ1ZVxcXCIgc3JjPVxcXCJcXFwiPlxcbiAgPGEtZW50aXR5IGdlb21ldHJ5PVxcXCJwcmltaXRpdmU6IGN5bGluZGVyO1xcbiAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6ICR7cmFkaXVzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke2hlaWdodH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzUmFkaWFsOiAke3NlZ21lbnRzLXJhZGlhbH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzSGVpZ2h0OiAxO1xcbiAgICAgICAgICAgICAgICAgICAgICB0aGV0YVN0YXJ0OiAke3RoZXRhLXN0YXJ0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgdGhldGFMZW5ndGg6ICR7dGhldGEtbGVuZ3RofTtcXG4gICAgICAgICAgICAgICAgICAgICAgb3BlbkVuZGVkOiB0cnVlXFxcIiBzY2FsZT1cXFwiMSAxIC0xXFxcIiBtYXRlcmlhbD1cXFwib3BhY2l0eTogJHtvcGFjaXR5fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2hhZGVyOiBmbGF0O1xcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBkb3VibGU7XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiAke3RyYW5zcGFyZW50fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJHtzcmN9KVxcXCI+PC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLWN5bGluZGVyXFxcIiByYWRpdXM9XFxcIjAuNzVcXFwiIHJhZGl1cy10b3A9XFxcIjAuNzVcXFwiIHJhZGl1cy1ib3R0b209XFxcIjAuNzVcXFwiIGhlaWdodD1cXFwiMS41XFxcIiBzZWdtZW50cy1yYWRpYWw9XFxcIjM2XFxcIiBzZWdtZW50cy1oZWlnaHQ9XFxcIjFcXFwiIHRoZXRhLXN0YXJ0PVxcXCIwXFxcIiB0aGV0YS1sZW5ndGg9XFxcIjM2MFxcXCIgb3Blbi1lbmRlZD1cXFwiZmFsc2VcXFwiIHRyYW5zbGF0ZT1cXFwiMCAwIDBcXFwiIGNvbG9yPVxcXCJncmF5XFxcIiBvcGFjaXR5PVxcXCIxLjBcXFwiIHNoYWRlcj1cXFwic3RhbmRhcmRcXFwiIHRyYW5zcGFyZW50PVxcXCJ0cnVlXFxcIiBtZXRhbG5lc3M9XFxcIjAuMFxcXCIgcm91Z2huZXNzPVxcXCIwLjVcXFwiIHNpZGU9XFxcImZyb250XFxcIiBzcmM9XFxcIlxcXCI+XFxuICA8YS1lbnRpdHkgZ2VvbWV0cnk9XFxcInByaW1pdGl2ZTogY3lsaW5kZXI7XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogJHtyYWRpdXN9O1xcbiAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3A6ICR7cmFkaXVzLXRvcH07XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c0JvdHRvbTogJHtyYWRpdXMtYm90dG9tfTtcXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAke2hlaWdodH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzUmFkaWFsOiAke3NlZ21lbnRzLXJhZGlhbH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzSGVpZ2h0OiAke3NlZ21lbnRzLWhlaWdodH07XFxuICAgICAgICAgICAgICAgICAgICAgIHRoZXRhU3RhcnQ6ICR7dGhldGEtc3RhcnR9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0aGV0YUxlbmd0aDogJHt0aGV0YS1sZW5ndGh9O1xcbiAgICAgICAgICAgICAgICAgICAgICBvcGVuRW5kZWQ6ICR7b3Blbi1lbmRlZH07XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZTogJHt0cmFuc2xhdGV9XFxcIiBtYXRlcmlhbD1cXFwiY29sb3I6ICR7Y29sb3J9O1xcbiAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAke29wYWNpdHl9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzaGFkZXI6ICR7c2hhZGVyfTtcXG4gICAgICAgICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAke21ldGFsbmVzc307XFxuICAgICAgICAgICAgICAgICAgICAgIHJvdWdobmVzczogJHtyb3VnaG5lc3N9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlOiAke3NpZGV9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogJHt0cmFuc3BhcmVudH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNyYzogdXJsKCR7c3JjfSlcXFwiPjwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS1mcmFtZVxcXCIgc2l6ZT1cXFwiMTBcXFwiIHRoaWNrbmVzcz1cXFwiMC4xXFxcIiBjb2xvcj1cXFwiIzQwNDA0MFxcXCI+XFxuICA8YS1jdWJlIHBvc2l0aW9uPVxcXCI1IDUgMFxcXCIgcm90YXRpb249XFxcIjAgMCAwXFxcIiB3aWR0aD1cXFwiJHt0aGlja25lc3N9XFxcIiBoZWlnaHQ9XFxcIiR7dGhpY2tuZXNzfVxcXCIgZGVwdGg9XFxcIiR7c2l6ZX1cXFwiIGNvbG9yPVxcXCIke2NvbG9yfVxcXCI+PC9hLWN1YmU+XFxuICA8YS1jdWJlIHBvc2l0aW9uPVxcXCI1IC01IDBcXFwiIHJvdGF0aW9uPVxcXCIwIDAgMFxcXCIgd2lkdGg9XFxcIiR7dGhpY2tuZXNzfVxcXCIgaGVpZ2h0PVxcXCIke3RoaWNrbmVzc31cXFwiIGRlcHRoPVxcXCIke3NpemV9XFxcIiBjb2xvcj1cXFwiJHtjb2xvcn1cXFwiPjwvYS1jdWJlPlxcbiAgPGEtY3ViZSBwb3NpdGlvbj1cXFwiLTUgNSAwXFxcIiByb3RhdGlvbj1cXFwiMCAwIDBcXFwiIHdpZHRoPVxcXCIke3RoaWNrbmVzc31cXFwiIGhlaWdodD1cXFwiJHt0aGlja25lc3N9XFxcIiBkZXB0aD1cXFwiJHtzaXplfVxcXCIgY29sb3I9XFxcIiR7Y29sb3J9XFxcIj48L2EtY3ViZT5cXG4gIDxhLWN1YmUgcG9zaXRpb249XFxcIi01IC01IDBcXFwiIHJvdGF0aW9uPVxcXCIwIDAgMFxcXCIgd2lkdGg9XFxcIiR7dGhpY2tuZXNzfVxcXCIgaGVpZ2h0PVxcXCIke3RoaWNrbmVzc31cXFwiIGRlcHRoPVxcXCIke3NpemV9XFxcIiBjb2xvcj1cXFwiJHtjb2xvcn1cXFwiPjwvYS1jdWJlPlxcblxcbiAgPGEtY3ViZSBwb3NpdGlvbj1cXFwiMCA1IDVcXFwiIHJvdGF0aW9uPVxcXCIwIDkwIDBcXFwiIHdpZHRoPVxcXCIke3RoaWNrbmVzc31cXFwiIGhlaWdodD1cXFwiJHt0aGlja25lc3N9XFxcIiBkZXB0aD1cXFwiJHtzaXplfVxcXCIgY29sb3I9XFxcIiR7Y29sb3J9XFxcIj48L2EtY3ViZT5cXG4gIDxhLWN1YmUgcG9zaXRpb249XFxcIjAgNSAtNVxcXCIgcm90YXRpb249XFxcIjAgOTAgMFxcXCIgd2lkdGg9XFxcIiR7dGhpY2tuZXNzfVxcXCIgaGVpZ2h0PVxcXCIke3RoaWNrbmVzc31cXFwiIGRlcHRoPVxcXCIke3NpemV9XFxcIiBjb2xvcj1cXFwiJHtjb2xvcn1cXFwiPjwvYS1jdWJlPlxcbiAgPGEtY3ViZSBwb3NpdGlvbj1cXFwiMCAtNSA1XFxcIiByb3RhdGlvbj1cXFwiMCA5MCAwXFxcIiB3aWR0aD1cXFwiJHt0aGlja25lc3N9XFxcIiBoZWlnaHQ9XFxcIiR7dGhpY2tuZXNzfVxcXCIgZGVwdGg9XFxcIiR7c2l6ZX1cXFwiIGNvbG9yPVxcXCIke2NvbG9yfVxcXCI+PC9hLWN1YmU+XFxuICA8YS1jdWJlIHBvc2l0aW9uPVxcXCIwIC01IC01XFxcIiByb3RhdGlvbj1cXFwiMCA5MCAwXFxcIiB3aWR0aD1cXFwiJHt0aGlja25lc3N9XFxcIiBoZWlnaHQ9XFxcIiR7dGhpY2tuZXNzfVxcXCIgZGVwdGg9XFxcIiR7c2l6ZX1cXFwiIGNvbG9yPVxcXCIke2NvbG9yfVxcXCI+PC9hLWN1YmU+XFxuXFxuICA8YS1jdWJlIHBvc2l0aW9uPVxcXCI1IDAgNVxcXCIgcm90YXRpb249XFxcIjkwIDAgMFxcXCIgd2lkdGg9XFxcIiR7dGhpY2tuZXNzfVxcXCIgaGVpZ2h0PVxcXCIke3RoaWNrbmVzc31cXFwiIGRlcHRoPVxcXCIke3NpemV9XFxcIiBjb2xvcj1cXFwiJHtjb2xvcn1cXFwiPjwvYS1jdWJlPlxcbiAgPGEtY3ViZSBwb3NpdGlvbj1cXFwiNSAwIC01XFxcIiByb3RhdGlvbj1cXFwiOTAgMCAwXFxcIiB3aWR0aD1cXFwiJHt0aGlja25lc3N9XFxcIiBoZWlnaHQ9XFxcIiR7dGhpY2tuZXNzfVxcXCIgZGVwdGg9XFxcIiR7c2l6ZX1cXFwiIGNvbG9yPVxcXCIke2NvbG9yfVxcXCI+PC9hLWN1YmU+XFxuICA8YS1jdWJlIHBvc2l0aW9uPVxcXCItNSAwIDVcXFwiIHJvdGF0aW9uPVxcXCI5MCAwIDBcXFwiIHdpZHRoPVxcXCIke3RoaWNrbmVzc31cXFwiIGhlaWdodD1cXFwiJHt0aGlja25lc3N9XFxcIiBkZXB0aD1cXFwiJHtzaXplfVxcXCIgY29sb3I9XFxcIiR7Y29sb3J9XFxcIj48L2EtY3ViZT5cXG4gIDxhLWN1YmUgcG9zaXRpb249XFxcIi01IDAgLTVcXFwiIHJvdGF0aW9uPVxcXCI5MCAwIDBcXFwiIHdpZHRoPVxcXCIke3RoaWNrbmVzc31cXFwiIGhlaWdodD1cXFwiJHt0aGlja25lc3N9XFxcIiBkZXB0aD1cXFwiJHtzaXplfVxcXCIgY29sb3I9XFxcIiR7Y29sb3J9XFxcIj48L2EtY3ViZT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLWltYWdlXFxcIiB3aWR0aD1cXFwiMS43NVxcXCIgaGVpZ2h0PVxcXCIxLjc1XFxcIiBvcGFjaXR5PVxcXCIxLjBcXFwiIHNyYz1cXFwiXFxcIj5cXG4gIDxhLWVudGl0eSBnZW9tZXRyeT1cXFwicHJpbWl0aXZlOiBwbGFuZTtcXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7d2lkdGh9O1xcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fVxcXCIgbWF0ZXJpYWw9XFxcInNoYWRlcjogZmxhdDtcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJHtzcmN9KTtcXG4gICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogJHtvcGFjaXR5fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2lkZTogZG91YmxlO1xcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZVxcXCI+XFxuICA8L2EtZW50aXR5PlxcbjwvdGVtcGxhdGU+XCIpO1xuXG59KSIsImRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24oKSB7XG52YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbmhlYWQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsXCI8dGVtcGxhdGUgaXM9XFxcImEtdGVtcGxhdGVcXFwiIGVsZW1lbnQ9XFxcImEtbGlnaHRcXFwiIGFuZ2xlPVxcXCI2MFxcXCIgY29sb3I9XFxcIiNmZmZcXFwiIGdyb3VuZC1jb2xvcj1cXFwiI2ZmZlxcXCIgZGVjYXk9XFxcIjFcXFwiIGRpc3RhbmNlPVxcXCIwLjBcXFwiIGV4cG9uZW50PVxcXCIxMC4wXFxcIiBpbnRlbnNpdHk9XFxcIjEuMFxcXCIgdHlwZT1cXFwiZGlyZWN0aW9uYWxcXFwiPlxcbiAgPGEtZW50aXR5IGxpZ2h0PVxcXCJhbmdsZTogJHthbmdsZX07XFxuICAgICAgICAgICAgICAgICAgIGNvbG9yOiAke2NvbG9yfTtcXG4gICAgICAgICAgICAgICAgICAgZ3JvdW5kQ29sb3I6ICR7Z3JvdW5kLWNvbG9yfTtcXG4gICAgICAgICAgICAgICAgICAgZGVjYXk6ICR7ZGVjYXl9O1xcbiAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogJHtkaXN0YW5jZX07XFxuICAgICAgICAgICAgICAgICAgIGV4cG9uZW50OiAke2V4cG9uZW50fTtcXG4gICAgICAgICAgICAgICAgICAgaW50ZW5zaXR5OiAke2ludGVuc2l0eX07XFxuICAgICAgICAgICAgICAgICAgIHR5cGU6ICR7dHlwZX1cXFwiPlxcbiAgPC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLW1vZGVsXFxcIiBvcGFjaXR5PVxcXCIxLjBcXFwiIHNyYz1cXFwiXFxcIiBmb3JtYXQ9XFxcImNvbGxhZGFcXFwiPlxcbiAgPGEtZW50aXR5IG1hdGVyaWFsPVxcXCJvcGFjaXR5OiAke29wYWNpdHl9XFxcIiBsb2FkZXI9XFxcInNyYzogdXJsKCR7c3JjfSk7IGZvcm1hdDogJHtmb3JtYXR9XFxcIj5cXG4gIDwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS1wbGFuZVxcXCIgd2lkdGg9XFxcIjEuNzVcXFwiIGhlaWdodD1cXFwiMS43NVxcXCIgdHJhbnNsYXRlPVxcXCIwIDAgMFxcXCIgY29sb3I9XFxcImdyYXlcXFwiIG9wYWNpdHk9XFxcIjEuMFxcXCIgc2hhZGVyPVxcXCJzdGFuZGFyZFxcXCIgdHJhbnNwYXJlbnQ9XFxcInRydWVcXFwiIG1ldGFsbmVzcz1cXFwiMC4wXFxcIiByb3VnaG5lc3M9XFxcIjAuNVxcXCIgc3JjPVxcXCJcXFwiPlxcbiAgPGEtZW50aXR5IGdlb21ldHJ5PVxcXCJwcmltaXRpdmU6IHBsYW5lO1xcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICR7d2lkdGh9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGU6ICR7dHJhbnNsYXRlfVxcXCIgbWF0ZXJpYWw9XFxcImNvbG9yOiAke2NvbG9yfTtcXG4gICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogJHtvcGFjaXR5fTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2hhZGVyOiAke3NoYWRlcn07XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50OiAke3RyYW5zcGFyZW50fTtcXG4gICAgICAgICAgICAgICAgICAgICAgbWV0YWxuZXNzOiAke21ldGFsbmVzc307XFxuICAgICAgICAgICAgICAgICAgICAgIHJvdWdobmVzczogJHtyb3VnaG5lc3N9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzaWRlOiBkb3VibGU7XFxuICAgICAgICAgICAgICAgICAgICAgIHNyYzogdXJsKCR7c3JjfSlcXFwiPjwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS1yaW5nXFxcIiByYWRpdXMtaW5uZXI9XFxcIjFcXFwiIHJhZGl1cy1vdXRlcj1cXFwiMlxcXCIgc2VnbWVudHMtdGhldGE9XFxcIjIwXFxcIiBzZWdtZW50cy1waGk9XFxcIjVcXFwiIHRoZXRhLXN0YXJ0PVxcXCIwXFxcIiB0aGV0YS1sZW5ndGg9XFxcIjM2MFxcXCIgdHJhbnNsYXRlPVxcXCIwIDAgMFxcXCIgY29sb3I9XFxcImdyYXlcXFwiIG9wYWNpdHk9XFxcIjEuMFxcXCIgc2hhZGVyPVxcXCJzdGFuZGFyZFxcXCIgdHJhbnNwYXJlbnQ9XFxcInRydWVcXFwiIG1ldGFsbmVzcz1cXFwiMC4wXFxcIiByb3VnaG5lc3M9XFxcIjAuNVxcXCIgc3JjPVxcXCJcXFwiPlxcbiAgPGEtZW50aXR5IGdlb21ldHJ5PVxcXCJwcmltaXRpdmU6IHJpbmc7XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c0lubmVyOiAke3JhZGl1cy1pbm5lcn07XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c091dGVyOiAke3JhZGl1cy1vdXRlcn07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzVGhldGE6ICR7c2VnbWVudHMtdGhldGF9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1BoaTogJHtzZWdtZW50cy1waGl9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0aGV0YVN0YXJ0OiAke3RoZXRhLXN0YXJ0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgdGhldGFMZW5ndGg6ICR7dGhldGEtbGVuZ3RofTtcXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiAke3RyYW5zbGF0ZX1cXFwiIG1hdGVyaWFsPVxcXCJjb2xvcjogJHtjb2xvcn07XFxuICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6ICR7b3BhY2l0eX07XFxuICAgICAgICAgICAgICAgICAgICAgIHNoYWRlcjogJHtzaGFkZXJ9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogJHt0cmFuc3BhcmVudH07XFxuICAgICAgICAgICAgICAgICAgICAgIG1ldGFsbmVzczogJHttZXRhbG5lc3N9O1xcbiAgICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6ICR7cm91Z2huZXNzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJHtzcmN9KVxcXCI+PC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLXNreVxcXCIgc3JjPVxcXCJcXFwiIGNvbG9yPVxcXCIjRkZGXFxcIiByYWRpdXM9XFxcIjUwMDBcXFwiIHNlZ21lbnRzLXdpZHRoPVxcXCI2NFxcXCIgc2VnbWVudHMtaGVpZ2h0PVxcXCI2NFxcXCI+XFxuICA8YS1lbnRpdHkgZ2VvbWV0cnk9XFxcInByaW1pdGl2ZTogc3BoZXJlO1xcbiAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6ICR7cmFkaXVzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNXaWR0aDogJHtzZWdtZW50cy13aWR0aH07XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzSGVpZ2h0OiAke3NlZ21lbnRzLWhlaWdodH1cXFwiIG1hdGVyaWFsPVxcXCJzaGFkZXI6IGZsYXQ7IFxcbiAgICAgICAgICAgICAgICAgICAgICBzcmM6IHVybCgke3NyY30pO1xcbiAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJHtjb2xvcn07XFxuICAgICAgICAgICAgICAgICAgICAgIGZvZzogZmFsc2VcXFwiIHNjYWxlPVxcXCItMSAxIDFcXFwiPlxcbiAgPC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLXNwaGVyZVxcXCIgcmFkaXVzPVxcXCIwLjg1XFxcIiBzZWdtZW50cy13aWR0aD1cXFwiMzZcXFwiIHNlZ21lbnRzLWhlaWdodD1cXFwiMThcXFwiIHRyYW5zbGF0ZT1cXFwiMCAwIDBcXFwiIGNvbG9yPVxcXCJncmF5XFxcIiBvcGFjaXR5PVxcXCIxLjBcXFwiIHNoYWRlcj1cXFwic3RhbmRhcmRcXFwiIHRyYW5zcGFyZW50PVxcXCJ0cnVlXFxcIiBtZXRhbG5lc3M9XFxcIjAuMFxcXCIgcm91Z2huZXNzPVxcXCIwLjVcXFwiIHNyYz1cXFwiXFxcIj5cXG4gIDxhLWVudGl0eSBnZW9tZXRyeT1cXFwicHJpbWl0aXZlOiBzcGhlcmU7XFxuICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogJHtyYWRpdXN9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1dpZHRoOiAke3NlZ21lbnRzLXdpZHRofTtcXG4gICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNIZWlnaHQ6ICR7c2VnbWVudHMtaGVpZ2h0fTtcXG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlOiAke3RyYW5zbGF0ZX1cXFwiIG1hdGVyaWFsPVxcXCJjb2xvcjogJHtjb2xvcn07XFxuICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6ICR7b3BhY2l0eX07XFxuICAgICAgICAgICAgICAgICAgICAgIHNoYWRlcjogJHtzaGFkZXJ9O1xcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogJHt0cmFuc3BhcmVudH07XFxuICAgICAgICAgICAgICAgICAgICAgIG1ldGFsbmVzczogJHttZXRhbG5lc3N9O1xcbiAgICAgICAgICAgICAgICAgICAgICByb3VnaG5lc3M6ICR7cm91Z2huZXNzfTtcXG4gICAgICAgICAgICAgICAgICAgICAgc3JjOiB1cmwoJHtzcmN9KVxcXCI+PC9hLWVudGl0eT5cXG48L3RlbXBsYXRlPlwiKTtcblxufSkiLCJkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCkge1xudmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5oZWFkLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLFwiPHRlbXBsYXRlIGlzPVxcXCJhLXRlbXBsYXRlXFxcIiBlbGVtZW50PVxcXCJhLXZpZGVvXFxcIiBzcmM9XFxcIlxcXCIgd2lkdGg9XFxcIjNcXFwiIGhlaWdodD1cXFwiMS43NVxcXCIgdHJhbnNsYXRlPVxcXCIwIDAgMFxcXCIgYXV0b3BsYXk9XFxcInRydWVcXFwiIGxvb3A9XFxcInRydWVcXFwiIGNyb3Nzb3JpZ2luPVxcXCJhbm9ueW1vdXNcXFwiPlxcbiAgPHZpZGVvIGlkPVxcXCJhLXZpZGVvLSR7X19jb3VudGVyX199XFxcIiBzcmM9XFxcIiR7c3JjfVxcXCIgd2lkdGg9XFxcIiR7d2lkdGh9XFxcIiBoZWlnaHQ9XFxcIiR7aGVpZ2h0fVxcXCIgYXV0b3BsYXk9XFxcIiR7YXV0b3BsYXl9XFxcIiBsb29wPVxcXCIke2xvb3B9XFxcIiBjcm9zc29yaWdpbj1cXFwiJHtjcm9zc09yaWdpbn1cXFwiIHN0eWxlPVxcXCJkaXNwbGF5OiBub25lXFxcIj5cXG4gIDwvdmlkZW8+XFxuICA8YS1lbnRpdHkgZ2VvbWV0cnk9XFxcInByaW1pdGl2ZTogcGxhbmU7XFxuICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJHtoZWlnaHR9O1xcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJHt3aWR0aH07XFxuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZTogJHt0cmFuc2xhdGV9XFxcIiBtYXRlcmlhbD1cXFwic2hhZGVyOiBmbGF0OyBzcmM6ICNhLXZpZGVvXyR7X19jb3VudGVyX199XFxcIj5cXG4gIDwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwiZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjx0ZW1wbGF0ZSBpcz1cXFwiYS10ZW1wbGF0ZVxcXCIgZWxlbWVudD1cXFwiYS12aWRlb3NwaGVyZVxcXCIgc3JjPVxcXCJcXFwiIHJhZGl1cz1cXFwiNTAwMFxcXCIgc2VnbWVudHMtd2lkdGg9XFxcIjY0XFxcIiBzZWdtZW50cy1oZWlnaHQ9XFxcIjY0XFxcIiBhdXRvcGxheT1cXFwidHJ1ZVxcXCIgbG9vcD1cXFwidHJ1ZVxcXCIgY3Jvc3NvcmlnaW49XFxcImFub255bW91c1xcXCI+XFxuICA8dmlkZW8gaWQ9XFxcImEtdmlkZW9zcGhlcmUtJHtfX2NvdW50ZXJfX31cXFwiIHNyYz1cXFwiJHtzcmN9XFxcIiB3aWR0aD1cXFwiMTAwMFxcXCIgaGVpZ2h0PVxcXCI1MDBcXFwiIGF1dG9wbGF5PVxcXCIke2F1dG9wbGF5fVxcXCIgbG9vcD1cXFwiJHtsb29wfVxcXCIgY3Jvc3NvcmlnaW49XFxcIiR7Y3Jvc3NPcmlnaW59XFxcIiBzdHlsZT1cXFwiZGlzcGxheTogbm9uZVxcXCI+XFxuICA8L3ZpZGVvPlxcbiAgPGEtZW50aXR5IGdlb21ldHJ5PVxcXCJwcmltaXRpdmU6IHNwaGVyZTtcXG4gICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAke3JhZGl1c307XFxuICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzV2lkdGg6ICR7c2VnbWVudHMtd2lkdGh9O1xcbiAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c0hlaWdodDogJHtzZWdtZW50cy1oZWlnaHR9XFxcIiBtYXRlcmlhbD1cXFwic2hhZGVyOiBmbGF0OyBzcmM6ICNhLXZpZGVvc3BoZXJlLSR7X19jb3VudGVyX199XFxcIiBzY2FsZT1cXFwiLTEgMSAxXFxcIj5cXG4gIDwvYS1lbnRpdHk+XFxuPC90ZW1wbGF0ZT5cIik7XG5cbn0pIiwicmVxdWlyZShcIi4vYS1jYW1lcmEuaHRtbFwiKTtcbnJlcXVpcmUoXCIuL2EtY29uZS5odG1sXCIpO1xucmVxdWlyZShcIi4vYS1jdWJlLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLWN1cnZlZGltYWdlLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLWN5bGluZGVyLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLWZyYW1lLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLWltYWdlLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLWxpZ2h0Lmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLW1vZGVsLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLXBsYW5lLmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLXJpbmcuaHRtbFwiKTtcbnJlcXVpcmUoXCIuL2Etc2t5L2luZGV4Lmh0bWxcIik7XG5yZXF1aXJlKFwiLi9hLXNwaGVyZS5odG1sXCIpO1xucmVxdWlyZShcIi4vYS12aWRlby5odG1sXCIpO1xucmVxdWlyZShcIi4vYS12aWRlb3NwaGVyZS5odG1sXCIpO1xuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpIHtcbnZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuaGVhZC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIixcIjxtZXRhIGNoYXJzZXQ9XFxcInV0Zi04XFxcIj5cIik7XG5cbn0pIiwicmVxdWlyZSgnZXM2LXByb21pc2UnKS5wb2x5ZmlsbCgpOyAgLy8gUG9seWZpbGwgYFByb21pc2VgLlxucmVxdWlyZSgncHJlc2VudCcpOyAgLy8gUG9seWZpbGwgYHBlcmZvcm1hbmNlLm5vdygpYC5cblxuLy8gVE9ETzogRXh0cmFjdCB0byBhZnJhbWUtcHJpbWl0aXZlcy5cbi8vIEhUTUwgSW1wb3J0cyBwb2x5ZmlsbCBtdXN0IGNvbWUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZS5cbmlmICghKCdpbXBvcnQnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSkpIHtcbiAgcmVxdWlyZSgnLi4vbGliL3ZlbmRvci9IVE1MSW1wb3J0cycpO1xufVxuXG5yZXF1aXJlKCcuLi9zdHlsZS9hZnJhbWUtY29yZS5jc3MnKTtcbnJlcXVpcmUoJy4uL3N0eWxlL3JTdGF0cy5jc3MnKTtcblxuLy8gUmVxdWlyZWQgYmVmb3JlIGBBRW50aXR5YCBzbyB0aGF0IGFsbCBjb21wb25lbnRzIGFyZSByZWdpc3RlcmVkLlxudmFyIEFTY2VuZSA9IHJlcXVpcmUoJy4vY29yZS9hLXNjZW5lJyk7XG52YXIgY29tcG9uZW50cyA9IHJlcXVpcmUoJy4vY29yZS9jb21wb25lbnQnKS5jb21wb25lbnRzO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnLi91dGlscy9kZWJ1ZycpO1xudmFyIHJlZ2lzdGVyQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb3JlL2NvbXBvbmVudCcpLnJlZ2lzdGVyQ29tcG9uZW50O1xudmFyIHJlZ2lzdGVyRWxlbWVudCA9IHJlcXVpcmUoJy4vY29yZS9hLXJlZ2lzdGVyLWVsZW1lbnQnKTtcbi8vIEV4cG9ydHMgVEhSRUUgdG8gd2luZG93IHNvIHRocmVlLmpzIGNhbiBiZSB1c2VkIHdpdGhvdXQgYWx0ZXJhdGlvbi5cbnZhciBUSFJFRSA9IHdpbmRvdy5USFJFRSA9IHJlcXVpcmUoJy4uL2xpYi90aHJlZScpO1xudmFyIFRXRUVOID0gd2luZG93LlRXRUVOID0gcmVxdWlyZSgndHdlZW4uanMnKTtcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvJyk7XG5cbnJlcXVpcmUoJy4vY29tcG9uZW50cy9pbmRleCcpOyAgLy8gUmVnaXN0ZXIgY29yZSBjb21wb25lbnRzLlxudmFyIEFOb2RlID0gcmVxdWlyZSgnLi9jb3JlL2Etbm9kZScpO1xudmFyIEFFbnRpdHkgPSByZXF1aXJlKCcuL2NvcmUvYS1lbnRpdHknKTsgIC8vIERlcGVuZHMgb24gQU5vZGUgYW5kIGNvcmUgY29tcG9uZW50cy5cblxuLy8gV2VidnIgcG9seWZpbGwgY29uZmlndXJhdGlvbi5cbndpbmRvdy5oYXNOb25Qb2x5ZmlsbFdlYlZSU3VwcG9ydCA9ICEhbmF2aWdhdG9yLmdldFZSRGV2aWNlcztcbndpbmRvdy5XZWJWUkNvbmZpZyA9IHtcbiAgVE9VQ0hfUEFOTkVSX0RJU0FCTEVEOiB0cnVlLFxuICBNT1VTRV9LRVlCT0FSRF9DT05UUk9MU19ESVNBQkxFRDogdHJ1ZVxufTtcbnJlcXVpcmUoJ3dlYnZyLXBvbHlmaWxsJyk7XG5cbnJlcXVpcmUoJy4vY29yZS9hLWFuaW1hdGlvbicpO1xucmVxdWlyZSgnLi9jb3JlL2EtYXNzZXRzJyk7XG5yZXF1aXJlKCcuL2NvcmUvYS1jdWJlbWFwJyk7XG5yZXF1aXJlKCcuL2NvcmUvYS1taXhpbicpO1xucmVxdWlyZSgnLi9jb3JlL2Etc2NlbmUnKTtcblxuLy8gVE9ETzogRXh0cmFjdCB0byBhZnJhbWUtcHJpbWl0aXZlcy5cbnZhciBjb3JlRWxlbWVudHMgPSByZXF1aXJlKCcuL2VsZW1lbnRzLycpO1xudmFyIHJlZ2lzdGVyVGVtcGxhdGUgPSByZXF1aXJlKCcuL2VsZW1lbnRzL2xpYi9yZWdpc3Rlci10ZW1wbGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUVudGl0eTogQUVudGl0eSxcbiAgQU5vZGU6IEFOb2RlLFxuICBBU2NlbmU6IEFTY2VuZSxcbiAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgZGVidWc6IGRlYnVnLFxuICByZWdpc3RlckNvbXBvbmVudDogcmVnaXN0ZXJDb21wb25lbnQsXG4gIHJlZ2lzdGVyRWxlbWVudDogcmVnaXN0ZXJFbGVtZW50LFxuICBUSFJFRTogVEhSRUUsXG4gIHV0aWxzOiB1dGlscyxcbiAgdmVyc2lvbjogcGtnLnZlcnNpb24sXG5cbiAgLy8gVE9ETzogRXh0cmFjdCB0byBhZnJhbWUtcHJpbWl0aXZlcy5cbiAgZWxlbWVudHM6IHtcbiAgICBjb3JlOiBjb3JlRWxlbWVudHNcbiAgfSxcbiAgcmVnaXN0ZXJUZW1wbGF0ZTogcmVnaXN0ZXJUZW1wbGF0ZVxufTtcbiIsIi8vIENvb3JkaW5hdGUgc3RyaW5nIHJlZ2V4LiBIYW5kbGVzIG5lZ2F0aXZlLCBwb3NpdGl2ZSwgYW5kIGRlY2ltYWxzLlxudmFyIHJlZ2V4ID0gL1xccyooLT9cXGQqXFwuezAsMX1cXGQrKVxccyooLT9cXGQqXFwuezAsMX1cXGQrKVxccyooLT9cXGQqXFwuezAsMX1cXGQrKVxccyovO1xubW9kdWxlLmV4cG9ydHMucmVnZXggPSByZWdleDtcblxuLyoqXG4gKiBQYXJzZXMgY29vcmRpbmF0ZXMgZnJvbSBhbiBcInggeSB6XCIgc3RyaW5nLlxuICogRXhhbXBsZTogXCIzIDEwIC01XCIgdG8ge3g6IDMsIHk6IDEwLCB6OiAtNX0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCAtIEFuIFwieCB5IHpcIiBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdHMgLSBmYWxsYmFjayB2YWx1ZS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIGtleXMgW3gsIHksIHpdLlxuICovXG5mdW5jdGlvbiBwYXJzZSAodmFsdWUsIGRlZmF1bHRDb29yZGluYXRlKSB7XG4gIHZhciBjb29yZGluYXRlO1xuXG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7IHJldHVybiB2YWx1ZTsgfVxuXG4gIGlmICghZGVmYXVsdENvb3JkaW5hdGUgJiYgdGhpcy5zY2hlbWEpIHtcbiAgICBpZiAoJ2RlZmF1bHQnIGluIHRoaXMuc2NoZW1hKSB7XG4gICAgICBkZWZhdWx0Q29vcmRpbmF0ZSA9IHRoaXMuc2NoZW1hLmRlZmF1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRDb29yZGluYXRlID0gdGhpcy5zY2hlbWE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdENvb3JkaW5hdGU7XG4gIH1cblxuICBjb29yZGluYXRlID0gdmFsdWUudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHg6IHBhcnNlRmxvYXQoY29vcmRpbmF0ZVswXSB8fCBkZWZhdWx0Q29vcmRpbmF0ZS54KSxcbiAgICB5OiBwYXJzZUZsb2F0KGNvb3JkaW5hdGVbMV0gfHwgZGVmYXVsdENvb3JkaW5hdGUueSksXG4gICAgejogcGFyc2VGbG9hdChjb29yZGluYXRlWzJdIHx8IGRlZmF1bHRDb29yZGluYXRlLnopXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG4vKipcbiAqIFN0cmluZ2lmaWVzIGNvb3JkaW5hdGVzIGZyb20gYW4gb2JqZWN0IHdpdGgga2V5cyBbeCB5IHpdLlxuICogRXhhbXBsZToge3g6IDMsIHk6IDEwLCB6OiAtNX0gdG8gXCIzIDEwIC01XCIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBkYXRhIC0gQW4gb2JqZWN0IHdpdGgga2V5cyBbeCB5IHpdLlxuICogQHJldHVybnMge3N0cmluZ30gQW4gXCJ4IHkgelwiIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChkYXRhKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGRhdGE7IH1cbiAgcmV0dXJuIFtkYXRhLngsIGRhdGEueSwgZGF0YS56XS5qb2luKCcgJyk7XG59XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2x9XG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gcmVnZXgudGVzdCh2YWx1ZSk7XG59O1xuIiwidmFyIGRlYnVnTGliID0gcmVxdWlyZSgnZGVidWcnKTtcbnZhciBleHRlbmQgPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBzZXR0aW5ncyA9IHtcbiAgY29sb3JzOiB7XG4gICAgZXJyb3I6ICdyZWQnLFxuICAgIGluZm86ICdncmF5JyxcbiAgICB3YXJuOiAnb3JhbmdlJyxcbiAgICB3YXJuaW5nOiAnb3JhbmdlJ1xuICB9XG59O1xuXG4vKipcbiAqIE1vbmtleXBhdGNoZXMgYGRlYnVnYCBzbyB3ZSBjYW4gY29sb3JpemUgZXJyb3Ivd2FybmluZyBtZXNzYWdlcy5cbiAqXG4gKiAoU2VlIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvZGVidWcvaXNzdWVzLzEzNylcbiAqL1xudmFyIGRlYnVnID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkge1xuICB2YXIgZCA9IGRlYnVnTGliKG5hbWVzcGFjZSk7XG5cbiAgZC5jb2xvciA9IGdldERlYnVnTmFtZXNwYWNlQ29sb3IobmFtZXNwYWNlKTtcblxuICByZXR1cm4gZDtcbn07XG5leHRlbmQoZGVidWcsIGRlYnVnTGliKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBuYW1lc3BhY2UgKGUuZy4sIGBlcnJvcmAsIGB3YXJuYCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogICBUaGUgZGVidWcgbG9nZ2VyJ3MgbmFtZXNwYWNlIChlLmcuLCBgY29tcG9uZW50czpnZW9tZXRyeTp3YXJuYCkuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdHlwZSBvZiB0aGUgbmFtZXNwYWNlIChlLmcuLCBgd2FybmApLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldERlYnVnTmFtZXNwYWNlVHlwZSAobmFtZXNwYWNlKSB7XG4gIHZhciBjaHVua3MgPSBuYW1lc3BhY2Uuc3BsaXQoJzonKTtcblxuICByZXR1cm4gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTsgIC8vIFJldHVybiB0aGUgbGFzdCBvbmVcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb2xvciBvZiB0aGUgbmFtZXNwYWNlIChlLmcuLCBgb3JhbmdlYCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogICBUaGUgZGVidWcgbG9nZ2VyJ3MgbmFtZXNwYWNlIChlLmcuLCBgY29tcG9uZW50czpnZW9tZXRyeTp3YXJuYCkuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29sb3Igb2YgdGhlIG5hbWVzcGFjZSAoZS5nLiwgYG9yYW5nZWApLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldERlYnVnTmFtZXNwYWNlQ29sb3IgKG5hbWVzcGFjZSkge1xuICB2YXIgdHlwZSA9IGdldERlYnVnTmFtZXNwYWNlVHlwZShuYW1lc3BhY2UpO1xuXG4gIHZhciBjb2xvciA9IHNldHRpbmdzLmNvbG9ycyAmJiBzZXR0aW5ncy5jb2xvcnNbdHlwZV07XG5cbiAgcmV0dXJuIGNvbG9yIHx8IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBgbG9jYWxTdG9yYWdlYCBpZiBwb3NzaWJsZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIFNhZmFyaSB0aHJvd3Mgd2hlbiBhIHVzZXIgZGlzYWJsZXNcbiAqIGNvb2tpZXMgb3IgYGxvY2FsU3RvcmFnZWAgYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJucyB7bG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0b3JhZ2UgKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBUbyBlbmFibGUgY29uc29sZSBsb2dnaW5nLCB0eXBlIHRoaXMgaW4gdGhlIENvbnNvbGUgb2YgeW91ciBEZXYgVG9vbHM6XG4gKlxuICogICBsb2NhbFN0b3JhZ2UubG9ncyA9IDFcbiAqXG4gKiBUbyBkaXNhYmxlIGNvbnNvbGUgbG9nZ2luZzpcbiAqXG4gKiAgIGxvY2FsU3RvcmFnZS5sb2dzID0gMFxuICpcbiAqL1xudmFyIGxzID0gc3RvcmFnZSgpO1xuaWYgKGxzICYmIChwYXJzZUludChscy5sb2dzLCAxMCkgfHwgbHMubG9ncyA9PT0gJ3RydWUnKSkge1xuICBkZWJ1Zy5lbmFibGUoJyonKTtcbn0gZWxzZSB7XG4gIC8vIFdlIGRvIG5vdCBjYWxsIGBkZWJ1Zy5kaXNhYmxlYCBiZWNhdXNlIGl0IHJlcXVpcmVzIHR3byByZWxvYWRzIHRvIHRha2UuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvZGVidWcvaXNzdWVzLzIzOFxuICAvLyBJbnN0ZWFkLCB3ZSBjYWxsIGBkZWJ1Zy5zYXZlYCB0byByZW1vdmUgdGhlIGBkZWJ1Z2AgbmFtZXNwYWNlcyBwZXJzaXN0ZWRcbiAgLy8gaW4gYGxvY2FsU3RvcmFnZWAuXG4gIGRlYnVnLnNhdmUobnVsbCk7XG4gIC8vIEFuZCB0aGVuIHdlIGBub29wYCB0aGUgZnVuY3Rpb24gc28gbm90aGluZyBoYXBwZW5zLlxuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBub29wICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICB9O1xufVxuXG5pZiAocHJvY2Vzcy5icm93c2VyKSB7IHdpbmRvdy5sb2dzID0gZGVidWc7IH1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbiIsIi8qIGdsb2JhbCBDdXN0b21FdmVudCwgbG9jYXRpb24gKi9cbi8qIENlbnRyYWxpemVkIHBsYWNlIHRvIHJlZmVyZW5jZSB1dGlsaXRpZXMgc2luY2UgdXRpbHMgaXMgZXhwb3NlZCB0byB0aGUgdXNlci4gKi9cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzLmNvb3JkaW5hdGVzID0gcmVxdWlyZSgnLi9jb29yZGluYXRlcycpO1xuXG4vKipcbiAqIEZpcmVzIGEgY3VzdG9tIERPTSBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIEVsZW1lbnQgb24gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gW2RhdGE9e2J1YmJsZXM6IHRydWUsIHtkZXRhaWw6IDxlbD59fV1cbiAqICAgRGF0YSB0byBwYXNzIGFzIGBjdXN0b21FdmVudEluaXRgIHRvIHRoZSBldmVudC5cbiAqL1xubW9kdWxlLmV4cG9ydHMuZmlyZUV2ZW50ID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBkYXRhKSB7XG4gIGRhdGEgPSBkYXRhIHx8IHt9O1xuICBkYXRhLmRldGFpbCA9IGRhdGEuZGV0YWlsIHx8IHt9O1xuICBkYXRhLmRldGFpbC50YXJnZXQgPSBkYXRhLmRldGFpbC50YXJnZXQgfHwgZWw7XG4gIHZhciBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwgZGF0YSk7XG4gIGV2dC50YXJnZXQgPSBlbDtcbiAgZWwuZGlzcGF0Y2hFdmVudChldnQpO1xufTtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgZ2l2ZW4gYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgRXJyb3IgbWVzc2FnZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuZXJyb3IgPSBmdW5jdGlvbiAobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufTtcblxuLyoqXG4gKiBFbWl0cyBhIGNvbnNvbGUgd2FybmluZyBnaXZlbiBwYXNzZWQgbWVzc2FnZSBhcmd1bWVudChzKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMud2FybiA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEVtaXRzIGEgY29uc29sZSBsb2cgZ2l2ZW4gcGFzc2VkIG1lc3NhZ2UgYXJndW1lbnQocykuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTWl4IHRoZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgaW50byBhIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRlc3QgLSBUaGUgb2JqZWN0IHRvIHdoaWNoIHByb3BlcnRpZXMgd2lsbCBiZSBjb3BpZWQuXG4gKiBAcGFyYW0gIHsuLi5vYmplY3R9IHNvdXJjZSAtIFRoZSBvYmplY3QocykgZnJvbSB3aGljaCBwcm9wZXJ0aWVzIHdpbGwgYmUgY29waWVkLlxuICovXG5tb2R1bGUuZXhwb3J0cy5leHRlbmQgPSBvYmplY3RBc3NpZ247XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBvYmplY3RzIGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlcyBhbmQgdmFsdWVzLCBpbmNsdWRpbmcgbmVzdGVkIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGEgLSBGaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0ge29iamVjdH0gYiAtIFNlY29uZCBvYmplY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0d28gb2JqZWN0cyBhcmUgZGVlcGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBkZWVwRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICB2YXIgaTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAvLyBJZiB0aGVyZSBhcmUgbm8ga2V5cywgY29tcGFyZSB0aGUgb2JqZWN0cy5cbiAgaWYgKGtleXNBLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gYSA9PT0gYjsgfVxuICBmb3IgKGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYVtrZXlzQVtpXV0gIT09IGJba2V5c0FbaV1dKSB7IHJldHVybiBmYWxzZTsgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxubW9kdWxlLmV4cG9ydHMuZGVlcEVxdWFsID0gZGVlcEVxdWFsO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGEgLSBGaXJzdCBvYmplY3QgdG8gY29tcGFyZSAoZS5nLiwgb2xkRGF0YSkuXG4gKiBAcGFyYW0ge29iamVjdH0gYiAtIFNlY29uZCBvYmplY3QgdG8gY29tcGFyZSAoZS5nLiwgbmV3RGF0YSkuXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICogICBEaWZmZXJlbmNlIG9iamVjdCB3aGVyZSBzZXQgb2Yga2V5cyBub3RlIHdoaWNoIHZhbHVlcyB3ZXJlIG5vdCBlcXVhbCwgYW5kIHZhbHVlcyBhcmVcbiAqICAgYGJgJ3MgdmFsdWVzLlxuICovXG5tb2R1bGUuZXhwb3J0cy5kaWZmID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGRpZmYgPSB7fTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgT2JqZWN0LmtleXMoYikuZm9yRWFjaChmdW5jdGlvbiBjb2xsZWN0S2V5cyAoYktleSkge1xuICAgIGlmIChrZXlzLmluZGV4T2YoYktleSkgPT09IC0xKSB7XG4gICAgICBrZXlzLnB1c2goYktleSk7XG4gICAgfVxuICB9KTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIGRvRGlmZiAoa2V5KSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgdmFyIGlzQ29tcGFyaW5nT2JqZWN0cyA9IGFWYWwgJiYgYlZhbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhVmFsLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgYlZhbC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIGlmICgoaXNDb21wYXJpbmdPYmplY3RzICYmICFkZWVwRXF1YWwoYVZhbCwgYlZhbCkpIHx8XG4gICAgICAgICghaXNDb21wYXJpbmdPYmplY3RzICYmIGFWYWwgIT09IGJWYWwpKSB7XG4gICAgICBkaWZmW2tleV0gPSBiVmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkaWZmO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYnJvd3NlciBpcyBtb2JpbGUuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIG1vYmlsZSBicm93c2VyIGRldGVjdGVkLlxuICovXG5tb2R1bGUuZXhwb3J0cy5pc01vYmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoZWNrID0gZmFsc2U7XG4gIChmdW5jdGlvbiAoYSkge1xuICAgIGlmICgvKGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgY2V8eGRhfHhpaW5vL2kudGVzdChhKSB8fCAvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KGEuc3Vic3RyKDAsIDQpKSkge1xuICAgICAgY2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJT1MoKSkge1xuICAgICAgY2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSkobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYSk7XG4gIHJldHVybiBjaGVjaztcbn07XG5cbnZhciBpc0lPUyA9IG1vZHVsZS5leHBvcnRzLmlzSU9TID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIG1vYmlsZSBkZXZpY2Ugb3JpZW50YXRpb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgbGFuZHNjYXBlIG9yaWVudGF0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzLmlzTGFuZHNjYXBlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93Lm9yaWVudGF0aW9uID09PSA5MCB8fCB3aW5kb3cub3JpZW50YXRpb24gPT09IC05MDtcbn07XG5cbi8qKlxuICogU3BsaXRzIGEgc3RyaW5nIGludG8gYW4gYXJyYXkgYmFzZWQgb24gYSBkZWxpbWl0ZXIuXG4gKlxuICogQHBhcmFtICAge3N0cmluZz19IFtzdHI9JyddICAgICAgICBTb3VyY2Ugc3RyaW5nXG4gKiBAcGFyYW0gICB7c3RyaW5nPX0gW2RlbGltaXRlcj0nICddIERlbGltaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHthcnJheX0gICAgICAgICAgICAgICAgICAgQXJyYXkgb2YgZGVsaW1pdGVkIHN0cmluZ3NcbiAqL1xubW9kdWxlLmV4cG9ydHMuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCBkZWxpbWl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnKSB7IGRlbGltaXRlciA9ICcgJzsgfVxuICAvLyBGaXJzdCBjb2xsYXBzZSB0aGUgd2hpdGVzcGFjZSAob3Igd2hhdGV2ZXIgdGhlIGRlbGltaXRlciBpcykuXG4gIHZhciByZWdleCA9IG5ldyBSZWdFeHAoZGVsaW1pdGVyLCAnZycpO1xuICBzdHIgPSAoc3RyIHx8ICcnKS5yZXBsYWNlKHJlZ2V4LCBkZWxpbWl0ZXIpO1xuICAvLyBUaGVuIHNwbGl0LlxuICByZXR1cm4gc3RyLnNwbGl0KGRlbGltaXRlcik7XG59O1xuXG4vKipcbiAqIEV4dHJhY3RzIGRhdGEgZnJvbSB0aGUgZWxlbWVudCBnaXZlbiBhbiBvYmplY3QgdGhhdCBjb250YWlucyBleHBlY3RlZCBrZXlzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gU291cmNlIGVsZW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW2RlZmF1bHRzPXt9XSBPYmplY3Qgb2YgZGVmYXVsdCBrZXktdmFsdWUgcGFpcnMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5tb2R1bGUuZXhwb3J0cy5nZXRFbERhdGEgPSBmdW5jdGlvbiAoZWwsIGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzID0gZGVmYXVsdHMgfHwge307XG4gIHZhciBkYXRhID0ge307XG4gIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGNvcHlBdHRyaWJ1dGUpO1xuICBmdW5jdGlvbiBjb3B5QXR0cmlidXRlIChrZXkpIHtcbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGtleSkpIHtcbiAgICAgIGRhdGFba2V5XSA9IGVsLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHF1ZXJ5c3RyaW5nIHZhbHVlLlxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgcXVlcnlzdHJpbmcga2V5LlxuICogQHJldHVybiB7U3RyaW5nfSAgICAgIFZhbHVlXG4gKi9cbm1vZHVsZS5leHBvcnRzLmdldFVybFBhcmFtZXRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtdLywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vLCAnXFxcXF0nKTtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW1xcXFw/Jl0nICsgbmFtZSArICc9KFteJiNdKiknKTtcbiAgdmFyIHJlc3VsdHMgPSByZWdleC5leGVjKGxvY2F0aW9uLnNlYXJjaCk7XG4gIHJldHVybiByZXN1bHRzID09PSBudWxsID8gJycgOiBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0c1sxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59O1xuXG4vLyBNdXN0IGJlIGF0IGJvdHRvbSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5LlxubW9kdWxlLmV4cG9ydHMuc3JjTG9hZGVyID0gcmVxdWlyZSgnLi9zcmMtbG9hZGVyJyk7XG4iLCIvKiBnbG9iYWwgSW1hZ2UgKi9cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcblxudmFyIHdhcm4gPSBkZWJ1ZygndXRpbHM6c3JjLWxvYWRlcjp3YXJuJyk7XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgdGV4dHVyZSwgZWl0aGVyIGFzIGEgc2VsZWN0b3Igb3IgYXMgYSBVUkwuXG4gKiBEZXRlY3RzIHdoZXRoZXIgYHNyY2AgaXMgcG9pbnRpbmcgdG8gYW4gaW1hZ2Ugb3IgdG8gYSB2aWRlbywgYW5kIGludm9rZXMgdGhlXG4gKiBhcHByb3ByaWF0ZSBjYWxsYmFjay5cbiAqXG4gKiBJZiBgc3JjYCBpcyBzZWxlY3RvciwgY2hlY2sgaWYgaXQncyB2YWxpZCwgcmV0dXJuIHRoZSBlbCBpbiB0aGUgY2FsbGJhY2suXG4gKiBBbiBlbCBpcyByZXR1cm5lZCBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQgZm9yIHRleHR1cmUgbG9hZGluZy5cbiAqXG4gKiBJZiBgc3JjYCBpcyBhIFVSTCwgY2hlY2sgaWYgaXQncyB2YWxpZCwgcmV0dXJuIHRoZSBzcmMgaW4gdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbXMge3N0cmluZ30gc3JjIC0gQSBzZWxlY3RvciBvciBhIFVSTC4gVVJMcyBtdXN0IGJlIHdyYXBwZWQgYnkgYHVybCgpYC5cbiAqIEBwYXJhbXMge2Z1bmN0aW9ufSBpc0ltYWdlQ2IgLSBjYWxsYmFjayBpZiB0ZXh0dXJlIGlzIGFuIGltYWdlLlxuICogQHBhcmFtcyB7ZnVuY3Rpb259IGlzVmlkZW9DYiAtIGNhbGxiYWNrIGlmIHRleHR1cmUgaXMgYSB2aWRlby5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTcmMgKHNyYywgaXNJbWFnZUNiLCBpc1ZpZGVvQ2IpIHtcbiAgdmFyIHRleHR1cmVFbDtcbiAgdmFyIGlzSW1hZ2U7XG4gIHZhciBpc1ZpZGVvO1xuICB2YXIgdXJsID0gcGFyc2VVcmwoc3JjKTtcblxuICAvLyBzcmMgaXMgYSB1cmwuXG4gIGlmICh1cmwpIHtcbiAgICB2YWxpZGF0ZUltYWdlVXJsKHVybCwgZnVuY3Rpb24gaXNBbkltYWdlVXJsIChpc0ltYWdlKSB7XG4gICAgICBpZiAoIWlzSW1hZ2UpIHsgaXNWaWRlb0NiKHVybCk7IHJldHVybjsgfVxuICAgICAgaXNJbWFnZUNiKHVybCk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3JjIGlzIGEgcXVlcnkgc2VsZWN0b3IuXG4gIHRleHR1cmVFbCA9IHZhbGlkYXRlQW5kR2V0UXVlcnlTZWxlY3RvcihzcmMpO1xuICBpZiAoIXRleHR1cmVFbCkgeyByZXR1cm47IH1cbiAgaXNJbWFnZSA9IHRleHR1cmVFbCAmJiB0ZXh0dXJlRWwudGFnTmFtZSA9PT0gJ0lNRyc7XG4gIGlzVmlkZW8gPSB0ZXh0dXJlRWwgJiYgdGV4dHVyZUVsLnRhZ05hbWUgPT09ICdWSURFTyc7XG4gIGlmIChpc0ltYWdlKSB7IHJldHVybiBpc0ltYWdlQ2IodGV4dHVyZUVsKTsgfVxuICBpZiAoaXNWaWRlbykgeyByZXR1cm4gaXNWaWRlb0NiKHRleHR1cmVFbCk7IH1cblxuICAvLyBzcmMgaXMgYSB2YWxpZCBzZWxlY3RvciBidXQgZG9lc24ndCBtYXRjaCB3aXRoIGEgPGltZz4gb3IgPHZpZGVvPiBlbGVtZW50LlxuICB3YXJuKCdcIiVzXCIgZG9lcyBub3QgcG9pbnQgdG8gYSB2YWxpZCA8aW1nPiBvciA8dmlkZW8+IGVsZW1lbnQnLCBzcmMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBzaXggaW1hZ2VzIGFzIGEgY3ViZW1hcCwgZWl0aGVyIGFzIHNlbGVjdG9yIG9yIGNvbW1hLXNlcGFyYXRlZFxuICogVVJMcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gQSBzZWxlY3RvciBvciBjb21tYS1zZXBhcmF0ZWQgaW1hZ2UgVVJMcy4gSW1hZ2UgVVJMc1xuICAgICAgICAgIG11c3QgYmUgd3JhcHBlZCBieSBgdXJsKClgLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyYyAtIEEgc2VsZWN0b3Igb3IgY29tbWEtc2VwYXJhdGVkIGltYWdlIFVSTHMuIEltYWdlIFVSTHNcbiAgICAgICAgICBtdXN0IGJlIHdyYXBwZWQgYnkgYHVybCgpYC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDdWJlbWFwU3JjIChzcmMsIGNiKSB7XG4gIHZhciBhQ3ViZW1hcDtcbiAgdmFyIGN1YmVtYXBTcmNSZWdleCA9ICcnO1xuICB2YXIgaTtcbiAgdmFyIHVybHM7XG4gIHZhciB2YWxpZGF0ZWRVcmxzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGN1YmVtYXBTcmNSZWdleCArPSAndXJsXFwoKC4rKVxcKVxccyosXFxzKic7XG4gIH1cbiAgdXJscyA9IHNyYy5tYXRjaChjdWJlbWFwU3JjUmVnZXgpO1xuXG4gIC8vIGBzcmNgIGlzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgVVJMcy5cbiAgLy8gSW4gdGhpcyBjYXNlLCByZS11c2UgdmFsaWRhdGVTcmMgZm9yIGVhY2ggc2lkZSBvZiB0aGUgY3ViZS5cbiAgZnVuY3Rpb24gaXNJbWFnZUNiICh1cmwpIHtcbiAgICB2YWxpZGF0ZWRVcmxzLnB1c2godXJsKTtcbiAgICBpZiAodmFsaWRhdGVkVXJscy5sZW5ndGggPT09IDYpIHtcbiAgICAgIGNiKHZhbGlkYXRlZFVybHMpO1xuICAgIH1cbiAgfVxuICBpZiAodXJscykge1xuICAgIGZvciAoaSA9IDE7IGkgPCA3OyBpKyspIHtcbiAgICAgIHZhbGlkYXRlU3JjKHVybHNbaV0sIGlzSW1hZ2VDYik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGBzcmNgIGlzIGEgcXVlcnkgc2VsZWN0b3IgdG8gPGEtY3ViZW1hcD4gY29udGFpbmluZyBzaXggJChbc3JjXSlzLlxuICBhQ3ViZW1hcCA9IHZhbGlkYXRlQW5kR2V0UXVlcnlTZWxlY3RvcihzcmMpO1xuICBpZiAoIWFDdWJlbWFwKSB7IHJldHVybjsgfVxuICBpZiAoYUN1YmVtYXAudGFnTmFtZSA9PT0gJ0EtQ1VCRU1BUCcgJiYgYUN1YmVtYXAuc3Jjcykge1xuICAgIHJldHVybiBjYihhQ3ViZW1hcC5zcmNzKTtcbiAgfVxuICAvLyBFbHNlIGlmIGFDdWJlTWFwIGlzIG5vdCBhIDxhLWN1YmVtYXA+LlxuICB3YXJuKCdTZWxlY3RvciBcIiVzXCIgZG9lcyBub3QgcG9pbnQgdG8gPGEtY3ViZW1hcD4nLCBzcmMpO1xufVxuXG4vKipcbiAqIFBhcnNlcyBzcmMgZnJvbSBgdXJsKHNyYylgLlxuICogQHBhcmFtICB7c3RyaW5nfSBzcmMgLSBTdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYXJzZWQgc3JjLCBpZiBwYXJzZWFibGUuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVXJsIChzcmMpIHtcbiAgdmFyIHBhcnNlZFNyYyA9IHNyYy5tYXRjaCgvXFx1cmxcXCgoLispXFwpLyk7XG4gIGlmICghcGFyc2VkU3JjKSB7IHJldHVybjsgfVxuICByZXR1cm4gcGFyc2VkU3JjWzFdO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHNyYyBpcyBhIHZhbGlkIGltYWdlIHVybFxuICogQHBhcmFtICB7c3RyaW5nfSBzcmMgLSB1cmwgdGhhdCB3aWxsIGJlIHRlc3RlZFxuICogQHBhcmFtICB7ZnVuY3Rpb259IG9uUmVzdWx0IC0gY2FsbGJhY2sgd2l0aCB0aGUgdGVzdCByZXN1bHRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZVVybCAoc3JjLCBvblJlc3VsdCkge1xuICB2YXIgdGVzdGVyID0gbmV3IEltYWdlKCk7XG4gIHRlc3Rlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgZnVuY3Rpb24gb25Mb2FkICgpIHsgb25SZXN1bHQodHJ1ZSk7IH1cbiAgdGVzdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gIGZ1bmN0aW9uIG9uRXJyb3IgKCkgeyBvblJlc3VsdChmYWxzZSk7IH1cbiAgdGVzdGVyLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBRdWVyeSBhbmQgdmFsaWRhdGUgYSBxdWVyeSBzZWxlY3RvcixcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlbGVjdG9yIC0gRE9NIHNlbGVjdG9yLlxuICogQHJldHVybiB7b2JqZWN0fG51bGx8dW5kZWZpbmVkfSBTZWxlY3RlZCBET00gZWxlbWVudCBpZiBleGlzdHMuXG4gICAgICAgICAgIG51bGwgaWYgcXVlcnkgeWllbGRzIG5vIHJlc3VsdHMuXG4gICAgICAgICAgIHVuZGVmaW5lZCBpZiBgc2VsZWN0b3JgIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFuZEdldFF1ZXJ5U2VsZWN0b3IgKHNlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFlbCkge1xuICAgICAgd2FybignTm8gZWxlbWVudCB3YXMgZm91bmQgbWF0Y2hpbmcgdGhlIHNlbGVjdG9yOiBcIiVzXCInLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbiAgfSBjYXRjaCAoZSkgeyAgLy8gQ2FwdHVyZSBleGNlcHRpb24gaWYgaXQncyBub3QgYSB2YWxpZCBzZWxlY3Rvci5cbiAgICB3YXJuKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgc2VsZWN0b3InLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VVcmw6IHBhcnNlVXJsLFxuICB2YWxpZGF0ZVNyYzogdmFsaWRhdGVTcmMsXG4gIHZhbGlkYXRlQ3ViZW1hcFNyYzogdmFsaWRhdGVDdWJlbWFwU3JjXG59O1xuIiwidmFyIGNzcyA9IFwiaHRtbHtib3R0b206MDtsZWZ0OjA7cG9zaXRpb246Zml4ZWQ7cmlnaHQ6MDt0b3A6MH1ib2R5e2hlaWdodDoxMDAlO21hcmdpbjowO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjA7d2lkdGg6MTAwJX0uYS1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0uYS1jYW52YXN7aGVpZ2h0OjEwMCU7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3dpZHRoOjEwMCV9YS1hc3NldHMsYS1zY2VuZSBpbWcsYS1zY2VuZSB2aWRlb3tkaXNwbGF5Om5vbmV9LmEtZW50ZXItdnJ7YWxpZ24taXRlbXM6ZmxleC1lbmQ7LXdlYmtpdC1hbGlnbi1pdGVtczpmbGV4LWVuZDtib3R0b206NXB4O2Rpc3BsYXk6ZmxleDtkaXNwbGF5Oi13ZWJraXQtZmxleDtmb250LWZhbWlseTpzYW5zLXNlcmlmLG1vbm9zcGFjZTtmb250LXNpemU6MTNweDtmb250LXdlaWdodDoyMDA7bGluZS1oZWlnaHQ6MTZweDtoZWlnaHQ6NzJweDtwb3NpdGlvbjpmaXhlZDtyaWdodDo1cHh9LmEtZW50ZXItdnItYnV0dG9ue2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0ElMkYlMkZ3d3cudzMub3JnJTJGMjAwMCUyRnN2ZyUyMiUyMHZpZXdCb3glM0QlMjIwJTIwMCUyMDI0NS44MiUyMDE0MS43MyUyMiUzRSUzQ2RlZnMlM0UlM0NzdHlsZSUzRS5hJTdCZmlsbCUzQSUyM2ZmZiUzQmZpbGwtcnVsZSUzQWV2ZW5vZGQlM0IlN0QlM0MlMkZzdHlsZSUzRSUzQyUyRmRlZnMlM0UlM0N0aXRsZSUzRW1hc2slM0MlMkZ0aXRsZSUzRSUzQ3BhdGglMjBjbGFzcyUzRCUyMmElMjIlMjBkJTNEJTIyTTE3NS41NiUyQzExMS4zN2MtMjIuNTIlMkMwLTQwLjc3LTE4Ljg0LTQwLjc3LTQyLjA3UzE1MyUyQzI3LjI0JTJDMTc1LjU2JTJDMjcuMjRzNDAuNzclMkMxOC44NCUyQzQwLjc3JTJDNDIuMDdTMTk4LjA4JTJDMTExLjM3JTJDMTc1LjU2JTJDMTExLjM3Wk0yNi44NCUyQzY5LjMxYzAtMjMuMjMlMkMxOC4yNS00Mi4wNyUyQzQwLjc3LTQyLjA3czQwLjc3JTJDMTguODQlMkM0MC43NyUyQzQyLjA3LTE4LjI2JTJDNDIuMDctNDAuNzclMkM0Mi4wN1MyNi44NCUyQzkyLjU0JTJDMjYuODQlMkM2OS4zMVpNMjcuMjclMkMwQzExLjU0JTJDMCUyQzAlMkMxMi4zNCUyQzAlMkMyOC41OFYxMTAuOWMwJTJDMTYuMjQlMkMxMS41NCUyQzMwLjgzJTJDMjcuMjclMkMzMC44M0g5OS41N2MyLjE3JTJDMCUyQzQuMTktMS44MyUyQzUuNC0zLjdMMTE2LjQ3JTJDMTE4YTglMkM4JTJDMCUyQzAlMkMxJTJDMTIuNTItLjE4bDExLjUxJTJDMjAuMzRjMS4yJTJDMS44NiUyQzMuMjIlMkMzLjYxJTJDNS4zOSUyQzMuNjFoNzIuMjljMTUuNzQlMkMwJTJDMjcuNjMtMTQuNiUyQzI3LjYzLTMwLjgzVjI4LjU4QzI0NS44MiUyQzEyLjM0JTJDMjMzLjkzJTJDMCUyQzIxOC4xOSUyQzBIMjcuMjdaJTIyJTJGJTNFJTNDJTJGc3ZnJTNFKSA1MCUgNTAlLzcwJSA3MCUgbm8tcmVwZWF0IHJnYmEoMCwwLDAsLjM1KTtib3JkZXI6MDtib3R0b206MDtjb2xvcjojRkZGO2N1cnNvcjpwb2ludGVyO2hlaWdodDo1MHB4O3RyYW5zaXRpb246YmFja2dyb3VuZCAuMDVzIGVhc2U7LXdlYmtpdC10cmFuc2l0aW9uOmJhY2tncm91bmQgLjA1cyBlYXNlO3dpZHRoOjYwcHg7ei1pbmRleDo5OTk5OTl9LmEtZW50ZXItdnItYnV0dG9uOmFjdGl2ZSwuYS1lbnRlci12ci1idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNjY2fVtkYXRhLWEtZW50ZXItdnItbm8td2VidnJdIC5hLWVudGVyLXZyLWJ1dHRvbntib3JkZXItY29sb3I6IzY2NjtvcGFjaXR5Oi42NX1bZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyXSAuYS1lbnRlci12ci1idXR0b246YWN0aXZlLFtkYXRhLWEtZW50ZXItdnItbm8td2VidnJdIC5hLWVudGVyLXZyLWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjM1KTtjdXJzb3I6bm90LWFsbG93ZWR9LmEtZW50ZXItdnItbW9kYWx7YmFja2dyb3VuZC1jb2xvcjojNjY2O2JvcmRlci1yYWRpdXM6MDtjb2xvcjojRkZGO2hlaWdodDozMnB4O29wYWNpdHk6MDttYXJnaW4tcmlnaHQ6MTBweDtwYWRkaW5nOjlweDt3aWR0aDoyODBweDtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOm9wYWNpdHkgLjA1cyBlYXNlOy13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IC4wNXMgZWFzZX0uYS1lbnRlci12ci1tb2RhbDphZnRlcntib3JkZXItYm90dG9tOjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCAjNjY2O2JvcmRlci10b3A6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtkaXNwbGF5OmlubGluZS1ibG9jaztjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi01cHg7dG9wOjVweDt3aWR0aDowO2hlaWdodDowfS5hLWVudGVyLXZyLW1vZGFsIHB7bWFyZ2luOjA7ZGlzcGxheTppbmxpbmV9LmEtZW50ZXItdnItbW9kYWwgcDphZnRlcntjb250ZW50OicgJ30uYS1lbnRlci12ci1tb2RhbCBhe2NvbG9yOiNGRkY7ZGlzcGxheTppbmxpbmV9W2RhdGEtYS1lbnRlci12ci1uby1oZWFkc2V0XTpob3ZlciAuYS1lbnRlci12ci1tb2RhbCxbZGF0YS1hLWVudGVyLXZyLW5vLXdlYnZyXTpob3ZlciAuYS1lbnRlci12ci1tb2RhbHtvcGFjaXR5OjF9LmEtb3JpZW50YXRpb24tbW9kYWx7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0b3A6MDtsZWZ0OjA7YmFja2dyb3VuZDp1cmwoZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyUyMHhtbG5zJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8yMDAwL3N2ZyUyMiUyMHhtbG5zJTNBeGxpbmslM0QlMjJodHRwJTNBLy93d3cudzMub3JnLzE5OTkveGxpbmslMjIlMjB2ZXJzaW9uJTNEJTIyMS4xJTIyJTIweCUzRCUyMjBweCUyMiUyMHklM0QlMjIwcHglMjIlMjB2aWV3Qm94JTNEJTIyMCUyMDAlMjA5MCUyMDkwJTIyJTIwZW5hYmxlLWJhY2tncm91bmQlM0QlMjJuZXclMjAwJTIwMCUyMDkwJTIwOTAlMjIlMjB4bWwlM0FzcGFjZSUzRCUyMnByZXNlcnZlJTIyJTNFJTNDcG9seWdvbiUyMHBvaW50cyUzRCUyMjAlMkMwJTIwMCUyQzAlMjAwJTJDMCUyMCUyMiUzRSUzQy9wb2x5Z29uJTNFJTNDZyUzRSUzQ3BhdGglMjBkJTNEJTIyTTcxLjU0NSUyQzQ4LjE0NWgtMzEuOThWMjAuNzQzYzAtMi42MjctMi4xMzgtNC43NjUtNC43NjUtNC43NjVIMTguNDU2Yy0yLjYyOCUyQzAtNC43NjclMkMyLjEzOC00Ljc2NyUyQzQuNzY1djQyLjc4OSUyMCUyMCUyMGMwJTJDMi42MjglMkMyLjEzOCUyQzQuNzY2JTJDNC43NjclMkM0Ljc2Nmg1LjUzNXYwLjk1OWMwJTJDMi42MjglMkMyLjEzOCUyQzQuNzY1JTJDNC43NjYlMkM0Ljc2NWg0Mi43ODhjMi42MjglMkMwJTJDNC43NjYtMi4xMzclMkM0Ljc2Ni00Ljc2NVY1Mi45MTQlMjAlMjAlMjBDNzYuMzExJTJDNTAuMjg0JTJDNzQuMTczJTJDNDguMTQ1JTJDNzEuNTQ1JTJDNDguMTQ1eiUyME0xOC40NTUlMkMxNi45MzVoMTYuMzQ0YzIuMSUyQzAlMkMzLjgwOCUyQzEuNzA4JTJDMy44MDglMkMzLjgwOHYyNy40MDFIMzcuMjVWMjIuNjM2JTIwJTIwJTIwYzAtMC4yNjQtMC4yMTUtMC40NzgtMC40NzktMC40NzhIMTYuNDgyYy0wLjI2NCUyQzAtMC40NzklMkMwLjIxNC0wLjQ3OSUyQzAuNDc4djM2LjU4NWMwJTJDMC4yNjQlMkMwLjIxNSUyQzAuNDc4JTJDMC40NzklMkMwLjQ3OGg3LjUwN3Y3LjY0NCUyMCUyMCUyMGgtNS41MzRjLTIuMTAxJTJDMC0zLjgxLTEuNzA5LTMuODEtMy44MVYyMC43NDNDMTQuNjQ1JTJDMTguNjQzJTJDMTYuMzU0JTJDMTYuOTM1JTJDMTguNDU1JTJDMTYuOTM1eiUyME0xNi45NiUyQzIzLjExNmgxOS4zMzF2MjUuMDMxaC03LjUzNSUyMCUyMCUyMGMtMi42MjglMkMwLTQuNzY2JTJDMi4xMzktNC43NjYlMkM0Ljc2OHY1LjgyOGgtNy4wM1YyMy4xMTZ6JTIwTTcxLjU0NSUyQzczLjA2NEgyOC43NTdjLTIuMTAxJTJDMC0zLjgxLTEuNzA4LTMuODEtMy44MDhWNTIuOTE0JTIwJTIwJTIwYzAtMi4xMDIlMkMxLjcwOS0zLjgxMiUyQzMuODEtMy44MTJoNDIuNzg4YzIuMSUyQzAlMkMzLjgwOSUyQzEuNzElMkMzLjgwOSUyQzMuODEydjE2LjM0M0M3NS4zNTQlMkM3MS4zNTYlMkM3My42NDUlMkM3My4wNjQlMkM3MS41NDUlMkM3My4wNjR6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk0yOC45MTklMkM1OC40MjRjLTEuNDY2JTJDMC0yLjY1OSUyQzEuMTkzLTIuNjU5JTJDMi42NmMwJTJDMS40NjYlMkMxLjE5MyUyQzIuNjU4JTJDMi42NTklMkMyLjY1OGMxLjQ2OCUyQzAlMkMyLjY2Mi0xLjE5MiUyQzIuNjYyLTIuNjU4JTIwJTIwJTIwQzMxLjU4MSUyQzU5LjYxNyUyQzMwLjM4NyUyQzU4LjQyNCUyQzI4LjkxOSUyQzU4LjQyNHolMjBNMjguOTE5JTJDNjIuNzg2Yy0wLjkzOSUyQzAtMS43MDMtMC43NjQtMS43MDMtMS43MDJjMC0wLjkzOSUyQzAuNzY0LTEuNzA0JTJDMS43MDMtMS43MDQlMjAlMjAlMjBjMC45NCUyQzAlMkMxLjcwNSUyQzAuNzY1JTJDMS43MDUlMkMxLjcwNEMzMC42MjMlMkM2Mi4wMjIlMkMyOS44NTglMkM2Mi43ODYlMkMyOC45MTklMkM2Mi43ODZ6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk02OS42NTQlMkM1MC40NjFIMzMuMDY5Yy0wLjI2NCUyQzAtMC40NzklMkMwLjIxNS0wLjQ3OSUyQzAuNDc5djIwLjI4OGMwJTJDMC4yNjQlMkMwLjIxNSUyQzAuNDc4JTJDMC40NzklMkMwLjQ3OGgzNi41ODUlMjAlMjAlMjBjMC4yNjMlMkMwJTJDMC40NzctMC4yMTQlMkMwLjQ3Ny0wLjQ3OFY1MC45MzlDNzAuMTMxJTJDNTAuNjc2JTJDNjkuOTE3JTJDNTAuNDYxJTJDNjkuNjU0JTJDNTAuNDYxeiUyME02OS4xNzQlMkM1MS40MTdWNzAuNzVIMzMuNTQ4VjUxLjQxN0g2OS4xNzR6JTIyJTNFJTNDL3BhdGglM0UlM0NwYXRoJTIwZCUzRCUyMk00NS4yMDElMkMzMC4yOTZjNi42NTElMkMwJTJDMTIuMjMzJTJDNS4zNTElMkMxMi41NTElMkMxMS45NzdsLTMuMDMzLTIuNjM4Yy0wLjE5My0wLjE2NS0wLjUwNy0wLjE0Mi0wLjY3NSUyQzAuMDQ4JTIwJTIwJTIwYy0wLjE3NCUyQzAuMTk4LTAuMTUzJTJDMC41MDElMkMwLjA0NSUyQzAuNjc2bDMuODgzJTJDMy4zNzVjMC4wOSUyQzAuMDc1JTJDMC4xOTglMkMwLjExNSUyQzAuMzEyJTJDMC4xMTVjMC4xNDElMkMwJTJDMC4yNzMtMC4wNjElMkMwLjM2Mi0wLjE2NiUyMCUyMCUyMGwzLjM3MS0zLjg3N2MwLjE3My0wLjIlMkMwLjE1MS0wLjUwMi0wLjA0Ny0wLjY3NWMtMC4xOTQtMC4xNjYtMC41MDgtMC4xNDQtMC42NzYlMkMwLjA0OGwtMi41OTIlMkMyLjk3OSUyMCUyMCUyMGMtMC4xOC0zLjQxNy0xLjYyOS02LjYwNS00LjA5OS05LjAwMWMtMi41MzgtMi40NjEtNS44NzctMy44MTctOS40MDQtMy44MTdjLTAuMjY0JTJDMC0wLjQ3OSUyQzAuMjE1LTAuNDc5JTJDMC40NzklMjAlMjAlMjBDNDQuNzIlMkMzMC4wODMlMkM0NC45MzYlMkMzMC4yOTYlMkM0NS4yMDElMkMzMC4yOTZ6JTIyJTNFJTNDL3BhdGglM0UlM0MvZyUzRSUzQy9zdmclM0UpIGNlbnRlciBjZW50ZXIvNTAlIDUwJSBuby1yZXBlYXQgcmdiYSgyNDQsMjQ0LDI0NCwxKX0uYS1vcmllbnRhdGlvbi1tb2RhbDphZnRlcntjb250ZW50OlxcXCJJbnNlcnQgcGhvbmUgaW50byBDYXJkYm9hcmQgaG9sZGVyLlxcXCI7Y29sb3I6IzMzMztmb250LWZhbWlseTpzYW5zLXNlcmlmLG1vbm9zcGFjZTtmb250LXNpemU6MTNweDt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxMDAlO3RvcDo3MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTcwJSl9LmEtb3JpZW50YXRpb24tbW9kYWwgYnV0dG9ue2JhY2tncm91bmQ6dXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmclMjB4bWxucyUzRCUyMmh0dHAlM0EvL3d3dy53My5vcmcvMjAwMC9zdmclMjIlMjB4bWxucyUzQXhsaW5rJTNEJTIyaHR0cCUzQS8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJTIyJTIwdmVyc2lvbiUzRCUyMjEuMSUyMiUyMHglM0QlMjIwcHglMjIlMjB5JTNEJTIyMHB4JTIyJTIwdmlld0JveCUzRCUyMjAlMjAwJTIwMTAwJTIwMTAwJTIyJTIwZW5hYmxlLWJhY2tncm91bmQlM0QlMjJuZXclMjAwJTIwMCUyMDEwMCUyMDEwMCUyMiUyMHhtbCUzQXNwYWNlJTNEJTIycHJlc2VydmUlMjIlM0UlM0NwYXRoJTIwZmlsbCUzRCUyMiUyMzAwMDAwMCUyMiUyMGQlM0QlMjJNNTUuMjA5JTJDNTBsMTcuODAzLTE3LjgwM2MxLjQxNi0xLjQxNiUyQzEuNDE2LTMuNzEzJTJDMC01LjEyOWMtMS40MTYtMS40MTctMy43MTMtMS40MTctNS4xMjklMkMwTDUwLjA4JTJDNDQuODcyJTIwJTIwTDMyLjI3OCUyQzI3LjA2OWMtMS40MTYtMS40MTctMy43MTQtMS40MTctNS4xMjklMkMwYy0xLjQxNyUyQzEuNDE2LTEuNDE3JTJDMy43MTMlMkMwJTJDNS4xMjlMNDQuOTUxJTJDNTBMMjcuMTQ5JTJDNjcuODAzJTIwJTIwYy0xLjQxNyUyQzEuNDE2LTEuNDE3JTJDMy43MTMlMkMwJTJDNS4xMjljMC43MDglMkMwLjcwOCUyQzEuNjM2JTJDMS4wNjIlMkMyLjU2NCUyQzEuMDYyYzAuOTI4JTJDMCUyQzEuODU2LTAuMzU0JTJDMi41NjQtMS4wNjJMNTAuMDglMkM1NS4xM2wxNy44MDMlMkMxNy44MDIlMjAlMjBjMC43MDglMkMwLjcwOCUyQzEuNjM3JTJDMS4wNjIlMkMyLjU2NCUyQzEuMDYyczEuODU2LTAuMzU0JTJDMi41NjQtMS4wNjJjMS40MTYtMS40MTYlMkMxLjQxNi0zLjcxMyUyQzAtNS4xMjlMNTUuMjA5JTJDNTB6JTIyJTNFJTNDL3BhdGglM0UlM0Mvc3ZnJTNFKTt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O2JvcmRlcjpub25lO3RleHQtaW5kZW50Oi05OTk5cHh9QG1lZGlhIChtaW4td2lkdGg6NDgwcHgpey5hLWVudGVyLXZye2JvdHRvbToyMHB4O3JpZ2h0OjIwcHh9LmEtZW50ZXItdnItbW9kYWx7d2lkdGg6NDAwcHh9fVwiOyAocmVxdWlyZShcImJyb3dzZXJpZnktY3NzXCIpLmNyZWF0ZVN0eWxlKGNzcywgeyBcImhyZWZcIjogXCJzdHlsZVxcXFxhZnJhbWUtY29yZS5jc3NcIn0pKTsgbW9kdWxlLmV4cG9ydHMgPSBjc3M7IiwidmFyIGNzcyA9IFwiLnJzLWJhc2V7YmFja2dyb3VuZC1jb2xvcjojRUYyRDVFO2JvcmRlci1yYWRpdXM6MDtmb250LWZhbWlseTonUm9ib3RvIENvbmRlbnNlZCcsdGFob21hLHNhbnMtc2VyaWY7Zm9udC1zaXplOjEwcHg7bGluZS1oZWlnaHQ6MS4yZW07b3BhY2l0eTouNzU7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MTBweDtwb3NpdGlvbjpmaXhlZDtsZWZ0OjVweDt0b3A6NXB4O3dpZHRoOjI3MHB4O3otaW5kZXg6MTAwMDB9LnJzLWJhc2UuaGlkZGVue2Rpc3BsYXk6bm9uZX0ucnMtYmFzZSBoMXtjb2xvcjojZmZmO2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjRlbTtmb250LXdlaWdodDozMDA7bWFyZ2luOjAgMCA1cHg7cGFkZGluZzowfS5ycy1ncm91cHtkaXNwbGF5Oi13ZWJraXQtYm94O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2Rpc3BsYXk6ZmxleDstd2Via2l0LWZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbi1yZXZlcnNlfS5ycy1jb3VudGVyLWJhc2V7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6LXdlYmtpdC1ib3g7ZGlzcGxheTotd2Via2l0LWZsZXg7ZGlzcGxheTpmbGV4O2hlaWdodDoxMHB4Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47bWFyZ2luOjJweCAwfS5ycy1jb3VudGVyLWlke2ZvbnQtd2VpZ2h0OjMwMDstd2Via2l0LWJveC1vcmRpbmFsLWdyb3VwOjA7LXdlYmtpdC1vcmRlcjowO29yZGVyOjB9LnJzLWNvdW50ZXItdmFsdWV7Zm9udC13ZWlnaHQ6MzAwOy13ZWJraXQtYm94LW9yZGluYWwtZ3JvdXA6MTstd2Via2l0LW9yZGVyOjE7b3JkZXI6MTt0ZXh0LWFsaWduOnJpZ2h0O3dpZHRoOjI1cHh9LnJzLWNhbnZhc3std2Via2l0LWJveC1vcmRpbmFsLWdyb3VwOjI7LXdlYmtpdC1vcmRlcjoyO29yZGVyOjJ9QG1lZGlhIChtaW4td2lkdGg6NDgwcHgpey5ycy1iYXNle2xlZnQ6MjBweDt0b3A6MjBweH19XCI7IChyZXF1aXJlKFwiYnJvd3NlcmlmeS1jc3NcIikuY3JlYXRlU3R5bGUoY3NzLCB7IFwiaHJlZlwiOiBcInN0eWxlXFxcXHJTdGF0cy5jc3NcIn0pKTsgbW9kdWxlLmV4cG9ydHMgPSBjc3M7Il19
